{
    "identifiers": [
        "math",
        "numpy",
        "np",
        "pandas",
        "pd",
        "scipy",
        "stats",
        "qmc",
        "qmc",
        "cvxpy",
        "cp",
        "estimagic",
        "estimation",
        "msm_weighting",
        "get_weighting_matrix",
        "estimagic",
        "estimation",
        "estimate_msm",
        "get_msm_optimization_functions",
        "simulate_moments",
        "msm_res",
        "moments_cov",
        "draws",
        "n_obs",
        "weights",
        "kernel",
        "sampling",
        "bandwidth",
        "cutoff",
        "population_mc_kwgs",
        "simulate_moments_kwargs",
        "logging",
        "log_options",
        "sum",
        "msm_res",
        "summary",
        "isnull",
        "ValueError",
        "msm_res",
        "len",
        "msm_params",
        "bandwidth",
        "math",
        "sqrt",
        "math",
        "log",
        "math",
        "log",
        "n_obs",
        "n_obs",
        "cutoff",
        "math",
        "sqrt",
        "math",
        "log",
        "n_obs",
        "n_obs",
        "sampling_level_sets",
        "simulate_moments",
        "msm_res",
        "moments_cov",
        "draws",
        "bandwidth",
        "weights",
        "sampling",
        "len",
        "grid_sub",
        "ValueError",
        "calculate_quasi_jacobian",
        "grid_sub",
        "moms_sub",
        "n_params",
        "category_selection",
        "moments_cov",
        "n_params",
        "Bn",
        "phi",
        "cutoff",
        "Bn",
        "sing",
        "cutoff",
        "n_sing",
        "simulate_moments",
        "msm_res",
        "moments_cov",
        "draws",
        "bandwidth",
        "weights",
        "sampling",
        "population_mc_kwgs",
        "msm_res",
        "msm_res",
        "summary",
        "len",
        "msm_params",
        "sampling",
        "NotImplementedError",
        "sampling",
        "sampling",
        "np",
        "random",
        "random",
        "draws",
        "n_params",
        "sampling",
        "qmc",
        "Sobol",
        "d",
        "n_params",
        "scramble",
        "sequences",
        "random",
        "n",
        "draws",
        "NotImplementedError",
        "np",
        "array",
        "msm_params",
        "draws",
        "msm_se",
        "sequences",
        "i",
        "i",
        "draws",
        "sampling",
        "NotImplementedError",
        "NotImplementedError",
        "np",
        "nan",
        "draws",
        "np",
        "nan",
        "n_params",
        "draws",
        "b",
        "draws",
        "simulate_moments",
        "pd",
        "DataFrame",
        "data",
        "params_draws",
        "b",
        "index",
        "msm_params",
        "index",
        "columns",
        "n_draws",
        "seed",
        "mm",
        "get_weighting_matrix",
        "moments_cov",
        "moments_cov",
        "method",
        "weights",
        "empirical_moments",
        "mm",
        "return_type",
        "np",
        "dot",
        "mm",
        "T",
        "np",
        "linalg",
        "solve",
        "W",
        "mm",
        "np",
        "array",
        "objs",
        "min",
        "np",
        "array",
        "objs",
        "bandwidth",
        "i",
        "i",
        "x",
        "ind",
        "x",
        "params_draws",
        "ind",
        "np",
        "array",
        "moms",
        "i",
        "i",
        "ind",
        "grid_sub",
        "moms_sub",
        "grid_sub",
        "moms_sub",
        "n_params",
        "np",
        "column_stack",
        "len",
        "grid_sub",
        "grid_sub",
        "cp",
        "Variable",
        "shape",
        "X",
        "shape",
        "moms_sub",
        "shape",
        "cp",
        "Minimize",
        "cp",
        "norm",
        "moms_sub",
        "X",
        "beta",
        "p",
        "cp",
        "Problem",
        "objc",
        "prob",
        "solve",
        "solver",
        "beta",
        "value",
        "solution",
        "cp",
        "Variable",
        "shape",
        "n_params",
        "np",
        "full",
        "len",
        "grid_sub",
        "cp",
        "Variable",
        "shape",
        "n_params",
        "n_params",
        "cp",
        "Minimize",
        "cp",
        "log_det",
        "VV",
        "cp",
        "norm",
        "grid_sub",
        "VV",
        "cp",
        "kron",
        "one",
        "mu",
        "T",
        "T",
        "cp",
        "Problem",
        "objc",
        "prob",
        "solve",
        "solver",
        "beta",
        "value",
        "Bn",
        "phi",
        "moments_cov",
        "n_params",
        "Bn",
        "phi",
        "cutoff",
        "np",
        "array",
        "i",
        "i",
        "n_params",
        "np",
        "identity",
        "n_params",
        "np",
        "dot",
        "v",
        "v",
        "T",
        "scipy",
        "scipy",
        "linalg",
        "inv",
        "scipy",
        "linalg",
        "sqrtm",
        "moments_cov",
        "np",
        "dot",
        "V_1_2",
        "Bn",
        "T",
        "np",
        "dot",
        "V_Bn",
        "M",
        "np",
        "dot",
        "V_Bn_P",
        "T",
        "phi",
        "T",
        "np",
        "dot",
        "V_Bn_P_phi",
        "T",
        "M",
        "V_Bn_P_phi_P",
        "scipy",
        "linalg",
        "svd",
        "Bnorm",
        "sum",
        "sing",
        "cutoff",
        "sing",
        "cutoff",
        "n_sing"
    ],
    "literals": [
        "\"diagonal\"",
        "\"uniform\"",
        "\"sobol\"",
        "\"standard_error\"",
        "\"Standard error is NA for some of the estimated parameters. Cannot proceed.\"",
        "\"value\"",
        "\"No draws fall in a level subset. Cannot proceed.\"",
        "\"value\"",
        "\"standard_error\"",
        "\"random\"",
        "\"sobol\"",
        "\"halton\"",
        "\"population_mc\"",
        "\"Custom sampling is not yet implemented.\"",
        "\"random\"",
        "\"sobol\"",
        "\"halton\"",
        "\"random\"",
        "\"sobol\"",
        "\"Sampling with Halton sequences is not yet implemented.\"",
        "\"population_mc\"",
        "\"Adaptive Sampling by Population Monte Carlo is not yet implemented.\"",
        "\"Custom sequences are not yet implemented.\"",
        "\"value\"",
        "\"pytree_and_array\"",
        "\"inf\"",
        "\"ECOS\"",
        "\"inf\"",
        "\"SCS\""
    ],
    "variables": [
        "msm_params",
        "n_params",
        "bandwidth",
        "cutoff",
        "grid_sub",
        "moms_sub",
        "Bn",
        "phi",
        "sing",
        "cutoff",
        "n_sing",
        "msm_params",
        "msm_se",
        "n_params",
        "sequences",
        "sequences",
        "sequences",
        "params_draws",
        "objs",
        "moms",
        "mm",
        "moms",
        "b",
        "W",
        "internal_weights",
        "objs",
        "b",
        "ind",
        "ind",
        "grid_sub",
        "moms_sub",
        "X",
        "beta",
        "objc",
        "prob",
        "solution",
        "Bn",
        "mu",
        "one",
        "VV",
        "objc",
        "prob",
        "phi",
        "v",
        "M",
        "V_1_2",
        "V_Bn",
        "V_Bn_P",
        "V_Bn_P_phi",
        "V_Bn_P_phi_P",
        "Bnorm",
        "sing",
        "n_sing"
    ],
    "comments": [
        "later: without this package, with linear programming",
        "params (pytree) – A pytree containing the estimated parameters of the model.",
        "Pytrees can be a numpy array, a pandas Series, a DataFrame with “value” column, a",
        "float and any kind of (nested) dictionary or list containing these elements.",
        "check whether the inputs are valid",
        "estimated coefficient vector",
        "number of estimated parameters",
        "calculate default inputs",
        "for step 2.i)",
        "for step 3.ii)",
        "(in the paper: Step 2.i Draw Uniformly on the Level Set)",
        "1. quasi-Jacobian Matrix",
        "1.1 set the integration grid and evaluate the moments on the grid,",
        "select draws on the level set",
        "(in the paper: Step 2.ii-iii) Linear Approximation and quasi-Jacobian; Compute variance)",
        "1.2 compute the intercept and slope",
        "1.3 compute the variance",
        "(in the paper: Step 3 Identification Category Selection)",
        "2. Identification Category Selection",
        "2.1 compute singular values",
        "2.2 number of values grater than cutoff",
        "3. Subvector Inference",
        "3.1 test statistic",
        "3.2 hypothesis, confidence set",
        "1. DRAWS",
        "1.1 DIRECT APPROACH",
        "d - dimension - number of estimated parameters",
        "instead of n=B try power of 2 (for Sobol sequence)",
        "[list(msm_params)]*draws + 2 * (sequences - 1 / 2)",
        "1.2. ADAPTIVE SAMPLING - TO DO",
        "2. WEIGHTING THE RESULTED DRAWS",
        "Store MSM objective values",
        "Store sample moments mom",
        "Evaluate the moments on the grid",
        "print(\"DRAW\"+str(b))",
        "Vs[b] = V",
        "weighting matrix",
        "objs[b] = get_msm_optimization_functions(simulate_moments,empirical_moments,W)",
        "Select draws on the level set",
        "why it was np.array(objs) - min(np.array(objs)) in the code? according to",
        "the paper it should be objs <= bandwidth",
        "Vs_sub = [V for i in ind]",
        "1. CALCULATE QUASI-JACOBIAN (THE SLOPE IN THE L-oo REGRESSION)",
        "the kernel ???",
        "regressors: intercept and theta_b",
        "matrix of coefficients (A,B)",
        "1 - infinity loss",
        "compile the problem",
        "compute the solution",
        "extract the solution",
        "qusi-Jacobian",
        "2. COMPUTE VARIANCE (REPARAMETRIZED)",
        "vector of means 1xnumber of parameters",
        "matrix of variances",
        "grid_sub.T@VV",
        "cp.norm( (grid_sub@VV - cp.kron(one,mu.T))**2,'inf')",
        "!!!ADDED TRANSPOSITION (doesnot matter which to transpose)",
        "compute the solution #DEPEDS ON THE SOLVER",
        "extract the solution",
        "Note that phi = Sigma^(-1/2), the problem was reparametrized",
        "phi",
        "V - moments_cov",
        "1. CALCULATE NORMALIZED QUASI-JACOBEAN",
        "1.1 Compute the normalization matrix for the left-hand-side",
        "(in the paper - Compute V_bar the average variance matrix)",
        "V = np.zeros(shape=(len(Vs_sub[0]),len(Vs_sub[0]))) # variance for moments,",
        "dimensions as much as moments",
        "for b in range(len(grid_sub)):",
        "V = V + Vs_sub[b] / len(grid_sub)",
        "1.2 Computed the normalization matrix for the right-hand-side in step 2.ii) - phi",
        "vector which spans theta1",
        "Projection matrix onto the span on theta2",
        "1.3 Normalized quasi-Jacobean",
        "all random transpositions!!!!!!!!!! from left to right",
        "np.dot(np.dot(np.dot(np.dot(scipy.linalg.inv(scipy.linalg.sqrtm(V)),Bn.T),M).T,phi.T).T,M)",
        "2. COMPUTE SINGULAR VALUES AND CUTOFF",
        "singular values in a decreasing order",
        "number of identified parameters"
    ],
    "docstrings": [
        "\"\"\"Detection of the identification failure in moment condition models.\n    Performs the identification check as described in Forneron, J. J. (2019).\n    Introduces the quasi-Jacobian matrix computed as a slope of a linear\n    approximation of the moments of the estimate of the identified set. It is\n    asymptotically singular when local or global identification fails and equivalent\n    to the usual Jacobian matrix which has full rank when model is point and locally\n    identified.\n\n    Args\n        simulate_moments (callable) – Function that takes as inputs model parameters,\n            data and potentially other keyword arguments and returns a pytree with\n            simulated moments.  If the function returns a dict containing the key\n            \"simulated_moments\" we only use the value corresponding to that key. Other\n            entries are stored in the log database if you use logging.\n        simulate_moments_kwargs (dict) – Additional keyword arguments for simulate_moments\n            with, for example, data on dependent and independent variables from the model\n            specification.\n        msm_res (dict) – The output of ``estimate_msm`` including estimated\n        parameters and standard errors.\n        weights (str) – One of “diagonal” (default), “identity” or “optimal”.  Note that\n            “optimal” refers to the asymptotically optimal weighting matrix and is often\n            not a good choice due to large finite sample bias.\n        bandwidth (float) - By default is calculated in the form of sqrt(2log(log[n])/n).\n            Required for the selection of subsets for levels sets.\n        kernel (callable) - By default  is the uniform kernel K(U) which is indicator\n            function for |U|<=1. Required for the calculation of quasi-jacobian matrix.\n        cutoff (float) - By default is calculated in the form sqrt(2log[n]/n). Required\n            for identification category selection.\n        draws (float)  - The number of draws for sampling on level sets. Supposed to be\n            sufficiently large.\n        n_obs (int): Number of observations. Required for calculation of bandwidth and cutoff.\n        sampling (str) - Methods of sampling uniformly from likelihood level sets. One of\n            the available options for direct approach using \"sobol\" or \"halton\" sequence\n            or adaptive sampling by \"population_mc\".\n        population_mc_kwgs (dict): Further tuning parameters for adaptive sampling.\n        significance (float) - The significance level with default level 5%.\n        H0 (dict) - Required for subvector inference. For example, b10 = 0.\n        logging (pathlib.Path, str or False) – Path to sqlite3 file (which typically has\n            the file extension .db. If the file does not exist, it will be created. The\n            dashboard can only be used when logging is used.\n        log_options (dict) – Additional keyword arguments to configure the logging.\n\n    Returns\n        dict: The estimated quasi-Jacobian, singular values, identification category.\"\"\"",
        "\"\"\"Calculates the uniform draws over the level set required for the computation\n    of the quasi-Jacobean. Uses either direct approach with random/pseudo-random\n    sequences (Sobol or Halton) or adaptive sampling by Population Monte Carlo.\n    For the direct approach the effective sample size tends to be too small when\n    the dimension of the parameter is moderately large. Adaptive sampling constructs\n    a sequence of proposal distributions with higher acceptance rate.\n\n    Args:\n        simulate_moments\n        msm_res (dict) – The output of ``estimate_msm`` including estimated\n        parameters and standard errors.\n        moments_cov\n        draws (float) - Number of initial draws for sampling.\n        bandwidth (float) - By default is calculated in the form of sqrt(2log(log[n])/n).\n            Required for the selection of subsets for levels sets.\n        weights\n        sampling (str) - Methods of sampling uniformly from likelihood level sets.\n            One of the available options for direct approach using \"random\",\n            \"sobol\" or \"halton\" sequence or adaptive sampling by \"population_mc\".\n        population_mc_kwgs (dict): Further tuning parameters for adaptive sampling.\n\n    Returns:\n        The selected draws, simulated moments and variance.\n\n    \"\"\"",
        "\"\"\"Calculates the quasi-Jacobean matrix as the slope of a linear\n    approximation of the moments on an estimate of the identified set.\n    It is asymptotically singular when local and/or global identification\n    fails, and equivalent to the usual Jacobean matrix which has full rank\n    when the model is points and locally identified.\n\n    Args:\n        grid_sub (list): The selected draws.\n        moms_sub (array): Simulated moments for the selected draws.\n        n_params (int): Number of parameters in the model.\n\n    Returns:\n        The quasi-Jacobean matrix and the inverse square root variance matrix.\n\n    \"\"\"",
        "\"\"\"Computes the singular values for normalized quasi-Jacobean.\n    Selects the number of singular values larger than cutoff value.\n\n    Args:\n        moments_cov (array): An array containing the covariance matrix of\n            the empirical moments. This is typically calculated with\n            our ``get_moments_cov`` function.\n        n_params (int): Number of parameters in the model.\n        Bn (array): Quasi-Jacobean matrix which is calculated with\n            ``calculate_quasi_jacobian``.\n        phi (array): Inverse square root variance matrix which is calculated\n            with``calculate_quasi_jacobian``.\n        cutoff (int): The cutoff for the identification category\n        selection. By default, calculated as sqrt(2*math.log(n)/n).\n\n    Returns:\n        The singular values for normalized quasi-Jacobean, the cutoff and\n        the number of identified parameters\n\n    \"\"\""
    ],
    "functions": [
        "check_msm_identification",
        "sampling_level_sets",
        "calculate_quasi_jacobian",
        "category_selection"
    ],
    "classes": []
}