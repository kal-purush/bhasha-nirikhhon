{
    "identifiers": [
        "numpy",
        "np",
        "numpy",
        "math",
        "brainmix",
        "modules",
        "imregistration",
        "imreg",
        "skimage",
        "transform",
        "scipy",
        "signal",
        "image",
        "tfrm",
        "np",
        "append",
        "tfrm",
        "skimage",
        "transform",
        "AffineTransform",
        "matrix",
        "matrix",
        "skimage",
        "transform",
        "warp",
        "image",
        "skTransform",
        "mode",
        "outimg",
        "source",
        "target",
        "tfrm",
        "maxIterations",
        "np",
        "eye",
        "source",
        "shape",
        "imshape",
        "tfrm",
        "identity",
        "np",
        "array",
        "scipy",
        "signal",
        "convolve2d",
        "target",
        "scharr",
        "boundary",
        "mode",
        "affine_transform",
        "source",
        "tfrm",
        "target",
        "np",
        "mean",
        "err",
        "tgrad",
        "real",
        "np",
        "arange",
        "width",
        "tgrad",
        "real",
        "np",
        "arange",
        "height",
        "np",
        "newaxis",
        "tgrad",
        "imag",
        "np",
        "arange",
        "width",
        "tgrad",
        "imag",
        "np",
        "arange",
        "height",
        "np",
        "newaxis",
        "np",
        "array",
        "imshape",
        "np",
        "array",
        "np",
        "sum",
        "xdx",
        "np",
        "sum",
        "xdy",
        "np",
        "sum",
        "tgrad",
        "real",
        "np",
        "sum",
        "ydx",
        "np",
        "sum",
        "ydy",
        "np",
        "sum",
        "tgrad",
        "imag",
        "np",
        "newaxis",
        "np",
        "dot",
        "Jacobian",
        "T",
        "Jacobian",
        "iteration",
        "maxIterations",
        "np",
        "array",
        "np",
        "sum",
        "err",
        "xdx",
        "np",
        "sum",
        "err",
        "xdy",
        "np",
        "sum",
        "err",
        "tgrad",
        "real",
        "np",
        "sum",
        "err",
        "ydx",
        "np",
        "sum",
        "err",
        "ydy",
        "np",
        "sum",
        "err",
        "tgrad",
        "imag",
        "np",
        "diag",
        "lambdavar",
        "np",
        "diag",
        "sHessian",
        "np",
        "dot",
        "np",
        "linalg",
        "inv",
        "sHessian",
        "sHessianDiag",
        "gradient",
        "reshape",
        "np",
        "vstack",
        "updateinv",
        "identity",
        "np",
        "array",
        "np",
        "linalg",
        "inv",
        "updateinv",
        "np",
        "vstack",
        "newtfrm",
        "identity",
        "np",
        "array",
        "np",
        "dot",
        "newtfrmfull",
        "update",
        "attempt",
        "np",
        "sqrt",
        "update",
        "update",
        "update",
        "update",
        "np",
        "sqrt",
        "widthSq",
        "heightSq",
        "np",
        "sum",
        "np",
        "absolute",
        "update",
        "affine_transform",
        "source",
        "attempt",
        "target",
        "np",
        "mean",
        "err",
        "bestMeanSquares",
        "np",
        "mean",
        "err",
        "attempt",
        "identity",
        "lambdavar",
        "lambdavar",
        "displacement",
        "newtfrm",
        "identity",
        "newtfrm",
        "identity",
        "source",
        "target",
        "pyramidDepth",
        "minLevel",
        "downscale",
        "debug",
        "skimage",
        "transform",
        "pyramid_gaussian",
        "source",
        "max_layer",
        "pyramidDepth",
        "downscale",
        "downscale",
        "skimage",
        "transform",
        "pyramid_gaussian",
        "target",
        "max_layer",
        "pyramidDepth",
        "downscale",
        "downscale",
        "np",
        "array",
        "layer",
        "pyramidDepth",
        "minLevel",
        "tfrm",
        "downscale",
        "affine_least_squares",
        "sourcePyramid",
        "layer",
        "targetPyramid",
        "layer",
        "tfrm",
        "layer",
        "np",
        "concatenate",
        "tfrm",
        "tfrm",
        "pow",
        "downscale",
        "layer",
        "axis",
        "debug",
        "toptfrm",
        "skimage",
        "io",
        "matplotlib",
        "pyplot",
        "plt",
        "skimage",
        "io",
        "imread",
        "as_grey",
        "skimage",
        "io",
        "imread",
        "as_grey",
        "CASE",
        "np",
        "array",
        "math",
        "cos",
        "math",
        "sin",
        "math",
        "sin",
        "math",
        "cos",
        "affine_transform",
        "sourceimg",
        "tfrm",
        "plt",
        "imshow",
        "outimg",
        "CASE",
        "affine_registration",
        "sourceimg",
        "targetimg",
        "debug",
        "tfrm",
        "affine_transform",
        "sourceimg",
        "tfrm",
        "plt",
        "subplot",
        "plt",
        "imshow",
        "targetimg",
        "cmap",
        "plt",
        "subplot",
        "plt",
        "imshow",
        "outimg",
        "cmap",
        "plt",
        "subplot",
        "plt",
        "imshow",
        "targetimg",
        "outimg",
        "cmap"
    ],
    "literals": [
        "'nearest'",
        "'symm'",
        "'same'",
        "'__main__'",
        "'/data/brainmix_data/test043_TL/p1-D4-01b.jpg'",
        "'/data/brainmix_data/test043_TL/p1-D3-01b.jpg'",
        "'PiYG'",
        "'PiYG'",
        "'PiYG'"
    ],
    "variables": [
        "matrix",
        "skTransform",
        "outimg",
        "identity",
        "imshape",
        "height",
        "width",
        "newtfrm",
        "lambdavar",
        "scharr",
        "tgrad",
        "err",
        "bestMeanSquares",
        "xdx",
        "ydx",
        "xdy",
        "ydy",
        "heightSq",
        "widthSq",
        "displacement",
        "Jacobian",
        "sHessian",
        "gradient",
        "sHessianDiag",
        "updateinv",
        "updateinv",
        "update",
        "newtfrmfull",
        "attempt",
        "attempt",
        "displacement",
        "err",
        "bestMeanSquares",
        "newtfrm",
        "sourcePyramid",
        "targetPyramid",
        "tfrm",
        "tfrm",
        "toptfrm",
        "sourceimg",
        "targetimg",
        "CASE",
        "tfrm",
        "outimg",
        "tfrm",
        "outimg"
    ],
    "comments": [
        "-- Use Scharr operator to calculate image gradient in horizontal and vertical directions --",
        "-- Calculate current error --",
        "-- Pre-calculate items for the Hessian (for efficiency) --",
        "NOTE: using range() for compatibility with Python3",
        "print lambdavar",
        "print gradient",
        "print update",
        "print attempt",
        "NOTE: Numpy 1.7 or newer has np.copyto() which should be faster than copy()",
        "We need to copy values, tfrm=attempt would just make a reference to 'attempt'",
        "FIXME: we may need to prevent lambda from becoming 0",
        "-- compute small scale rigid body transformation to provide the initial guess for the affine transformation --",
        "Scale translation for next level in pyramid",
        "print 'Layer {0}: {1}x{2}'.format(layer, *targetPyramid[layer].shape)",
        "print 'th={0:0.4}, x={1:0.1f} , y={2:0.1f}'.format(*toptfrm) ### DEBUG"
    ],
    "docstrings": [
        "'''\nAffine image registration.\n\nThis module implements the algorithm by Simon Baker and Iain Matthews (2004)\n\"Lucas-Kanade 20 Years On: A Unifying Framework\"\nhttp://www.ri.cmu.edu/pub_files/pub3/baker_simon_2004_1/baker_simon_2004_1.pdf\n\nwith improved convergence by Noppadol Chumchob and Ke Chen (2009)\n\"A Robust Affine Registration Method\"\nhttp://www.math.ualberta.ca/ijnam/Volume-6-2009/No-2-09/2009-02-09.pdf\n\n\nWritten by Anna Lakunina and Santiago Jaramillo.\nSee AUTHORS file for credits.\n\nTO DO:\n- does Hessian computation need to be inside loop when we've taken out the mask?\n'''",
        "'''\n    Apply an affine transformation to an image (grayscale).\n\n    Args: \n        image (np.ndarray): original image\n        tfrm (np.ndarray): (3,3) homogeneous affine transformation matrix.\n\n    Returns:\n        outimg (np.ndarray): A transformed image.\n    '''",
        "'''\n    Apply modified Levenberg-Marquardt algorithm to minimize the difference in pixel\n    intensities between the source and target images.\n\n    Args:\n        source (np.ndarray): source image, the one that will be transformed.\n        target (np.ndarray): target image, the one that will not move.\n        tfrm (np.ndarray): (3,2) initial transformation [homogeneous affine transformation matrix].\n        maxIterations (int): maximum number of iterations performed by algorithm before returning a transformation\n\n    Returns:\n        tfrm (np.ndarray): (3,2) best transformation.\n    '''",
        "'''\n    Find affine transformation that registers source image to the target image.\n\n    This function computes the image pyramid for source and target and calculates the transformation\n    that minimizes the least-square error between images (starting at the lowest resolution).\n\n    Args:\n        source (np.ndarray): source image, the one that will be transformed.\n        target (np.ndarray): target image, the one that will not move.\n        pyramidDepth (int): number of pyramid levels, in addition to the original.\n        minLevel (int): 0 for original level, >0 for coarser resolution.\n    \n    Return:\n        tfrm (np.ndarray):\n    '''",
        "'''rtfrm = imreg.rigid_body_registration(sourcePyramid[minLevel], targetPyramid[minLevel], pyramidDepth-minLevel)\n    rotmatrix = np.array([[math.cos(rtfrm[0]), -math.sin(rtfrm[0])], [math.sin(rtfrm[0]), math.cos(rtfrm[0])]])\n    tfrm = np.append(rotmatrix, [[rtfrm[1]], [rtfrm[2]]], 1)\n    tfrm[:,-1] /= pow(downscale,pyramidDepth-minLevel)'''"
    ],
    "functions": [
        "affine_transform",
        "affine_least_squares",
        "affine_registration"
    ],
    "classes": []
}