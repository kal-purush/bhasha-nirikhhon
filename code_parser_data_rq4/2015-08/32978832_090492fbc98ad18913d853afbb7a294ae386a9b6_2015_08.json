{
    "identifiers": [
        "division",
        "glob",
        "glob",
        "os",
        "os",
        "path",
        "op",
        "matplotlib",
        "pyplot",
        "plt",
        "numpy",
        "np",
        "pandas",
        "pd",
        "nibabel",
        "nitime",
        "timeseries",
        "nitime",
        "analysis",
        "nitime",
        "viz",
        "utils_rois",
        "os",
        "environ",
        "rootdir",
        "os",
        "path",
        "join",
        "os",
        "getenv",
        "op",
        "join",
        "datadir",
        "op",
        "join",
        "datadir",
        "op",
        "join",
        "datadir",
        "r",
        "list_rois",
        "s",
        "list_subjs",
        "glob",
        "datadir",
        "s",
        "op",
        "join",
        "path_rois",
        "r",
        "utils_rois",
        "get_data_in_roi",
        "path_roi",
        "data_file",
        "plt",
        "figure",
        "pd",
        "DataFrame",
        "columns",
        "columns",
        "name_cond",
        "label",
        "conditions",
        "iteritems",
        "utils_rois",
        "get_onsets",
        "path_onsets",
        "label",
        "utils_rois",
        "analyze_average",
        "data",
        "ravel",
        "onsets",
        "sampling_interval",
        "time_unit",
        "time_unit",
        "et",
        "append",
        "analyzer",
        "eta",
        "analyzer",
        "eta",
        "data",
        "list_cd",
        "append",
        "name_cond",
        "means",
        "append",
        "np",
        "mean",
        "data",
        "figure",
        "get_axes",
        "figure",
        "add_subplot",
        "figure",
        "get_axes",
        "np",
        "array",
        "analyzer",
        "eta",
        "time",
        "analyzer",
        "eta",
        "time",
        "_conversion_factor",
        "ax",
        "xaxis",
        "set_ticks",
        "time",
        "ax",
        "plot",
        "time",
        "analyzer",
        "eta",
        "data",
        "label",
        "label",
        "name_cond",
        "linewidth",
        "marker",
        "xdata",
        "time",
        "curve",
        "analyzer",
        "eta",
        "data",
        "analyzer",
        "ets",
        "data",
        "ax",
        "fill_between",
        "time",
        "y",
        "error",
        "y",
        "error",
        "alpha",
        "edgecolor",
        "facecolor",
        "for_color",
        "get_color",
        "figure",
        "axes",
        "curve",
        "legend",
        "name_cond",
        "i",
        "len",
        "time",
        "label",
        "i",
        "len",
        "time",
        "time",
        "tolist",
        "analyzer",
        "eta",
        "data",
        "tolist",
        "analyzer",
        "ets",
        "data",
        "tolist",
        "pd",
        "DataFrame",
        "to_save",
        "columns",
        "df_to_save",
        "append",
        "df",
        "df_to_save",
        "figure",
        "get_axes",
        "ax",
        "get_xlim",
        "join",
        "key",
        "key",
        "conditions",
        "iterkeys",
        "format",
        "s",
        "s",
        "roi",
        "r",
        "conditions_name",
        "conditions_name",
        "figure",
        "suptitle",
        "title",
        "ax",
        "get_xlim",
        "join",
        "key",
        "key",
        "conditions",
        "iterkeys",
        "format",
        "s",
        "s",
        "roi",
        "r",
        "conditions_name",
        "conditions_name",
        "figure",
        "savefig",
        "op",
        "join",
        "save_analysis",
        "format",
        "file_name",
        "file_name",
        "df_to_save",
        "to_csv",
        "op",
        "join",
        "save_analysis",
        "format",
        "file_name",
        "file_name",
        "plt",
        "show",
        "plt",
        "close",
        "figure"
    ],
    "literals": [
        "\"/neurospin/unicog/protocols/IRMf/Tests_Isa/Test_nitime/\"",
        "\"test_data_antonio\"",
        "'ROOTDIR'",
        "'ROOTDIR'",
        "\"times_series_analysis\"",
        "\"ROIs_analyses\"",
        "'pSTS_Pallier_2011.nii'",
        "'AB130058'",
        "'AB130058'",
        "'onsets/ab130058_cLSF1_bis.dat'",
        "'c01'",
        "'c02'",
        "'c04'",
        "'c08'",
        "'s'",
        "\"/\"",
        "\"/fMRI/acquisition1/\"",
        "\"swaclsf1*.nii\"",
        "'condition_name'",
        "'condition_label'",
        "'time'",
        "'average'",
        "'standart_deviation'",
        "' : '",
        "'+'",
        "'#CC4F1B'",
        "'condition_name'",
        "'condition_label'",
        "'time'",
        "'average'",
        "'standart_deviation'",
        "'condition_name'",
        "'condition_label'",
        "'time'",
        "'average'",
        "'standart_deviation'",
        "', '",
        "'Plot of {s}, for {roi} and the {conditions_name}'",
        "'_'",
        "'{s}_{roi}_{conditions_name}.png'",
        "'{file_name}.png'",
        "'{file_name}.csv'"
    ],
    "variables": [
        "rootdir",
        "datadir",
        "save_analysis",
        "path_rois",
        "list_rois",
        "list_subjs",
        "path_onsets",
        "conditions",
        "sampling_interval",
        "time_unit",
        "data_file",
        "path_roi",
        "data",
        "et",
        "means",
        "list_cd",
        "figure",
        "columns",
        "df_to_save",
        "onsets",
        "analyzer",
        "data_to_plot",
        "ax",
        "ax",
        "time",
        "curve",
        "for_color",
        "y",
        "error",
        "curve",
        "to_save",
        "df",
        "df_to_save",
        "ax",
        "xlim",
        "conditions_name",
        "title",
        "xlim",
        "conditions_name",
        "file_name"
    ],
    "comments": [
        "-*- coding: utf-8 -*-",
        "GENERIC MODULES",
        "SPECIFIC MODULES",
        "UNICOG MODULES",
        "",
        "SET THE PATHS",
        "",
        "GET THE DATADIR",
        "datadir = utils_rois.get_rootdir()",
        "OR",
        "",
        "ROI(s) ANALYSIS",
        "",
        "CAS VOXEL COORDINATES",
        "if rois are voxels coordinates in MNI, convert them into volume",
        "list_coord = []",
        "list_rois = utils_roi.get_volume_from_coord(list_coord, path_rois)",
        "CAS ROI NAMES",
        "",
        "SUBJECT(s) SELECTION",
        "",
        "",
        "CONDITION(s) SELECTION",
        "IN THIS EXAMPLE",
        "0 = T0 (target, sentence indicating to push on the button)",
        "1 = c01 (liste de signes)",
        "2 = c02",
        "3 = c04",
        "4 = c08 (phrases de 8 signes)",
        "",
        "here read the onset from a .dat file",
        "conditions = {'T0':0, 'c01':1, 'c02':2, 'c04':3, 'c08':4, 'cM':5} #dic of conditions",
        "dic of conditions",
        "conditions = {'c08':4}",
        "conditions = {'c01':1, 'c02':2, 'c08':4}",
        "",
        "PARAMS FOR THE ANALYZE",
        "",
        "sampling_interval = TR value",
        "SUBJECT LEVEL ANALYSIS",
        "Pattern to fetch data for each subj",
        "Many methods to extract data are available in utils_roi",
        "Here using of NiftiMapsMasker",
        "Filtered data ...",
        "data = data_filtered(data)",
        "INTIALIZATION",
        "list_data_avg = []",
        "list_data_se = []",
        "SAVE THE VALUES INTO DATAFRAME",
        "get the onsets for one condition",
        "methods available to plot data using ntime module",
        "print analyzer.eta",
        "list_data_avg.append = []",
        "list_data_se.append = []",
        "",
        "fig02 = viz.plot_tseries(analyzer.FIR, ylabel='BOLD (% signal change)')",
        "figure = viz.plot_tseries(",
        "timeseries.TimeSeries(analyzer.eta, sampling_rate=sampling_interval,",
        "time_unit='s'), fig = figure, label=name_cond)",
        "figure = viz.plot_tseries(",
        "timeseries.TimeSeries(analyzer.eta,",
        "sampling_rate=sampling_interval,",
        "#time = analyzer.eta.time,",
        "time_unit = 's'),",
        "fig = figure,",
        "label=name_cond,",
        "linewidth=0.2,",
        "marker='+',",
        "xdata= analyzer.eta.time",
        ")",
        "#ax = figure.add_subplot()",
        "need to divide by the _conversion_factor attribute added by nitime",
        "add sd",
        "ax.errorbar(time, analyzer.eta.data, yerr=error, linestyle=\"None\", marker=\"None\")",
        "curve.axis([-2, 6, 681,688])",
        "SAVE IN DATA_FRAME",
        "utils_rois.save_data_time_analysis(file_csv,",
        "time,",
        "name_cond,",
        "label,",
        "analyzer.eta.data,",
        "analyzer.ets.data)",
        "plot the results: all condition for the same subj, the same rois",
        "legend",
        "figure = viz.plot_tseries(analyzer.eta, ylabel='Bold signal', time_unit='s')",
        "select the condition for the display",
        "list_data = []",
        "for i, c in conditions.iteritems():",
        "print i",
        "print c",
        "list_data.append(et[i].data)",
        "data_to_plot=np.vstack(list_data)",
        "print data_to_plot",
        "Plot the data",
        "figure = viz.plot_tseries(",
        "timeseries.TimeSeries(data=np.vstack([et[3].data, et[4].data]),",
        "sampling_rate=et[3].sampling_rate, time_unit='s'))",
        "timeseries.TimeSeries(data_to_plot,",
        "sampling_rate=sampling_interval,",
        "time_unit='s'), axis = '-4.8' )",
        "figure = plt.figure()",
        "for plot in list_data:",
        "figure = viz.plot_tseries(",
        "timeseries.TimeSeries(plot, sampling_rate=sampling_interval,",
        "time_unit='s'), fig = figure, label='toto')",
        "curve = figure.axes[0]",
        "curve.legend()",
        "figure = viz.plot_tseries(timeseries.TimeSeries(data=np.vstack([et[0].data, et[1].data])), ylabel='Bold signal', time_unit='s')",
        "print type(figure)",
        "add title",
        "print conditions_name",
        "add legend",
        "print xlim",
        "ax.plot([xlim[0], xlim[1]], [means[0], means[0]], 'b--')",
        "ax.plot([xlim[0], xlim[1]], [means[1], means[1]], 'g--')",
        "print figure.axes",
        "for subplot in figure.axes :",
        "print subplot",
        "SAVE THE PLOTS",
        "matplotlib.pyplot.imsave",
        "print op.join(save_analysis, file_png)",
        "save the figure to file",
        "close the figure",
        "SAVE in pdf",
        "from matplotlib.backends.backend_pdf import PdfPages",
        "pp = PdfPages('multipage.pdf')",
        "You can give the PdfPages object to savefig(), but you have to specify the format:",
        "plt.savefig(pp, format='pdf')",
        "An easier way is to call PdfPages.savefig:",
        "pp.savefig()",
        "Finally, the multipage pdf object has to be closed:",
        "pp.close()"
    ],
    "docstrings": [
        "\"\"\"\nCreated on Fri Jul 31 09:12:50 2015\n\n@author: id983365\n\n\"\"\"",
        "\"\"\"\nEvent-related analysis\n\nTR\n\nINPUT / OUTPUT\nINPUT\ndata :  raw data\n        beta\n        group level\n\nmask : roi\n       voxel\n\nonsets\n\ncon\n\nOUTPUT\n\naverage / sdt\n\n\nFUNCTIONS\nremove low frequence before\nanalysis one condtion\nanalysis grouping of conditions\n\ncalculer les résidus\n\nROI\n1) extraction of data into fmri data and compute the mean\nnscans * 1\n\n2) extraction beta values and compute the mean\nnscans * nb reg\n\n3) SPM.mat : extraction of SPM.xX.X\nnscans * nb reg\n\n4) compute the Y and Y\ncase     Y = SPM.xX.X * beta;\n\n5) prepare the time axis\n\n6) prepare mean and sd\nfor each run in runs\n for condition in conditions\n   test\n   mean : add the value\n   sdt : add the value\n\n\nNot yet implemented : Finterest\nY = spm_FcUtil('Yc',SPM.xCon(Ic),SPM.xX.xKXs,beta);\nLIKE IN STANPLOT\nFinterest\n%%%% The argument Finterest (usually = 1) indicates which contrast in the SPM model\n%%%% refers to the F test of real interest. This F test usually has ones in columns for all\n%%%% variables of interest, and zero everywhere else, e.g. for movement\n%%%% regressors whose effects on the data must be subtracted out.\n%%%% Specify zero (0) if you have no contrast of interest. However, note\n%%%% that your plot may not be as nice as it could be (for instance, the\n%%%% effects of movement might be regressed out in the SPM stats, but not\n%%%% in your plot).\n\nTO CHECK\n\nbcov : to see\n\nFIR\n\n\nReunion 28/07 \n\nConversion du stanplot\n\nInput\n\n\nOutput\n\n\n\nsingle subj\ngroupe\nmultigroup : comparaison groupes\n\npb avec stanplot pour definr les groupes\n\nCAS single subj\n\ntimeS : y\ncond / onset\n-> selective avering ou FIR\n\ndonc reucp Y ou y\n\nraw signal\nrawsignal avec var nuisance enlevés\nY provenant du model FIT\n\n-> implementaiton\ny = get_raw_data(funcfiles, ROI) -> cas du voxel à traiter\n(recréer une roi à partir d'une coord)\ny2 = remove_nuissance_variables\nonstes, conds = read_onset_onset_files (csv)\nplot_fir(y, conds, onsets)\nplot_avg(y, conds, onsets)\n\nget_model_fit(SPM_mat ou autres valeurs contenant )\n\ninput\n\noutput\n\nX : XiBi + xnBn + con \nXnBn -> varaibles nuisance\n\n\nAttention affine qd extraction ROIs\n\nB  si plusieurs sessions > moyenne\n\n\nComparaison des .dat\n\n\nModules nistat\nnilearn : good\nnipy : premier prjet à la dérive\nnistat : new projet\n\n\nMême ROIs pour tous les sujets\nmais on peut faire l'instersection avec un masque du sujet\n-> frederinko\nliste sujet\nliste locai\nliste scans (betas ou con)\ncol roi, col suj, col signal(beta)\ninput ; localiser : intersction localizer/ roi\n\nlocalizer puet etre un carte par ex de SPM_T\nSPMT con, -> seuill SPm_T à 10-3 par ex, 3.2\nintersection SPMt\ndefaut sjt avec bcp de voxles et d'autres non\netendu des activation sensibles aux seuils\n-> donc pas bonne idee de choisi un seuil commun pour tous les sujets\nautre methodes :\nnvoxels (mm pour tous les sujets) les plus activées = p% de voxels activées env 20-25 %\nsi plus grosse ROI, % plus bas\n\ncode Christophe\n-> cf code niftimasker ghtiutb nilearnissu\nv1 : 1iere methode\nv2 = seuil fix pour localizer\nv3 = methode avec %\n\nnop nifitmaps masker : serie images binaires\n\ngit -> code de christophe\n\nqd  groupe\n\nstanplot que methode 1, ajout possibilté des methodes 2 et 3\n\nrenomer les noms des methodes\nget raw_data utilisr le code christophe\n\n\nvariables de nuissance\nvoir nilearn, nibabel sous forme de fichier txt, \nmm log que timeseries\net voir aussi filtrage temporel\n\n\ncomparaison de donner : simuler les données\ngenerer + ajout bruit\n\n\nread onset fmri -> martin\n\n\ngroupement des conditions\nsi grpmt et mis a zero -> part dans la baseline\n\nSOA 4 secondes = pics tous les 4 secondes\n-> mélanges de conditions\n-> FIR régression linéaire, contribution des différentes conditions\n\nFIR enlever l'effet de tous si on les mets tous ! [1 1 1 1 1] dans \nle groupVar\n\nUtiliser nifitmasker qui vérifie l'affine\n\nCorrection : passer les params de realignements à la fonction\nreader nibabel ou nilearn -> variables de nuisances\n\nspm_filter reader nilearn -> see the cutoff\n\n-- \nBcp de basses fréquences \nSPM : cutoff à 128 par défaut\nsin et cos de basse fréquence, 128s puis 2 fois, puis 4 fois \npuis regarder les résidus\n\n--\npb autour de 0 -> baseline ?\nBaseline utile mais pas forcée\n\n--\nGrp => cond, onsets\nplot_fmri\nnoms des conditions, pas de labels avec des chiffres\n\n\nmanip pour merge les conditions\nplot_fmri\nplot_avg\n\nd1 = dict(cd1=onset, cd2=onset)\nd2=[\"new\"] = d1[cond] + d2[cond2]\n\nLocalizer peut être 1 contraste de la manip principale,\ndonnées 1 session et utiliser sur les autres sessions. \n \nSUMMARY :\n\nCOMPARAISON OF:\npour un single subj | pour un groupe | multigroup : comparaison groupes\n\n\nINPUT :\nInput_1 : signal, can be\n raw signal | rawsignal avec var nuisance enlevés | Y provenant du model FIT\nInput_2 : rois\n\n\n\ntimeS : y\ncond / onset\n-> selective avering ou FIR\n\ndonc reucp Y ou y\n\n\nA VOIR:\n\nQuand utilisation de 'c04':3 :\n  File \"/home/id983365/.local/lib/python2.7/site-packages/nitime/timeseries.py\", line 977, in __getitem__\n    return self.data[key]  # time is the last dimension\nIndexError: index 177 is out of bounds for axis 1 with size 177\n\nNiftiMasker\n\n\nSCRIPT TO SHOW \n\nINPUT\n\nOUTPUT :\nevented related plot for unfiltered fmri signal.\n\n\n\n\"\"\""
    ],
    "functions": [],
    "classes": []
}