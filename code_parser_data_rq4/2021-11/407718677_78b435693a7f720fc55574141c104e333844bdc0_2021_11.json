{
    "identifiers": [
        "args",
        "generateParenthesis",
        "n",
        "res",
        "dfs",
        "n",
        "n",
        "res",
        "res",
        "s",
        "lCount",
        "rCount",
        "res",
        "lCount",
        "rCount",
        "res",
        "add",
        "s",
        "lCount",
        "dfs",
        "s",
        "lCount",
        "rCount",
        "res",
        "rCount",
        "lCount",
        "rCount",
        "dfs",
        "s",
        "lCount",
        "rCount",
        "res"
    ],
    "literals": [
        "\"\"",
        "\"(\"",
        "\")\""
    ],
    "variables": [],
    "comments": [
        "Solution s = new Solution();",
        "System.out.println(s.generateParenthesis(6));",
        "static class Solution {",
        "private int n;",
        "private List<String> list;",
        "private int[] visit;",
        "private StringBuilder s;",
        "",
        "public List<String> generateParenthesis(int n) {",
        "this.n = n;",
        "this.list = new ArrayList<>();",
        "this.visit = new int[2*n+1];",
        "this.s = new StringBuilder();",
        "",
        "Set<String> sets = new HashSet<>();",
        "for (int i = 1; i <= 2*n; i++) {",
        "if (i <= n) {",
        "visit[i] = 1;",
        "s.append(\"(\");",
        "dfs(s, sets);",
        "s.deleteCharAt(s.length()-1);",
        "visit[i] = 0;",
        "} else {",
        "visit[i] = 1;",
        "s.append(\")\");",
        "dfs(s, sets);",
        "s.deleteCharAt(s.length()-1);",
        "visit[i] = 0;",
        "}",
        "",
        "}",
        "",
        "this.list = new ArrayList<>(sets);",
        "",
        "int j = 0;",
        "while (j != list.size()) {",
        "if (!isValid(list.get(j)))",
        "list.remove(j);",
        "else",
        "j++;",
        "}",
        "",
        "return this.list;",
        "}",
        "",
        "/**",
        "public void dfs(StringBuilder s, Set<String> sets) {",
        "/**",
        "if (s.length() == 2*n) {",
        "sets.add(new String(s));",
        "return;",
        "}",
        "",
        "for (int i = 1; i <= 2*n; i++) {",
        "/**",
        "if(visit[i] == 1){",
        "continue;",
        "}",
        "",
        "if (i <= n) {",
        "visit[i] = 1;",
        "s.append(\"(\");",
        "dfs(s, sets);",
        "s.deleteCharAt(s.length()-1);",
        "visit[i] = 0;",
        "} else {",
        "visit[i] = 1;",
        "s.append(\")\");",
        "dfs(s, sets);",
        "s.deleteCharAt(s.length()-1);",
        "visit[i] = 0;",
        "}",
        "}",
        "}",
        "",
        "/**",
        "public boolean isValid(String s) {",
        "Stack<Character> stack = new Stack<Character>();",
        "",
        "for (int i = 0; i < s.length(); i++) {",
        "if (s.charAt(i) == '(') {",
        "stack.push('(');",
        "} else {",
        "if (stack.empty() || stack.pop() != '(') {",
        "return false;",
        "}",
        "}",
        "}",
        "",
        "if (!stack.empty()) {",
        "return false;",
        "}",
        "",
        "return true;",
        "}",
        "}"
    ],
    "docstrings": [
        "* dfs + 回溯\n     * 有效括号：左括号剩余数必须少于右括号时，才可以添加右括号\n     * @param s  s的传递相当于回溯\n     * @param lCount\n     * @param rCount\n     * @param res",
        "* dfs + 回溯生成所有情形",
        "* @param s",
        "*/",
        "* 满足条件",
        "*/",
        "* 剪枝",
        "*/",
        "* 判断是否是有效括号",
        "* @param s",
        "* @return",
        "*/"
    ],
    "functions": [
        "main",
        "generateParenthesis",
        "dfs"
    ],
    "classes": [
        "Main"
    ]
}