{
    "identifiers": [
        "bisect",
        "copy",
        "dataclasses",
        "dataclass",
        "field",
        "typing",
        "Tuple",
        "Any",
        "cached_property",
        "cached_property",
        "paderbox",
        "array",
        "interval",
        "core",
        "ArrayInterval",
        "numpy",
        "np",
        "paderbox",
        "pb",
        "paderbox",
        "array",
        "interval",
        "util",
        "cy_parse_item",
        "cy_invert_intervals",
        "torch",
        "shape",
        "shape",
        "isinstance",
        "shape",
        "shape",
        "isinstance",
        "shape",
        "shape",
        "shape",
        "all",
        "isinstance",
        "s",
        "s",
        "shape",
        "shape",
        "shape",
        "shape",
        "shape",
        "SparseArray",
        "shape",
        "shape",
        "shape1",
        "shape2",
        "shape1",
        "shape2",
        "ValueError",
        "shape1",
        "shape2",
        "target",
        "array",
        "onset",
        "onset",
        "array",
        "shape",
        "onset",
        "target",
        "shape",
        "onset",
        "array",
        "onset",
        "offset",
        "target",
        "shape",
        "target",
        "shape",
        "array",
        "target",
        "shape",
        "onset",
        "onset",
        "offset",
        "array",
        "dataclass",
        "np",
        "ndarray",
        "torch",
        "Tensor",
        "property",
        "onset",
        "array",
        "shape",
        "property",
        "array",
        "shape",
        "cached_property",
        "isinstance",
        "array",
        "torch",
        "Tensor",
        "__class__",
        "onset",
        "segment_length",
        "array",
        "dataclass",
        "field",
        "default_factory",
        "_normalize_shape",
        "shape",
        "_update_dtype",
        "dtype",
        "classmethod",
        "cls",
        "array",
        "offset",
        "shape",
        "SparseArray",
        "shape",
        "shape",
        "_add_segment",
        "_SparseSegment",
        "offset",
        "array",
        "dtype",
        "_new_full",
        "dtype",
        "dtype",
        "segment",
        "_segments",
        "_clip",
        "arr",
        "segment",
        "array",
        "segment",
        "onset",
        "array",
        "arr",
        "dtype",
        "pad_value",
        "dtype",
        "dtype",
        "_segments",
        "_segments",
        "array",
        "dtype",
        "dtype",
        "isinstance",
        "dtype",
        "torch",
        "dtype",
        "_is_torch",
        "torch",
        "tensor",
        "pad_value",
        "dtype",
        "dtype",
        "dtype",
        "pad_value",
        "_segments",
        "all",
        "s",
        "array",
        "dtype",
        "dtype",
        "s",
        "_segments",
        "s",
        "array",
        "dtype",
        "s",
        "_segments",
        "dtype",
        "property",
        "ArrayInterval",
        "pb",
        "array",
        "interval",
        "zeros",
        "shape",
        "_SparseSegment",
        "s",
        "_segments",
        "s",
        "onset",
        "s",
        "offset",
        "ai",
        "shape",
        "dtype",
        "fill_value",
        "shape",
        "shape",
        "dtype",
        "dtype",
        "fill_value",
        "pad_value",
        "_is_torch",
        "torch",
        "full",
        "size",
        "shape",
        "fill_value",
        "fill_value",
        "dtype",
        "dtype",
        "np",
        "full",
        "shape",
        "shape",
        "fill_value",
        "fill_value",
        "dtype",
        "dtype",
        "segment",
        "_SparseSegment",
        "_segments",
        "_is_torch",
        "isinstance",
        "segment",
        "array",
        "torch",
        "Tensor",
        "isinstance",
        "segment",
        "array",
        "np",
        "ndarray",
        "segment",
        "array",
        "dtype",
        "_update_dtype",
        "segment",
        "array",
        "dtype",
        "dtype",
        "segment",
        "array",
        "dtype",
        "dtype",
        "segment",
        "array",
        "dtype",
        "segment",
        "array",
        "shape",
        "shape",
        "ValueError",
        "shape",
        "segment",
        "array",
        "shape",
        "segment",
        "offset",
        "segment",
        "onset",
        "shape",
        "bisect",
        "bisect_right",
        "s",
        "onset",
        "s",
        "_segments",
        "segment",
        "onset",
        "len",
        "_segments",
        "position",
        "_segments",
        "position",
        "offset",
        "segment",
        "onset",
        "textwrap",
        "ValueError",
        "textwrap",
        "indent",
        "repr",
        "_segments",
        "position",
        "textwrap",
        "indent",
        "repr",
        "segment",
        "position",
        "len",
        "_segments",
        "_segments",
        "position",
        "onset",
        "segment",
        "offset",
        "textwrap",
        "ValueError",
        "textwrap",
        "indent",
        "repr",
        "_segments",
        "position",
        "textwrap",
        "indent",
        "repr",
        "segment",
        "_segments",
        "insert",
        "position",
        "segment",
        "__class__",
        "shape",
        "shape",
        "segment",
        "_segments",
        "arr",
        "_add_segment",
        "_SparseSegment",
        "segment",
        "onset",
        "segment",
        "array",
        "arr",
        "memodict",
        "__class__",
        "shape",
        "shape",
        "segment",
        "_segments",
        "arr",
        "_add_segment",
        "_SparseSegment",
        "segment",
        "offset",
        "segment",
        "array",
        "copy",
        "arr",
        "dtype",
        "_is_torch",
        "NotImplementedError",
        "as_contiguous",
        "dtype",
        "textwrap",
        "_segments",
        "join",
        "_segments",
        "textwrap",
        "indent",
        "content",
        "content",
        "pad_value",
        "pad_value",
        "__class__",
        "content",
        "p",
        "shape",
        "item",
        "value",
        "isinstance",
        "item",
        "item",
        "len",
        "shape",
        "len",
        "selector",
        "selector",
        "NotImplementedError",
        "item",
        "isinstance",
        "item",
        "NotImplementedError",
        "__class__",
        "item",
        "cy_parse_item",
        "item",
        "shape",
        "stop",
        "start",
        "np",
        "isscalar",
        "value",
        "_new_full",
        "shape",
        "shape",
        "length",
        "fill_value",
        "value",
        "isinstance",
        "value",
        "np",
        "ndarray",
        "isinstance",
        "value",
        "torch",
        "Tensor",
        "value",
        "shape",
        "length",
        "ValueError",
        "value",
        "shape",
        "length",
        "_add_segment",
        "_SparseSegment",
        "start",
        "value",
        "NotImplementedError",
        "item",
        "isinstance",
        "item",
        "item",
        "item",
        "len",
        "shape",
        "selector",
        "selector",
        "len",
        "item",
        "len",
        "shape",
        "item",
        "isinstance",
        "item",
        "np",
        "integer",
        "item",
        "index",
        "index",
        "shape",
        "index",
        "shape",
        "index",
        "shape",
        "IndexError",
        "item",
        "shape",
        "bisect",
        "bisect_right",
        "s",
        "onset",
        "s",
        "_segments",
        "index",
        "position",
        "pad_value",
        "_segments",
        "position",
        "s",
        "onset",
        "index",
        "s",
        "offset",
        "s",
        "array",
        "selector",
        "index",
        "s",
        "onset",
        "pad_value",
        "cy_parse_item",
        "item",
        "shape",
        "stop",
        "start",
        "np",
        "zeros",
        "dtype",
        "dtype",
        "s",
        "s",
        "_segments",
        "s",
        "onset",
        "stop",
        "s",
        "offset",
        "start",
        "__class__",
        "shape",
        "_segments",
        "array",
        "selector",
        "shape",
        "stop",
        "start",
        "s",
        "active",
        "arr",
        "_add_segment",
        "_SparseSegment",
        "s",
        "onset",
        "start",
        "s",
        "array",
        "selector",
        "arr",
        "shape",
        "other",
        "isinstance",
        "other",
        "SparseArray",
        "_check_shape",
        "shape",
        "other",
        "shape",
        "copy",
        "copy",
        "self_copy",
        "other",
        "self_copy",
        "other",
        "other",
        "isinstance",
        "other",
        "_SparseSegment",
        "_add_segment",
        "_SparseSegment",
        "other",
        "onset",
        "other",
        "array",
        "isinstance",
        "other",
        "SparseArray",
        "_check_shape",
        "shape",
        "other",
        "shape",
        "s",
        "other",
        "_segments",
        "_add_segment",
        "_SparseSegment",
        "s",
        "onset",
        "s",
        "array",
        "other",
        "ufunc",
        "method",
        "inputs",
        "kwargs",
        "_is_torch",
        "method",
        "len",
        "inputs",
        "isinstance",
        "inputs",
        "SparseArray",
        "isinstance",
        "inputs",
        "SparseArray",
        "_check_shape",
        "inputs",
        "shape",
        "inputs",
        "shape",
        "isinstance",
        "inputs",
        "SparseArray",
        "isinstance",
        "inputs",
        "np",
        "ndarray",
        "inputs",
        "ufunc",
        "a",
        "b",
        "_ufunc",
        "b",
        "a",
        "kwargs",
        "pop",
        "copy",
        "copy",
        "inputs",
        "_combine_inplace_array_with_sparse",
        "ufunc",
        "inputs",
        "classmethod",
        "cls",
        "func",
        "types",
        "args",
        "kwargs",
        "kwargs",
        "isinstance",
        "args",
        "torch",
        "Tensor",
        "isinstance",
        "args",
        "SparseArray",
        "args",
        "_is_torch",
        "args",
        "func",
        "endswith",
        "clone",
        "_combine_inplace_array_with_sparse",
        "func",
        "args",
        "func",
        "input1",
        "input2",
        "input1",
        "shape",
        "input2",
        "shape",
        "segment",
        "input1",
        "_segments",
        "segments",
        "append",
        "segment",
        "segment",
        "input2",
        "_segments",
        "segments",
        "append",
        "segment",
        "sorted",
        "segments",
        "key",
        "x",
        "x",
        "onset",
        "s",
        "segments",
        "len",
        "c",
        "s",
        "onset",
        "s",
        "offset",
        "c",
        "s",
        "onset",
        "max",
        "s",
        "offset",
        "c",
        "connected_components",
        "append",
        "c",
        "s",
        "onset",
        "s",
        "offset",
        "c",
        "connected_components",
        "append",
        "c",
        "input1",
        "__class__",
        "shape",
        "input1",
        "shape",
        "start",
        "stop",
        "connected_components",
        "np",
        "asarray",
        "input1",
        "start",
        "stop",
        "input2",
        "start",
        "stop",
        "func",
        "lhs",
        "rhs",
        "add_segment",
        "start",
        "result",
        "_update_dtype",
        "func",
        "input1",
        "pad_value",
        "input2",
        "pad_value",
        "func",
        "array",
        "sparse_array",
        "segment",
        "sparse_array",
        "_segments",
        "_clip",
        "array",
        "segment",
        "array",
        "segment",
        "onset",
        "func",
        "array",
        "s",
        "array_",
        "func",
        "np",
        "add",
        "np",
        "subtract",
        "torch",
        "Tensor",
        "add_",
        "torch",
        "Tensor",
        "add",
        "torch",
        "Tensor",
        "sub_",
        "torch",
        "Tensor",
        "sub",
        "array",
        "cy_invert_intervals",
        "sparse_array",
        "interval",
        "normalized_intervals",
        "sparse_array",
        "shape",
        "start",
        "stop",
        "intervals",
        "start",
        "stop",
        "func",
        "array",
        "start",
        "stop",
        "sparse_array",
        "pad_value",
        "array"
    ],
    "literals": [
        "f'None shape is not supported'",
        "f'Invalid shape {shape} of type {type(shape)}'",
        "f'Invalid shape {shape} with elements of type {type(shape[0])}'",
        "f'Shape mismatch: {shape1} {shape2}'",
        "f'{self.__class__.__name__}(onset={self.onset}, '",
        "f'length={self.segment_length}: {self.array})'",
        "f'Type mismatch: SparseArray has dtype {self.dtype}, but '",
        "f'assigned array has dtype {segment.array.dtype}'",
        "f'Shape mismatch: SparseArray has shape {self.shape}, but '",
        "f'assigned array has shape {segment.array.shape}.'",
        "f'Overlap detected between \\n'",
        "f'{textwrap.indent(repr(self._segments[position - 1]), \"  \")}\\n'",
        "\"  \"",
        "f'and newly added\\n'",
        "f'{textwrap.indent(repr(segment), \"  \")}'",
        "\"  \"",
        "f'Overlap detected between \\n'",
        "f'{textwrap.indent(repr(self._segments[position]), \"  \")}\\n'",
        "\"  \"",
        "f'and newly added'",
        "f'{textwrap.indent(repr(segment), \"  \")}'",
        "\"  \"",
        "'__array__ is not implemented for torch SparseArrays'",
        "'\\n'",
        "'  '",
        "'\\n'",
        "',\\n  '",
        "''",
        "f'pad_value={self.pad_value}, '",
        "''",
        "f'{self.__class__.__name__}({content}{p}shape={self.shape})'",
        "'Only ellipsis is allowed for first dimensions in setitem'",
        "f'{self.__class__.__name__}.__setitem__ only supports slices '",
        "f'for indexing, not {item!r}'",
        "f'Could not assign array with shape {value.shape} to '",
        "f'SparseArray slice with size {length}'",
        "f'Index {item} is out of bounds for ArrayInterval with '",
        "f'shape {self.shape}'",
        "'__call__'",
        "'out'",
        "'_'"
    ],
    "variables": [
        "offset",
        "array",
        "onset",
        "offset",
        "array",
        "onset",
        "array",
        "shape",
        "_segments",
        "pad_value",
        "_is_torch",
        "dtype",
        "shape",
        "arr",
        "s",
        "array",
        "arr",
        "s",
        "dtype",
        "dtype",
        "_is_torch",
        "pad_value",
        "pad_value",
        "ai",
        "s",
        "ai",
        "shape",
        "dtype",
        "fill_value",
        "position",
        "arr",
        "arr",
        "content",
        "content",
        "content",
        "content",
        "p",
        "p",
        "selector",
        "item",
        "start",
        "stop",
        "length",
        "value",
        "item",
        "selector",
        "selector",
        "item",
        "item",
        "index",
        "index",
        "position",
        "s",
        "start",
        "stop",
        "active",
        "arr",
        "self_copy",
        "inputs",
        "_ufunc",
        "ufunc",
        "connected_components",
        "segments",
        "segments",
        "c",
        "c",
        "c",
        "c",
        "lhs",
        "rhs",
        "result",
        "s",
        "array_",
        "array",
        "s",
        "intervals",
        "array"
    ],
    "comments": [
        "As of now, we only support fixed shapes. This can be changed",
        "Use dataclass for recursive to_numpy",
        "(repr=False, eq=False)",
        "Public constructor interface",
        "Private constructor arguments: Don't use _segments directly.",
        "This is required for pt.data.batch.example_to_device to work",
        "Other instance attributes",
        "Check input dtype and shape",
        "This is the first segment we add. It defines dtype and pad value",
        "Ignore setting anything that is outside of the boundaries (numpy",
        "behavior)",
        "Get insert position",
        "Check for overlaps with neighboring segments",
        "Could be optimized",
        "This is numpy behavior",
        "Get all active segments",
        "Useful math operations",
        "Let numpy handle this case",
        "Only supported if all segments are numpy arrays",
        "Only support elementwise operations",
        "TODO: We could allow reductions along free dimensions",
        "Only support combination of np.ndarray and SparseArray",
        "Make sure that both have the same shape",
        "The code blow expects the numpy array to be the LHS. Swap if",
        "it is supplied as the RHS",
        "Left-hand side is numpy array, right hand side is SparseArray,",
        "Only supported if tensor is RHS",
        "Only supported if all segments are torch tensors",
        "If func is not inplace: Copy. All inplace function names end with '_'",
        "Shortcut functions where 0 is the neutral element",
        "Handle everything outside segments"
    ],
    "docstrings": [
        "\"\"\"\n    A sparse array implementation using intervals to define non-zero regions.\n\n    >>> a = SparseArray(shape=(20, ))\n    >>> a\n    SparseArray(shape=(20,))\n    >>> a[5:10] = np.ones(5, dtype=int)\n    >>> a\n    SparseArray(\n      _SparseSegment(onset=5, length=5: [1 1 1 1 1]),\n      shape=(20,))\n    >>> np.asarray(a)\n    array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    >>> a[15:20] = 2\n    >>> a\n    SparseArray(\n      _SparseSegment(onset=5, length=5: [1 1 1 1 1])\n      _SparseSegment(onset=15, length=5: [2 2 2 2 2]),\n      shape=(20,))\n    >>> np.asarray(a)\n    array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2])\n\n    Overlapping intervals are not allowed\n    >>> a[5:20] = 3\n    Traceback (most recent call last):\n      ...\n    ValueError: Overlap detected between\n      _SparseSegment(onset=5, length=5: [1 1 1 1 1])\n    and newly added\n      _SparseSegment(onset=5, length=15: [3 3 3 3 3 3 3 3 3 3 3 3 3 3 3])\n\n\n    dtype is inferred from segments:\n    >>> a.dtype\n    dtype('int64')\n    >>> a.pad_value, type(a.pad_value)\n    (0, <class 'numpy.int64'>)\n\n    Can't add segments with differing dtypes (yet)\n    >>> a[:3] = np.ones(3, dtype=np.float32)\n    Traceback (most recent call last):\n      ...\n    TypeError: Type mismatch: SparseArray has dtype int64, but assigned array has dtype float32\n\n    Adding multiple SparseArray returns a SparseArray\n    >>> b = SparseArray(a.shape)\n    >>> b[10:15] = 8\n    >>> a + b\n    SparseArray(\n      _SparseSegment(onset=5, length=5: [1 1 1 1 1])\n      _SparseSegment(onset=10, length=5: [8 8 8 8 8])\n      _SparseSegment(onset=15, length=5: [2 2 2 2 2]),\n      shape=(20,))\n    >>> np.asarray(a + b)\n    array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 2, 2, 2, 2, 2])\n\n    Arithmetic works with numpy arrays\n    >>> np.ones(20, dtype=int) * a\n    array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2])\n    >>> np.ones(20, dtype=int) + a\n    array([1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3])\n    >>> a + np.ones(20, dtype=int)\n    array([1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3])\n    >>> c = np.ones(20, dtype=int)\n    >>> c += a\n    >>> c\n    array([1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3])\n\n    \"\"\"",
        "\"\"\"\n        >>> a = SparseArray(10)\n        >>> a[:3] = 1\n        >>> a[3:5] = np.arange(2) + 1\n        >>> a[6:8] = np.ones(2, dtype=int)\n        >>> np.asarray(a)\n        array([1, 1, 1, 1, 2, 0, 1, 1, 0, 0])\n\n        >>> a = SparseArray(10)\n        >>> a[:100] = 1\n        >>> a\n        SparseArray(\n          _SparseSegment(onset=0, length=10: [1 1 1 1 1 1 1 1 1 1]),\n          shape=(10,))\n\n        # Multi-dimensional\n        >>> a = SparseArray((2, 10))\n        >>> a[..., :5] = 1\n        >>> a[..., 7:] = np.arange(6).reshape((2, 3))\n        >>> np.asarray(a)\n        array([[1, 1, 1, 1, 1, 0, 0, 0, 1, 2],\n               [1, 1, 1, 1, 1, 0, 0, 3, 4, 5]])\n        >>> a[0, 5:] = 2\n        Traceback (most recent call last):\n          ...\n        NotImplementedError: Only ellipsis is allowed for first dimensions in setitem\n\n\n        # Test some exceptions\n        >>> a = SparseArray(shape=10)\n        >>> a[:5] = np.ones(3)\n        Traceback (most recent call last):\n         ...\n        ValueError: Could not assign array with shape (3,) to SparseArray slice with size 5\n        >>> a[:5] = np.ones((1, 5))\n        Traceback (most recent call last):\n         ...\n        ValueError: Shape mismatch: SparseArray has shape (10,), but assigned array has shape (1, 5).\n        >>> a[:100] = np.ones(100)\n        Traceback (most recent call last):\n         ...\n        ValueError: Could not assign array with shape (100,) to SparseArray slice with size 10\n        \"\"\"",
        "\"\"\"\n        >>> a = SparseArray(20)\n        >>> a[:10] = 1\n        >>> a[15:] = np.arange(5) + 1\n\n        # Integer getitem\n        >>> a[0], a[10], a[11], a[14], a[15], a[18], a[-1]\n        (1, 0, 0, 0, 1, 4, 5)\n        >>> a[21]\n        Traceback (most recent call last):\n          ...\n        IndexError: Index 21 is out of bounds for ArrayInterval with shape (20,)\n\n        # Slicing\n        >>> np.asarray(a[:5])\n        array([1, 1, 1, 1, 1])\n        >>> np.asarray(a[10:15])\n        array([0., 0., 0., 0., 0.])\n        >>> a[-10:]\n        SparseArray(\n          _SparseSegment(onset=5, length=5: [1 2 3 4 5]),\n          shape=(10,))\n        >>> np.asarray(a[-10:])\n        array([0, 0, 0, 0, 0, 1, 2, 3, 4, 5])\n        >>> np.asarray(a[:-10])\n        array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])\n\n        # Multi-dimensional\n        >>> a = SparseArray((2, 10))\n        >>> a[..., :5] = np.arange(10).reshape((2, 5))\n        >>> a[..., 7:] = 1\n        >>> np.asarray(a)\n        array([[0, 1, 2, 3, 4, 0, 0, 1, 1, 1],\n               [5, 6, 7, 8, 9, 0, 0, 1, 1, 1]])\n        >>> a[..., :5]\n        SparseArray(\n          _SparseSegment(onset=0, length=5: [[0 1 2 3 4]\n           [5 6 7 8 9]]),\n          shape=(2, 5))\n        >>> a[0]\n        SparseArray(\n          _SparseSegment(onset=0, length=5: [0 1 2 3 4])\n          _SparseSegment(onset=7, length=3: [1 1 1]),\n          shape=(10,))\n        >>> a[-1]\n        SparseArray(\n          _SparseSegment(onset=0, length=5: [5 6 7 8 9])\n          _SparseSegment(onset=7, length=3: [1 1 1]),\n          shape=(10,))\n        >>> a[5]\n        Traceback (most recent call last):\n         ...\n        IndexError: index 5 is out of bounds for axis 0 with size 2\n        >>> np.asarray(a[1, 3:5])\n        array([8, 9])\n        \"\"\"",
        "\"\"\"\n        >>> a = SparseArray(10)\n        >>> a[:5] = 1\n        >>> b = SparseArray(10)\n        >>> b[7:] = 2\n        >>> np.asarray(a + b)\n        array([1, 1, 1, 1, 1, 0, 0, 2, 2, 2])\n        >>> c = np.arange(10)\n        >>> a + c\n        array([1, 2, 3, 4, 5, 5, 6, 7, 8, 9])\n        >>> c + a\n        array([1, 2, 3, 4, 5, 5, 6, 7, 8, 9])\n\n        >>> a + SparseArray(5)\n        Traceback (most recent call last):\n         ...\n        ValueError: Shape mismatch: (10,) (5,)\n        >>> c + SparseArray(5)\n        Traceback (most recent call last):\n         ...\n        ValueError: Shape mismatch: (10,) (5,)\n        \"\"\"",
        "\"\"\"\n        >>> a = SparseArray(10)\n        >>> a[:5] = 1\n        >>> b = SparseArray(10)\n        >>> b[7:] = 2\n        >>> c = np.arange(10)\n        >>> a += b\n        >>> a\n        SparseArray(\n          _SparseSegment(onset=0, length=5: [1 1 1 1 1])\n          _SparseSegment(onset=7, length=3: [2 2 2]),\n          shape=(10,))\n        >>> c += b\n        >>> c\n        array([ 0,  1,  2,  3,  4,  5,  6,  9, 10, 11])\n        >>> a += c\n        Traceback (most recent call last):\n         ...\n        TypeError: <class 'numpy.ndarray'>\n        \"\"\"",
        "\"\"\"\n        Support cheap elementwise array operations with numpy arrays by only\n        evaluating the function where data is present.\n        Always returns a `np.ndarray`, never a `SparseArray`.\n\n        >>> a = SparseArray(10)\n        >>> a[:8] = np.arange(8)\n        >>> b = SparseArray(10)\n        >>> b[:5] = 1\n        >>> b[8:] = 2\n        >>> c = -np.arange(10)\n        >>> a * c\n        array([  0,  -1,  -4,  -9, -16, -25, -36, -49,   0,   0])\n        >>> c * a\n        array([  0,  -1,  -4,  -9, -16, -25, -36, -49,   0,   0])\n        >>> c -= a\n        >>> c\n        array([  0,  -2,  -4,  -6,  -8, -10, -12, -14,  -8,  -9])\n        \"\"\"",
        "\"\"\"\n        Support cheap elementwise array operations for torch tensors.\n\n        Note:\n            Clones the input tensor and uses inplace operations.\n            IT DOES NOT SUPPORT GRADIENTS RELIABLY!\n            TODO: Test this\n\n        >>> a = SparseArray(10)\n        >>> a[:8] = torch.arange(8)\n        >>> b = SparseArray(10)\n        >>> b[:5] = 1\n        >>> b[8:] = 2\n        >>> c = -torch.arange(10)\n        >>> a * c\n        tensor([  0,  -1,  -4,  -9, -16, -25, -36, -49,   0,   0])\n        >>> c * a\n        tensor([  0,  -1,  -4,  -9, -16, -25, -36, -49,   0,   0])\n        >>> c -= a\n        >>> c\n        tensor([  0,  -2,  -4,  -6,  -8, -10, -12, -14,  -8,  -9])\n        >>> c = torch.arange(10, dtype=torch.float32)\n        \"\"\"",
        "\"\"\"Function to compute any elementwise operation over two Sparse Arrays.\"\"\""
    ],
    "functions": [
        "_normalize_shape",
        "zeros",
        "_check_shape",
        "_clip",
        "offset",
        "segment_length",
        "is_torch",
        "__repr__",
        "__post_init__",
        "from_array_and_offset",
        "as_contiguous",
        "_update_dtype",
        "interval",
        "_new_full",
        "_add_segment",
        "__copy__",
        "__deepcopy__",
        "__array__",
        "__repr__",
        "__setitem__",
        "__getitem__",
        "__len__",
        "__add__",
        "__iadd__",
        "__array_ufunc__",
        "__torch_function__",
        "_combine_sparse_arrays",
        "_combine_inplace_array_with_sparse"
    ],
    "classes": [
        "_SparseSegment",
        "SparseArray"
    ]
}