{
    "identifiers": [
        "absolute_import",
        "division",
        "print_function",
        "ansible",
        "plugins",
        "inventory",
        "BaseInventoryPlugin",
        "Constructable",
        "Cacheable",
        "ansible",
        "module_utils",
        "parsing",
        "convert_bool",
        "ansible",
        "errors",
        "AnsibleError",
        "AnsibleParserError",
        "ansible",
        "module_utils",
        "_text",
        "to_native",
        "yandexcloud",
        "yandex",
        "cloud",
        "compute",
        "v1",
        "instance_service_pb2",
        "ListInstancesRequest",
        "yandex",
        "cloud",
        "compute",
        "v1",
        "instance_service_pb2_grpc",
        "InstanceServiceStub",
        "ImportError",
        "AnsibleError",
        "json",
        "grpc",
        "google",
        "protobuf",
        "json_format",
        "MessageToDict",
        "BaseInventoryPlugin",
        "Constructable",
        "Cacheable",
        "InventoryModule",
        "path",
        "InventoryModule",
        "verify_file",
        "path",
        "path",
        "endswith",
        "instance",
        "instance",
        "get",
        "get",
        "get",
        "get",
        "instance",
        "instance",
        "get",
        "get",
        "get",
        "instance",
        "get_option",
        "hostnames",
        "AnsibleError",
        "expr",
        "hostnames",
        "expr",
        "public_ip",
        "instance",
        "expr",
        "private_ip",
        "instance",
        "expr",
        "instance",
        "templar",
        "instance",
        "templar",
        "template",
        "expr",
        "name",
        "name",
        "AnsibleError",
        "variables",
        "strict",
        "get_option",
        "filters",
        "templar",
        "variables",
        "rule",
        "filters",
        "format",
        "rule",
        "templar",
        "template",
        "conditional",
        "e",
        "strict",
        "AnsibleParserError",
        "format",
        "rule",
        "to_native",
        "e",
        "folder_id",
        "remote_filter",
        "folder_id",
        "remote_filter",
        "service",
        "ListInstancesRequest",
        "folder_id",
        "folder_id",
        "remote_filter",
        "page_token",
        "page_token",
        "instance",
        "response",
        "instances",
        "MessageToDict",
        "instance",
        "preserving_proto_field_name",
        "response",
        "next_page_token",
        "page_token",
        "instances",
        "get_option",
        "instance",
        "instances",
        "choose_hostname",
        "instance",
        "filter_host",
        "variables",
        "instance",
        "strict",
        "strict",
        "inventory",
        "add_host",
        "host",
        "hostname",
        "_set_composite_vars",
        "compose",
        "get_option",
        "variables",
        "instance",
        "host",
        "hostname",
        "strict",
        "strict",
        "_add_host_to_composed_groups",
        "groups",
        "get_option",
        "variables",
        "instance",
        "host",
        "hostname",
        "strict",
        "strict",
        "_add_host_to_keyed_groups",
        "keys",
        "get_option",
        "variables",
        "instance",
        "host",
        "hostname",
        "strict",
        "strict",
        "yandexcloud",
        "RetryInterceptor",
        "max_retry_count",
        "get_option",
        "retriable_codes",
        "grpc",
        "StatusCode",
        "UNAVAILABLE",
        "get_option",
        "auth_kind",
        "get_option",
        "get_option",
        "sa_file_path",
        "sa_file_contents",
        "AnsibleError",
        "sa_file_path",
        "open",
        "sa_file_path",
        "f",
        "f",
        "read",
        "e",
        "AnsibleError",
        "format",
        "sa_file_path",
        "to_native",
        "e",
        "json",
        "loads",
        "sa_file_contents",
        "e",
        "AnsibleError",
        "format",
        "to_native",
        "e",
        "yandexcloud",
        "SDK",
        "interceptor",
        "interceptor",
        "service_account_key",
        "sa",
        "auth_kind",
        "get_option",
        "oauth_token",
        "AnsibleError",
        "yandexcloud",
        "SDK",
        "interceptor",
        "interceptor",
        "token",
        "oauth_token",
        "AnsibleError",
        "format",
        "auth_kind",
        "inventory",
        "loader",
        "path",
        "cache",
        "InventoryModule",
        "parse",
        "inventory",
        "loader",
        "path",
        "_read_config_data",
        "path",
        "init_sdk",
        "sdk",
        "client",
        "InstanceServiceStub",
        "get_cache_key",
        "path",
        "get_option",
        "user_cache_setting",
        "cache",
        "user_cache_setting",
        "cache",
        "attempt_to_read_cache",
        "_cache",
        "cache_key",
        "KeyError",
        "instances",
        "get_option",
        "folder_id",
        "get_option",
        "instances",
        "extend",
        "list_instances",
        "folder_id",
        "folder_id",
        "remote_filter",
        "remote_filter",
        "cache_needs_update",
        "_cache",
        "instances",
        "populate",
        "instances"
    ],
    "literals": [
        "r'''\n    name: yc_compute\n    plugin_type: inventory\n    short_description: Yandex.Cloud Compute inventory source\n    requirements:\n      - yandexcloud==0.10.1\n    extends_documentation_fragment:\n      - constructed\n      - inventory_cache\n    description:\n      - Pull inventory from Yandex Cloud Compute.\n      - Uses a YAML configuration file that ends with yc_compute.(yml|yaml) or yc.(yml|yaml).\n    version_added: \"1.3.0\"\n    options:\n      plugin:\n        description: The name of this plugin, it should always be set to C(community.general.yc_compute) for this plugin to recognize it as it's own.\n        required: yes\n        choices: ['community.general.yc_compute']\n        type: str\n      auth_kind:\n        description: The type of credential used.\n        required: true\n        type: string\n        choices: ['oauth', 'serviceaccountfile']\n        env:\n          - name: YC_ANSIBLE_AUTH_KIND\n      oauth_token:\n        description: OAUTH token string. See U(https://cloud.yandex.com/docs/iam/concepts/authorization/oauth-token).\n        type: string\n        env:\n          - name: YC_ANSIBLE_OAUTH_TOKEN\n      service_account_file:\n        description:\n          - The path of a Service Account JSON file. Must be set if auth_kind is \"serviceaccountfile\".\n          - \"Service Account JSON file can be created by C(yc) tool:\"\n          - C(yc iam key create --service-account-name my_service_account --output my_service_account.json)\n        type: path\n        env:\n          - name: YC_ANSIBLE_SERVICE_ACCOUNT_FILE\n      service_account_contents:\n        description: Similar to service_account_file. Should contain raw contents of the Service Account JSON file.\n        type: string\n        env:\n          - name: YC_ANSIBLE_SERVICE_ACCOUNT_CONTENTS\n      hostnames:\n        description:\n          - The list of methods for determining the hostname.\n          - Several methods can be tried one by one. Until successful hostname detection.\n          - Currently supported methods are 'public_ip', 'private_ip' and 'fqdn'.\n          - Any other value is parsed as a jinja2 expression.\n        default: ['public_ip', 'private_ip', 'fqdn']\n        type: list\n      folders:\n        description: List of Yandex.Cloud folder ID's to list instances from.\n        type: list\n        required: True\n      remote_filter:\n        description:\n          - Sets C(filter) parameter for C(list) API call.\n          - Currently you can use filtering only on the Instance.name field.\n          - See U(https://cloud.yandex.com/docs/compute/api-ref/Instance/list).\n          - Use C(filters) option for more flexible client-side filtering.\n        type: string\n      filters:\n        description:\n          - List of jinja2 expressions to perform client-side hosts filtering.\n          - Possible fields are described here U(https://cloud.yandex.com/docs/compute/api-ref/Instance/list).\n          - When overriding this option don't forget to explicitly include default value to your rules (if you need it).\n        type: list\n        default: status == 'RUNNING'\n      api_retry_count:\n        description: Retries count for API calls.\n        type: int\n        default: 5\n'''",
        "r'''\nplugin: community.general.yc_compute\nfolders:  # List inventory hosts from these folders.\n  - <your_folder_id>\nfilters:\n  - status == 'RUNNING'\n  - labels['role'] == 'db'\nauth_kind: serviceaccountfile\nservice_account_file: /path/to/your/service/account/file.json\nhostnames:\n  - fqdn  # Use FQDN for inventory hostnames.\n# You can also format hostnames with jinja2 expressions like this\n# - \"{{id}}_{{name}}\"\n\ncompose:\n  # Set ansible_host to the Public IP address to connect to the host.\n  # For Private IP use \"network_interfaces[0].primary_v4_address.address\".\n  ansible_host: network_interfaces[0].primary_v4_address.one_to_one_nat.address\n\nkeyed_groups:\n  # Place hosts in groups named by folder_id.\n  - key: folder_id\n    prefix: ''\n    separator: ''\n  # Place hosts in groups named by value of labels['group'].\n  - key: labels['group']\n\ngroups:\n  # Place hosts in 'ssd' group if they have appropriate disk_type label.\n  ssd: labels['disk_type'] == 'ssd'\n'''",
        "'Import error for yandex.cloud SDK. '",
        "'Please install \"yandexcloud\" package to your environment.'",
        "'community.general.yc_compute'",
        "'yc.yml'",
        "'yc.yaml'",
        "'yc_compute.yml'",
        "'yc_compute.yaml'",
        "'network_interfaces'",
        "'primary_v4_address'",
        "'one_to_one_nat'",
        "'address'",
        "'network_interfaces'",
        "'primary_v4_address'",
        "'address'",
        "'hostnames'",
        "'hostnames option should not be empty'",
        "'public_ip'",
        "'private_ip'",
        "'fqdn'",
        "'fqdn'",
        "\"No valid name found for host\"",
        "'filters'",
        "'{{% if {0} %}} True {{% else %}} False {{% endif %}}'",
        "'Could not apply host filter \"{0}\": {1}'",
        "'strict'",
        "'compose'",
        "'groups'",
        "'keyed_groups'",
        "'api_retry_count'",
        "'auth_kind'",
        "'serviceaccountfile'",
        "'service_account_file'",
        "'service_account_contents'",
        "'Either \"service_account_file\" or \"service_account_contents\" must be set '",
        "'when auth_kind is set to \"serviceaccountfile\"'",
        "'r'",
        "'Error reading Service Account data from file: \"{0}\": {1}'",
        "'Error reading Service Account data from JSON: {0}'",
        "'oauth'",
        "'oauth_token'",
        "'oauth_token should be set'",
        "'Unknown value for auth_kind: {0}'",
        "'cache'",
        "'remote_filter'",
        "'folders'"
    ],
    "variables": [
        "__metaclass__",
        "DOCUMENTATION",
        "EXAMPLES",
        "NAME",
        "sdk",
        "service",
        "hostnames",
        "name",
        "name",
        "name",
        "available_variables",
        "name",
        "filters",
        "available_variables",
        "conditional",
        "page_token",
        "response",
        "page_token",
        "strict",
        "hostname",
        "interceptor",
        "auth_kind",
        "sa_file_path",
        "sa_file_contents",
        "sa_file_contents",
        "sa",
        "sdk",
        "oauth_token",
        "sdk",
        "service",
        "cache_key",
        "user_cache_setting",
        "attempt_to_read_cache",
        "cache_needs_update",
        "instances",
        "instances",
        "cache_needs_update",
        "instances",
        "remote_filter",
        "cache_key"
    ],
    "comments": [
        "Copyright (c) 2019 Ansible Project",
        "GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
        "cache may be True or False at this point to indicate if the inventory is being refreshed",
        "get the user's cache option too to see if we should save the cache if it is changing.",
        "read if the user has caching enabled and the cache isn't being refreshed.",
        "update if the user has caching enabled and the cache is being refreshed; update this value to True",
        "if the cache has expired below.",
        "attempt to read the cache if inventory isn't being refreshed and the user has caching enabled.",
        "This occurs if the cache_key is not in the cache or if the cache_key expired,",
        "so the cache needs to be updated."
    ],
    "docstrings": [
        "''' return true/false if this is possibly a valid file for this plugin to consume '''",
        "'''Returns Public IP of instance or None'''",
        "'''Returns Private IP of instance or None'''",
        "'''Choose hostname for given instance'''",
        "'''\n        Apply client-side host filtering.\n        :param variables: variables to run expression with.\n        :param strict: should it raise exceptions on errors or not.\n        :return: True if host pass filters and should be included in inventory.\n        '''",
        "'''Make API calls to list folder with given ID. Wraps pagination loop. Returns generator.'''",
        "'''Populate inventory with given instances'''",
        "'''Init Yandex.Cloud SDK with provided auth method'''"
    ],
    "functions": [
        "verify_file",
        "public_ip",
        "private_ip",
        "choose_hostname",
        "filter_host",
        "list_instances",
        "populate",
        "init_sdk",
        "parse"
    ],
    "classes": [
        "InventoryModule"
    ]
}