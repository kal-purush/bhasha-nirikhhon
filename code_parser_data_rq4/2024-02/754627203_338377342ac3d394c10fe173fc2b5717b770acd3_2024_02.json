{
    "identifiers": [
        "abc",
        "collections",
        "collections",
        "abc",
        "functools",
        "inspect",
        "sys",
        "types",
        "_types",
        "typing",
        "warnings",
        "_Sentinel",
        "cls",
        "parameters",
        "elen",
        "_marker",
        "elen",
        "cls",
        "elen",
        "_marker",
        "hasattr",
        "cls",
        "cls",
        "__parameters__",
        "cls",
        "len",
        "cls",
        "__parameters__",
        "len",
        "parameters",
        "alen",
        "elen",
        "hasattr",
        "cls",
        "p",
        "p",
        "cls",
        "__parameters__",
        "_is_unpack",
        "p",
        "sum",
        "isinstance",
        "p",
        "TypeVarTuple",
        "p",
        "parameters",
        "num_tv_tuples",
        "alen",
        "elen",
        "num_tv_tuples",
        "alen",
        "elen",
        "cls",
        "alen",
        "elen",
        "sys",
        "version_info",
        "t",
        "isinstance",
        "t",
        "typing",
        "_GenericAlias",
        "_types",
        "GenericAlias",
        "_types",
        "UnionType",
        "sys",
        "version_info",
        "t",
        "isinstance",
        "t",
        "typing",
        "_GenericAlias",
        "_types",
        "GenericAlias",
        "t",
        "isinstance",
        "t",
        "typing",
        "_GenericAlias",
        "t",
        "_special",
        "types",
        "typevar_types",
        "typevar_types",
        "typing",
        "TypeVar",
        "t",
        "types",
        "isinstance",
        "t",
        "typevar_types",
        "t",
        "tvars",
        "_is_unpack",
        "t",
        "tvars",
        "append",
        "t",
        "_should_collect_from_parameters",
        "t",
        "tvars",
        "extend",
        "t",
        "t",
        "t",
        "__parameters__",
        "t",
        "tvars",
        "tvars",
        "typing",
        "NoReturn",
        "typing",
        "TypeVar",
        "typing",
        "TypeVar",
        "typing",
        "TypeVar",
        "typing",
        "TypeVar",
        "covariant",
        "typing",
        "TypeVar",
        "contravariant",
        "sys",
        "version_info",
        "typing",
        "Any",
        "obj",
        "Any",
        "__instancecheck__",
        "obj",
        "Any",
        "__repr__",
        "metaclass",
        "_AnyMeta",
        "cls",
        "args",
        "kwargs",
        "cls",
        "Any",
        "__new__",
        "cls",
        "args",
        "kwargs",
        "typing",
        "ClassVar",
        "typing",
        "_SpecialForm",
        "_root",
        "_name",
        "typing",
        "Final",
        "sys",
        "version_info",
        "typing",
        "f",
        "AttributeError",
        "f",
        "name",
        "typing",
        "TypeVar",
        "name",
        "sys",
        "version_info",
        "typing",
        "Literal",
        "parameters",
        "p",
        "parameters",
        "isinstance",
        "p",
        "_LiteralGenericAlias",
        "extend",
        "p",
        "__args__",
        "append",
        "p",
        "p",
        "p",
        "p",
        "typing",
        "_GenericAlias",
        "_root",
        "other",
        "isinstance",
        "other",
        "_LiteralGenericAlias",
        "_value_and_type_iter",
        "__args__",
        "_value_and_type_iter",
        "other",
        "__args__",
        "these_args_deduped",
        "other_args_deduped",
        "hash",
        "_value_and_type_iter",
        "__args__",
        "_ExtensionsSpecialForm",
        "_root",
        "doc",
        "doc",
        "parameters",
        "isinstance",
        "parameters",
        "parameters",
        "_flatten_literal_params",
        "parameters",
        "_value_and_type_iter",
        "parameters",
        "val_type_pairs",
        "len",
        "deduped_pairs",
        "len",
        "val_type_pairs",
        "pair",
        "val_type_pairs",
        "pair",
        "deduped_pairs",
        "new_parameters",
        "append",
        "pair",
        "deduped_pairs",
        "remove",
        "pair",
        "deduped_pairs",
        "deduped_pairs",
        "new_parameters",
        "_LiteralGenericAlias",
        "parameters",
        "_LiteralForm",
        "doc",
        "typing",
        "_overload_dummy",
        "hasattr",
        "typing",
        "typing",
        "overload",
        "typing",
        "get_overloads",
        "typing",
        "clear_overloads",
        "collections",
        "defaultdict",
        "functools",
        "partial",
        "collections",
        "defaultdict",
        "func",
        "getattr",
        "func",
        "func",
        "_overload_registry",
        "f",
        "__module__",
        "f",
        "__qualname__",
        "f",
        "__code__",
        "co_firstlineno",
        "func",
        "AttributeError",
        "_overload_dummy",
        "func",
        "getattr",
        "func",
        "func",
        "f",
        "__module__",
        "_overload_registry",
        "_overload_registry",
        "f",
        "__module__",
        "f",
        "__qualname__",
        "mod_dict",
        "mod_dict",
        "f",
        "__qualname__",
        "values",
        "_overload_registry",
        "clear",
        "typing",
        "Type",
        "typing",
        "Awaitable",
        "typing",
        "Coroutine",
        "typing",
        "AsyncIterable",
        "typing",
        "AsyncIterator",
        "typing",
        "typing",
        "ContextManager",
        "typing",
        "AsyncContextManager",
        "typing",
        "DefaultDict",
        "typing",
        "OrderedDict",
        "typing",
        "Counter",
        "typing",
        "ChainMap",
        "typing",
        "AsyncGenerator",
        "typing",
        "Text",
        "typing",
        "TYPE_CHECKING",
        "sys",
        "version_info",
        "_EXCLUDED_ATTRS",
        "add",
        "sys",
        "version_info",
        "_EXCLUDED_ATTRS",
        "add",
        "_EXCLUDED_ATTRS",
        "cls",
        "cls",
        "__mro__",
        "getattr",
        "attr",
        "__dict__",
        "annotations",
        "attr",
        "startswith",
        "attr",
        "_EXCLUDED_ATTRS",
        "attrs",
        "add",
        "attr",
        "attrs",
        "depth",
        "sys",
        "_getframe",
        "depth",
        "f_globals",
        "get",
        "AttributeError",
        "ValueError",
        "sys",
        "version_info",
        "typing",
        "Protocol",
        "depth",
        "_caller",
        "depth",
        "args",
        "kwargs",
        "_is_protocol",
        "typing",
        "Protocol",
        "mcls",
        "name",
        "bases",
        "kwargs",
        "name",
        "len",
        "bases",
        "Protocol",
        "typing",
        "Protocol",
        "bases",
        "bases",
        "typing",
        "Generic",
        "Protocol",
        "typing",
        "Protocol",
        "_PROTO_ALLOWLIST",
        "get",
        "__module__",
        "is_protocol",
        "abc",
        "ABCMeta",
        "__new__",
        "mcls",
        "name",
        "bases",
        "kwargs",
        "cls",
        "args",
        "kwargs",
        "abc",
        "ABCMeta",
        "cls",
        "args",
        "kwargs",
        "getattr",
        "cls",
        "_get_protocol_attrs",
        "cls",
        "all",
        "callable",
        "getattr",
        "cls",
        "attr",
        "attr",
        "cls",
        "__protocol_attrs__",
        "cls",
        "other",
        "cls",
        "Protocol",
        "__subclasscheck__",
        "cls",
        "other",
        "getattr",
        "cls",
        "_allow_reckless_class_checks",
        "isinstance",
        "other",
        "cls",
        "__callable_proto_members_only__",
        "cls",
        "__dict__",
        "get",
        "_proto_hook",
        "sorted",
        "attr",
        "attr",
        "cls",
        "__protocol_attrs__",
        "callable",
        "getattr",
        "cls",
        "attr",
        "non_method_attrs",
        "getattr",
        "cls",
        "abc",
        "ABCMeta",
        "__subclasscheck__",
        "cls",
        "other",
        "cls",
        "instance",
        "cls",
        "Protocol",
        "__instancecheck__",
        "cls",
        "instance",
        "getattr",
        "cls",
        "abc",
        "ABCMeta",
        "__instancecheck__",
        "cls",
        "instance",
        "getattr",
        "cls",
        "_allow_reckless_class_checks",
        "abc",
        "ABCMeta",
        "__instancecheck__",
        "cls",
        "instance",
        "attr",
        "cls",
        "__protocol_attrs__",
        "inspect",
        "getattr_static",
        "instance",
        "attr",
        "AttributeError",
        "val",
        "callable",
        "getattr",
        "cls",
        "attr",
        "cls",
        "other",
        "abc",
        "ABCMeta",
        "__eq__",
        "cls",
        "other",
        "cls",
        "Protocol",
        "other",
        "typing",
        "Protocol",
        "cls",
        "__hash__",
        "cls",
        "classmethod",
        "cls",
        "other",
        "cls",
        "__dict__",
        "get",
        "attr",
        "cls",
        "__protocol_attrs__",
        "other",
        "__mro__",
        "attr",
        "__dict__",
        "__dict__",
        "attr",
        "getattr",
        "isinstance",
        "annotations",
        "collections",
        "abc",
        "Mapping",
        "attr",
        "annotations",
        "is_protocol",
        "other",
        "typing",
        "Generic",
        "metaclass",
        "_ProtocolMeta",
        "typing",
        "Protocol",
        "__doc__",
        "cls",
        "args",
        "kwargs",
        "__init_subclass__",
        "args",
        "kwargs",
        "cls",
        "__dict__",
        "get",
        "b",
        "Protocol",
        "b",
        "cls",
        "__bases__",
        "cls",
        "__dict__",
        "_proto_hook",
        "cls",
        "_is_protocol",
        "cls",
        "Protocol",
        "_no_init",
        "typing",
        "runtime_checkable",
        "sys",
        "version_info",
        "typing",
        "SupportsInt",
        "typing",
        "SupportsFloat",
        "typing",
        "SupportsComplex",
        "typing",
        "SupportsBytes",
        "typing",
        "SupportsIndex",
        "typing",
        "SupportsAbs",
        "typing",
        "SupportsRound",
        "runtime_checkable",
        "Protocol",
        "abc",
        "abstractmethod",
        "runtime_checkable",
        "Protocol",
        "abc",
        "abstractmethod",
        "runtime_checkable",
        "Protocol",
        "abc",
        "abstractmethod",
        "runtime_checkable",
        "Protocol",
        "abc",
        "abstractmethod",
        "runtime_checkable",
        "Protocol",
        "abc",
        "abstractmethod",
        "runtime_checkable",
        "Protocol",
        "T_co",
        "abc",
        "abstractmethod",
        "T_co",
        "runtime_checkable",
        "Protocol",
        "T_co",
        "abc",
        "abstractmethod",
        "ndigits",
        "T_co",
        "mro_entries",
        "func",
        "sys",
        "implementation",
        "name",
        "sys",
        "version_info",
        "staticmethod",
        "func",
        "staticmethod",
        "mro_entries",
        "func",
        "cls_dict",
        "functools",
        "update_wrapper",
        "t",
        "func",
        "mro_entries",
        "func",
        "inner",
        "hasattr",
        "typing",
        "typing",
        "TypedDict",
        "typing",
        "_TypedDictMeta",
        "typing",
        "is_typeddict",
        "inspect",
        "signature",
        "typing",
        "_type_check",
        "parameters",
        "annotation_type",
        "get_origin",
        "annotation_type",
        "annotation_origin",
        "Annotated",
        "get_args",
        "annotation_type",
        "annotation_args",
        "annotation_args",
        "annotation_origin",
        "Required",
        "Required",
        "get_args",
        "annotation_type",
        "annotation_origin",
        "NotRequired",
        "NotRequired",
        "get_args",
        "annotation_type",
        "annotation_origin",
        "ReadOnly",
        "ReadOnly",
        "get_args",
        "annotation_type",
        "cls",
        "name",
        "bases",
        "ns",
        "total",
        "bases",
        "_TypedDictMeta",
        "typing",
        "Generic",
        "issubclass",
        "b",
        "typing",
        "Generic",
        "b",
        "bases",
        "typing",
        "Generic",
        "__new__",
        "_TypedDictMeta",
        "generic_base",
        "ns",
        "name",
        "tp_dict",
        "__qualname__",
        "name",
        "hasattr",
        "tp_dict",
        "bases",
        "ns",
        "get",
        "_TAKES_MODULE",
        "n",
        "typing",
        "_type_check",
        "tp",
        "msg",
        "tp_dict",
        "__module__",
        "n",
        "tp",
        "own_annotations",
        "items",
        "n",
        "typing",
        "_type_check",
        "tp",
        "msg",
        "n",
        "tp",
        "own_annotations",
        "items",
        "bases",
        "__dict__",
        "annotations",
        "update",
        "base_dict",
        "get",
        "required_keys",
        "update",
        "base_dict",
        "get",
        "optional_keys",
        "update",
        "base_dict",
        "get",
        "readonly_keys",
        "update",
        "base_dict",
        "get",
        "mutable_keys",
        "update",
        "base_dict",
        "get",
        "annotations",
        "update",
        "own_annotations",
        "annotation_key",
        "annotation_type",
        "own_annotations",
        "items",
        "_get_typeddict_qualifiers",
        "annotation_type",
        "Required",
        "qualifiers",
        "required_keys",
        "add",
        "annotation_key",
        "NotRequired",
        "qualifiers",
        "optional_keys",
        "add",
        "annotation_key",
        "total",
        "required_keys",
        "add",
        "annotation_key",
        "optional_keys",
        "add",
        "annotation_key",
        "ReadOnly",
        "qualifiers",
        "annotation_key",
        "mutable_keys",
        "annotation_key",
        "readonly_keys",
        "add",
        "annotation_key",
        "mutable_keys",
        "add",
        "annotation_key",
        "readonly_keys",
        "discard",
        "annotation_key",
        "annotations",
        "required_keys",
        "optional_keys",
        "readonly_keys",
        "mutable_keys",
        "hasattr",
        "tp_dict",
        "total",
        "tp_dict",
        "cls",
        "other",
        "__subclasscheck__",
        "__new__",
        "_TypedDictMeta",
        "_ensure_subclassable",
        "bases",
        "_TypedDict",
        "typename",
        "fields",
        "_marker",
        "total",
        "kwargs",
        "fields",
        "_marker",
        "fields",
        "fields",
        "_marker",
        "typename",
        "typename",
        "deprecated_thing",
        "example",
        "warnings",
        "warn",
        "deprecation_msg",
        "DeprecationWarning",
        "stacklevel",
        "kwargs",
        "kwargs",
        "kwargs",
        "sys",
        "version_info",
        "warnings",
        "warn",
        "DeprecationWarning",
        "stacklevel",
        "fields",
        "_caller",
        "_TypedDictMeta",
        "typename",
        "ns",
        "total",
        "total",
        "TypedDict",
        "td",
        "hasattr",
        "typing",
        "typing",
        "_TypedDictMeta",
        "_TypedDictMeta",
        "_TypedDictMeta",
        "tp",
        "hasattr",
        "typing",
        "tp",
        "typing",
        "TypedDict",
        "isinstance",
        "tp",
        "_TYPEDDICT_TYPES",
        "hasattr",
        "typing",
        "typing",
        "assert_type",
        "val",
        "typ",
        "val",
        "hasattr",
        "typing",
        "typing",
        "get_type_hints",
        "t",
        "isinstance",
        "t",
        "_AnnotatedAlias",
        "_strip_extras",
        "t",
        "__origin__",
        "hasattr",
        "t",
        "t",
        "__origin__",
        "Required",
        "NotRequired",
        "_strip_extras",
        "t",
        "__args__",
        "isinstance",
        "t",
        "typing",
        "_GenericAlias",
        "_strip_extras",
        "a",
        "a",
        "t",
        "__args__",
        "stripped_args",
        "t",
        "__args__",
        "t",
        "t",
        "copy_with",
        "stripped_args",
        "hasattr",
        "_types",
        "isinstance",
        "t",
        "_types",
        "GenericAlias",
        "_strip_extras",
        "a",
        "a",
        "t",
        "__args__",
        "stripped_args",
        "t",
        "__args__",
        "t",
        "_types",
        "GenericAlias",
        "t",
        "__origin__",
        "stripped_args",
        "hasattr",
        "_types",
        "isinstance",
        "t",
        "_types",
        "UnionType",
        "_strip_extras",
        "a",
        "a",
        "t",
        "__args__",
        "stripped_args",
        "t",
        "__args__",
        "t",
        "functools",
        "reduce",
        "or_",
        "stripped_args",
        "t",
        "obj",
        "globalns",
        "localns",
        "include_extras",
        "hasattr",
        "typing",
        "typing",
        "get_type_hints",
        "obj",
        "globalns",
        "globalns",
        "localns",
        "localns",
        "include_extras",
        "typing",
        "get_type_hints",
        "obj",
        "globalns",
        "globalns",
        "localns",
        "localns",
        "include_extras",
        "hint",
        "k",
        "_strip_extras",
        "t",
        "k",
        "t",
        "hint",
        "items",
        "hasattr",
        "typing",
        "typing",
        "Annotated",
        "typing",
        "_AnnotatedAlias",
        "typing",
        "_GenericAlias",
        "_root",
        "origin",
        "metadata",
        "isinstance",
        "origin",
        "_AnnotatedAlias",
        "origin",
        "__metadata__",
        "metadata",
        "origin",
        "__origin__",
        "origin",
        "origin",
        "metadata",
        "len",
        "_AnnotatedAlias",
        "new_type",
        "__metadata__",
        "typing",
        "_type_repr",
        "__origin__",
        "join",
        "repr",
        "a",
        "a",
        "__metadata__",
        "getitem",
        "Annotated",
        "__origin__",
        "__metadata__",
        "other",
        "isinstance",
        "other",
        "_AnnotatedAlias",
        "__origin__",
        "other",
        "__origin__",
        "__metadata__",
        "other",
        "__metadata__",
        "hash",
        "__origin__",
        "__metadata__",
        "cls",
        "args",
        "kwargs",
        "typing",
        "_tp_cache",
        "cls",
        "isinstance",
        "len",
        "ClassVar",
        "Final",
        "get_origin",
        "allowed_special_forms",
        "typing",
        "_type_check",
        "msg",
        "_AnnotatedAlias",
        "origin",
        "metadata",
        "cls",
        "args",
        "kwargs",
        "cls",
        "__module__",
        "sys",
        "version_info",
        "typing",
        "get_origin",
        "typing",
        "get_args",
        "typing",
        "_BaseGenericAlias",
        "ImportError",
        "typing",
        "_GenericAlias",
        "typing",
        "GenericAlias",
        "_typing_GenericAlias",
        "ImportError",
        "typing",
        "_GenericAlias",
        "tp",
        "isinstance",
        "tp",
        "_AnnotatedAlias",
        "Annotated",
        "isinstance",
        "tp",
        "typing",
        "_GenericAlias",
        "_typing_GenericAlias",
        "_BaseGenericAlias",
        "ParamSpecArgs",
        "ParamSpecKwargs",
        "tp",
        "__origin__",
        "tp",
        "typing",
        "Generic",
        "typing",
        "Generic",
        "tp",
        "isinstance",
        "tp",
        "_AnnotatedAlias",
        "tp",
        "__origin__",
        "tp",
        "__metadata__",
        "isinstance",
        "tp",
        "typing",
        "_GenericAlias",
        "_typing_GenericAlias",
        "getattr",
        "tp",
        "tp",
        "__args__",
        "get_origin",
        "tp",
        "collections",
        "abc",
        "Callable",
        "res",
        "res",
        "res",
        "res",
        "hasattr",
        "typing",
        "typing",
        "TypeAlias",
        "sys",
        "version_info",
        "_ExtensionsSpecialForm",
        "parameters",
        "_ExtensionsSpecialForm",
        "doc",
        "type_param",
        "isinstance",
        "typing",
        "_type_check",
        "d",
        "d",
        "_marker",
        "isinstance",
        "type_param",
        "ParamSpec",
        "typing",
        "_type_check",
        "typevarlike",
        "_caller",
        "depth",
        "def_mod",
        "def_mod",
        "_set_default",
        "cls",
        "__instance",
        "Any",
        "isinstance",
        "__instance",
        "cls",
        "_backported_typevarlike",
        "metaclass",
        "_TypeVarLikeMeta",
        "typing",
        "TypeVar",
        "cls",
        "name",
        "constraints",
        "bound",
        "covariant",
        "contravariant",
        "_marker",
        "infer_variance",
        "hasattr",
        "typing",
        "typing",
        "TypeVar",
        "name",
        "constraints",
        "bound",
        "bound",
        "covariant",
        "covariant",
        "contravariant",
        "contravariant",
        "infer_variance",
        "infer_variance",
        "typing",
        "TypeVar",
        "name",
        "constraints",
        "bound",
        "bound",
        "covariant",
        "covariant",
        "contravariant",
        "contravariant",
        "infer_variance",
        "covariant",
        "contravariant",
        "ValueError",
        "infer_variance",
        "_set_default",
        "typevar",
        "_set_module",
        "typevar",
        "typevar",
        "cls",
        "hasattr",
        "typing",
        "typing",
        "ParamSpecArgs",
        "typing",
        "ParamSpecKwargs",
        "memo",
        "_Immutable",
        "origin",
        "origin",
        "__origin__",
        "other",
        "isinstance",
        "other",
        "ParamSpecArgs",
        "__origin__",
        "other",
        "__origin__",
        "_Immutable",
        "origin",
        "origin",
        "__origin__",
        "other",
        "isinstance",
        "other",
        "ParamSpecKwargs",
        "__origin__",
        "other",
        "__origin__",
        "hasattr",
        "typing",
        "metaclass",
        "_TypeVarLikeMeta",
        "typing",
        "ParamSpec",
        "cls",
        "name",
        "bound",
        "covariant",
        "contravariant",
        "infer_variance",
        "_marker",
        "hasattr",
        "typing",
        "typing",
        "ParamSpec",
        "name",
        "bound",
        "bound",
        "covariant",
        "covariant",
        "contravariant",
        "contravariant",
        "infer_variance",
        "infer_variance",
        "typing",
        "ParamSpec",
        "name",
        "bound",
        "bound",
        "covariant",
        "covariant",
        "contravariant",
        "contravariant",
        "infer_variance",
        "_set_default",
        "paramspec",
        "_set_module",
        "paramspec",
        "paramspec",
        "cls",
        "_DefaultMixin",
        "typing",
        "TypeVar",
        "property",
        "ParamSpecArgs",
        "property",
        "ParamSpecKwargs",
        "name",
        "bound",
        "covariant",
        "contravariant",
        "infer_variance",
        "_marker",
        "name",
        "covariant",
        "contravariant",
        "infer_variance",
        "bound",
        "typing",
        "_type_check",
        "bound",
        "_DefaultMixin",
        "_caller",
        "def_mod",
        "def_mod",
        "__infer_variance__",
        "__covariant__",
        "__contravariant__",
        "prefix",
        "__hash__",
        "other",
        "other",
        "args",
        "kwargs",
        "hasattr",
        "typing",
        "typing",
        "_GenericAlias",
        "origin",
        "args",
        "args",
        "origin",
        "args",
        "typing",
        "_type_repr",
        "_type_repr",
        "__origin__",
        "join",
        "_type_repr",
        "arg",
        "arg",
        "__args__",
        "hash",
        "__origin__",
        "__args__",
        "args",
        "kwargs",
        "property",
        "tp",
        "tp",
        "__args__",
        "isinstance",
        "tp",
        "typing",
        "TypeVar",
        "ParamSpec",
        "typing",
        "_tp_cache",
        "parameters",
        "parameters",
        "isinstance",
        "parameters",
        "parameters",
        "isinstance",
        "parameters",
        "ParamSpec",
        "typing",
        "_type_check",
        "p",
        "msg",
        "p",
        "parameters",
        "_ConcatenateGenericAlias",
        "parameters",
        "hasattr",
        "typing",
        "typing",
        "Concatenate",
        "typing",
        "_ConcatenateGenericAlias",
        "sys",
        "version_info",
        "_ExtensionsSpecialForm",
        "parameters",
        "_concatenate_getitem",
        "parameters",
        "_ExtensionsSpecialForm",
        "_root",
        "parameters",
        "_concatenate_getitem",
        "parameters",
        "_ConcatenateForm",
        "doc",
        "hasattr",
        "typing",
        "typing",
        "TypeGuard",
        "sys",
        "version_info",
        "_ExtensionsSpecialForm",
        "parameters",
        "typing",
        "_type_check",
        "parameters",
        "typing",
        "_GenericAlias",
        "item",
        "_ExtensionsSpecialForm",
        "_root",
        "parameters",
        "typing",
        "_type_check",
        "parameters",
        "_name",
        "typing",
        "_GenericAlias",
        "item",
        "_TypeGuardForm",
        "doc",
        "typing",
        "_Final",
        "_root",
        "getitem",
        "getitem",
        "getitem",
        "getitem",
        "__doc__",
        "item",
        "item",
        "_name",
        "AttributeError",
        "item",
        "bases",
        "_name",
        "_name",
        "args",
        "kwds",
        "other",
        "typing",
        "Union",
        "other",
        "other",
        "typing",
        "Union",
        "other",
        "obj",
        "cls",
        "typing",
        "_tp_cache",
        "parameters",
        "_getitem",
        "parameters",
        "hasattr",
        "typing",
        "typing",
        "LiteralString",
        "_SpecialForm",
        "hasattr",
        "typing",
        "typing",
        "Self",
        "_SpecialForm",
        "hasattr",
        "typing",
        "typing",
        "Never",
        "_SpecialForm",
        "hasattr",
        "typing",
        "typing",
        "Required",
        "typing",
        "NotRequired",
        "sys",
        "version_info",
        "_ExtensionsSpecialForm",
        "parameters",
        "typing",
        "_type_check",
        "parameters",
        "_name",
        "typing",
        "_GenericAlias",
        "item",
        "_ExtensionsSpecialForm",
        "parameters",
        "typing",
        "_type_check",
        "parameters",
        "_name",
        "typing",
        "_GenericAlias",
        "item",
        "_ExtensionsSpecialForm",
        "_root",
        "parameters",
        "typing",
        "_type_check",
        "parameters",
        "_name",
        "typing",
        "_GenericAlias",
        "item",
        "_RequiredForm",
        "doc",
        "_RequiredForm",
        "doc",
        "hasattr",
        "typing",
        "typing",
        "ReadOnly",
        "sys",
        "version_info",
        "_ExtensionsSpecialForm",
        "parameters",
        "typing",
        "_type_check",
        "parameters",
        "_name",
        "typing",
        "_GenericAlias",
        "item",
        "_ExtensionsSpecialForm",
        "_root",
        "parameters",
        "typing",
        "_type_check",
        "parameters",
        "_name",
        "typing",
        "_GenericAlias",
        "item",
        "_ReadOnlyForm",
        "doc",
        "sys",
        "version_info",
        "typing",
        "Unpack",
        "obj",
        "get_origin",
        "obj",
        "Unpack",
        "sys",
        "version_info",
        "_ExtensionsSpecialForm",
        "_root",
        "getitem",
        "getitem",
        "_UNPACK_DOC",
        "typing",
        "_GenericAlias",
        "_root",
        "typing",
        "TypeVar",
        "_UnpackSpecialForm",
        "parameters",
        "typing",
        "_type_check",
        "parameters",
        "_name",
        "_UnpackAlias",
        "item",
        "obj",
        "isinstance",
        "obj",
        "_UnpackAlias",
        "typing",
        "_GenericAlias",
        "_root",
        "typing",
        "TypeVar",
        "_ExtensionsSpecialForm",
        "_root",
        "parameters",
        "typing",
        "_type_check",
        "parameters",
        "_name",
        "_UnpackAlias",
        "item",
        "_UnpackForm",
        "doc",
        "_UNPACK_DOC",
        "obj",
        "isinstance",
        "obj",
        "_UnpackAlias",
        "hasattr",
        "typing",
        "metaclass",
        "_TypeVarLikeMeta",
        "typing",
        "TypeVarTuple",
        "cls",
        "name",
        "_marker",
        "typing",
        "TypeVarTuple",
        "name",
        "_set_default",
        "tvt",
        "_set_module",
        "tvt",
        "tvt",
        "args",
        "kwds",
        "_DefaultMixin",
        "typing",
        "TypeVar",
        "__unpacked__",
        "name",
        "_marker",
        "name",
        "_DefaultMixin",
        "_caller",
        "def_mod",
        "def_mod",
        "Unpack",
        "__hash__",
        "other",
        "other",
        "args",
        "kwds",
        "kwds",
        "hasattr",
        "typing",
        "typing",
        "reveal_type",
        "obj",
        "T",
        "T",
        "obj",
        "file",
        "sys",
        "stderr",
        "obj",
        "hasattr",
        "typing",
        "typing",
        "assert_never",
        "arg",
        "Never",
        "Never",
        "AssertionError",
        "sys",
        "version_info",
        "typing",
        "dataclass_transform",
        "eq_default",
        "order_default",
        "kw_only_default",
        "frozen_default",
        "field_specifiers",
        "typing",
        "Tuple",
        "typing",
        "Union",
        "typing",
        "Type",
        "typing",
        "Any",
        "typing",
        "Callable",
        "typing",
        "Any",
        "kwargs",
        "typing",
        "Any",
        "typing",
        "Callable",
        "T",
        "T",
        "cls_or_fn",
        "eq_default",
        "order_default",
        "kw_only_default",
        "frozen_default",
        "field_specifiers",
        "kwargs",
        "cls_or_fn",
        "decorator",
        "hasattr",
        "typing",
        "typing",
        "typing",
        "TypeVar",
        "bound",
        "typing",
        "Callable",
        "typing",
        "Any",
        "arg",
        "_F",
        "_F",
        "AttributeError",
        "arg",
        "hasattr",
        "warnings",
        "warnings",
        "deprecated",
        "typing",
        "TypeVar",
        "message",
        "category",
        "typing",
        "Optional",
        "typing",
        "Type",
        "Warning",
        "DeprecationWarning",
        "stacklevel",
        "isinstance",
        "message",
        "message",
        "message",
        "category",
        "stacklevel",
        "arg",
        "_T",
        "_T",
        "message",
        "category",
        "stacklevel",
        "category",
        "msg",
        "arg",
        "isinstance",
        "arg",
        "functools",
        "types",
        "MethodType",
        "arg",
        "__new__",
        "functools",
        "wraps",
        "original_new",
        "cls",
        "args",
        "kwargs",
        "cls",
        "arg",
        "warnings",
        "warn",
        "msg",
        "category",
        "category",
        "stacklevel",
        "stacklevel",
        "original_new",
        "__new__",
        "original_new",
        "cls",
        "args",
        "kwargs",
        "cls",
        "args",
        "kwargs",
        "cls",
        "original_new",
        "cls",
        "staticmethod",
        "__new__",
        "arg",
        "__init_subclass__",
        "isinstance",
        "original_init_subclass",
        "MethodType",
        "original_init_subclass",
        "__func__",
        "functools",
        "wraps",
        "original_init_subclass",
        "args",
        "kwargs",
        "warnings",
        "warn",
        "msg",
        "category",
        "category",
        "stacklevel",
        "stacklevel",
        "original_init_subclass",
        "args",
        "kwargs",
        "classmethod",
        "__init_subclass__",
        "functools",
        "wraps",
        "original_init_subclass",
        "args",
        "kwargs",
        "warnings",
        "warn",
        "msg",
        "category",
        "category",
        "stacklevel",
        "stacklevel",
        "original_init_subclass",
        "args",
        "kwargs",
        "__init_subclass__",
        "msg",
        "msg",
        "arg",
        "callable",
        "arg",
        "functools",
        "functools",
        "wraps",
        "arg",
        "args",
        "kwargs",
        "warnings",
        "warn",
        "msg",
        "category",
        "category",
        "stacklevel",
        "stacklevel",
        "arg",
        "args",
        "kwargs",
        "msg",
        "wrapper",
        "arg",
        "hasattr",
        "typing",
        "_collect_type_vars",
        "_check_generic",
        "sys",
        "version_info",
        "typing",
        "NamedTuple",
        "name",
        "types",
        "defaults",
        "n",
        "n",
        "t",
        "types",
        "n",
        "typing",
        "_type_check",
        "t",
        "n",
        "n",
        "t",
        "types",
        "collections",
        "namedtuple",
        "name",
        "fields",
        "defaults",
        "defaults",
        "nm_tpl",
        "__new__",
        "annotations",
        "sys",
        "version_info",
        "annotations",
        "nm_tpl",
        "typing",
        "_prohibited",
        "cls",
        "typename",
        "bases",
        "ns",
        "_NamedTuple",
        "bases",
        "bases",
        "_NamedTuple",
        "typing",
        "Generic",
        "_NamedTuple",
        "bases",
        "ns",
        "get",
        "field_name",
        "types",
        "field_name",
        "ns",
        "default_names",
        "append",
        "field_name",
        "default_names",
        "field_name",
        "len",
        "default_names",
        "join",
        "default_names",
        "_make_nmtuple",
        "typename",
        "types",
        "items",
        "defaults",
        "ns",
        "n",
        "n",
        "default_names",
        "ns",
        "bases",
        "typing",
        "Generic",
        "bases",
        "hasattr",
        "typing",
        "classmethod",
        "typing",
        "_generic_class_getitem",
        "typing",
        "Generic",
        "__class_getitem__",
        "__func__",
        "classmethod",
        "class_getitem",
        "key",
        "val",
        "ns",
        "items",
        "key",
        "_prohibited_namedtuple_fields",
        "AttributeError",
        "key",
        "key",
        "_special_namedtuple_fields",
        "key",
        "nm_tpl",
        "_fields",
        "setattr",
        "nm_tpl",
        "key",
        "ns",
        "key",
        "val",
        "__set_name__",
        "AttributeError",
        "set_name",
        "val",
        "nm_tpl",
        "key",
        "e",
        "val",
        "key",
        "typename",
        "sys",
        "version_info",
        "e",
        "add_note",
        "msg",
        "RuntimeError",
        "msg",
        "e",
        "typing",
        "Generic",
        "bases",
        "nm_tpl",
        "__init_subclass__",
        "nm_tpl",
        "__new__",
        "_NamedTupleMeta",
        "bases",
        "NamedTuple",
        "bases",
        "_NamedTuple",
        "_ensure_subclassable",
        "_namedtuple_mro_entries",
        "typename",
        "fields",
        "_marker",
        "kwargs",
        "fields",
        "_marker",
        "kwargs",
        "typename",
        "typename",
        "example",
        "fields",
        "kwargs",
        "typename",
        "typename",
        "example",
        "kwargs",
        "fields",
        "_marker",
        "fields",
        "warnings",
        "warn",
        "deprecation_msg",
        "format",
        "name",
        "deprecated_thing",
        "remove",
        "DeprecationWarning",
        "stacklevel",
        "kwargs",
        "items",
        "_make_nmtuple",
        "typename",
        "fields",
        "_caller",
        "NamedTuple",
        "nt",
        "hasattr",
        "collections",
        "abc",
        "collections",
        "abc",
        "Buffer",
        "abc",
        "ABC",
        "Buffer",
        "register",
        "Buffer",
        "register",
        "Buffer",
        "register",
        "hasattr",
        "_types",
        "_types",
        "get_original_bases",
        "cls",
        "cls",
        "__dict__",
        "get",
        "cls",
        "__bases__",
        "AttributeError",
        "cls",
        "sys",
        "version_info",
        "typing",
        "NewType",
        "obj",
        "obj",
        "name",
        "tp",
        "name",
        "name",
        "name",
        "rpartition",
        "name",
        "tp",
        "_caller",
        "def_mod",
        "def_mod",
        "bases",
        "cls",
        "cls",
        "subcls_name",
        "subcls_name",
        "supercls_name",
        "Dummy",
        "__module__",
        "__qualname__",
        "__qualname__",
        "sys",
        "version_info",
        "other",
        "typing",
        "Union",
        "other",
        "other",
        "typing",
        "Union",
        "other",
        "hasattr",
        "typing",
        "typing",
        "TypeAliasType",
        "obj",
        "obj",
        "isinstance",
        "obj",
        "_types",
        "GenericAlias",
        "_types",
        "UnionType",
        "TypeAliasType",
        "name",
        "value",
        "type_params",
        "isinstance",
        "name",
        "value",
        "type_params",
        "type_param",
        "type_params",
        "isinstance",
        "type_param",
        "TypeVarTuple",
        "parameters",
        "extend",
        "type_param",
        "parameters",
        "append",
        "type_param",
        "parameters",
        "_caller",
        "def_mod",
        "def_mod",
        "name",
        "name",
        "value",
        "hasattr",
        "_raise_attribute_error",
        "name",
        "__setattr__",
        "name",
        "value",
        "name",
        "Never",
        "_raise_attribute_error",
        "name",
        "name",
        "Never",
        "name",
        "AttributeError",
        "name",
        "AttributeError",
        "name",
        "AttributeError",
        "name",
        "parameters",
        "isinstance",
        "parameters",
        "parameters",
        "typing",
        "_type_check",
        "item",
        "item",
        "parameters",
        "typing",
        "_GenericAlias",
        "parameters",
        "cls",
        "args",
        "kwargs",
        "sys",
        "version_info",
        "right",
        "_is_unionable",
        "right",
        "typing",
        "Union",
        "right",
        "left",
        "_is_unionable",
        "left",
        "typing",
        "Union",
        "left",
        "hasattr",
        "typing",
        "typing",
        "is_protocol",
        "typing",
        "get_protocol_members",
        "tp",
        "isinstance",
        "tp",
        "getattr",
        "tp",
        "tp",
        "Protocol",
        "tp",
        "typing",
        "Protocol",
        "tp",
        "typing",
        "FrozenSet",
        "is_protocol",
        "tp",
        "tp",
        "hasattr",
        "tp",
        "tp",
        "__protocol_attrs__",
        "_get_protocol_attrs",
        "tp",
        "hasattr",
        "typing",
        "typing",
        "Doc",
        "documentation",
        "documentation",
        "documentation",
        "hash",
        "documentation",
        "other",
        "isinstance",
        "other",
        "Doc",
        "documentation",
        "other",
        "documentation",
        "typing",
        "AbstractSet",
        "typing",
        "AnyStr",
        "typing",
        "BinaryIO",
        "typing",
        "Callable",
        "typing",
        "Collection",
        "typing",
        "Container",
        "typing",
        "Dict",
        "typing",
        "ForwardRef",
        "typing",
        "FrozenSet",
        "typing",
        "Generator",
        "typing",
        "Generic",
        "typing",
        "Hashable",
        "typing",
        "IO",
        "typing",
        "ItemsView",
        "typing",
        "typing",
        "Iterator",
        "typing",
        "KeysView",
        "typing",
        "typing",
        "Mapping",
        "typing",
        "MappingView",
        "typing",
        "Match",
        "typing",
        "MutableMapping",
        "typing",
        "MutableSequence",
        "typing",
        "MutableSet",
        "typing",
        "Optional",
        "typing",
        "Pattern",
        "typing",
        "Reversible",
        "typing",
        "Sequence",
        "typing",
        "typing",
        "Sized",
        "typing",
        "TextIO",
        "typing",
        "Tuple",
        "typing",
        "Union",
        "typing",
        "ValuesView",
        "typing",
        "cast",
        "typing",
        "no_type_check",
        "typing",
        "no_type_check_decorator"
    ],
    "literals": [
        "'Any'",
        "'ClassVar'",
        "'Concatenate'",
        "'Final'",
        "'LiteralString'",
        "'ParamSpec'",
        "'ParamSpecArgs'",
        "'ParamSpecKwargs'",
        "'Self'",
        "'Type'",
        "'TypeVar'",
        "'TypeVarTuple'",
        "'Unpack'",
        "'Awaitable'",
        "'AsyncIterator'",
        "'AsyncIterable'",
        "'Coroutine'",
        "'AsyncGenerator'",
        "'AsyncContextManager'",
        "'Buffer'",
        "'ChainMap'",
        "'ContextManager'",
        "'Counter'",
        "'Deque'",
        "'DefaultDict'",
        "'NamedTuple'",
        "'OrderedDict'",
        "'TypedDict'",
        "'SupportsAbs'",
        "'SupportsBytes'",
        "'SupportsComplex'",
        "'SupportsFloat'",
        "'SupportsIndex'",
        "'SupportsInt'",
        "'SupportsRound'",
        "'Annotated'",
        "'assert_never'",
        "'assert_type'",
        "'clear_overloads'",
        "'dataclass_transform'",
        "'deprecated'",
        "'Doc'",
        "'get_overloads'",
        "'final'",
        "'get_args'",
        "'get_origin'",
        "'get_original_bases'",
        "'get_protocol_members'",
        "'get_type_hints'",
        "'IntVar'",
        "'is_protocol'",
        "'is_typeddict'",
        "'Literal'",
        "'NewType'",
        "'overload'",
        "'override'",
        "'Protocol'",
        "'reveal_type'",
        "'runtime'",
        "'runtime_checkable'",
        "'Text'",
        "'TypeAlias'",
        "'TypeAliasType'",
        "'TypeGuard'",
        "'TYPE_CHECKING'",
        "'Never'",
        "'NoReturn'",
        "'ReadOnly'",
        "'Required'",
        "'NotRequired'",
        "'AbstractSet'",
        "'AnyStr'",
        "'BinaryIO'",
        "'Callable'",
        "'Collection'",
        "'Container'",
        "'Dict'",
        "'ForwardRef'",
        "'FrozenSet'",
        "'Generator'",
        "'Generic'",
        "'Hashable'",
        "'IO'",
        "'ItemsView'",
        "'Iterable'",
        "'Iterator'",
        "'KeysView'",
        "'List'",
        "'Mapping'",
        "'MappingView'",
        "'Match'",
        "'MutableMapping'",
        "'MutableSequence'",
        "'MutableSet'",
        "'Optional'",
        "'Pattern'",
        "'Reversible'",
        "'Sequence'",
        "'Set'",
        "'Sized'",
        "'TextIO'",
        "'Tuple'",
        "'Union'",
        "'ValuesView'",
        "'cast'",
        "'no_type_check'",
        "'no_type_check_decorator'",
        "\"<sentinel>\"",
        "f\"{cls} is not a generic class\"",
        "\"__parameters__\"",
        "f\"{cls} is not a generic class\"",
        "\"__parameters__\"",
        "f\"Too {'many' if alen > elen else 'few'} parameters for {cls};\"",
        "'many'",
        "'few'",
        "f\" actual {alen}, expected {elen}\"",
        "'T'",
        "'KT'",
        "'VT'",
        "'T_co'",
        "'T_contra'",
        "\"typing_extensions.Any cannot be used with isinstance()\"",
        "\"typing_extensions.Any\"",
        "\"Any cannot be instantiated\"",
        "'typing_extensions.'",
        "'Literal'",
        "\"get_overloads\"",
        "\"__func__\"",
        "\"__func__\"",
        "'collections.abc'",
        "'Callable'",
        "'Awaitable'",
        "'Iterable'",
        "'Iterator'",
        "'AsyncIterable'",
        "'Hashable'",
        "'Sized'",
        "'Container'",
        "'Collection'",
        "'Reversible'",
        "'Buffer'",
        "'contextlib'",
        "'AbstractContextManager'",
        "'AbstractAsyncContextManager'",
        "'typing_extensions'",
        "'Buffer'",
        "\"__abstractmethods__\"",
        "\"__annotations__\"",
        "\"__weakref__\"",
        "\"_is_protocol\"",
        "\"_is_runtime_protocol\"",
        "\"__dict__\"",
        "\"__slots__\"",
        "\"__parameters__\"",
        "\"__orig_bases__\"",
        "\"__module__\"",
        "\"_MutableMapping__marker\"",
        "\"__doc__\"",
        "\"__subclasshook__\"",
        "\"__orig_class__\"",
        "\"__init__\"",
        "\"__new__\"",
        "\"__protocol_attrs__\"",
        "\"__callable_proto_members_only__\"",
        "\"__match_args__\"",
        "\"__class_getitem__\"",
        "\"__type_params__\"",
        "'Protocol'",
        "'Generic'",
        "'__annotations__'",
        "'_abc_'",
        "'__name__'",
        "'__main__'",
        "'abc'",
        "'functools'",
        "'Protocols cannot be instantiated'",
        "\"Protocol\"",
        "f\"Protocols can only inherit from other protocols, \"",
        "f\"got {base!r}\"",
        "\"_is_protocol\"",
        "'_is_protocol'",
        "'issubclass() arg 1 must be a class'",
        "\"__subclasshook__\"",
        "\"Protocols with non-method members don't support issubclass().\"",
        "f\" Non-method members: {str(non_method_attrs)[1:-1]}.\"",
        "'_is_runtime_protocol'",
        "\"Instance and class checks can only be used with \"",
        "\"@runtime_checkable protocols\"",
        "\"_is_protocol\"",
        "'_is_runtime_protocol'",
        "\"Instance and class checks can only be used with\"",
        "\" @runtime_checkable protocols\"",
        "'_is_protocol'",
        "'__annotations__'",
        "'_is_protocol'",
        "'__subclasshook__'",
        "\"pypy\"",
        "\"__call__\"",
        "\"__mro_entries__\"",
        "\"ReadOnly\"",
        "\"module\"",
        "'cannot inherit from both a TypedDict type '",
        "'and a non-TypedDict base class'",
        "\"Protocol\"",
        "\"Protocol\"",
        "'__orig_bases__'",
        "'__annotations__'",
        "\"TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type\"",
        "'__annotations__'",
        "'__required_keys__'",
        "'__optional_keys__'",
        "'__readonly_keys__'",
        "'__mutable_keys__'",
        "f\"Cannot override mutable key {annotation_key!r}\"",
        "\" with read-only key\"",
        "'__total__'",
        "'TypedDict does not support instance and class checks'",
        "'TypedDict'",
        "\"Failing to pass a value for the 'fields' parameter\"",
        "\"Passing `None` as the 'fields' parameter\"",
        "f\"`{typename} = TypedDict({typename!r}, {{}})`\"",
        "f\"{deprecated_thing} is deprecated and will be disallowed in \"",
        "\"Python 3.15. To create a TypedDict class with 0 fields \"",
        "\"using the functional syntax, pass an empty dictionary, e.g. \"",
        "\".\"",
        "\"TypedDict takes either a dict or keyword arguments,\"",
        "\" but not both\"",
        "\"TypedDict takes no keyword arguments\"",
        "\"The kwargs-based syntax for TypedDict definitions is deprecated \"",
        "\"in Python 3.11, will be removed in Python 3.13, and may not be \"",
        "\"understood by third-party type checkers.\"",
        "'__annotations__'",
        "'__module__'",
        "\"_TypedDictMeta\"",
        "\"TypedDict\"",
        "\"assert_type\"",
        "\"Required\"",
        "\"__origin__\"",
        "\"GenericAlias\"",
        "\"UnionType\"",
        "\"Annotated\"",
        "'Annotated'",
        "f\"typing_extensions.Annotated[{typing._type_repr(self.__origin__)}, \"",
        "f\"{', '.join(repr(a) for a in self.__metadata__)}]\"",
        "', '",
        "\"Type Annotated cannot be instantiated.\"",
        "\"Annotated[...] should be used \"",
        "\"with at least two arguments (a type and an \"",
        "\"annotation).\"",
        "\"Annotated[t, ...]: t must be a type.\"",
        "f\"Cannot subclass {cls.__module__}.Annotated\"",
        "\"_special\"",
        "'TypeAlias'",
        "f\"{self} is not subscriptable\"",
        "'TypeAlias'",
        "\"Default must be a type\"",
        "\"Default must be a type\"",
        "'typing_extensions'",
        "\"TypeAliasType\"",
        "\"Variance cannot be specified with infer_variance.\"",
        "f\"type '{__name__}.TypeVar' is not an acceptable base type\"",
        "'ParamSpecArgs'",
        "f\"{self.__origin__.__name__}.args\"",
        "f\"{self.__origin__.__name__}.kwargs\"",
        "'ParamSpec'",
        "\"TypeAliasType\"",
        "f\"type '{__name__}.ParamSpec' is not an acceptable base type\"",
        "'Bound must be a type.'",
        "'typing_extensions'",
        "''",
        "'+'",
        "'-'",
        "'~'",
        "'Concatenate'",
        "f'{_type_repr(self.__origin__)}'",
        "f'[{\", \".join(_type_repr(arg) for arg in self.__args__)}]'",
        "\", \"",
        "\"Cannot take a Concatenate of no types.\"",
        "\"The last parameter to Concatenate should be a \"",
        "\"ParamSpec variable.\"",
        "\"Concatenate[arg, ...]: each arg must be a type.\"",
        "'Concatenate'",
        "'Concatenate'",
        "'TypeGuard'",
        "f'{self} accepts only a single type.'",
        "f'{self._name} accepts only a single type'",
        "'TypeGuard'",
        "'_name'",
        "'__doc__'",
        "'_getitem'",
        "'__name__'",
        "'__qualname__'",
        "f\"Cannot subclass {self!r}\"",
        "f'typing_extensions.{self._name}'",
        "f\"Cannot instantiate {self!r}\"",
        "f\"{self} cannot be used with isinstance()\"",
        "f\"{self} cannot be used with issubclass()\"",
        "\"LiteralString\"",
        "f\"{self} is not subscriptable\"",
        "\"Self\"",
        "f\"{self} is not subscriptable\"",
        "\"Never\"",
        "f\"{self} is not subscriptable\"",
        "'Required'",
        "f'{self._name} accepts only a single type.'",
        "f'{self._name} accepts only a single type.'",
        "f'{self._name} accepts only a single type.'",
        "'Required'",
        "'NotRequired'",
        "'ReadOnly'",
        "f'{self._name} accepts only a single type.'",
        "f'{self._name} accepts only a single type.'",
        "'ReadOnly'",
        "f'{self._name} accepts only a single type.'",
        "f'{self._name} accepts only a single type.'",
        "'Unpack'",
        "\"TypeVarTuple\"",
        "\"Cannot subclass special typing classes\"",
        "'typing_extensions'",
        "'_root'",
        "\"Cannot subclass special typing classes\"",
        "\"reveal_type\"",
        "f\"Runtime type is {type(obj).__name__!r}\"",
        "\"assert_never\"",
        "\"Expected code to be unreachable\"",
        "\"eq_default\"",
        "\"order_default\"",
        "\"kw_only_default\"",
        "\"frozen_default\"",
        "\"field_specifiers\"",
        "\"kwargs\"",
        "\"override\"",
        "\"_F\"",
        "\"deprecated\"",
        "\"_T\"",
        "\"Expected an object of type str for 'message', not \"",
        "f\"{type(message).__name__!r}\"",
        "f\"{cls.__name__}() takes no arguments\"",
        "\"@deprecated decorator with non-None category must be applied to \"",
        "f\"a class or callable, not {arg!r}\"",
        "\"TypeVarTuple\"",
        "f\"field {n} annotation must be a type\"",
        "'__module__'",
        "'__name__'",
        "'__annotations__'",
        "'can only inherit from a NamedTuple type and Generic'",
        "'__annotations__'",
        "f\"Non-default namedtuple field {field_name} \"",
        "f\"cannot follow default field\"",
        "f\"{'s' if len(default_names) > 1 else ''} \"",
        "'s'",
        "''",
        "f\"{', '.join(default_names)}\"",
        "', '",
        "'__module__'",
        "'_generic_class_getitem'",
        "\"Cannot overwrite NamedTuple attribute \"",
        "f\"Error calling __set_name__ on {type(val).__name__!r} \"",
        "f\"instance {key!r} in {typename!r}\"",
        "'NamedTuple'",
        "\"Creating NamedTuple classes using keyword arguments\"",
        "\"{name} is deprecated and will be disallowed in Python {remove}. \"",
        "\"Use the class-based or functional syntax instead.\"",
        "\"Failing to pass a value for the 'fields' parameter\"",
        "f\"`{typename} = NamedTuple({typename!r}, [])`\"",
        "\"{name} is deprecated and will be disallowed in Python {remove}. \"",
        "\"To create a NamedTuple class with 0 fields \"",
        "\"using the functional syntax, \"",
        "\"pass an empty list, e.g. \"",
        "\".\"",
        "\"Cannot pass `None` as the 'fields' parameter \"",
        "\"and also specify fields using keyword arguments\"",
        "\"Passing `None` as the 'fields' parameter\"",
        "f\"`{typename} = NamedTuple({typename!r}, [])`\"",
        "\"{name} is deprecated and will be disallowed in Python {remove}. \"",
        "\"To create a NamedTuple class with 0 fields \"",
        "\"using the functional syntax, \"",
        "\"pass an empty list, e.g. \"",
        "\".\"",
        "\"Either list of fields or keywords\"",
        "\" can be provided to NamedTuple, not both\"",
        "\"3.15\"",
        "\"Buffer\"",
        "\"get_original_bases\"",
        "\"__orig_bases__\"",
        "f'Expected an instance of type, not {type(cls).__name__!r}'",
        "'.'",
        "'.'",
        "'typing_extensions'",
        "f\"Cannot subclass an instance of NewType. \"",
        "f\"Perhaps you were looking for: \"",
        "f\"`{subcls_name} = NewType({subcls_name!r}, {supercls_name})`\"",
        "f'{self.__module__}.{self.__qualname__}'",
        "\"TypeAliasType\"",
        "\"TypeAliasType name must be a string\"",
        "'typing_extensions'",
        "\"__name__\"",
        "\"__name__\"",
        "\"readonly attribute\"",
        "\"__value__\"",
        "\"__type_params__\"",
        "\"__parameters__\"",
        "\"__module__\"",
        "f\"attribute '{name}' of 'typing.TypeAliasType' objects \"",
        "\"is not writable\"",
        "f\"'typing.TypeAliasType' object has no attribute '{name}'\"",
        "f'Subscripting {self.__name__} requires a type.'",
        "\"type 'typing_extensions.TypeAliasType' is not an acceptable base type\"",
        "\"Type alias is not callable\"",
        "\"is_protocol\"",
        "'_is_protocol'",
        "f'{tp!r} is not a Protocol'",
        "'__protocol_attrs__'",
        "\"Doc\"",
        "f\"Doc({self.documentation!r})\""
    ],
    "variables": [
        "__all__",
        "PEP_560",
        "GenericMeta",
        "_marker",
        "elen",
        "alen",
        "parameters",
        "num_tv_tuples",
        "typevar_types",
        "tvars",
        "NoReturn",
        "T",
        "KT",
        "VT",
        "T_co",
        "T_contra",
        "ClassVar",
        "Final",
        "f",
        "__final__",
        "Literal",
        "these_args_deduped",
        "other_args_deduped",
        "_name",
        "_doc",
        "__doc__",
        "parameters",
        "parameters",
        "val_type_pairs",
        "deduped_pairs",
        "new_parameters",
        "parameters",
        "Literal",
        "_overload_dummy",
        "overload",
        "get_overloads",
        "clear_overloads",
        "_overload_registry",
        "f",
        "f",
        "mod_dict",
        "Type",
        "Awaitable",
        "Coroutine",
        "AsyncIterable",
        "AsyncIterator",
        "ContextManager",
        "AsyncContextManager",
        "DefaultDict",
        "OrderedDict",
        "Counter",
        "ChainMap",
        "AsyncGenerator",
        "Text",
        "TYPE_CHECKING",
        "_PROTO_ALLOWLIST",
        "_EXCLUDED_ATTRS",
        "_EXCLUDED_ATTRS",
        "attrs",
        "annotations",
        "Protocol",
        "cls",
        "__protocol_attrs__",
        "cls",
        "__callable_proto_members_only__",
        "non_method_attrs",
        "val",
        "annotations",
        "__doc__",
        "__slots__",
        "_is_protocol",
        "_is_runtime_protocol",
        "cls",
        "_is_protocol",
        "cls",
        "__subclasshook__",
        "cls",
        "runtime",
        "runtime_checkable",
        "SupportsInt",
        "SupportsFloat",
        "SupportsComplex",
        "SupportsBytes",
        "SupportsIndex",
        "SupportsAbs",
        "SupportsRound",
        "__slots__",
        "__slots__",
        "__slots__",
        "__slots__",
        "__slots__",
        "__slots__",
        "__slots__",
        "cls_dict",
        "t",
        "func",
        "__mro_entries__",
        "TypedDict",
        "_TypedDictMeta",
        "is_typeddict",
        "_TAKES_MODULE",
        "annotation_origin",
        "annotation_args",
        "annotation_type",
        "annotation_type",
        "annotation_type",
        "annotation_type",
        "generic_base",
        "generic_base",
        "tp_dict",
        "tp_dict",
        "tp_dict",
        "__qualname__",
        "tp_dict",
        "__orig_bases__",
        "annotations",
        "own_annotations",
        "msg",
        "own_annotations",
        "own_annotations",
        "required_keys",
        "optional_keys",
        "readonly_keys",
        "mutable_keys",
        "base_dict",
        "qualifiers",
        "tp_dict",
        "__annotations__",
        "tp_dict",
        "__required_keys__",
        "tp_dict",
        "__optional_keys__",
        "tp_dict",
        "__readonly_keys__",
        "tp_dict",
        "__mutable_keys__",
        "tp_dict",
        "__total__",
        "__call__",
        "__instancecheck__",
        "_TypedDict",
        "deprecated_thing",
        "deprecated_thing",
        "example",
        "deprecation_msg",
        "fields",
        "ns",
        "ns",
        "td",
        "td",
        "__orig_bases__",
        "_TYPEDDICT_TYPES",
        "_TYPEDDICT_TYPES",
        "assert_type",
        "get_type_hints",
        "stripped_args",
        "stripped_args",
        "stripped_args",
        "hint",
        "hint",
        "Annotated",
        "_AnnotatedAlias",
        "metadata",
        "origin",
        "__metadata__",
        "new_type",
        "__slots__",
        "allowed_special_forms",
        "origin",
        "msg",
        "origin",
        "metadata",
        "get_origin",
        "get_args",
        "_BaseGenericAlias",
        "_typing_GenericAlias",
        "res",
        "res",
        "TypeAlias",
        "TypeAlias",
        "type_param",
        "__default__",
        "type_param",
        "__default__",
        "type_param",
        "__default__",
        "type_param",
        "__default__",
        "def_mod",
        "typevarlike",
        "__module__",
        "__slots__",
        "_backported_typevarlike",
        "typevar",
        "typevar",
        "typevar",
        "__infer_variance__",
        "ParamSpecArgs",
        "ParamSpecKwargs",
        "__slots__",
        "__origin__",
        "__origin__",
        "_backported_typevarlike",
        "paramspec",
        "paramspec",
        "paramspec",
        "__infer_variance__",
        "__class__",
        "__covariant__",
        "__contravariant__",
        "__infer_variance__",
        "__bound__",
        "__bound__",
        "def_mod",
        "__module__",
        "prefix",
        "prefix",
        "prefix",
        "prefix",
        "__class__",
        "_special",
        "__origin__",
        "__args__",
        "_type_repr",
        "parameters",
        "msg",
        "parameters",
        "Concatenate",
        "_ConcatenateGenericAlias",
        "Concatenate",
        "TypeGuard",
        "item",
        "item",
        "TypeGuard",
        "__slots__",
        "_getitem",
        "_name",
        "__doc__",
        "LiteralString",
        "Self",
        "Never",
        "Required",
        "NotRequired",
        "item",
        "item",
        "item",
        "Required",
        "NotRequired",
        "ReadOnly",
        "item",
        "item",
        "ReadOnly",
        "_UNPACK_DOC",
        "Unpack",
        "__doc__",
        "__class__",
        "item",
        "__class__",
        "item",
        "Unpack",
        "_backported_typevarlike",
        "tvt",
        "__class__",
        "def_mod",
        "__module__",
        "__unpacked__",
        "reveal_type",
        "assert_never",
        "dataclass_transform",
        "cls_or_fn",
        "__dataclass_transform__",
        "_F",
        "arg",
        "__override__",
        "deprecated",
        "_T",
        "message",
        "category",
        "stacklevel",
        "msg",
        "category",
        "stacklevel",
        "arg",
        "__deprecated__",
        "original_new",
        "arg",
        "__new__",
        "original_init_subclass",
        "original_init_subclass",
        "arg",
        "__init_subclass__",
        "arg",
        "__init_subclass__",
        "arg",
        "__deprecated__",
        "__new__",
        "__deprecated__",
        "__init_subclass__",
        "__deprecated__",
        "arg",
        "__deprecated__",
        "wrapper",
        "__deprecated__",
        "typing",
        "_collect_type_vars",
        "typing",
        "_check_generic",
        "NamedTuple",
        "fields",
        "annotations",
        "nm_tpl",
        "nm_tpl",
        "__annotations__",
        "__annotations__",
        "nm_tpl",
        "_field_types",
        "_prohibited_namedtuple_fields",
        "_special_namedtuple_fields",
        "bases",
        "types",
        "default_names",
        "nm_tpl",
        "nm_tpl",
        "__bases__",
        "nm_tpl",
        "__class_getitem__",
        "class_getitem",
        "nm_tpl",
        "__class_getitem__",
        "set_name",
        "msg",
        "_NamedTuple",
        "deprecated_thing",
        "deprecation_msg",
        "deprecated_thing",
        "example",
        "deprecation_msg",
        "deprecated_thing",
        "example",
        "deprecation_msg",
        "fields",
        "nt",
        "nt",
        "__orig_bases__",
        "Buffer",
        "get_original_bases",
        "NewType",
        "__qualname__",
        "name",
        "__supertype__",
        "def_mod",
        "__module__",
        "supercls_name",
        "subcls_name",
        "TypeAliasType",
        "__value__",
        "__type_params__",
        "parameters",
        "__parameters__",
        "def_mod",
        "__module__",
        "parameters",
        "parameters",
        "is_protocol",
        "get_protocol_members",
        "Doc",
        "documentation",
        "AbstractSet",
        "AnyStr",
        "BinaryIO",
        "Callable",
        "Collection",
        "Container",
        "Dict",
        "ForwardRef",
        "FrozenSet",
        "Generator",
        "Generic",
        "Hashable",
        "IO",
        "ItemsView",
        "Iterator",
        "KeysView",
        "Mapping",
        "MappingView",
        "Match",
        "MutableMapping",
        "MutableSequence",
        "MutableSet",
        "Optional",
        "Pattern",
        "Reversible",
        "Sequence",
        "Sized",
        "TextIO",
        "Tuple",
        "Union",
        "ValuesView",
        "cast",
        "no_type_check",
        "no_type_check_decorator"
    ],
    "comments": [
        "Super-special typing primitives.",
        "ABCs (from collections.abc).",
        "Concrete collection types.",
        "Structural checks, a.k.a. protocols.",
        "One-off things.",
        "Pure aliases, have always been in typing",
        "for backward compatibility",
        "The functions below are modified copies of typing internal helpers.",
        "They are needed by _ProtocolMeta and they provide support for PEP 646.",
        "Some unconstrained type variables.  These are used by the container types.",
        "(These are not for export.)",
        "Any type.",
        "Key type.",
        "Value type.",
        "Any type covariant containers.",
        "Ditto contravariant.",
        "@final exists in 3.8+, but we backport it for all versions",
        "before 3.11 to keep support for the __final__ attribute.",
        "See https://bugs.python.org/issue46342",
        "Skip the attribute silently if it is not writable.",
        "AttributeError happens if the object has __slots__ or a",
        "read-only property, TypeError if it's a builtin class.",
        "A Literal bug was fixed in 3.11.0, 3.10.1 and 3.9.8",
        "unhashable parameters",
        "similar logic to typing._deduplicate on Python 3.9+",
        "3.11+",
        "{module: {qualname: {firstlineno: func}}}",
        "classmethod and staticmethod",
        "Not a normal function; ignore.",
        "classmethod and staticmethod",
        "This is not a real generic class.  Don't use outside annotations.",
        "Various ABCs mimicking those in collections.abc.",
        "A few are simply re-exported for completeness.",
        "without object",
        "For platforms without _getframe()",
        "`__match_args__` attribute was removed from protocol members in 3.13,",
        "we want to backport this change to older Python versions.",
        "Inheriting from typing._ProtocolMeta isn't actually desirable,",
        "but is necessary to allow typing.Protocol and typing_extensions.Protocol",
        "to mix without getting TypeErrors about \"metaclass conflict\"",
        "This metaclass is somewhat unfortunate,",
        "but is necessary for several reasons...",
        "",
        "NOTE: DO NOT call super() in any methods in this class",
        "That would call the methods on typing._ProtocolMeta on Python 3.8-3.11",
        "and those are slow",
        "PEP 544 prohibits using issubclass()",
        "with protocols that have non-method members.",
        "Same error message as for issubclass(1, int).",
        "We need this method for situations where attributes are",
        "assigned in __init__.",
        "i.e., it's a concrete subclass of a protocol",
        "Hack so that typing.Generic.__class_getitem__",
        "treats typing_extensions.Protocol",
        "as equivalent to typing.Protocol",
        "This has to be defined, or the abc-module cache",
        "complains about classes with this metaclass being unhashable,",
        "if we define only __eq__!",
        "Check if the members appears in the class dictionary...",
        "...or in annotations, if it is a sub-protocol.",
        "Determine if this is a protocol or a concrete subclass.",
        "Set (or override) the protocol subclass hook.",
        "Prohibit instantiation for protocol classes",
        "The \"runtime\" alias exists for backwards compatibility.",
        "Our version of runtime-checkable protocols is faster on Python 3.8-3.11",
        "The standard library TypedDict in Python 3.8 does not store runtime information",
        "about which (if any) keys are optional.  See https://bugs.python.org/issue38834",
        "The standard library TypedDict in Python 3.9.0/1 does not honour the \"total\"",
        "keyword with old-style TypedDict().  See https://bugs.python.org/issue42059",
        "The standard library TypedDict below Python 3.11 does not store runtime",
        "information about optional and required keys when using Required or NotRequired.",
        "Generic TypedDicts are also impossible using typing.TypedDict on Python <3.11.",
        "Aaaand on 3.12 we add __orig_bases__ to TypedDict",
        "to enable better runtime introspection.",
        "On 3.13 we deprecate some odd ways of creating TypedDicts.",
        "PEP 705 proposes adding the ReadOnly[] qualifier.",
        "3.10.0 and later",
        "typing.py generally doesn't let you inherit from plain Generic, unless",
        "the name of the class happens to be \"Protocol\"",
        "static method",
        "Typed dicts are only for static structural subtyping.",
        "Setting correct module is necessary to make typed dict classes pickleable.",
        "On 3.8, this would otherwise return True",
        "3.11+",
        "<=3.10",
        "replaces _strip_annotations()",
        "3.9+",
        "3.8",
        "Python 3.9+ has PEP 593 (Annotated)",
        "Not exported and not a public API, but needed for get_origin() and get_args()",
        "to work.",
        "3.8",
        "Python 3.8 has get_origin() and get_args() but those implementations aren't",
        "Annotated-aware, so we can't use those. Python 3.9's versions don't support",
        "ParamSpecArgs and ParamSpecKwargs, so only Python 3.10's versions will do.",
        "3.8-3.9",
        "3.9+",
        "3.9+",
        "3.10+",
        "3.9",
        "3.8",
        "... not valid <3.11",
        "for pickling:",
        "Classes using this metaclass must provide a _backported_typevarlike ClassVar",
        "Add default and infer_variance parameters from PEP 696 and 695",
        "PEP 695 implemented (3.12+), can pass infer_variance to typing.TypeVar",
        "Python 3.10+ has PEP 612",
        "3.8-3.9",
        "3.10+",
        "Add default parameter - PEP 696",
        "PEP 695 implemented, can pass infer_variance to typing.TypeVar",
        "3.8-3.9",
        "Inherits from list as a workaround for Callable checks in Python < 3.9.2.",
        "Trick Generic __parameters__.",
        "for pickling:",
        "Hack to get typing._type_check to pass.",
        "3.8-3.9",
        "Inherits from list as a workaround for Callable checks in Python < 3.9.2.",
        "Trick Generic into looking into this for __parameters__.",
        "Flag in 3.8.",
        "Hack to get typing._type_check to pass in Generic.",
        "3.8-3.9",
        "3.10+",
        "noqa: F811",
        "3.9",
        "3.8",
        "3.10+",
        "3.9",
        "3.8",
        "Vendored from cpython typing._SpecialFrom",
        "3.11+",
        "3.11+",
        "3.11+",
        "3.11+",
        "3.9-3.10",
        "3.8",
        "3.9-3.12",
        "3.8",
        "PEP 692 changed the repr of Unpack[]",
        "3.9+",
        "3.8",
        "3.11+",
        "Add default parameter - PEP 696",
        "<=3.10",
        "Trick Generic __parameters__.",
        "for pickling:",
        "3.11+",
        "<=3.10",
        "3.11+",
        "<=3.10",
        "3.12+",
        "dataclass_transform exists in 3.11 but lacks the frozen_default parameter",
        "<=3.11",
        "3.12+",
        "<=3.11",
        "Skip the attribute silently if it is not writable.",
        "AttributeError happens if the object has __slots__ or a",
        "read-only property, TypeError if it's a builtin class.",
        "Make sure the inner functions created below don't",
        "retain a reference to self.",
        "Mirrors a similar check in object.__new__.",
        "We need slightly different behavior if __init_subclass__",
        "is a bound method (likely if it was implemented in Python)",
        "Or otherwise, which likely means it's a builtin such as",
        "object's implementation of __init_subclass__.",
        "We have to do some monkey patching to deal with the dual nature of",
        "Unpack/TypeVarTuple:",
        "- We want Unpack to be a kind of TypeVar so it gets accepted in",
        "Generic[Unpack[Ts]]",
        "- We want it to *not* be treated as a TypeVar for the purposes of",
        "counting generic parameters, so that when we subscript a generic,",
        "the runtime doesn't try to substitute the Unpack with the subscripted type.",
        "Backport typing.NamedTuple as it exists in Python 3.13.",
        "In 3.11, the ability to define generic `NamedTuple`s was supported.",
        "This was explicitly disallowed in 3.9-3.10, and only half-worked in <=3.8.",
        "On 3.12, we added __orig_bases__ to call-based NamedTuples",
        "On 3.13, we deprecated kwargs-based NamedTuples",
        "The `_field_types` attribute was removed in 3.9;",
        "in earlier versions, it is the same as the `__annotations__` attribute",
        "3.12+",
        "update from user namespace without overriding special namedtuple attributes",
        "BaseException.add_note() existed on py311,",
        "but the __set_name__ machinery didn't start",
        "using add_note() until py312.",
        "Making sure exceptions are raised in the same way",
        "as in \"normal\" classes seems most important here.",
        "As a courtesy, register the most common stdlib buffer classes.",
        "Backport of types.get_original_bases, available on 3.12+ in CPython",
        "NewType is a class on Python 3.10+, making it pickleable",
        "The error message for subclassing instances of NewType was improved on 3.11+",
        "We defined __mro_entries__ to get a better error message",
        "if a user attempts to subclass a NewType instance. bpo-46170",
        "PEP 604 methods",
        "It doesn't make sense to have these methods on Python <3.10",
        "Setting this attribute closes the TypeAliasType from further modification",
        "Match the Python 3.12 error messages exactly",
        "The presence of this method convinces typing._type_check",
        "that TypeAliasTypes are types.",
        "For forward compatibility with 3.12, reject Unions",
        "that are not accepted by the built-in Union.",
        "Aliases for items that have always been in typing.",
        "Explicitly assign these (rather than using `from typing import *` at the top),",
        "so that we get a CI error if one of these is deleted from typing.py",
        "in a future version of Python"
    ],
    "docstrings": [
        "\"\"\"Check correct count for parameters of a generic cls (internal helper).\n    This gives a nice error message in case of count mismatch.\n    \"\"\"",
        "\"\"\"Collect all type variable contained in types in order of\n    first appearance (lexicographic order). For example::\n\n        _collect_type_vars((T, List[S, T])) == (T, S)\n    \"\"\"",
        "\"\"\"Special type indicating an unconstrained type.\n        - Any is compatible with every type.\n        - Any assumed to have all methods.\n        - All values assumed to be instances of Any.\n        Note that all the above statements are true from the point of view of\n        static type checkers. At runtime, Any should not be used with instance\n        checks.\n        \"\"\"",
        "\"\"\"This decorator can be used to indicate to type checkers that\n        the decorated method cannot be overridden, and decorated class\n        cannot be subclassed. For example:\n\n            class Base:\n                @final\n                def done(self) -> None:\n                    ...\n            class Sub(Base):\n                def done(self) -> None:  # Error reported by type checker\n                    ...\n            @final\n            class Leaf:\n                ...\n            class Other(Leaf):  # Error reported by type checker\n                ...\n\n        There is no runtime checking of these properties. The decorator\n        sets the ``__final__`` attribute to ``True`` on the decorated object\n        to allow runtime introspection.\n        \"\"\"",
        "\"\"\"An internal helper for Literal creation: flatten Literals among parameters\"\"\"",
        "\"\"\"\\\n                           A type that can be used to indicate to type checkers\n                           that the corresponding value has a value literally equivalent\n                           to the provided parameter. For example:\n\n                               var: Literal[4] = 4\n\n                           The type checker understands that 'var' is literally equal to\n                           the value 4 and no other value.\n\n                           Literal[...] cannot be subclassed. There is no runtime\n                           checking verifying that the parameter is actually a value\n                           instead of a type.\"\"\"",
        "\"\"\"Decorator for overloaded functions/methods.\n\n        In a stub file, place two or more stub definitions for the same\n        function in a row, each decorated with @overload.  For example:\n\n        @overload\n        def utf8(value: None) -> None: ...\n        @overload\n        def utf8(value: bytes) -> bytes: ...\n        @overload\n        def utf8(value: str) -> bytes: ...\n\n        In a non-stub file (i.e. a regular .py file), do the same but\n        follow it with an implementation.  The implementation should *not*\n        be decorated with @overload.  For example:\n\n        @overload\n        def utf8(value: None) -> None: ...\n        @overload\n        def utf8(value: bytes) -> bytes: ...\n        @overload\n        def utf8(value: str) -> bytes: ...\n        def utf8(value):\n            # implementation goes here\n\n        The overloads for a function can be retrieved at runtime using the\n        get_overloads() function.\n        \"\"\"",
        "\"\"\"Return all defined overloads for *func* as a sequence.\"\"\"",
        "\"\"\"Clear all overloads in the registry.\"\"\"",
        "\"\"\"Allow instance and class checks for special stdlib modules.\n        The abc and functools modules indiscriminately call isinstance() and\n        issubclass() on the whole MRO of a user class, which may contain protocols.\n        \"\"\"",
        "\"\"\"An ABC with one abstract method __int__.\"\"\"",
        "\"\"\"An ABC with one abstract method __float__.\"\"\"",
        "\"\"\"An ABC with one abstract method __complex__.\"\"\"",
        "\"\"\"An ABC with one abstract method __bytes__.\"\"\"",
        "\"\"\"\n        An ABC with one abstract method __abs__ that is covariant in its return type.\n        \"\"\"",
        "\"\"\"\n        An ABC with one abstract method __round__ that is covariant in its return type.\n        \"\"\"",
        "\"\"\"Create new typed dict class object.\n\n            This method is called when TypedDict is subclassed,\n            or when TypedDict is instantiated. This way\n            TypedDict supports all three syntax forms described in its docstring.\n            Subclasses and instances of TypedDict return actual dictionaries.\n            \"\"\"",
        "\"\"\"A simple typed namespace. At runtime it is equivalent to a plain dict.\n\n        TypedDict creates a dictionary type such that a type checker will expect all\n        instances to have a certain set of keys, where each key is\n        associated with a value of a consistent type. This expectation\n        is not checked at runtime.\n\n        Usage::\n\n            class Point2D(TypedDict):\n                x: int\n                y: int\n                label: str\n\n            a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK\n            b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check\n\n            assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')\n\n        The type info can be accessed via the Point2D.__annotations__ dict, and\n        the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.\n        TypedDict supports an additional equivalent form::\n\n            Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})\n\n        By default, all keys must be present in a TypedDict. It is possible\n        to override this by specifying totality::\n\n            class Point2D(TypedDict, total=False):\n                x: int\n                y: int\n\n        This means that a Point2D TypedDict can have any of the keys omitted. A type\n        checker is only expected to support a literal False or True as the value of\n        the total argument. True is the default, and makes all items defined in the\n        class body be required.\n\n        The Required and NotRequired special forms can also be used to mark\n        individual keys as being required or not required::\n\n            class Point2D(TypedDict):\n                x: int  # the \"x\" key must always be present (Required is the default)\n                y: NotRequired[int]  # the \"y\" key can be omitted\n\n        See PEP 655 for more details on Required and NotRequired.\n        \"\"\"",
        "\"\"\"Check if an annotation is a TypedDict class\n\n        For example::\n            class Film(TypedDict):\n                title: str\n                year: int\n\n            is_typeddict(Film)  # => True\n            is_typeddict(Union[list, str])  # => False\n        \"\"\"",
        "\"\"\"Assert (to the type checker) that the value is of the given type.\n\n        When the type checker encounters a call to assert_type(), it\n        emits an error if the value is not of the specified type::\n\n            def greet(name: str) -> None:\n                assert_type(name, str)  # ok\n                assert_type(name, int)  # type checker error\n\n        At runtime this returns the first argument unchanged and otherwise\n        does nothing.\n        \"\"\"",
        "\"\"\"Strips Annotated, Required and NotRequired from a given type.\"\"\"",
        "\"\"\"Return type hints for an object.\n\n        This is often the same as obj.__annotations__, but it handles\n        forward references encoded as string literals, adds Optional[t] if a\n        default value equal to None is set and recursively replaces all\n        'Annotated[T, ...]', 'Required[T]' or 'NotRequired[T]' with 'T'\n        (unless 'include_extras=True').\n\n        The argument may be a module, class, method, or function. The annotations\n        are returned as a dictionary. For classes, annotations include also\n        inherited members.\n\n        TypeError is raised if the argument is not of a type that can contain\n        annotations, and an empty dictionary is returned if no annotations are\n        present.\n\n        BEWARE -- the behavior of globalns and localns is counterintuitive\n        (unless you are familiar with how eval() and exec() work).  The\n        search order is locals first, then globals.\n\n        - If no dict arguments are passed, an attempt is made to use the\n          globals from obj (or the respective module's globals for classes),\n          and these are also used as the locals.  If the object does not appear\n          to have globals, an empty dictionary is used.\n\n        - If one dict argument is passed, it is used for both globals and\n          locals.\n\n        - If two dict arguments are passed, they specify globals and\n          locals, respectively.\n        \"\"\"",
        "\"\"\"Runtime representation of an annotated type.\n\n        At its core 'Annotated[t, dec1, dec2, ...]' is an alias for the type 't'\n        with extra annotations. The alias behaves like a normal typing alias,\n        instantiating is the same as instantiating the underlying type, binding\n        it to types is also the same.\n        \"\"\"",
        "\"\"\"Add context specific metadata to a type.\n\n        Example: Annotated[int, runtime_check.Unsigned] indicates to the\n        hypothetical runtime_check module that this type is an unsigned int.\n        Every other consumer of this type can ignore this metadata and treat\n        this type as int.\n\n        The first argument to Annotated must be a valid type (and will be in\n        the __origin__ field), the remaining arguments are kept as a tuple in\n        the __extra__ field.\n\n        Details:\n\n        - It's an error to call `Annotated` with less than two arguments.\n        - Nested Annotated are flattened::\n\n            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n        - Instantiating an annotated type is equivalent to instantiating the\n        underlying type::\n\n            Annotated[C, Ann1](5) == C(5)\n\n        - Annotated can be used as a generic type alias::\n\n            Optimized = Annotated[T, runtime.Optimize()]\n            Optimized[int] == Annotated[int, runtime.Optimize()]\n\n            OptimizedList = Annotated[List[T], runtime.Optimize()]\n            OptimizedList[int] == Annotated[List[int], runtime.Optimize()]\n        \"\"\"",
        "\"\"\"Get the unsubscripted version of a type.\n\n        This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar\n        and Annotated. Return None for unsupported types. Examples::\n\n            get_origin(Literal[42]) is Literal\n            get_origin(int) is None\n            get_origin(ClassVar[int]) is ClassVar\n            get_origin(Generic) is Generic\n            get_origin(Generic[T]) is Generic\n            get_origin(Union[T, int]) is Union\n            get_origin(List[Tuple[T, T]][int]) == list\n            get_origin(P.args) is P\n        \"\"\"",
        "\"\"\"Get type arguments with all substitutions performed.\n\n        For unions, basic simplifications used by Union constructor are performed.\n        Examples::\n            get_args(Dict[str, int]) == (str, int)\n            get_args(int) == ()\n            get_args(Union[int, Union[T, int], str][int]) == (int, str)\n            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])\n            get_args(Callable[[], T][int]) == ([], int)\n        \"\"\"",
        "\"\"\"Special marker indicating that an assignment should\n        be recognized as a proper type alias definition by type\n        checkers.\n\n        For example::\n\n            Predicate: TypeAlias = Callable[..., bool]\n\n        It's invalid when used anywhere except as in the example above.\n        \"\"\"",
        "\"\"\"Special marker indicating that an assignment should\n        be recognized as a proper type alias definition by type\n        checkers.\n\n        For example::\n\n            Predicate: TypeAlias = Callable[..., bool]\n\n        It's invalid when used anywhere except as in the example\n        above.\"\"\"",
        "\"\"\"Mixin for TypeVarLike defaults.\"\"\"",
        "\"\"\"Type variable.\"\"\"",
        "\"\"\"Mixin to indicate that object should not be copied.\"\"\"",
        "\"\"\"The args for a ParamSpec object.\n\n        Given a ParamSpec object P, P.args is an instance of ParamSpecArgs.\n\n        ParamSpecArgs objects have a reference back to their ParamSpec:\n\n        P.args.__origin__ is P\n\n        This type is meant for runtime introspection and has no special meaning to\n        static type checkers.\n        \"\"\"",
        "\"\"\"The kwargs for a ParamSpec object.\n\n        Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs.\n\n        ParamSpecKwargs objects have a reference back to their ParamSpec:\n\n        P.kwargs.__origin__ is P\n\n        This type is meant for runtime introspection and has no special meaning to\n        static type checkers.\n        \"\"\"",
        "\"\"\"Parameter specification.\"\"\"",
        "\"\"\"Parameter specification variable.\n\n        Usage::\n\n           P = ParamSpec('P')\n\n        Parameter specification variables exist primarily for the benefit of static\n        type checkers.  They are used to forward the parameter types of one\n        callable to another callable, a pattern commonly found in higher order\n        functions and decorators.  They are only valid when used in ``Concatenate``,\n        or s the first argument to ``Callable``. In Python 3.10 and higher,\n        they are also supported in user-defined Generics at runtime.\n        See class Generic for more information on generic types.  An\n        example for annotating a decorator::\n\n           T = TypeVar('T')\n           P = ParamSpec('P')\n\n           def add_logging(f: Callable[P, T]) -> Callable[P, T]:\n               '''A type-safe decorator to add logging to a function.'''\n               def inner(*args: P.args, **kwargs: P.kwargs) -> T:\n                   logging.info(f'{f.__name__} was called')\n                   return f(*args, **kwargs)\n               return inner\n\n           @add_logging\n           def add_two(x: float, y: float) -> float:\n               '''Add two numbers together.'''\n               return x + y\n\n        Parameter specification variables defined with covariant=True or\n        contravariant=True can be used to declare covariant or contravariant\n        generic types.  These keyword arguments are valid, but their actual semantics\n        are yet to be decided.  See PEP 612 for details.\n\n        Parameter specification variables can be introspected. e.g.:\n\n           P.__name__ == 'T'\n           P.__bound__ == None\n           P.__covariant__ == False\n           P.__contravariant__ == False\n\n        Note that only parameter specification variables defined in global scope can\n        be pickled.\n        \"\"\"",
        "\"\"\"Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a\n        higher order function which adds, removes or transforms parameters of a\n        callable.\n\n        For example::\n\n           Callable[Concatenate[int, P], int]\n\n        See PEP 612 for detailed information.\n        \"\"\"",
        "\"\"\"Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a\n        higher order function which adds, removes or transforms parameters of a\n        callable.\n\n        For example::\n\n           Callable[Concatenate[int, P], int]\n\n        See PEP 612 for detailed information.\n        \"\"\"",
        "\"\"\"Special typing form used to annotate the return type of a user-defined\n        type guard function.  ``TypeGuard`` only accepts a single type argument.\n        At runtime, functions marked this way should return a boolean.\n\n        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static\n        type checkers to determine a more precise type of an expression within a\n        program's code flow.  Usually type narrowing is done by analyzing\n        conditional code flow and applying the narrowing to a block of code.  The\n        conditional expression here is sometimes referred to as a \"type guard\".\n\n        Sometimes it would be convenient to use a user-defined boolean function\n        as a type guard.  Such a function should use ``TypeGuard[...]`` as its\n        return type to alert static type checkers to this intention.\n\n        Using  ``-> TypeGuard`` tells the static type checker that for a given\n        function:\n\n        1. The return value is a boolean.\n        2. If the return value is ``True``, the type of its argument\n        is the type inside ``TypeGuard``.\n\n        For example::\n\n            def is_str(val: Union[str, float]):\n                # \"isinstance\" type guard\n                if isinstance(val, str):\n                    # Type of ``val`` is narrowed to ``str``\n                    ...\n                else:\n                    # Else, type of ``val`` is narrowed to ``float``.\n                    ...\n\n        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower\n        form of ``TypeA`` (it can even be a wider form) and this may lead to\n        type-unsafe results.  The main reason is to allow for things like\n        narrowing ``List[object]`` to ``List[str]`` even though the latter is not\n        a subtype of the former, since ``List`` is invariant.  The responsibility of\n        writing type-safe type guards is left to the user.\n\n        ``TypeGuard`` also works with type variables.  For more information, see\n        PEP 647 (User-Defined Type Guards).\n        \"\"\"",
        "\"\"\"Special typing form used to annotate the return type of a user-defined\n        type guard function.  ``TypeGuard`` only accepts a single type argument.\n        At runtime, functions marked this way should return a boolean.\n\n        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static\n        type checkers to determine a more precise type of an expression within a\n        program's code flow.  Usually type narrowing is done by analyzing\n        conditional code flow and applying the narrowing to a block of code.  The\n        conditional expression here is sometimes referred to as a \"type guard\".\n\n        Sometimes it would be convenient to use a user-defined boolean function\n        as a type guard.  Such a function should use ``TypeGuard[...]`` as its\n        return type to alert static type checkers to this intention.\n\n        Using  ``-> TypeGuard`` tells the static type checker that for a given\n        function:\n\n        1. The return value is a boolean.\n        2. If the return value is ``True``, the type of its argument\n        is the type inside ``TypeGuard``.\n\n        For example::\n\n            def is_str(val: Union[str, float]):\n                # \"isinstance\" type guard\n                if isinstance(val, str):\n                    # Type of ``val`` is narrowed to ``str``\n                    ...\n                else:\n                    # Else, type of ``val`` is narrowed to ``float``.\n                    ...\n\n        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower\n        form of ``TypeA`` (it can even be a wider form) and this may lead to\n        type-unsafe results.  The main reason is to allow for things like\n        narrowing ``List[object]`` to ``List[str]`` even though the latter is not\n        a subtype of the former, since ``List`` is invariant.  The responsibility of\n        writing type-safe type guards is left to the user.\n\n        ``TypeGuard`` also works with type variables.  For more information, see\n        PEP 647 (User-Defined Type Guards).\n        \"\"\"",
        "\"\"\"Represents an arbitrary literal string.\n\n        Example::\n\n          from typing_extensions import LiteralString\n\n          def query(sql: LiteralString) -> ...:\n              ...\n\n          query(\"SELECT * FROM table\")  # ok\n          query(f\"SELECT * FROM {input()}\")  # not ok\n\n        See PEP 675 for details.\n\n        \"\"\"",
        "\"\"\"Used to spell the type of \"self\" in classes.\n\n        Example::\n\n          from typing import Self\n\n          class ReturnsSelf:\n              def parse(self, data: bytes) -> Self:\n                  ...\n                  return self\n\n        \"\"\"",
        "\"\"\"The bottom type, a type that has no members.\n\n        This can be used to define a function that should never be\n        called, or a function that never returns::\n\n            from typing_extensions import Never\n\n            def never_call_me(arg: Never) -> None:\n                pass\n\n            def int_or_str(arg: int | str) -> None:\n                never_call_me(arg)  # type checker error\n                match arg:\n                    case int():\n                        print(\"It's an int\")\n                    case str():\n                        print(\"It's a str\")\n                    case _:\n                        never_call_me(arg)  # ok, arg is of type Never\n\n        \"\"\"",
        "\"\"\"A special typing construct to mark a key of a total=False TypedDict\n        as required. For example:\n\n            class Movie(TypedDict, total=False):\n                title: Required[str]\n                year: int\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n\n        There is no runtime checking that a required key is actually provided\n        when instantiating a related TypedDict.\n        \"\"\"",
        "\"\"\"A special typing construct to mark a key of a TypedDict as\n        potentially missing. For example:\n\n            class Movie(TypedDict):\n                title: str\n                year: NotRequired[int]\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n        \"\"\"",
        "\"\"\"A special typing construct to mark a key of a total=False TypedDict\n        as required. For example:\n\n            class Movie(TypedDict, total=False):\n                title: Required[str]\n                year: int\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n\n        There is no runtime checking that a required key is actually provided\n        when instantiating a related TypedDict.\n        \"\"\"",
        "\"\"\"A special typing construct to mark a key of a TypedDict as\n        potentially missing. For example:\n\n            class Movie(TypedDict):\n                title: str\n                year: NotRequired[int]\n\n            m = Movie(\n                title='The Matrix',  # typechecker error if key is omitted\n                year=1999,\n            )\n        \"\"\"",
        "\"\"\"A special typing construct to mark an item of a TypedDict as read-only.\n\n        For example:\n\n            class Movie(TypedDict):\n                title: ReadOnly[str]\n                year: int\n\n            def mutate_movie(m: Movie) -> None:\n                m[\"year\"] = 1992  # allowed\n                m[\"title\"] = \"The Matrix\"  # typechecker error\n\n        There is no runtime checking for this property.\n        \"\"\"",
        "\"\"\"A special typing construct to mark a key of a TypedDict as read-only.\n\n        For example:\n\n            class Movie(TypedDict):\n                title: ReadOnly[str]\n                year: int\n\n            def mutate_movie(m: Movie) -> None:\n                m[\"year\"] = 1992  # allowed\n                m[\"title\"] = \"The Matrix\"  # typechecker error\n\n        There is no runtime checking for this propery.\n        \"\"\"",
        "\"\"\"\\\nType unpack operator.\n\nThe type unpack operator takes the child types from some container type,\nsuch as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'. For\nexample:\n\n  # For some generic class `Foo`:\n  Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]\n\n  Ts = TypeVarTuple('Ts')\n  # Specifies that `Bar` is generic in an arbitrary number of types.\n  # (Think of `Ts` as a tuple of an arbitrary number of individual\n  #  `TypeVar`s, which the `Unpack` is 'pulling out' directly into the\n  #  `Generic[]`.)\n  class Bar(Generic[Unpack[Ts]]): ...\n  Bar[int]  # Valid\n  Bar[int, str]  # Also valid\n\nFrom Python 3.11, this can also be done using the `*` operator:\n\n    Foo[*tuple[int, str]]\n    class Bar(Generic[*Ts]): ...\n\nThe operator can also be used along with a `TypedDict` to annotate\n`**kwargs` in a function signature. For instance:\n\n  class Movie(TypedDict):\n    name: str\n    year: int\n\n  # This function expects two keyword arguments - *name* of type `str` and\n  # *year* of type `int`.\n  def foo(**kwargs: Unpack[Movie]): ...\n\nNote that there is only some runtime checking of this operator. Not\neverything the runtime allows may be accepted by static type checkers.\n\nFor more information, see PEP 646 and PEP 692.\n\"\"\"",
        "\"\"\"Type variable tuple.\"\"\"",
        "\"\"\"Type variable tuple.\n\n        Usage::\n\n            Ts = TypeVarTuple('Ts')\n\n        In the same way that a normal type variable is a stand-in for a single\n        type such as ``int``, a type variable *tuple* is a stand-in for a *tuple*\n        type such as ``Tuple[int, str]``.\n\n        Type variable tuples can be used in ``Generic`` declarations.\n        Consider the following example::\n\n            class Array(Generic[*Ts]): ...\n\n        The ``Ts`` type variable tuple here behaves like ``tuple[T1, T2]``,\n        where ``T1`` and ``T2`` are type variables. To use these type variables\n        as type parameters of ``Array``, we must *unpack* the type variable tuple using\n        the star operator: ``*Ts``. The signature of ``Array`` then behaves\n        as if we had simply written ``class Array(Generic[T1, T2]): ...``.\n        In contrast to ``Generic[T1, T2]``, however, ``Generic[*Shape]`` allows\n        us to parameterise the class with an *arbitrary* number of type parameters.\n\n        Type variable tuples can be used anywhere a normal ``TypeVar`` can.\n        This includes class definitions, as shown above, as well as function\n        signatures and variable annotations::\n\n            class Array(Generic[*Ts]):\n\n                def __init__(self, shape: Tuple[*Ts]):\n                    self._shape: Tuple[*Ts] = shape\n\n                def get_shape(self) -> Tuple[*Ts]:\n                    return self._shape\n\n            shape = (Height(480), Width(640))\n            x: Array[Height, Width] = Array(shape)\n            y = abs(x)  # Inferred type is Array[Height, Width]\n            z = x + x   #        ...    is Array[Height, Width]\n            x.get_shape()  #     ...    is tuple[Height, Width]\n\n        \"\"\"",
        "\"\"\"Reveal the inferred type of a variable.\n\n        When a static type checker encounters a call to ``reveal_type()``,\n        it will emit the inferred type of the argument::\n\n            x: int = 1\n            reveal_type(x)\n\n        Running a static type checker (e.g., ``mypy``) on this example\n        will produce output similar to 'Revealed type is \"builtins.int\"'.\n\n        At runtime, the function prints the runtime type of the\n        argument and returns it unchanged.\n\n        \"\"\"",
        "\"\"\"Assert to the type checker that a line of code is unreachable.\n\n        Example::\n\n            def int_or_str(arg: int | str) -> None:\n                match arg:\n                    case int():\n                        print(\"It's an int\")\n                    case str():\n                        print(\"It's a str\")\n                    case _:\n                        assert_never(arg)\n\n        If a type checker finds that a call to assert_never() is\n        reachable, it will emit an error.\n\n        At runtime, this throws an exception when called.\n\n        \"\"\"",
        "\"\"\"Decorator that marks a function, class, or metaclass as providing\n        dataclass-like behavior.\n\n        Example:\n\n            from typing_extensions import dataclass_transform\n\n            _T = TypeVar(\"_T\")\n\n            # Used on a decorator function\n            @dataclass_transform()\n            def create_model(cls: type[_T]) -> type[_T]:\n                ...\n                return cls\n\n            @create_model\n            class CustomerModel:\n                id: int\n                name: str\n\n            # Used on a base class\n            @dataclass_transform()\n            class ModelBase: ...\n\n            class CustomerModel(ModelBase):\n                id: int\n                name: str\n\n            # Used on a metaclass\n            @dataclass_transform()\n            class ModelMeta(type): ...\n\n            class ModelBase(metaclass=ModelMeta): ...\n\n            class CustomerModel(ModelBase):\n                id: int\n                name: str\n\n        Each of the ``CustomerModel`` classes defined in this example will now\n        behave similarly to a dataclass created with the ``@dataclasses.dataclass``\n        decorator. For example, the type checker will synthesize an ``__init__``\n        method.\n\n        The arguments to this decorator can be used to customize this behavior:\n        - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be\n          True or False if it is omitted by the caller.\n        - ``order_default`` indicates whether the ``order`` parameter is\n          assumed to be True or False if it is omitted by the caller.\n        - ``kw_only_default`` indicates whether the ``kw_only`` parameter is\n          assumed to be True or False if it is omitted by the caller.\n        - ``frozen_default`` indicates whether the ``frozen`` parameter is\n          assumed to be True or False if it is omitted by the caller.\n        - ``field_specifiers`` specifies a static list of supported classes\n          or functions that describe fields, similar to ``dataclasses.field()``.\n\n        At runtime, this decorator records its arguments in the\n        ``__dataclass_transform__`` attribute on the decorated object.\n\n        See PEP 681 for details.\n\n        \"\"\"",
        "\"\"\"Indicate that a method is intended to override a method in a base class.\n\n        Usage:\n\n            class Base:\n                def method(self) -> None:\n                    pass\n\n            class Child(Base):\n                @override\n                def method(self) -> None:\n                    super().method()\n\n        When this decorator is applied to a method, the type checker will\n        validate that it overrides a method with the same name on a base class.\n        This helps prevent bugs that may occur when a base class is changed\n        without an equivalent change to a child class.\n\n        There is no runtime checking of these properties. The decorator\n        sets the ``__override__`` attribute to ``True`` on the decorated object\n        to allow runtime introspection.\n\n        See PEP 698 for details.\n\n        \"\"\"",
        "\"\"\"Indicate that a class, function or overload is deprecated.\n\n        When this decorator is applied to an object, the type checker\n        will generate a diagnostic on usage of the deprecated object.\n\n        Usage:\n\n            @deprecated(\"Use B instead\")\n            class A:\n                pass\n\n            @deprecated(\"Use g instead\")\n            def f():\n                pass\n\n            @overload\n            @deprecated(\"int support is deprecated\")\n            def g(x: int) -> int: ...\n            @overload\n            def g(x: str) -> int: ...\n\n        The warning specified by *category* will be emitted at runtime\n        on use of deprecated objects. For functions, that happens on calls;\n        for classes, on instantiation and on creation of subclasses.\n        If the *category* is ``None``, no warning is emitted at runtime.\n        The *stacklevel* determines where the\n        warning is emitted. If it is ``1`` (the default), the warning\n        is emitted at the direct caller of the deprecated object; if it\n        is higher, it is emitted further up the stack.\n        Static type checker behavior is not affected by the *category*\n        and *stacklevel* arguments.\n\n        The deprecation message passed to the decorator is saved in the\n        ``__deprecated__`` attribute on the decorated object.\n        If applied to an overload, the decorator\n        must be after the ``@overload`` decorator for the attribute to\n        exist on the overload as returned by ``get_overloads()``.\n\n        See PEP 702 for details.\n\n        \"\"\"",
        "\"\"\"Typed version of namedtuple.\n\n        Usage::\n\n            class Employee(NamedTuple):\n                name: str\n                id: int\n\n        This is equivalent to::\n\n            Employee = collections.namedtuple('Employee', ['name', 'id'])\n\n        The resulting class has an extra __annotations__ attribute, giving a\n        dict that maps field names to types.  (The field names are also in\n        the _fields attribute, which is part of the namedtuple API.)\n        An alternative equivalent functional syntax is also accepted::\n\n            Employee = NamedTuple('Employee', [('name', str), ('id', int)])\n        \"\"\"",
        "\"\"\"Base class for classes that implement the buffer protocol.\n\n        The buffer protocol allows Python objects to expose a low-level\n        memory buffer interface. Before Python 3.12, it is not possible\n        to implement the buffer protocol in pure Python code, or even\n        to check whether a class implements the buffer protocol. In\n        Python 3.12 and higher, the ``__buffer__`` method allows access\n        to the buffer protocol from Python code, and the\n        ``collections.abc.Buffer`` ABC allows checking whether a class\n        implements the buffer protocol.\n\n        To indicate support for the buffer protocol in earlier versions,\n        inherit from this ABC, either in a stub file or at runtime,\n        or use ABC registration. This ABC provides no methods, because\n        there is no Python-accessible methods shared by pre-3.12 buffer\n        classes. It is useful primarily for static checks.\n\n        \"\"\"",
        "\"\"\"Return the class's \"original\" bases prior to modification by `__mro_entries__`.\n\n        Examples::\n\n            from typing import TypeVar, Generic\n            from typing_extensions import NamedTuple, TypedDict\n\n            T = TypeVar(\"T\")\n            class Foo(Generic[T]): ...\n            class Bar(Foo[int], float): ...\n            class Baz(list[str]): ...\n            Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n            Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})\n\n            assert get_original_bases(Bar) == (Foo[int], float)\n            assert get_original_bases(Baz) == (list[str],)\n            assert get_original_bases(Eggs) == (NamedTuple,)\n            assert get_original_bases(Spam) == (TypedDict,)\n            assert get_original_bases(int) == (object,)\n        \"\"\"",
        "\"\"\"NewType creates simple unique types with almost zero\n        runtime overhead. NewType(name, tp) is considered a subtype of tp\n        by static type checkers. At runtime, NewType(name, tp) returns\n        a dummy callable that simply returns its argument. Usage::\n            UserId = NewType('UserId', int)\n            def name_by_id(user_id: UserId) -> str:\n                ...\n            UserId('user')          # Fails type check\n            name_by_id(42)          # Fails type check\n            name_by_id(UserId(42))  # OK\n            num = UserId(5) + 1     # type: int\n        \"\"\"",
        "\"\"\"Corresponds to is_unionable() in unionobject.c in CPython.\"\"\"",
        "\"\"\"Create named, parameterized type aliases.\n\n        This provides a backport of the new `type` statement in Python 3.12:\n\n            type ListOrSet[T] = list[T] | set[T]\n\n        is equivalent to:\n\n            T = TypeVar(\"T\")\n            ListOrSet = TypeAliasType(\"ListOrSet\", list[T] | set[T], type_params=(T,))\n\n        The name ListOrSet can then be used as an alias for the type it refers to.\n\n        The type_params argument should contain all the type parameters used\n        in the value of the type alias. If the alias is not generic, this\n        argument is omitted.\n\n        Static type checkers should only support type aliases declared using\n        TypeAliasType that follow these rules:\n\n        - The first argument (the name) must be a string literal.\n        - The TypeAliasType instance must be immediately assigned to a variable\n          of the same name. (For example, 'X = TypeAliasType(\"Y\", int)' is invalid,\n          as is 'X, Y = TypeAliasType(\"X\", int), TypeAliasType(\"Y\", int)').\n\n        \"\"\"",
        "\"\"\"Return True if the given type is a Protocol.\n\n        Example::\n\n            >>> from typing_extensions import Protocol, is_protocol\n            >>> class P(Protocol):\n            ...     def a(self) -> str: ...\n            ...     b: int\n            >>> is_protocol(P)\n            True\n            >>> is_protocol(int)\n            False\n        \"\"\"",
        "\"\"\"Return the set of members defined in a Protocol.\n\n        Example::\n\n            >>> from typing_extensions import Protocol, get_protocol_members\n            >>> class P(Protocol):\n            ...     def a(self) -> str: ...\n            ...     b: int\n            >>> get_protocol_members(P)\n            frozenset({'a', 'b'})\n\n        Raise a TypeError for arguments that are not Protocols.\n        \"\"\"",
        "\"\"\"Define the documentation of a type annotation using ``Annotated``, to be\n         used in class attributes, function and method parameters, return values,\n         and variables.\n\n        The value should be a positional-only string literal to allow static tools\n        like editors and documentation generators to use it.\n\n        This complements docstrings.\n\n        The string value passed is available in the attribute ``documentation``.\n\n        Example::\n\n            >>> from typing_extensions import Annotated, Doc\n            >>> def hi(to: Annotated[str, Doc(\"Who to say hi to\")]) -> None: ...\n        \"\"\""
    ],
    "functions": [
        "__repr__",
        "_check_generic",
        "_should_collect_from_parameters",
        "_should_collect_from_parameters",
        "_should_collect_from_parameters",
        "_collect_type_vars",
        "__instancecheck__",
        "__repr__",
        "__new__",
        "__repr__",
        "IntVar",
        "_flatten_literal_params",
        "_value_and_type_iter",
        "__eq__",
        "__hash__",
        "__getitem__",
        "overload",
        "get_overloads",
        "clear_overloads",
        "_get_protocol_attrs",
        "_caller",
        "_allow_reckless_class_checks",
        "_no_init",
        "__new__",
        "__subclasscheck__",
        "__instancecheck__",
        "__eq__",
        "__hash__",
        "_proto_hook",
        "__init_subclass__",
        "__int__",
        "__float__",
        "__complex__",
        "__bytes__",
        "__index__",
        "__abs__",
        "__round__",
        "_ensure_subclassable",
        "inner",
        "_get_typeddict_qualifiers",
        "__new__",
        "__subclasscheck__",
        "TypedDict",
        "is_typeddict",
        "assert_type",
        "_strip_extras",
        "get_type_hints",
        "copy_with",
        "__repr__",
        "__reduce__",
        "__eq__",
        "__hash__",
        "__new__",
        "__class_getitem__",
        "__init_subclass__",
        "get_origin",
        "get_args",
        "TypeAlias",
        "_set_default",
        "_set_module",
        "__instancecheck__",
        "__new__",
        "__init_subclass__",
        "__copy__",
        "__deepcopy__",
        "__repr__",
        "__eq__",
        "__repr__",
        "__eq__",
        "__new__",
        "__init_subclass__",
        "args",
        "kwargs",
        "__repr__",
        "__hash__",
        "__eq__",
        "__reduce__",
        "__call__",
        "__repr__",
        "__hash__",
        "__call__",
        "__parameters__",
        "_concatenate_getitem",
        "Concatenate",
        "__getitem__",
        "TypeGuard",
        "__getitem__",
        "__getattr__",
        "__mro_entries__",
        "__repr__",
        "__reduce__",
        "__call__",
        "__or__",
        "__ror__",
        "__instancecheck__",
        "__subclasscheck__",
        "__getitem__",
        "LiteralString",
        "Self",
        "Never",
        "Required",
        "NotRequired",
        "__getitem__",
        "ReadOnly",
        "__getitem__",
        "_is_unpack",
        "Unpack",
        "_is_unpack",
        "__getitem__",
        "_is_unpack",
        "__new__",
        "__init_subclass__",
        "__iter__",
        "__repr__",
        "__hash__",
        "__eq__",
        "__reduce__",
        "__init_subclass__",
        "reveal_type",
        "assert_never",
        "dataclass_transform",
        "decorator",
        "__call__",
        "__new__",
        "__init_subclass__",
        "__init_subclass__",
        "wrapper",
        "_make_nmtuple",
        "__new__",
        "_namedtuple_mro_entries",
        "NamedTuple",
        "get_original_bases",
        "__call__",
        "__mro_entries__",
        "__init_subclass__",
        "__repr__",
        "__reduce__",
        "__or__",
        "__ror__",
        "_is_unionable",
        "__setattr__",
        "__delattr__",
        "_raise_attribute_error",
        "__repr__",
        "__getitem__",
        "__reduce__",
        "__init_subclass__",
        "__call__",
        "__or__",
        "__ror__",
        "is_protocol",
        "get_protocol_members",
        "__repr__",
        "__hash__",
        "__eq__"
    ],
    "classes": [
        "_Sentinel",
        "_AnyMeta",
        "Any",
        "_ExtensionsSpecialForm",
        "_LiteralGenericAlias",
        "_LiteralForm",
        "_ProtocolMeta",
        "Protocol",
        "SupportsInt",
        "SupportsFloat",
        "SupportsComplex",
        "SupportsBytes",
        "SupportsIndex",
        "SupportsAbs",
        "SupportsRound",
        "_TypedDictMeta",
        "_AnnotatedAlias",
        "Annotated",
        "_DefaultMixin",
        "_TypeVarLikeMeta",
        "TypeVar",
        "_Immutable",
        "ParamSpecArgs",
        "ParamSpecKwargs",
        "ParamSpec",
        "ParamSpec",
        "_ConcatenateGenericAlias",
        "_ConcatenateForm",
        "_TypeGuardForm",
        "_SpecialForm",
        "_RequiredForm",
        "_ReadOnlyForm",
        "_UnpackSpecialForm",
        "_UnpackAlias",
        "_UnpackAlias",
        "_UnpackForm",
        "TypeVarTuple",
        "TypeVarTuple",
        "deprecated",
        "_NamedTupleMeta",
        "Buffer",
        "NewType",
        "Dummy",
        "TypeAliasType",
        "Doc"
    ]
}