{
    "identifiers": [
        "algorithms",
        "array",
        "java",
        "util",
        "nums",
        "k",
        "n",
        "nums",
        "length",
        "dp",
        "n",
        "queue",
        "dp",
        "n",
        "nums",
        "n",
        "queue",
        "offer",
        "n",
        "i",
        "n",
        "i",
        "i",
        "queue",
        "peek",
        "i",
        "k",
        "queue",
        "poll",
        "dp",
        "i",
        "nums",
        "i",
        "dp",
        "queue",
        "peek",
        "queue",
        "isEmpty",
        "dp",
        "queue",
        "getLast",
        "dp",
        "i",
        "queue",
        "pollLast",
        "queue",
        "offer",
        "i",
        "dp"
    ],
    "literals": [],
    "variables": [],
    "comments": [],
    "docstrings": [
        "*\n * You are given a 0-indexed integer array nums and an integer k.\n\n    You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array. That is, you can jump from index i to any index in the range [i + 1, min(n - 1, i + k)] inclusive.\n    \n    You want to reach the last index of the array (index n - 1). Your score is the sum of all nums[j] for each index j you visited in the array.\n    \n    Return the maximum score you can get.\n    \n     \n    \n    Example 1:\n    \n    Input: nums = [1,-1,-2,4,-7,3], k = 2\n    Output: 7\n    Explanation: You can choose your jumps forming the subsequence [1,-1,4,3] (underlined above). The sum is 7.\n    Example 2:\n    \n    Input: nums = [10,-5,-2,4,0,3], k = 3\n    Output: 17\n    Explanation: You can choose your jumps forming the subsequence [10,4,3] (underlined above). The sum is 17.\n    Example 3:\n    \n    Input: nums = [1,-5,-20,4,-1,3,-6,-3], k = 2\n    Output: 0\n     \n    \n    Constraints:\n    \n    1 <= nums.length, k <= 10^5\n    -10^4 <= nums[i] <= 10^4\n * @author michel\n *",
        "*\n     * Let dp[i] be \"the maximum score to reach the end starting at index i\". \n     * The answer for dp[i] is nums[i] + max{dp[i+j]} for 1 <= j <= k.\n     * Instead of checking every j for every i, keep track of the largest dp[i] values in a heap and calculate dp[i] from right to left. \n     * When the largest value in the heap is out of bounds of the current index, remove it and keep checking.\n     * @param nums\n     * @param k\n     * @return"
    ],
    "functions": [
        "maxResult"
    ],
    "classes": [
        "JumpGameVI"
    ]
}