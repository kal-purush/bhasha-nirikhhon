{
    "identifiers": [
        "SyntacticAnalyzer",
        "Exceptions",
        "LexicalException",
        "FileManager",
        "FileManager",
        "LexicalAnalyzer",
        "LexicalAnalyzer",
        "LexicalAnalyzer",
        "Token",
        "java",
        "io",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "hashMap",
        "startHashTable",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "hashMap",
        "put",
        "inputPath",
        "outputPath",
        "fileManager",
        "inputPath",
        "outputPath",
        "tokens",
        "file",
        "fileManager",
        "getInputFile",
        "lexicalAnalyzer",
        "file",
        "token",
        "lexicalAnalyzer",
        "getNextToken",
        "token",
        "getToken",
        "equals",
        "lexicalAnalyzer",
        "getEOF",
        "hashMap",
        "containsKey",
        "token",
        "getLexeme",
        "token",
        "setToken",
        "token",
        "getLexeme",
        "token",
        "getToken",
        "equals",
        "lexicalAnalyzer",
        "getBLANK_SPACE",
        "token",
        "getToken",
        "equals",
        "lexicalAnalyzer",
        "getTAB",
        "token",
        "getToken",
        "equals",
        "lexicalAnalyzer",
        "getCARRIAGE_RETURN",
        "token",
        "getToken",
        "equals",
        "lexicalAnalyzer",
        "getNEW_LINE",
        "token",
        "getToken",
        "equals",
        "lexicalAnalyzer",
        "getVERTICAL_TAB",
        "token",
        "getToken",
        "equals",
        "lexicalAnalyzer",
        "getSIMPLE_COMMENT",
        "tokens",
        "add",
        "token",
        "token",
        "lexicalAnalyzer",
        "getNextToken",
        "tokens",
        "add",
        "token",
        "outputPath",
        "printResults",
        "tokens",
        "fileManager",
        "saveResults",
        "validTokenFormat",
        "tokens",
        "exception",
        "printException",
        "exception",
        "tokenList",
        "validTokens",
        "validTokenFormat",
        "tokenList",
        "printByConsole",
        "validTokens",
        "tokenList",
        "validStrings",
        "validStrings",
        "add",
        "validStrings",
        "add",
        "token",
        "tokenList",
        "validStrings",
        "add",
        "token",
        "getToken",
        "token",
        "getLexeme",
        "token",
        "getRow",
        "token",
        "getColumn",
        "validStrings",
        "stringTokens",
        "tokenString",
        "stringTokens",
        "tokenString",
        "exception",
        "tokenException",
        "exception",
        "getToken",
        "tokenException",
        "getRow",
        "tokenException",
        "getColumn",
        "exception",
        "getExceptionType",
        "tokenException",
        "getLexeme"
    ],
    "literals": [
        "\"start\"",
        "\"start\"",
        "\"struct\"",
        "\"struct\"",
        "\"self\"",
        "\"self\"",
        "\"st\"",
        "\"st\"",
        "\"pri\"",
        "\"pri\"",
        "\"nil\"",
        "\"nil\"",
        "\"new\"",
        "\"new\"",
        "\"impl\"",
        "\"impl\"",
        "\"ret\"",
        "\"ret\"",
        "\"if\"",
        "\"if\"",
        "\"else\"",
        "\"else\"",
        "\"while\"",
        "\"while\"",
        "\"true\"",
        "\"true\"",
        "\"false\"",
        "\"false\"",
        "\"fn\"",
        "\"fn\"",
        "\"void\"",
        "\"void\"",
        "\"Array\"",
        "\"Array\"",
        "\"Str\"",
        "\"Str\"",
        "\"Bool\"",
        "\"Bool\"",
        "\"Int\"",
        "\"Int\"",
        "\"Char\"",
        "\"Char\"",
        "\"CORRECTO: ANALISIS LEXICO\"",
        "\"| TOKEN | LEXEMA | NUMERO DE LINEA (NUMERO DE COLUMNA) |\"",
        "\"| \"",
        "\" | \"",
        "\" | LINEA \"",
        "\" (COLUMNA \"",
        "\") |\"",
        "\"ERROR: LEXICO\"",
        "\"| NUMERO DE LINEA: | NUMERO DE COLUMNA: | DESCRIPCION: |\"",
        "\"| Linea \"",
        "\" | COLUMNA \"",
        "\" | \"",
        "\" \""
    ],
    "variables": [],
    "comments": [
        "Crea una lista de tokens utilizando el LexicalAnalyzer",
        "Verifico si el lexema esta en la tabla Hash",
        "Si esta, entonces es una palabra reservada y cambio su token",
        "Verificamos si no es algunos de los tokens skipeables, si no lo es entonces lo agregamos a la lista de tokens",
        "agrega token EOF a la lista de tokens",
        "Imprimo reusltados por consola",
        "Guardo resultados en archivo de salida",
        "Si no pasaron argumento de path de salida, etonces:",
        "Declaro lista de strings",
        "Agrego encabezado",
        "Imprimo reocrriendo la lista"
    ],
    "docstrings": [
        "* Clase que será la encargada de llamar al analizador lèxico\n * e imprimir los resultados por consola o llamar a la clase\n * FileManager en caso de que haya que escribir los resultados\n * en un archivo de salida\n * @throws LexicalException\n * @author Yeumen Silva",
        "* Constructor que inicia nuestra tablas hash de palabras reservadas\n     * @author Yeumen Silva",
        "* Método que inicia nuestra hashMap agregando todas las\n     * palabras reservadas de nuestro lenguaje\n     * @author Yeumen Silva",
        "* Método que dado un String de entrada crea una instancia de la clase\n     * FileMannager, recibe los tokens del analizador léxico y llama\n     * a función que guarda los resultados en un archivo de salida\n     * o los imprime por consola\n     * @param inputPath String con ruta del archivo de entrada\n     * @param outputPath String con ruta del archivo de salida",
        "Este bloque try/catch es el encargado de ejecutarse siempre\n       y cuando no encontremos un error lexico en la ejecución",
        "Si encuentra un error lexico, llama a metodo\n            que sera el encrgado de imprimir el error",
        "* Método que dado una lista de tokens finales, sera el encargado\n     * de escribirlos en consola o de escribirlos en un archivo en el caso\n     * de que este se haya dado como parametro de entrada\n     * @param tokenList lista con tokens de todo el archivo de entrada\n     * @throws IOException si no puedo escribir el archivo\n     * @author Yeumen Silva",
        "Llamo a función que convierte las instancias de clase token\n        a string con el formato pedido",
        "* Método que dado una lista de tokens finales, los convierte a string\n     * en el formato indicado por el documento de entrega\n     * @param tokenList lista con tokens de todo el archivo de entrada\n     * @return Lista con los tokens convertidos en string para imprimir\n     * @author Yeumen Silva\n     * @author Lucas Moyano",
        "Recorro lista de tokens y los guardo en una lista con el\n        formato pedido",
        "* Método que dado una lista de strings con formato solicitado,\n     * escribe por consola los resultados\n     * @param stringTokens lista con strings\n     *en formato pedido(token,lexeme,row,column)\n     * @author Yeumen Silva",
        "* Método que dado un error, lo imprime con el formato pedido\n     * @param exception error de tipo léxico\n     * @author Yeumen Silva"
    ],
    "functions": [
        "SyntacticExecutor",
        "startHashTable",
        "startExecution",
        "printResults",
        "validTokenFormat",
        "printByConsole",
        "printException"
    ],
    "classes": [
        "SyntacticExecutor"
    ]
}