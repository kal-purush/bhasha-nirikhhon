{
    "identifiers": [
        "Immutable",
        "fromJS",
        "json",
        "reviver",
        "k",
        "v",
        "first",
        "second",
        "isList",
        "maybeList",
        "of",
        "values",
        "iter",
        "iter",
        "iter",
        "array",
        "iterator",
        "iterable",
        "Collection",
        "index",
        "value",
        "index",
        "index",
        "index",
        "value",
        "values",
        "values",
        "updater",
        "value",
        "index",
        "updater",
        "value",
        "index",
        "notSetValue",
        "updater",
        "value",
        "iterables",
        "iterables",
        "merger",
        "previous",
        "next",
        "key",
        "iterables",
        "merger",
        "previous",
        "next",
        "key",
        "iterables",
        "iterables",
        "iterables",
        "merger",
        "previous",
        "next",
        "key",
        "iterables",
        "merger",
        "previous",
        "next",
        "key",
        "iterables",
        "size",
        "keyPath",
        "value",
        "keyPath",
        "value",
        "keyPath",
        "keyPath",
        "keyPath",
        "keyPath",
        "keyPath",
        "updater",
        "value",
        "keyPath",
        "notSetValue",
        "updater",
        "value",
        "keyPath",
        "updater",
        "value",
        "keyPath",
        "notSetValue",
        "updater",
        "value",
        "keyPath",
        "iterables",
        "keyPath",
        "iterables",
        "keyPath",
        "iterables",
        "keyPath",
        "iterables",
        "keyPath",
        "iterables",
        "keyPath",
        "iterables",
        "mutator",
        "mutable",
        "isMap",
        "maybeMap",
        "of",
        "keyValues",
        "iter",
        "iter",
        "array",
        "obj",
        "key",
        "iterator",
        "iterable",
        "Collection",
        "key",
        "value",
        "key",
        "key",
        "updater",
        "value",
        "key",
        "updater",
        "value",
        "key",
        "notSetValue",
        "updater",
        "value",
        "iterables",
        "iterables",
        "key",
        "merger",
        "previous",
        "next",
        "key",
        "iterables",
        "merger",
        "previous",
        "next",
        "key",
        "iterables",
        "key",
        "iterables",
        "iterables",
        "key",
        "merger",
        "previous",
        "next",
        "key",
        "iterables",
        "merger",
        "previous",
        "next",
        "key",
        "iterables",
        "key",
        "keyPath",
        "value",
        "KeyPath",
        "value",
        "keyPath",
        "keyPath",
        "keyPath",
        "keyPath",
        "keyPath",
        "updater",
        "value",
        "keyPath",
        "notSetValue",
        "updater",
        "value",
        "keyPath",
        "updater",
        "value",
        "keyPath",
        "notSetValue",
        "updater",
        "value",
        "keyPath",
        "iterables",
        "keyPath",
        "iterables",
        "keyPath",
        "iterables",
        "key",
        "keyPath",
        "iterables",
        "keyPath",
        "iterables",
        "keyPath",
        "iterables",
        "key",
        "mutator",
        "mutable",
        "OrderedMap",
        "isOrderedMap",
        "maybeOrderedMap",
        "OrderedMap",
        "OrderedMap",
        "iter",
        "OrderedMap",
        "iter",
        "OrderedMap",
        "array",
        "OrderedMap",
        "obj",
        "key",
        "OrderedMap",
        "iterator",
        "OrderedMap",
        "iterable",
        "isSet",
        "maybeSet",
        "of",
        "values",
        "fromKeys",
        "iter",
        "fromKeys",
        "obj",
        "key",
        "iter",
        "iter",
        "iter",
        "array",
        "iterator",
        "iterable",
        "Collection",
        "value",
        "value",
        "value",
        "iterables",
        "iterables",
        "iterables",
        "iterables",
        "iterables",
        "iterables",
        "iterables",
        "iterables",
        "mutator",
        "mutable",
        "OrderedSet",
        "isOrderedSet",
        "maybeOrderedSet",
        "of",
        "values",
        "fromKeys",
        "iter",
        "fromKeys",
        "obj",
        "key",
        "OrderedSet",
        "OrderedSet",
        "iter",
        "OrderedSet",
        "iter",
        "OrderedSet",
        "iter",
        "OrderedSet",
        "array",
        "OrderedSet",
        "iterator",
        "OrderedSet",
        "iterable",
        "isStack",
        "maybeStack",
        "of",
        "values",
        "iter",
        "iter",
        "iter",
        "array",
        "iterator",
        "iterable",
        "Collection",
        "values",
        "iter",
        "iter",
        "values",
        "iter",
        "iter",
        "mutator",
        "mutable",
        "Range",
        "start",
        "end",
        "step",
        "Seq",
        "Repeat",
        "value",
        "times",
        "Seq",
        "values",
        "key",
        "values",
        "values",
        "key",
        "values",
        "defaultValues",
        "key",
        "name",
        "Seq",
        "isSeq",
        "maybeSeq",
        "of",
        "values",
        "Seq",
        "Keyed",
        "Keyed",
        "Seq",
        "Keyed",
        "seq",
        "Seq",
        "Keyed",
        "seq",
        "Seq",
        "Keyed",
        "array",
        "Seq",
        "Keyed",
        "obj",
        "key",
        "Seq",
        "Keyed",
        "iterator",
        "Seq",
        "Keyed",
        "iterable",
        "Seq",
        "Seq",
        "Indexed",
        "of",
        "values",
        "Seq",
        "Indexed",
        "Seq",
        "Indexed",
        "seq",
        "Seq",
        "Indexed",
        "seq",
        "Seq",
        "Indexed",
        "seq",
        "Seq",
        "Indexed",
        "array",
        "Seq",
        "Indexed",
        "iterator",
        "Seq",
        "Indexed",
        "iterable",
        "Seq",
        "Seq",
        "of",
        "values",
        "Seq",
        "Seq",
        "seq",
        "Seq",
        "seq",
        "Seq",
        "seq",
        "Seq",
        "array",
        "Seq",
        "iterator",
        "Seq",
        "iterable",
        "Seq",
        "Seq",
        "Seq",
        "Seq",
        "seq",
        "Seq",
        "iterable",
        "Seq",
        "array",
        "Seq",
        "Seq",
        "obj",
        "key",
        "Seq",
        "Seq",
        "iterator",
        "Seq",
        "Seq",
        "iterable",
        "Seq",
        "isIterable",
        "maybeIterable",
        "isKeyed",
        "maybeKeyed",
        "isIndexed",
        "maybeIndexed",
        "isAssociative",
        "maybeAssociative",
        "isOrdered",
        "maybeOrdered",
        "Keyed",
        "Keyed",
        "iter",
        "Keyed",
        "iter",
        "Keyed",
        "array",
        "Keyed",
        "obj",
        "key",
        "Keyed",
        "iterator",
        "Keyed",
        "iterable",
        "Seq",
        "mapper",
        "key",
        "value",
        "iter",
        "context",
        "mapper",
        "entry",
        "index",
        "iter",
        "context",
        "searchValue",
        "searchValue",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "Indexed",
        "Indexed",
        "iter",
        "Indexed",
        "iter",
        "Indexed",
        "iter",
        "Indexed",
        "array",
        "Indexed",
        "iterator",
        "Indexed",
        "iterable",
        "index",
        "notSetValue",
        "Seq",
        "Seq",
        "separator",
        "iterables",
        "index",
        "removeNum",
        "values",
        "iterables",
        "zipper",
        "value",
        "otherValue",
        "otherIterable",
        "zipper",
        "value",
        "otherValue",
        "thirdValue",
        "otherIterable",
        "thirdIterable",
        "zipper",
        "iterables",
        "searchValue",
        "searchValue",
        "predicate",
        "value",
        "index",
        "iter",
        "context",
        "predicate",
        "value",
        "index",
        "iter",
        "context",
        "iter",
        "iter",
        "iter",
        "array",
        "iterator",
        "iterable",
        "Seq",
        "iterable",
        "array",
        "obj",
        "key",
        "iterator",
        "iterable",
        "value",
        "other",
        "key",
        "notSetValue",
        "key",
        "value",
        "value",
        "searchKeyPath",
        "notSetValue",
        "searchKeyPath",
        "notSetValue",
        "searchKeyPath",
        "searchKeyPath",
        "key",
        "Seq",
        "Seq",
        "Seq",
        "Seq",
        "Seq",
        "Seq",
        "mapper",
        "value",
        "key",
        "iter",
        "context",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "comparator",
        "valueA",
        "valueB",
        "comparatorValueMapper",
        "value",
        "key",
        "iter",
        "comparator",
        "valueA",
        "valueB",
        "grouper",
        "value",
        "key",
        "iter",
        "context",
        "Seq",
        "sideEffect",
        "value",
        "key",
        "iter",
        "context",
        "begin",
        "end",
        "amount",
        "amount",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "amount",
        "amount",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "valuesOrIterables",
        "depth",
        "shallow",
        "mapper",
        "value",
        "key",
        "iter",
        "context",
        "mapper",
        "value",
        "key",
        "iter",
        "context",
        "reducer",
        "reduction",
        "value",
        "key",
        "iter",
        "initialReduction",
        "context",
        "reducer",
        "reduction",
        "value",
        "key",
        "iter",
        "initialReduction",
        "context",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "separator",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "grouper",
        "value",
        "key",
        "iter",
        "context",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "notSetValue",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "notSetValue",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "notSetValue",
        "predicate",
        "value",
        "key",
        "iter",
        "context",
        "notSetValue",
        "comparator",
        "valueA",
        "valueB",
        "comparatorValueMapper",
        "value",
        "key",
        "iter",
        "comparator",
        "valueA",
        "valueB",
        "comparator",
        "valueA",
        "valueB",
        "comparatorValueMapper",
        "value",
        "key",
        "iter",
        "comparator",
        "valueA",
        "valueB",
        "iter",
        "iter",
        "iter",
        "iter",
        "Collection",
        "Keyed",
        "Seq",
        "Indexed",
        "Seq",
        "Seq",
        "Immutable"
    ],
    "literals": [
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "\"immutable\""
    ],
    "variables": [],
    "comments": [
        "[K,V]",
        "Iterable<T>",
        "Persistent changes",
        "Deep persistent changes",
        "Transient changes",
        "[K,V]",
        "[K,V]",
        "[K,V]",
        "Iterable<[K,V]>",
        "Persistent changes",
        "Deep persistent changes",
        "Transient changes",
        "[K,V]",
        "[K,V]",
        "[K,V]",
        "Iterable<[K,V]>",
        "[K,V]",
        "Iterable<T>",
        "Persistent changes",
        "Transient changes",
        "[K,V]",
        "Iterable<T>",
        "[K,V]",
        "Iterable<T>",
        "Reading values",
        "Persistent changes",
        "Transient changes",
        "deprecated",
        "deprecated",
        "[K,V]",
        "[K,V]",
        "[K,V]",
        "Iterable<[K,V]>",
        "this",
        "[K,V]",
        "Iterable<T>",
        "this",
        "[K,V]",
        "Iterable<T>",
        "this",
        "ES6Iterable<T>",
        "?",
        "Force evaluation",
        "this",
        "[K,V]",
        "[K,V]",
        "[K,V]",
        "Iterable<[K,V]>",
        "Sequence functions",
        "this",
        "this",
        "this",
        "(K, V)",
        "this",
        "[KM, VM]",
        "this",
        "Search for value",
        "this",
        "this",
        "[K,V]",
        "Iterable<T>",
        "Reading values",
        "Conversion to Seq",
        "Combination",
        "this",
        "this",
        "Array<Iterable.Indexed<T> | T>",
        "this",
        "this",
        "Search for value",
        "this",
        "this",
        "[K,V]",
        "Iterable<T>",
        "ES6Iterable<T>",
        "Value equality",
        "Reading values",
        "Reading deep values",
        "Conversion to JavaScript types",
        "Conversion to Collections",
        "Conversion to Seq",
        "Iterators",
        "[K, V]",
        "Iterables (Seq)",
        "(K, V)",
        "Sequence algorithms",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "Map",
        "this",
        "Side effects",
        "this",
        "Creating subsets",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "Combination",
        "Array<Iterable<K, V>|V",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "iterable-like",
        "this",
        "Reducing a value",
        "this",
        "this",
        "this",
        "this",
        "this",
        "this",
        "Search for value",
        "this",
        "this",
        "this",
        "[K, V]",
        "this",
        "[K, V]",
        "this",
        "this",
        "Comparison"
    ],
    "docstrings": [
        "*  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.",
        "* Immutable data encourages pure functions (data-in, data-out) and lends itself\n * to much simpler application development and enabling techniques from\n * functional programming such as lazy evaluation.\n *\n * While designed to bring these powerful functional concepts to JavaScript, it\n * presents an Object-Oriented API familiar to Javascript engineers and closely\n * mirroring that of Array, Map, and Set. It is easy and efficient to convert to\n * and from plain Javascript types.\n\n * Note: all examples are presented in [ES6][]. To run in all browsers, they\n * need to be translated to ES3. For example:\n *\n *     // ES6\n *     foo.map(x => x * x);\n *     // ES3\n *     foo.map(function (x) { return x * x; });\n *\n * [ES6]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla",
        "* Deeply converts plain JS objects and arrays to Immutable Maps and Lists.\n   *\n   * If a `reviver` is optionally provided, it will be called with every\n   * collection as a Seq (beginning with the most nested collections\n   * and proceeding to the top-level collection itself), along with the key\n   * refering to each collection and the parent JS object provided as `this`.\n   * For the top level, object, the key will be `\"\"`. This `reviver` is expected\n   * to return a new Immutable Iterable, allowing for custom conversions from\n   * deep JS objects.\n   *\n   * This example converts JSON to List and OrderedMap:\n   *\n   *     Immutable.fromJS({a: {b: [10, 20, 30]}, c: 40}, function (key, value) {\n   *       var isIndexed = Immutable.Iterable.isIndexed(value);\n   *       return isIndexed ? value.toList() : value.toOrderedMap();\n   *     });\n   *\n   *     // true, \"b\", {b: [10, 20, 30]}\n   *     // false, \"a\", {a: {b: [10, 20, 30]}, c: 40}\n   *     // false, \"\", {\"\": {a: {b: [10, 20, 30]}, c: 40}}\n   *\n   * If `reviver` is not provided, the default behavior will convert Arrays into\n   * Lists and Objects into Maps.\n   *\n   * `reviver` acts similarly to the [same parameter in `JSON.parse`][1].\n   *\n   * `Immutable.fromJS` is conservative in its conversion. It will only convert\n   * arrays which pass `Array.isArray` to Lists, and only raw objects (no custom\n   * prototype) to Map.\n   *\n   * Keep in mind, when using JS objects to construct Immutable Maps, that\n   * JavaScript Object properties are always strings, even if written in a\n   * quote-less shorthand, while Immutable Maps accept keys of any type.\n   *\n   * ```js\n   * var obj = { 1: \"one\" };\n   * Object.keys(obj); // [ \"1\" ]\n   * obj[\"1\"]; // \"one\"\n   * obj[1];   // \"one\"\n   *\n   * var map = Map(obj);\n   * map.get(\"1\"); // \"one\"\n   * map.get(1);   // undefined\n   * ```\n   *\n   * Property access for JavaScript Objects first converts the key to a string,\n   * but since Immutable Map keys can be of any type the argument to `get()` is\n   * not altered.\n   *\n   * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter\n   *      \"Using the reviver parameter\"",
        "* Value equality check with semantics similar to `Object.is`, but treats\n   * Immutable `Iterable`s as values, equal if the second `Iterable` includes\n   * equivalent values.\n   *\n   * It's used throughout Immutable when checking for equality, including `Map`\n   * key equality and `Set` membership.\n   *\n   *     var map1 = Immutable.Map({a:1, b:1, c:1});\n   *     var map2 = Immutable.Map({a:1, b:1, c:1});\n   *     assert(map1 !== map2);\n   *     assert(Object.is(map1, map2) === false);\n   *     assert(Immutable.is(map1, map2) === true);\n   *\n   * Note: Unlike `Object.is`, `Immutable.is` assumes `0` and `-0` are the same\n   * value, matching the behavior of ES6 Map key equality.",
        "* Lists are ordered indexed dense collections, much like a JavaScript\n   * Array.\n   *\n   * Lists are immutable and fully persistent with O(log32 N) gets and sets,\n   * and O(1) push and pop.\n   *\n   * Lists implement Deque, with efficient addition and removal from both the\n   * end (`push`, `pop`) and beginning (`unshift`, `shift`).\n   *\n   * Unlike a JavaScript Array, there is no distinction between an\n   * \"unset\" index and an index set to `undefined`. `List#forEach` visits all\n   * indices from 0 to size, regardless of if they were explicitly defined.",
        "* True if the provided value is a List",
        "* Creates a new List containing `values`.",
        "* Create a new immutable List containing the values of the provided\n   * iterable-like.",
        "* Returns a new List which includes `value` at `index`. If `index` already\n     * exists in this List, it will be replaced.\n     *\n     * `index` may be a negative number, which indexes back from the end of the\n     * List. `v.set(-1, \"value\")` sets the last item in the List.\n     *\n     * If `index` larger than `size`, the returned List's `size` will be large\n     * enough to include the `index`.",
        "* Returns a new List which excludes this `index` and with a size 1 less\n     * than this List. Values at indices above `index` are shifted down by 1 to\n     * fill the position.\n     *\n     * This is synonymous with `list.splice(index, 1)`.\n     *\n     * `index` may be a negative number, which indexes back from the end of the\n     * List. `v.delete(-1)` deletes the last item in the List.\n     *\n     * Note: `delete` cannot be safely used in IE8\n     * @alias remove",
        "* Returns a new List with `value` at `index` with a size 1 more than this\n     * List. Values at indices above `index` are shifted over by 1.\n     *\n     * This is synonymous with `list.splice(index, 0, value)",
        "* Returns a new List with 0 size and no values.",
        "* Returns a new List with the provided `values` appended, starting at this\n     * List's `size`.",
        "* Returns a new List with a size ones less than this List, excluding\n     * the last index in this List.\n     *\n     * Note: this differs from `Array#pop` because it returns a new\n     * List rather than the removed value. Use `last()` to get the last value\n     * in this List.",
        "* Returns a new List with the provided `values` prepended, shifting other\n     * values ahead to higher indices.",
        "* Returns a new List with a size ones less than this List, excluding\n     * the first index in this List, shifting all other values to a lower index.\n     *\n     * Note: this differs from `Array#shift` because it returns a new\n     * List rather than the removed value. Use `first()` to get the first\n     * value in this List.",
        "* Returns a new List with an updated value at `index` with the return\n     * value of calling `updater` with the existing value, or `notSetValue` if\n     * `index` was not set. If called with a single argument, `updater` is\n     * called with the List itself.\n     *\n     * `index` may be a negative number, which indexes back from the end of the\n     * List. `v.update(-1)` updates the last item in the List.\n     *\n     * @see `Map#update`",
        "* @see `Map#merge`",
        "* @see `Map#mergeWith`",
        "* @see `Map#mergeDeep`",
        "* @see `Map#mergeDeepWith`",
        "* Returns a new List with size `size`. If `size` is less than this\n     * List's size, the new List will exclude values at the higher indices.\n     * If `size` is greater than this List's size, the new List will have\n     * undefined values for the newly available indices.\n     *\n     * When building a new List and the final size is known up front, `setSize`\n     * used in conjunction with `withMutations` may result in the more\n     * performant construction.",
        "* Returns a new List having set `value` at this `keyPath`. If any keys in\n     * `keyPath` do not exist, a new immutable Map will be created at that key.\n     *\n     * Index numbers are used as keys to determine the path to follow in\n     * the List.",
        "* Returns a new List having removed the value at this `keyPath`. If any\n     * keys in `keyPath` do not exist, no change will occur.\n     *\n     * @alias removeIn",
        "* @see `Map#updateIn`",
        "* @see `Map#mergeIn`",
        "* @see `Map#mergeDeepIn`",
        "* Note: Not all methods can be used on a mutable collection or within\n     * `withMutations`! Only `set`, `push`, `pop`, `shift`, `unshift` and\n     * `merge` may be used mutatively.\n     *\n     * @see `Map#withMutations`",
        "* @see `Map#asMutable`",
        "* @see `Map#asImmutable`",
        "* Immutable Map is an unordered Iterable.Keyed of (key, value) pairs with\n   * `O(log32 N)` gets and `O(log32 N)` persistent sets.\n   *\n   * Iteration order of a Map is undefined, however is stable. Multiple\n   * iterations of the same Map will iterate in the same order.\n   *\n   * Map's keys can be of any type, and use `Immutable.is` to determine key\n   * equality. This allows the use of any value (including NaN) as a key.\n   *\n   * Because `Immutable.is` returns equality based on value semantics, and\n   * Immutable collections are treated as values, any Immutable collection may\n   * be used as a key.\n   *\n   *     Map().set(List.of(1), 'listofone').get(List.of(1));\n   *     // 'listofone'\n   *\n   * Any JavaScript object may be used as a key, however strict identity is used\n   * to evaluate key equality. Two similar looking objects will represent two\n   * different keys.\n   *\n   * Implemented by a hash-array mapped trie.",
        "* True if the provided value is a Map",
        "* Creates a new Map from alternating keys and values",
        "* Creates a new Immutable Map.\n   *\n   * Created with the same key value pairs as the provided Iterable.Keyed or\n   * JavaScript Object or expects an Iterable of [K, V] tuple entries.\n   *\n   *     var newMap = Map({key: \"value\"});\n   *     var newMap = Map([[\"key\", \"value\"]]);\n   *\n   * Keep in mind, when using JS objects to construct Immutable Maps, that\n   * JavaScript Object properties are always strings, even if written in a\n   * quote-less shorthand, while Immutable Maps accept keys of any type.\n   *\n   * ```js\n   * var obj = { 1: \"one\" };\n   * Object.keys(obj); // [ \"1\" ]\n   * obj[\"1\"]; // \"one\"\n   * obj[1];   // \"one\"\n   *\n   * var map = Map(obj);\n   * map.get(\"1\"); // \"one\"\n   * map.get(1);   // undefined\n   * ```\n   *\n   * Property access for JavaScript Objects first converts the key to a string,\n   * but since Immutable Map keys can be of any type the argument to `get()` is\n   * not altered.",
        "* Returns a new Map also containing the new key, value pair. If an equivalent\n     * key already exists in this Map, it will be replaced.",
        "* Returns a new Map which excludes this `key`.\n     *\n     * Note: `delete` cannot be safely used in IE8, but is provided to mirror\n     * the ES6 collection API.\n     * @alias remove",
        "* Returns a new Map containing no keys or values.",
        "* Returns a new Map having updated the value at this `key` with the return\n     * value of calling `updater` with the existing value, or `notSetValue` if\n     * the key was not set. If called with only a single argument, `updater` is\n     * called with the Map itself.\n     *\n     * Equivalent to: `map.set(key, updater(map.get(key, notSetValue)))`.",
        "* Returns a new Map resulting from merging the provided Iterables\n     * (or JS objects) into this Map. In other words, this takes each entry of\n     * each iterable and sets it on this Map.\n     *\n     * If any of the values provided to `merge` are not Iterable (would return\n     * false for `Immutable.Iterable.isIterable`) then they are deeply converted\n     * via `Immutable.fromJS` before being merged. However, if the value is an\n     * Iterable but includes non-iterable JS objects or arrays, those nested\n     * values will be preserved.\n     *\n     *     var x = Immutable.Map({a: 10, b: 20, c: 30});\n     *     var y = Immutable.Map({b: 40, a: 50, d: 60});\n     *     x.merge(y) // { a: 50, b: 40, c: 30, d: 60 }\n     *     y.merge(x) // { b: 20, a: 10, d: 60, c: 30 }\n     *",
        "* Like `merge()`, `mergeWith()` returns a new Map resulting from merging\n     * the provided Iterables (or JS objects) into this Map, but uses the\n     * `merger` function for dealing with conflicts.\n     *\n     *     var x = Immutable.Map({a: 10, b: 20, c: 30});\n     *     var y = Immutable.Map({b: 40, a: 50, d: 60});\n     *     x.mergeWith((prev, next) => prev / next, y) // { a: 0.2, b: 0.5, c: 30, d: 60 }\n     *     y.mergeWith((prev, next) => prev / next, x) // { b: 2, a: 5, d: 60, c: 30 }\n     *",
        "* Like `merge()`, but when two Iterables conflict, it merges them as well,\n     * recursing deeply through the nested data.\n     *\n     *     var x = Immutable.fromJS({a: { x: 10, y: 10 }, b: { x: 20, y: 50 } });\n     *     var y = Immutable.fromJS({a: { x: 2 }, b: { y: 5 }, c: { z: 3 } });\n     *     x.mergeDeep(y) // {a: { x: 2, y: 10 }, b: { x: 20, y: 5 }, c: { z: 3 } }\n     *",
        "* Like `mergeDeep()`, but when two non-Iterables conflict, it uses the\n     * `merger` function to determine the resulting value.\n     *\n     *     var x = Immutable.fromJS({a: { x: 10, y: 10 }, b: { x: 20, y: 50 } });\n     *     var y = Immutable.fromJS({a: { x: 2 }, b: { y: 5 }, c: { z: 3 } });\n     *     x.mergeDeepWith((prev, next) => prev / next, y)\n     *     // {a: { x: 5, y: 10 }, b: { x: 20, y: 10 }, c: { z: 3 } }\n     *",
        "* Returns a new Map having set `value` at this `keyPath`. If any keys in\n     * `keyPath` do not exist, a new immutable Map will be created at that key.",
        "* Returns a new Map having removed the value at this `keyPath`. If any keys\n     * in `keyPath` do not exist, no change will occur.\n     *\n     * @alias removeIn",
        "* Returns a new Map having applied the `updater` to the entry found at the\n     * keyPath.\n     *\n     * If any keys in `keyPath` do not exist, new Immutable `Map`s will\n     * be created at those keys. If the `keyPath` does not already contain a\n     * value, the `updater` function will be called with `notSetValue`, if\n     * provided, otherwise `undefined`.\n     *\n     *     var data = Immutable.fromJS({ a: { b: { c: 10 } } });\n     *     data = data.updateIn(['a', 'b', 'c'], val => val * 2);\n     *     // { a: { b: { c: 20 } } }\n     *\n     * If the `updater` function returns the same value it was called with, then\n     * no change will occur. This is still true if `notSetValue` is provided.\n     *\n     *     var data1 = Immutable.fromJS({ a: { b: { c: 10 } } });\n     *     data2 = data1.updateIn(['x', 'y', 'z'], 100, val => val);\n     *     assert(data2 === data1);\n     *",
        "* A combination of `updateIn` and `merge`, returning a new Map, but\n     * performing the merge at a point arrived at by following the keyPath.\n     * In other words, these two lines are equivalent:\n     *\n     *     x.updateIn(['a', 'b', 'c'], abc => abc.merge(y));\n     *     x.mergeIn(['a', 'b', 'c'], y);\n     *",
        "* A combination of `updateIn` and `mergeDeep`, returning a new Map, but\n     * performing the deep merge at a point arrived at by following the keyPath.\n     * In other words, these two lines are equivalent:\n     *\n     *     x.updateIn(['a', 'b', 'c'], abc => abc.mergeDeep(y));\n     *     x.mergeDeepIn(['a', 'b', 'c'], y);\n     *",
        "* Every time you call one of the above functions, a new immutable Map is\n     * created. If a pure function calls a number of these to produce a final\n     * return value, then a penalty on performance and memory has been paid by\n     * creating all of the intermediate immutable Maps.\n     *\n     * If you need to apply a series of mutations to produce a new immutable\n     * Map, `withMutations()` creates a temporary mutable copy of the Map which\n     * can apply mutations in a highly performant manner. In fact, this is\n     * exactly how complex mutations like `merge` are done.\n     *\n     * As an example, this results in the creation of 2, not 4, new Maps:\n     *\n     *     var map1 = Immutable.Map();\n     *     var map2 = map1.withMutations(map => {\n     *       map.set('a', 1).set('b', 2).set('c', 3);\n     *     });\n     *     assert(map1.size === 0);\n     *     assert(map2.size === 3);\n     *\n     * Note: Not all methods can be used on a mutable collection or within\n     * `withMutations`! Only `set` and `merge` may be used mutatively.\n     *",
        "* Another way to avoid creation of intermediate Immutable maps is to create\n     * a mutable copy of this collection. Mutable copies *always* return `this`,\n     * and thus shouldn't be used for equality. Your function should never return\n     * a mutable copy of a collection, only use it internally to create a new\n     * collection. If possible, use `withMutations` as it provides an easier to\n     * use API.\n     *\n     * Note: if the collection is already mutable, `asMutable` returns itself.\n     *\n     * Note: Not all methods can be used on a mutable collection or within\n     * `withMutations`! Only `set` and `merge` may be used mutatively.",
        "* The yin to `asMutable`'s yang. Because it applies to mutable collections,\n     * this operation is *mutable* and returns itself. Once performed, the mutable\n     * copy has become immutable and can be safely returned from a function.",
        "* A type of Map that has the additional guarantee that the iteration order of\n   * entries will be the order in which they were set().\n   *\n   * The iteration behavior of OrderedMap is the same as native ES6 Map and\n   * JavaScript Object.\n   *\n   * Note that `OrderedMap` are more expensive than non-ordered `Map` and may\n   * consume more memory. `OrderedMap#set` is amortized O(log32 N), but not\n   * stable.",
        "* True if the provided value is an OrderedMap.",
        "* Creates a new Immutable OrderedMap.\n   *\n   * Created with the same key value pairs as the provided Iterable.Keyed or\n   * JavaScript Object or expects an Iterable of [K, V] tuple entries.\n   *\n   * The iteration order of key-value pairs provided to this constructor will\n   * be preserved in the OrderedMap.\n   *\n   *     var newOrderedMap = OrderedMap({key: \"value\"});\n   *     var newOrderedMap = OrderedMap([[\"key\", \"value\"]]);\n   *",
        "* A Collection of unique values with `O(log32 N)` adds and has.\n   *\n   * When iterating a Set, the entries will be (value, value) pairs. Iteration\n   * order of a Set is undefined, however is stable. Multiple iterations of the\n   * same Set will iterate in the same order.\n   *\n   * Set values, like Map keys, may be of any type. Equality is determined using\n   * `Immutable.is`, enabling Sets to uniquely include other Immutable\n   * collections, custom value types, and NaN.",
        "* True if the provided value is a Set",
        "* Creates a new Set containing `values`.",
        "* `Set.fromKeys()` creates a new immutable Set containing the keys from\n     * this Iterable or JavaScript Object.",
        "* Create a new immutable Set containing the values of the provided\n   * iterable-like.",
        "* Returns a new Set which also includes this value.",
        "* Returns a new Set which excludes this value.\n     *\n     * Note: `delete` cannot be safely used in IE8\n     * @alias remove",
        "* Returns a new Set containing no values.",
        "* Returns a Set including any value from `iterables` that does not already\n     * exist in this Set.\n     * @alias merge",
        "* Returns a Set which has removed any values not also contained\n     * within `iterables`.",
        "* Returns a Set excluding any values contained within `iterables`.",
        "* Note: Not all methods can be used on a mutable collection or within\n     * `withMutations`! Only `add` may be used mutatively.\n     *\n     * @see `Map#withMutations`",
        "* @see `Map#asMutable`",
        "* @see `Map#asImmutable`",
        "* A type of Set that has the additional guarantee that the iteration order of\n   * values will be the order in which they were `add`ed.\n   *\n   * The iteration behavior of OrderedSet is the same as native ES6 Set.\n   *\n   * Note that `OrderedSet` are more expensive than non-ordered `Set` and may\n   * consume more memory. `OrderedSet#add` is amortized O(log32 N), but not\n   * stable.",
        "* True if the provided value is an OrderedSet.",
        "* Creates a new OrderedSet containing `values`.",
        "* `OrderedSet.fromKeys()` creates a new immutable OrderedSet containing\n     * the keys from this Iterable or JavaScript Object.",
        "* Create a new immutable OrderedSet containing the values of the provided\n   * iterable-like.",
        "* Stacks are indexed collections which support very efficient O(1) addition\n   * and removal from the front using `unshift(v)` and `shift()`.\n   *\n   * For familiarity, Stack also provides `push(v)`, `pop()`, and `peek()`, but\n   * be aware that they also operate on the front of the list, unlike List or\n   * a JavaScript Array.\n   *\n   * Note: `reverse()` or any inherent reverse traversal (`reduceRight`,\n   * `lastIndexOf`, etc.) is not efficient with a Stack.\n   *\n   * Stack is implemented with a Single-Linked List.",
        "* True if the provided value is a Stack",
        "* Creates a new Stack containing `values`.",
        "* Create a new immutable Stack containing the values of the provided\n   * iterable-like.\n   *\n   * The iteration order of the provided iterable is preserved in the\n   * resulting `Stack`.",
        "* Alias for `Stack.first()`.",
        "* Returns a new Stack with 0 size and no values.",
        "* Returns a new Stack with the provided `values` prepended, shifting other\n     * values ahead to higher indices.\n     *\n     * This is very efficient for Stack.",
        "* Like `Stack#unshift`, but accepts a iterable rather than varargs.",
        "* Returns a new Stack with a size ones less than this Stack, excluding\n     * the first item in this Stack, shifting all other values to a lower index.\n     *\n     * Note: this differs from `Array#shift` because it returns a new\n     * Stack rather than the removed value. Use `first()` or `peek()` to get the\n     * first value in this Stack.",
        "* Alias for `Stack#unshift` and is not equivalent to `List#push`.",
        "* Alias for `Stack#unshiftAll`.",
        "* Alias for `Stack#shift` and is not equivalent to `List#pop`.",
        "* Note: Not all methods can be used on a mutable collection or within\n     * `withMutations`! Only `set`, `push`, and `pop` may be used mutatively.\n     *\n     * @see `Map#withMutations`",
        "* @see `Map#asMutable`",
        "* @see `Map#asImmutable`",
        "* Returns a Seq.Indexed of numbers from `start` (inclusive) to `end`\n   * (exclusive), by `step`, where `start` defaults to 0, `step` to 1, and `end` to\n   * infinity. When `start` is equal to `end`, returns empty range.\n   *\n   *     Range() // [0,1,2,3,...]\n   *     Range(10) // [10,11,12,13,...]\n   *     Range(10,15) // [10,11,12,13,14]\n   *     Range(10,30,5) // [10,15,20,25]\n   *     Range(30,10,5) // [30,25,20,15]\n   *     Range(30,30,5) // []\n   *",
        "* Returns a Seq.Indexed of `value` repeated `times` times. When `times` is\n   * not defined, returns an infinite `Seq` of `value`.\n   *\n   *     Repeat('foo') // ['foo','foo','foo',...]\n   *     Repeat('bar',4) // ['bar','bar','bar','bar']\n   *",
        "* Creates a new Class which produces Record instances. A record is similar to\n   * a JS object, but enforce a specific set of allowed string keys, and have\n   * default values.\n   *\n   *     var ABRecord = Record({a:1, b:2})\n   *     var myRecord = new ABRecord({b:3})\n   *\n   * Records always have a value for the keys they define. `remove`ing a key\n   * from a record simply resets it to the default value for that key.\n   *\n   *     myRecord.size // 2\n   *     myRecord.get('a') // 1\n   *     myRecord.get('b') // 3\n   *     myRecordWithoutB = myRecord.remove('b')\n   *     myRecordWithoutB.get('b') // 2\n   *     myRecordWithoutB.size // 2\n   *\n   * Values provided to the constructor not found in the Record type will\n   * be ignored. For example, in this case, ABRecord is provided a key \"x\" even\n   * though only \"a\" and \"b\" have been defined. The value for \"x\" will be\n   * ignored for this record.\n   *\n   *     var myRecord = new ABRecord({b:3, x:10})\n   *     myRecord.get('x') // undefined\n   *\n   * Because Records have a known set of string keys, property get access works\n   * as expected, however property sets will throw an Error.\n   *\n   * Note: IE8 does not support property access. Only use `get()` when\n   * supporting IE8.\n   *\n   *     myRecord.b // 3\n   *     myRecord.b = 5 // throws Error\n   *\n   * Record Classes can be extended as well, allowing for custom methods on your\n   * Record. This is not a common pattern in functional environments, but is in\n   * many JS programs.\n   *\n   * Note: TypeScript does not support this type of subclassing.\n   *\n   *     class ABRecord extends Record({a:1,b:2}) {\n   *       getAB() {\n   *         return this.a + this.b;\n   *       }\n   *     }\n   *\n   *     var myRecord = new ABRecord({b: 3})\n   *     myRecord.getAB() // 4\n   *",
        "* Represents a sequence of values, but may not be backed by a concrete data\n   * structure.\n   *\n   * **Seq is immutable** — Once a Seq is created, it cannot be\n   * changed, appended to, rearranged or otherwise modified. Instead, any\n   * mutative method called on a `Seq` will return a new `Seq`.\n   *\n   * **Seq is lazy** — Seq does as little work as necessary to respond to any\n   * method call. Values are often created during iteration, including implicit\n   * iteration when reducing or converting to a concrete data structure such as\n   * a `List` or JavaScript `Array`.\n   *\n   * For example, the following performs no work, because the resulting\n   * Seq's values are never iterated:\n   *\n   *     var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8)\n   *       .filter(x => x % 2).map(x => x * x);\n   *\n   * Once the Seq is used, it performs only the work necessary. In this\n   * example, no intermediate data structures are ever created, filter is only\n   * called three times, and map is only called once:\n   *\n   *     console.log(evenSquares.get(1)); // 9\n   *\n   * Seq allows for the efficient chaining of operations,\n   * allowing for the expression of logic that can otherwise be very tedious:\n   *\n   *     Immutable.Seq({a:1, b:1, c:1})\n   *       .flip().map(key => key.toUpperCase()).flip().toObject();\n   *     // Map { A: 1, B: 1, C: 1 }\n   *\n   * As well as expressing logic that would otherwise be memory or time limited:\n   *\n   *     Immutable.Range(1, Infinity)\n   *       .skip(1000)\n   *       .map(n => -n)\n   *       .filter(n => n % 2 === 0)\n   *       .take(2)\n   *       .reduce((r, n) => r * n, 1);\n   *     // 1006008\n   *\n   * Seq is often used to provide a rich collection API to JavaScript Object.\n   *\n   *     Immutable.Seq({ x: 0, y: 1, z: 2 }).map(v => v * 2).toObject();\n   *     // { x: 0, y: 2, z: 4 }",
        "* True if `maybeSeq` is a Seq, it is not backed by a concrete\n     * structure such as Map, List, or Set.",
        "* Returns a Seq of the values provided. Alias for `Seq.Indexed.of()`.",
        "* `Seq` which represents key-value pairs.",
        "* Always returns a Seq.Keyed, if input is not keyed, expects an\n     * iterable of [K, V] tuples.",
        "* Returns itself",
        "* `Seq` which represents an ordered indexed list of values.",
        "* Provides an Seq.Indexed of the values provided.",
        "* Always returns Seq.Indexed, discarding associated keys and\n     * supplying incrementing indices.",
        "* Returns itself",
        "* `Seq` which represents a set of values.\n     *\n     * Because `Seq` are often lazy, `Seq.Set` does not provide the same guarantee\n     * of value uniqueness as the concrete `Set`.",
        "* Returns a Seq.Set of the provided values",
        "* Always returns a Seq.Set, discarding associated indices or keys.",
        "* Returns itself",
        "* Creates a Seq.\n   *\n   * Returns a particular kind of `Seq` based on the input.\n   *\n   *   * If a `Seq`, that same `Seq`.\n   *   * If an `Iterable`, a `Seq` of the same kind (Keyed, Indexed, or Set).\n   *   * If an Array-like, an `Seq.Indexed`.\n   *   * If an Object with an Iterator, an `Seq.Indexed`.\n   *   * If an Iterator, an `Seq.Indexed`.\n   *   * If an Object, a `Seq.Keyed`.\n   *",
        "* Some Seqs can describe their size lazily. When this is the case,\n     * size will be an integer. Otherwise it will be undefined.\n     *\n     * For example, Seqs returned from `map()` or `reverse()`\n     * preserve the size of the original `Seq` while `filter()` does not.\n     *\n     * Note: `Range`, `Repeat` and `Seq`s made from `Array`s and `Object`s will\n     * always have a size.",
        "* Because Sequences are lazy and designed to be chained together, they do\n     * not cache their results. For example, this map function is called a total\n     * of 6 times, as each `join` iterates the Seq of three values.\n     *\n     *     var squares = Seq.of(1,2,3).map(x => x * x);\n     *     squares.join() + squares.join();\n     *\n     * If you know a `Seq` will be used multiple times, it may be more\n     * efficient to first cache it in memory. Here, the map function is called\n     * only 3 times.\n     *\n     *     var squares = Seq.of(1,2,3).map(x => x * x).cacheResult();\n     *     squares.join() + squares.join();\n     *\n     * Use this method judiciously, as it must fully evaluate a Seq which can be\n     * a burden on memory and possibly performance.\n     *\n     * Note: after calling `cacheResult`, a Seq will always have a `size`.",
        "* The `Iterable` is a set of (key, value) entries which can be iterated, and\n   * is the base class for all collections in `immutable`, allowing them to\n   * make use of all the Iterable methods (such as `map` and `filter`).\n   *\n   * Note: An iterable is always iterated in the same order, however that order\n   * may not always be well defined, as is the case for the `Map` and `Set`.",
        "* True if `maybeIterable` is an Iterable, or any of its subclasses.",
        "* True if `maybeKeyed` is an Iterable.Keyed, or any of its subclasses.",
        "* True if `maybeIndexed` is a Iterable.Indexed, or any of its subclasses.",
        "* True if `maybeAssociative` is either a keyed or indexed Iterable.",
        "* True if `maybeOrdered` is an Iterable where iteration order is well\n     * defined. True for Iterable.Indexed as well as OrderedMap and OrderedSet.",
        "* Keyed Iterables have discrete keys tied to each value.\n     *\n     * When iterating `Iterable.Keyed`, each iteration will yield a `[K, V]`\n     * tuple, in other words, `Iterable#entries` is the default iterator for\n     * Keyed Iterables.",
        "* Creates an Iterable.Keyed\n     *\n     * Similar to `Iterable()`, however it expects iterable-likes of [K, V]\n     * tuples if not constructed from a Iterable.Keyed or JS Object.",
        "* Returns Seq.Keyed.\n       * @override",
        "* Returns a new Iterable.Keyed of the same type where the keys and values\n       * have been flipped.\n       *\n       *     Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }\n       *",
        "* Returns a new Iterable.Keyed of the same type with keys passed through\n       * a `mapper` function.\n       *\n       *     Seq({ a: 1, b: 2 })\n       *       .mapKeys(x => x.toUpperCase())\n       *     // Seq { A: 1, B: 2 }\n       *",
        "* Returns a new Iterable.Keyed of the same type with entries\n       * ([key, value] tuples) passed through a `mapper` function.\n       *\n       *     Seq({ a: 1, b: 2 })\n       *       .mapEntries(([k, v]) => [k.toUpperCase(), v * 2])\n       *     // Seq { A: 2, B: 4 }\n       *",
        "* Returns the key associated with the search value, or undefined.",
        "* Returns the last key associated with the search value, or undefined.",
        "* Returns the key for which the `predicate` returns true.",
        "* Returns the last key for which the `predicate` returns true.\n       *\n       * Note: `predicate` will be called for each entry in reverse.",
        "* Indexed Iterables have incrementing numeric keys. They exhibit\n     * slightly different behavior than `Iterable.Keyed` for some methods in order\n     * to better mirror the behavior of JavaScript's `Array`, and add methods\n     * which do not make sense on non-indexed Iterables such as `indexOf`.\n     *\n     * Unlike JavaScript arrays, `Iterable.Indexed`s are always dense. \"Unset\"\n     * indices and `undefined` indices are indistinguishable, and all indices from\n     * 0 to `size` are visited when iterated.\n     *\n     * All Iterable.Indexed methods return re-indexed Iterables. In other words,\n     * indices always start at 0 and increment until size. If you wish to\n     * preserve indices, using them as keys, convert to a Iterable.Keyed by\n     * calling `toKeyedSeq`.",
        "* Creates a new Iterable.Indexed.",
        "* Returns the value associated with the provided index, or notSetValue if\n       * the index is beyond the bounds of the Iterable.\n       *\n       * `index` may be a negative number, which indexes back from the end of the\n       * Iterable. `s.get(-1)` gets the last item in the Iterable.",
        "* Returns Seq.Indexed.\n       * @override",
        "* If this is an iterable of [key, value] entry tuples, it will return a\n       * Seq.Keyed of those entries.",
        "* Returns an Iterable of the same type with `separator` between each item\n       * in this Iterable.",
        "* Returns an Iterable of the same type with the provided `iterables`\n       * interleaved into this iterable.\n       *\n       * The resulting Iterable includes the first item from each, then the\n       * second from each, etc.\n       *\n       *     I.Seq.of(1,2,3).interleave(I.Seq.of('A','B','C'))\n       *     // Seq [ 1, 'A', 2, 'B', 3, 'C' ]\n       *\n       * The shortest Iterable stops interleave.\n       *\n       *     I.Seq.of(1,2,3).interleave(\n       *       I.Seq.of('A','B'),\n       *       I.Seq.of('X','Y','Z')\n       *     )\n       *     // Seq [ 1, 'A', 'X', 2, 'B', 'Y' ]",
        "* Splice returns a new indexed Iterable by replacing a region of this\n       * Iterable with new values. If values are not provided, it only skips the\n       * region to be removed.\n       *\n       * `index` may be a negative number, which indexes back from the end of the\n       * Iterable. `s.splice(-2)` splices after the second to last item.\n       *\n       *     Seq(['a','b','c','d']).splice(1, 2, 'q', 'r', 's')\n       *     // Seq ['a', 'q', 'r', 's', 'd']\n       *",
        "* Returns an Iterable of the same type \"zipped\" with the provided\n       * iterables.\n       *\n       * Like `zipWith`, but using the default `zipper`: creating an `Array`.\n       *\n       *     var a = Seq.of(1, 2, 3);\n       *     var b = Seq.of(4, 5, 6);\n       *     var c = a.zip(b); // Seq [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\n       *",
        "* Returns an Iterable of the same type \"zipped\" with the provided\n       * iterables by using a custom `zipper` function.\n       *\n       *     var a = Seq.of(1, 2, 3);\n       *     var b = Seq.of(4, 5, 6);\n       *     var c = a.zipWith((a, b) => a + b, b); // Seq [ 5, 7, 9 ]\n       *",
        "* Returns the first index at which a given value can be found in the\n       * Iterable, or -1 if it is not present.",
        "* Returns the last index at which a given value can be found in the\n       * Iterable, or -1 if it is not present.",
        "* Returns the first index in the Iterable where a value satisfies the\n       * provided predicate function. Otherwise -1 is returned.",
        "* Returns the last index in the Iterable where a value satisfies the\n       * provided predicate function. Otherwise -1 is returned.",
        "* Set Iterables only represent values. They have no associated keys or\n     * indices. Duplicate values are possible in Seq.Sets, however the\n     * concrete `Set` does not allow duplicate values.\n     *\n     * Iterable methods on Iterable.Set such as `map` and `forEach` will provide\n     * the value as both the first and second arguments to the provided function.\n     *\n     *     var seq = Seq.Set.of('A', 'B', 'C');\n     *     assert.equal(seq.every((v, k) => v === k), true);\n     *",
        "* Similar to `Iterable()`, but always returns a Iterable.Set.",
        "* Returns Seq.Set.\n       * @override",
        "* Creates an Iterable.\n   *\n   * The type of Iterable created is based on the input.\n   *\n   *   * If an `Iterable`, that same `Iterable`.\n   *   * If an Array-like, an `Iterable.Indexed`.\n   *   * If an Object with an Iterator, an `Iterable.Indexed`.\n   *   * If an Iterator, an `Iterable.Indexed`.\n   *   * If an Object, an `Iterable.Keyed`.\n   *\n   * This methods forces the conversion of Objects and Strings to Iterables.\n   * If you want to ensure that a Iterable of one item is returned, use\n   * `Seq.of`.",
        "* True if this and the other Iterable have value equality, as defined\n     * by `Immutable.is()`.\n     *\n     * Note: This is equivalent to `Immutable.is(this, other)`, but provided to\n     * allow for chained expressions.",
        "* Computes and returns the hashed identity for this Iterable.\n     *\n     * The `hashCode` of an Iterable is used to determine potential equality,\n     * and is used when adding this to a `Set` or as a key in a `Map`, enabling\n     * lookup via a different instance.\n     *\n     *     var a = List.of(1, 2, 3);\n     *     var b = List.of(1, 2, 3);\n     *     assert(a !== b); // different instances\n     *     var set = Set.of(a);\n     *     assert(set.has(b) === true);\n     *\n     * If two values have the same `hashCode`, they are [not guaranteed\n     * to be equal][Hash Collision]. If two values have different `hashCode`s,\n     * they must not be equal.\n     *\n     * [Hash Collision]: http://en.wikipedia.org/wiki/Collision_(computer_science)",
        "* Returns the value associated with the provided key, or notSetValue if\n     * the Iterable does not contain this key.\n     *\n     * Note: it is possible a key may be associated with an `undefined` value,\n     * so if `notSetValue` is not provided and this method returns `undefined`,\n     * that does not guarantee the key was not found.",
        "* True if a key exists within this `Iterable`.",
        "* True if a value exists within this `Iterable`.\n     * @alias contains",
        "* The first value in the Iterable.",
        "* The last value in the Iterable.",
        "* Returns the value found by following a path of keys or indices through\n     * nested Iterables.",
        "* True if the result of following a path of keys or indices through nested\n     * Iterables results in a set value.",
        "* Deeply converts this Iterable to equivalent JS.\n     *\n     * `Iterable.Indexeds`, and `Iterable.Sets` become Arrays, while\n     * `Iterable.Keyeds` become Objects.\n     *\n     * @alias toJSON",
        "* Shallowly converts this iterable to an Array, discarding keys.",
        "* Shallowly converts this Iterable to an Object.\n     *\n     * Throws if keys are not strings.",
        "* Converts this Iterable to a Map, Throws if keys are not hashable.\n     *\n     * Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided\n     * for convenience and to allow for chained expressions.",
        "* Converts this Iterable to a Map, maintaining the order of iteration.\n     *\n     * Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but\n     * provided for convenience and to allow for chained expressions.",
        "* Converts this Iterable to a Set, discarding keys. Throws if values\n     * are not hashable.\n     *\n     * Note: This is equivalent to `Set(this)`, but provided to allow for\n     * chained expressions.",
        "* Converts this Iterable to a Set, maintaining the order of iteration and\n     * discarding keys.\n     *\n     * Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided\n     * for convenience and to allow for chained expressions.",
        "* Converts this Iterable to a List, discarding keys.\n     *\n     * Note: This is equivalent to `List(this)`, but provided to allow\n     * for chained expressions.",
        "* Converts this Iterable to a Stack, discarding keys. Throws if values\n     * are not hashable.\n     *\n     * Note: This is equivalent to `Stack(this)`, but provided to allow for\n     * chained expressions.",
        "* Converts this Iterable to a Seq of the same kind (indexed,\n     * keyed, or set).",
        "* Returns a Seq.Keyed from this Iterable where indices are treated as keys.\n     *\n     * This is useful if you want to operate on an\n     * Iterable.Indexed and preserve the [index, value] pairs.\n     *\n     * The returned Seq will have identical iteration order as\n     * this Iterable.\n     *\n     * Example:\n     *\n     *     var indexedSeq = Immutable.Seq.of('A', 'B', 'C');\n     *     indexedSeq.filter(v => v === 'B').toString() // Seq [ 'B' ]\n     *     var keyedSeq = indexedSeq.toKeyedSeq();\n     *     keyedSeq.filter(v => v === 'B').toString() // Seq { 1: 'B' }\n     *",
        "* Returns an Seq.Indexed of the values of this Iterable, discarding keys.",
        "* Returns a Seq.Set of the values of this Iterable, discarding keys.",
        "* An iterator of this `Iterable`'s keys.",
        "* An iterator of this `Iterable`'s values.",
        "* An iterator of this `Iterable`'s entries as `[key, value]` tuples.",
        "* Returns a new Seq.Indexed of the keys of this Iterable,\n     * discarding values.",
        "* Returns an Seq.Indexed of the values of this Iterable, discarding keys.",
        "* Returns a new Seq.Indexed of [key, value] tuples.",
        "* Returns a new Iterable of the same type with values passed through a\n     * `mapper` function.\n     *\n     *     Seq({ a: 1, b: 2 }).map(x => 10 * x)\n     *     // Seq { a: 10, b: 20 }\n     *",
        "* Returns a new Iterable of the same type with only the entries for which\n     * the `predicate` function returns true.\n     *\n     *     Seq({a:1,b:2,c:3,d:4}).filter(x => x % 2 === 0)\n     *     // Seq { b: 2, d: 4 }\n     *",
        "* Returns a new Iterable of the same type with only the entries for which\n     * the `predicate` function returns false.\n     *\n     *     Seq({a:1,b:2,c:3,d:4}).filterNot(x => x % 2 === 0)\n     *     // Seq { a: 1, c: 3 }\n     *",
        "* Returns a new Iterable of the same type in reverse order.",
        "* Returns a new Iterable of the same type which includes the same entries,\n     * stably sorted by using a `comparator`.\n     *\n     * If a `comparator` is not provided, a default comparator uses `<` and `>`.\n     *\n     * `comparator(valueA, valueB)`:\n     *\n     *   * Returns `0` if the elements should not be swapped.\n     *   * Returns `-1` (or any negative number) if `valueA` comes before `valueB`\n     *   * Returns `1` (or any positive number) if `valueA` comes after `valueB`\n     *   * Is pure, i.e. it must always return the same value for the same pair\n     *     of values.\n     *\n     * When sorting collections which have no defined order, their ordered\n     * equivalents will be returned. e.g. `map.sort()` returns OrderedMap.",
        "* Like `sort`, but also accepts a `comparatorValueMapper` which allows for\n     * sorting by more sophisticated means:\n     *\n     *     hitters.sortBy(hitter => hitter.avgHits);\n     *",
        "* Returns a `Iterable.Keyed` of `Iterable.Keyeds`, grouped by the return\n     * value of the `grouper` function.\n     *\n     * Note: This is always an eager operation.",
        "* The `sideEffect` is executed for every entry in the Iterable.\n     *\n     * Unlike `Array#forEach`, if any call of `sideEffect` returns\n     * `false`, the iteration will stop. Returns the number of entries iterated\n     * (including the last iteration which returned false).",
        "* Returns a new Iterable of the same type representing a portion of this\n     * Iterable from start up to but not including end.\n     *\n     * If begin is negative, it is offset from the end of the Iterable. e.g.\n     * `slice(-2)` returns a Iterable of the last two entries. If it is not\n     * provided the new Iterable will begin at the beginning of this Iterable.\n     *\n     * If end is negative, it is offset from the end of the Iterable. e.g.\n     * `slice(0, -1)` returns an Iterable of everything but the last entry. If\n     * it is not provided, the new Iterable will continue through the end of\n     * this Iterable.\n     *\n     * If the requested slice is equivalent to the current Iterable, then it\n     * will return itself.",
        "* Returns a new Iterable of the same type containing all entries except\n     * the first.",
        "* Returns a new Iterable of the same type containing all entries except\n     * the last.",
        "* Returns a new Iterable of the same type which excludes the first `amount`\n     * entries from this Iterable.",
        "* Returns a new Iterable of the same type which excludes the last `amount`\n     * entries from this Iterable.",
        "* Returns a new Iterable of the same type which includes entries starting\n     * from when `predicate` first returns false.\n     *\n     *     Seq.of('dog','frog','cat','hat','god')\n     *       .skipWhile(x => x.match(/g/))\n     *     // Seq [ 'cat', 'hat', 'god' ]\n     *",
        "* Returns a new Iterable of the same type which includes entries starting\n     * from when `predicate` first returns true.\n     *\n     *     Seq.of('dog','frog','cat','hat','god')\n     *       .skipUntil(x => x.match(/hat/))\n     *     // Seq [ 'hat', 'god' ]\n     *",
        "* Returns a new Iterable of the same type which includes the first `amount`\n     * entries from this Iterable.",
        "* Returns a new Iterable of the same type which includes the last `amount`\n     * entries from this Iterable.",
        "* Returns a new Iterable of the same type which includes entries from this\n     * Iterable as long as the `predicate` returns true.\n     *\n     *     Seq.of('dog','frog','cat','hat','god')\n     *       .takeWhile(x => x.match(/o/))\n     *     // Seq [ 'dog', 'frog' ]\n     *",
        "* Returns a new Iterable of the same type which includes entries from this\n     * Iterable as long as the `predicate` returns false.\n     *\n     *     Seq.of('dog','frog','cat','hat','god').takeUntil(x => x.match(/at/))\n     *     // ['dog', 'frog']\n     *",
        "* Returns a new Iterable of the same type with other values and\n     * iterable-like concatenated to this one.\n     *\n     * For Seqs, all entries will be present in\n     * the resulting iterable, even if they have the same key.",
        "* Flattens nested Iterables.\n     *\n     * Will deeply flatten the Iterable by default, returning an Iterable of the\n     * same type, but a `depth` can be provided in the form of a number or\n     * boolean (where true means to shallowly flatten one level). A depth of 0\n     * (or shallow: false) will deeply flatten.\n     *\n     * Flattens only others Iterable, not Arrays or Objects.\n     *\n     * Note: `flatten(true)` operates on Iterable<any, Iterable<K, V>> and\n     * returns Iterable<K, V>",
        "* Flat-maps the Iterable, returning an Iterable of the same type.\n     *\n     * Similar to `iter.map(...).flatten(true)`.",
        "* Reduces the Iterable to a value by calling the `reducer` for every entry\n     * in the Iterable and passing along the reduced value.\n     *\n     * If `initialReduction` is not provided, or is null, the first item in the\n     * Iterable will be used.\n     *\n     * @see `Array#reduce`.",
        "* Reduces the Iterable in reverse (from the right side).\n     *\n     * Note: Similar to this.reverse().reduce(), and provided for parity\n     * with `Array#reduceRight`.",
        "* True if `predicate` returns true for all entries in the Iterable.",
        "* True if `predicate` returns true for any entry in the Iterable.",
        "* Joins values together as a string, inserting a separator between each.\n     * The default separator is `\",\"`.",
        "* Returns true if this Iterable includes no values.\n     *\n     * For some lazy `Seq`, `isEmpty` might need to iterate to determine\n     * emptiness. At most one iteration will occur.",
        "* Returns the size of this Iterable.\n     *\n     * Regardless of if this Iterable can describe its size lazily (some Seqs\n     * cannot), this method will always return the correct size. E.g. it\n     * evaluates a lazy `Seq` if necessary.\n     *\n     * If `predicate` is provided, then this returns the count of entries in the\n     * Iterable for which the `predicate` returns true.",
        "* Returns a `Seq.Keyed` of counts, grouped by the return value of\n     * the `grouper` function.\n     *\n     * Note: This is not a lazy operation.",
        "* Returns the value for which the `predicate` returns true.",
        "* Returns the last value for which the `predicate` returns true.\n     *\n     * Note: `predicate` will be called for each entry in reverse.",
        "* Returns the [key, value] entry for which the `predicate` returns true.",
        "* Returns the last [key, value] entry for which the `predicate`\n     * returns true.\n     *\n     * Note: `predicate` will be called for each entry in reverse.",
        "* Returns the maximum value in this collection. If any values are\n     * comparatively equivalent, the first one found will be returned.\n     *\n     * The `comparator` is used in the same way as `Iterable#sort`. If it is not\n     * provided, the default comparator is `>`.\n     *\n     * When two values are considered equivalent, the first encountered will be\n     * returned. Otherwise, `max` will operate independent of the order of input\n     * as long as the comparator is commutative. The default comparator `>` is\n     * commutative *only* when types do not differ.\n     *\n     * If `comparator` returns 0 and either value is NaN, undefined, or null,\n     * that value will be returned.",
        "* Like `max`, but also accepts a `comparatorValueMapper` which allows for\n     * comparing by more sophisticated means:\n     *\n     *     hitters.maxBy(hitter => hitter.avgHits);\n     *",
        "* Returns the minimum value in this collection. If any values are\n     * comparatively equivalent, the first one found will be returned.\n     *\n     * The `comparator` is used in the same way as `Iterable#sort`. If it is not\n     * provided, the default comparator is `<`.\n     *\n     * When two values are considered equivalent, the first encountered will be\n     * returned. Otherwise, `min` will operate independent of the order of input\n     * as long as the comparator is commutative. The default comparator `<` is\n     * commutative *only* when types do not differ.\n     *\n     * If `comparator` returns 0 and either value is NaN, undefined, or null,\n     * that value will be returned.",
        "* Like `min`, but also accepts a `comparatorValueMapper` which allows for\n     * comparing by more sophisticated means:\n     *\n     *     hitters.minBy(hitter => hitter.avgHits);\n     *",
        "* True if `iter` includes every value in this Iterable.",
        "* True if this Iterable includes every value in `iter`.",
        "* Note: this is here as a convenience to work around an issue with\n     * TypeScript https://github.com/Microsoft/TypeScript/issues/285, but\n     * Iterable does not define `size`, instead `Seq` defines `size` as\n     * nullable number, and `Collection` defines `size` as always a number.\n     *\n     * @ignore",
        "* Collection is the abstract base class for concrete data structures. It\n   * cannot be constructed directly.\n   *\n   * Implementations should extend one of the subclasses, `Collection.Keyed`,\n   * `Collection.Indexed`, or `Collection.Set`.",
        "* `Collection` which represents key-value pairs.",
        "* Returns Seq.Keyed.\n       * @override",
        "* `Collection` which represents ordered indexed values.",
        "* Returns Seq.Indexed.\n       * @override",
        "* `Collection` which represents values, unassociated with keys or indices.\n     *\n     * `Collection.Set` implementations should guarantee value uniqueness.",
        "* Returns Seq.Set.\n       * @override",
        "* All collections maintain their current `size` as an integer.",
        "* ES6 Iterator.\n   *\n   * This is not part of the Immutable library, but a common interface used by\n   * many types in ES6 JavaScript.\n   *\n   * @ignore"
    ],
    "functions": [],
    "classes": []
}