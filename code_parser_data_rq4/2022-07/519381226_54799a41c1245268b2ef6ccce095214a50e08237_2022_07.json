{
    "identifiers": [
        "root",
        "factory",
        "define",
        "define",
        "define",
        "p5",
        "factory",
        "p5",
        "exports",
        "factory",
        "require",
        "factory",
        "root",
        "p5",
        "p5",
        "p5PlayInit",
        "Camera",
        "DEFAULT_FRAME_RATE",
        "startDate",
        "name",
        "getter",
        "p5",
        "name",
        "p5",
        "context",
        "context",
        "name",
        "context",
        "context",
        "name",
        "getter",
        "context",
        "context",
        "name",
        "createBoundConstructor",
        "arguments",
        "pInst",
        "args",
        "F",
        "F",
        "pInst",
        "pInstBind",
        "methodName",
        "pInst",
        "methodName",
        "method",
        "methodName",
        "method",
        "pInst",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "arguments",
        "result",
        "p5",
        "p5",
        "p5",
        "p5",
        "x",
        "y",
        "w",
        "h",
        "w",
        "w",
        "w",
        "h",
        "w",
        "h",
        "w",
        "h",
        "x",
        "y",
        "w",
        "h",
        "p5",
        "p5",
        "p5",
        "p5",
        "x",
        "y",
        "w",
        "h",
        "w",
        "w",
        "w",
        "h",
        "w",
        "h",
        "w",
        "h",
        "x",
        "y",
        "w",
        "h",
        "p5",
        "e",
        "i",
        "e",
        "i",
        "validTouch",
        "getTouchInfo",
        "e",
        "i",
        "validTouch",
        "validTouch",
        "e",
        "e",
        "context",
        "executeDefault",
        "context",
        "e",
        "executeDefault",
        "e",
        "context",
        "executeDefault",
        "context",
        "e",
        "executeDefault",
        "e",
        "p5",
        "e",
        "e",
        "e",
        "e",
        "e",
        "x",
        "y",
        "getTouchInfo",
        "e",
        "touchInfo",
        "x",
        "touchInfo",
        "y",
        "touchInfo",
        "i",
        "e",
        "i",
        "touchInfo",
        "getTouchInfo",
        "e",
        "i",
        "touchInfo",
        "touches",
        "touchIndex",
        "touchInfo",
        "touchIndex",
        "touches",
        "x",
        "y",
        "canvas",
        "e",
        "i",
        "i",
        "i",
        "canvas",
        "e",
        "i",
        "e",
        "i",
        "touch",
        "rect",
        "touch",
        "rect",
        "xPos",
        "xPos",
        "rect",
        "yPos",
        "yPos",
        "rect",
        "xPos",
        "canvas",
        "rect",
        "yPos",
        "canvas",
        "rect",
        "touch",
        "p5",
        "e",
        "getMousePos",
        "e",
        "e",
        "e",
        "e",
        "context",
        "executeDefault",
        "context",
        "e",
        "executeDefault",
        "e",
        "context",
        "executeDefault",
        "context",
        "e",
        "executeDefault",
        "e",
        "p5",
        "e",
        "e",
        "e",
        "e",
        "e",
        "x",
        "y",
        "getMousePos",
        "e",
        "mousePos",
        "x",
        "mousePos",
        "y",
        "mousePos",
        "x",
        "y",
        "e",
        "e",
        "canvas",
        "evt",
        "canvas",
        "evt",
        "rect",
        "evt",
        "rect",
        "xPos",
        "xPos",
        "rect",
        "yPos",
        "yPos",
        "rect",
        "xPos",
        "canvas",
        "rect",
        "yPos",
        "canvas",
        "rect",
        "p5",
        "a",
        "b",
        "p5",
        "b",
        "p5",
        "a",
        "b",
        "p5",
        "b",
        "b",
        "p5",
        "v2",
        "tolerance",
        "tolerance",
        "tolerance",
        "tolerance",
        "tolerance",
        "v2",
        "tolerance",
        "tolerance",
        "v2",
        "tolerance",
        "v2",
        "v2",
        "tolerance",
        "p5",
        "path",
        "successCallback",
        "failureCallback",
        "Image",
        "p5",
        "arguments",
        "img",
        "successCallback",
        "successCallback",
        "img",
        "decrementPreload",
        "successCallback",
        "decrementPreload",
        "decrementPreload",
        "img",
        "e",
        "p5",
        "img",
        "failureCallback",
        "failureCallback",
        "decrementPreload",
        "failureCallback",
        "e",
        "path",
        "img",
        "img",
        "path",
        "img",
        "p5",
        "imgEl",
        "sx",
        "sy",
        "sWidth",
        "sHeight",
        "dx",
        "dy",
        "dWidth",
        "dHeight",
        "sVal",
        "iVal",
        "sVal",
        "sVal",
        "iVal",
        "sVal",
        "iVal",
        "a",
        "b",
        "c",
        "d",
        "mode",
        "mode",
        "p5",
        "a",
        "b",
        "c",
        "d",
        "mode",
        "p5",
        "a",
        "b",
        "c",
        "a",
        "d",
        "b",
        "mode",
        "p5",
        "a",
        "c",
        "b",
        "d",
        "c",
        "d",
        "mode",
        "p5",
        "a",
        "c",
        "b",
        "d",
        "c",
        "d",
        "arguments",
        "dx",
        "sx",
        "dy",
        "sy",
        "sx",
        "sy",
        "dWidth",
        "sWidth",
        "imgEl",
        "dHeight",
        "sHeight",
        "imgEl",
        "sWidth",
        "imgEl",
        "sHeight",
        "imgEl",
        "arguments",
        "sx",
        "sx",
        "sy",
        "sy",
        "sWidth",
        "_sAssign",
        "sWidth",
        "imgEl",
        "sHeight",
        "_sAssign",
        "sHeight",
        "imgEl",
        "dx",
        "dx",
        "dy",
        "dy",
        "dWidth",
        "dWidth",
        "imgEl",
        "dHeight",
        "dHeight",
        "imgEl",
        "modeAdjust",
        "dx",
        "dy",
        "dWidth",
        "dHeight",
        "vals",
        "vals",
        "vals",
        "vals",
        "context",
        "vals",
        "vals",
        "context",
        "imgEl",
        "sx",
        "sy",
        "sWidth",
        "sHeight",
        "vals",
        "vals",
        "vals",
        "vals",
        "vals",
        "vals",
        "vals",
        "vals",
        "imgEl",
        "sx",
        "sy",
        "sWidth",
        "sHeight",
        "vals",
        "vals",
        "vals",
        "vals",
        "defineLazyP5Property",
        "p5",
        "p5",
        "buttonCode",
        "buttonCode",
        "buttonCode",
        "p5",
        "p5",
        "sprite",
        "sprite",
        "sprite",
        "sprite",
        "mousePosition",
        "mousePosition",
        "sprite",
        "mousePosition",
        "p5",
        "sprite",
        "sprite",
        "p5",
        "x",
        "y",
        "sides",
        "size",
        "rotation",
        "doFill",
        "doStroke",
        "ctx",
        "styleEmpty",
        "doFill",
        "doStroke",
        "ctx",
        "styleEmpty",
        "sides",
        "ctx",
        "ctx",
        "x",
        "size",
        "rotation",
        "y",
        "size",
        "rotation",
        "i",
        "sides",
        "i",
        "rotation",
        "i",
        "sides",
        "ctx",
        "x",
        "size",
        "angle",
        "y",
        "size",
        "angle",
        "ctx",
        "doFill",
        "ctx",
        "doStroke",
        "ctx",
        "p5",
        "x",
        "y",
        "sides",
        "size",
        "rotation",
        "arguments",
        "i",
        "args",
        "i",
        "args",
        "i",
        "arguments",
        "i",
        "rotation",
        "rotation",
        "sides",
        "rotation",
        "sides",
        "rotation",
        "rotation",
        "args",
        "args",
        "args",
        "args",
        "args",
        "rotation",
        "p5",
        "doFill",
        "doStroke",
        "ctx",
        "styleEmpty",
        "doFill",
        "doStroke",
        "ctx",
        "styleEmpty",
        "arguments",
        "numCoords",
        "ctx",
        "ctx",
        "arguments",
        "arguments",
        "i",
        "numCoords",
        "i",
        "ctx",
        "arguments",
        "i",
        "arguments",
        "i",
        "ctx",
        "doFill",
        "ctx",
        "doStroke",
        "ctx",
        "p5",
        "arguments",
        "p5",
        "r",
        "g",
        "b",
        "a",
        "a",
        "a",
        "a",
        "a",
        "r",
        "g",
        "b",
        "a",
        "p5",
        "defineLazyP5Property",
        "name",
        "World",
        "name",
        "name",
        "createReadOnlyP5PropertyAlias",
        "createReadOnlyP5PropertyAlias",
        "createReadOnlyP5PropertyAlias",
        "createReadOnlyP5PropertyAlias",
        "createReadOnlyP5PropertyAlias",
        "createReadOnlyP5PropertyAlias",
        "World",
        "value",
        "value",
        "World",
        "currentDate",
        "currentTime",
        "World",
        "p5",
        "p5",
        "x",
        "y",
        "width",
        "height",
        "Sprite",
        "x",
        "y",
        "width",
        "height",
        "s",
        "s",
        "s",
        "p5",
        "sprite",
        "sprite",
        "p5",
        "upd",
        "upd",
        "upd",
        "i",
        "i",
        "i",
        "p5",
        "arguments",
        "j",
        "arguments",
        "j",
        "i",
        "i",
        "i",
        "arguments",
        "j",
        "arr",
        "i",
        "arr",
        "p5",
        "group",
        "group",
        "group",
        "group",
        "group",
        "p5",
        "sprite",
        "sprite",
        "sprite",
        "p5",
        "construct",
        "arguments",
        "p5",
        "construct",
        "arguments",
        "p5",
        "anim",
        "x",
        "y",
        "anim",
        "x",
        "y",
        "defineLazyP5Property",
        "p5",
        "key",
        "key",
        "KEY_WENT_DOWN",
        "p5",
        "key",
        "key",
        "KEY_WENT_UP",
        "p5",
        "key",
        "key",
        "KEY_IS_DOWN",
        "p5",
        "key",
        "state",
        "key",
        "keyCode",
        "key",
        "keyCode",
        "key",
        "keyStates",
        "keyCode",
        "keyCode",
        "keyStates",
        "keyCode",
        "KEY_IS_DOWN",
        "keyStates",
        "keyCode",
        "KEY_IS_UP",
        "keyStates",
        "keyCode",
        "state",
        "p5",
        "buttonCode",
        "buttonCode",
        "KEY_IS_DOWN",
        "p5",
        "buttonCode",
        "buttonCode",
        "KEY_IS_UP",
        "p5",
        "buttonCode",
        "buttonCode",
        "KEY_WENT_UP",
        "p5",
        "buttonCode",
        "buttonCode",
        "KEY_WENT_DOWN",
        "p5",
        "buttonCode",
        "buttonCode",
        "buttonCode",
        "buttonCode",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "buttonCode",
        "state",
        "buttonCode",
        "buttonCode",
        "buttonCode",
        "buttonCode",
        "mouseStates",
        "buttonCode",
        "buttonCode",
        "mouseStates",
        "buttonCode",
        "KEY_IS_DOWN",
        "mouseStates",
        "buttonCode",
        "KEY_IS_UP",
        "mouseStates",
        "buttonCode",
        "state",
        "p5",
        "p5",
        "p5",
        "alias",
        "alias",
        "alias",
        "alias",
        "alias",
        "alias",
        "alias",
        "alias",
        "alias",
        "p5",
        "key",
        "keyStates",
        "key",
        "keyStates",
        "key",
        "KEY_IS_UP",
        "keyStates",
        "key",
        "KEY_WENT_DOWN",
        "keyStates",
        "key",
        "KEY_IS_DOWN",
        "keyStates",
        "key",
        "KEY_IS_DOWN",
        "keyStates",
        "key",
        "KEY_WENT_UP",
        "keyStates",
        "key",
        "KEY_IS_UP",
        "btn",
        "mouseStates",
        "btn",
        "mouseStates",
        "btn",
        "KEY_IS_UP",
        "mouseStates",
        "btn",
        "KEY_WENT_DOWN",
        "mouseStates",
        "btn",
        "KEY_IS_DOWN",
        "mouseStates",
        "btn",
        "KEY_IS_DOWN",
        "mouseStates",
        "btn",
        "KEY_WENT_UP",
        "mouseStates",
        "btn",
        "KEY_IS_UP",
        "p5",
        "use",
        "use",
        "use",
        "defineLazyP5Property",
        "Quadtree",
        "quadTree",
        "quadTree",
        "pInst",
        "_x",
        "_y",
        "_w",
        "_h",
        "createPInstBinder",
        "pInst",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInstBind",
        "pInst",
        "pInst",
        "p5",
        "p5",
        "p5",
        "p5",
        "createVector",
        "_x",
        "_y",
        "createVector",
        "_x",
        "_y",
        "createVector",
        "_x",
        "_y",
        "createVector",
        "value",
        "value",
        "value",
        "_w",
        "_h",
        "pInst",
        "value",
        "pInst",
        "value",
        "value",
        "_w",
        "_w",
        "pInst",
        "value",
        "pInst",
        "value",
        "value",
        "_h",
        "_h",
        "color",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "target",
        "target",
        "displacement",
        "displacement",
        "animations",
        "currentAnimation",
        "pInst",
        "animations",
        "currentAnimation",
        "animations",
        "currentAnimation",
        "abs",
        "animations",
        "currentAnimation",
        "abs",
        "createVector",
        "createVector",
        "createVector",
        "animations",
        "currentAnimation",
        "animations",
        "currentAnimation",
        "animations",
        "currentAnimation",
        "animations",
        "currentAnimation",
        "animations",
        "currentAnimation",
        "animations",
        "currentAnimation",
        "camera",
        "mousePosition",
        "createVector",
        "camera",
        "camera",
        "mousePosition",
        "createVector",
        "pInst",
        "pInst",
        "p5",
        "mousePosition",
        "pInst",
        "pInst",
        "mouseWasOver",
        "mouseWasOver",
        "mouseWasPressed",
        "mouseWasPressed",
        "pInst",
        "offsetX",
        "offsetY",
        "width",
        "height",
        "rotation",
        "_type",
        "_type",
        "_type",
        "_type",
        "_type",
        "_type",
        "_type",
        "arguments",
        "arguments",
        "_type",
        "arguments",
        "arguments",
        "arguments",
        "_type",
        "arguments",
        "arguments",
        "arguments",
        "_type",
        "arguments",
        "arguments",
        "arguments",
        "arguments",
        "createVector",
        "offsetX",
        "offsetY",
        "_type",
        "p5",
        "offset",
        "_type",
        "p5",
        "offset",
        "width",
        "_type",
        "p5",
        "offset",
        "width",
        "height",
        "_type",
        "p5",
        "offset",
        "width",
        "height",
        "radians",
        "rotation",
        "p5",
        "dir",
        "dir",
        "dir",
        "dirX",
        "dir",
        "dirX",
        "dir",
        "dir",
        "dir",
        "dirY",
        "dir",
        "dirY",
        "pInst",
        "pInst",
        "push",
        "colorMode",
        "RGB",
        "noStroke",
        "rectMode",
        "CENTER",
        "ellipseMode",
        "CENTER",
        "imageMode",
        "CENTER",
        "translate",
        "pInst",
        "pInst",
        "rotate",
        "radians",
        "rotate",
        "scale",
        "dirX",
        "dirY",
        "pop",
        "push",
        "stroke",
        "strokeWeight",
        "line",
        "line",
        "noFill",
        "noStroke",
        "fill",
        "textAlign",
        "LEFT",
        "BOTTOM",
        "textSize",
        "text",
        "noFill",
        "stroke",
        "pInst",
        "pop",
        "currentAnimation",
        "animations",
        "animations",
        "currentAnimation",
        "push",
        "tint",
        "animations",
        "currentAnimation",
        "pop",
        "fillColor",
        "lerpColor",
        "color",
        "fillColor",
        "color",
        "noStroke",
        "fill",
        "fillColor",
        "rect",
        "quadTree",
        "x",
        "y",
        "x",
        "y",
        "atan2",
        "isNaN",
        "direction",
        "direction",
        "pInst",
        "pInst",
        "direction",
        "degrees",
        "direction",
        "direction",
        "group",
        "group",
        "group",
        "group",
        "max",
        "abs",
        "speed",
        "max",
        "max",
        "abs",
        "speed",
        "k",
        "k",
        "speed",
        "angle",
        "angle",
        "a",
        "pInst",
        "pInst",
        "pInst",
        "a",
        "radians",
        "a",
        "pInst",
        "pInst",
        "a",
        "radians",
        "angle",
        "a",
        "angle",
        "cos",
        "a",
        "speed",
        "sin",
        "a",
        "speed",
        "f",
        "f",
        "x",
        "y",
        "y",
        "x",
        "isNaN",
        "xDelta",
        "isNaN",
        "yDelta",
        "xDelta",
        "yDelta",
        "yDelta",
        "xDelta",
        "radiansAngle",
        "speed",
        "angle",
        "pInst",
        "pInst",
        "a",
        "radians",
        "angle",
        "a",
        "angle",
        "cos",
        "a",
        "speed",
        "sin",
        "a",
        "speed",
        "magnitude",
        "pointX",
        "pointY",
        "atan2",
        "pointY",
        "pointX",
        "cos",
        "angle",
        "magnitude",
        "sin",
        "angle",
        "magnitude",
        "arguments",
        "arguments",
        "p5",
        "arguments",
        "arguments",
        "arguments",
        "p5",
        "arguments",
        "label",
        "label",
        "arguments",
        "arguments",
        "Animation",
        "arguments",
        "sourceAnimation",
        "animations",
        "label",
        "newAnimation",
        "currentAnimation",
        "currentAnimation",
        "label",
        "newAnimation",
        "newAnimation",
        "newAnimation",
        "abs",
        "newAnimation",
        "abs",
        "newAnimation",
        "i",
        "arguments",
        "i",
        "animFrames",
        "arguments",
        "i",
        "anim",
        "construct",
        "pInst",
        "animFrames",
        "animations",
        "label",
        "anim",
        "currentAnimation",
        "currentAnimation",
        "label",
        "anim",
        "anim",
        "anim",
        "abs",
        "anim",
        "abs",
        "anim",
        "label",
        "label",
        "currentAnimation",
        "label",
        "animations",
        "label",
        "label",
        "currentAnimation",
        "label",
        "animations",
        "label",
        "animationName",
        "animationName",
        "pInst",
        "pInst",
        "animationName",
        "animation",
        "animationName",
        "animationName",
        "animation",
        "animationName",
        "pInst",
        "pointX",
        "pointY",
        "createVector",
        "pointX",
        "pointY",
        "point",
        "img",
        "point",
        "img",
        "point",
        "point",
        "img",
        "point",
        "point",
        "img",
        "img",
        "point",
        "point",
        "values",
        "pointX",
        "pointY",
        "p5",
        "p5",
        "pointX",
        "pointY",
        "point",
        "target",
        "callback",
        "target",
        "callback",
        "target",
        "callback",
        "target",
        "callback",
        "target",
        "callback",
        "target",
        "callback",
        "target",
        "callback",
        "target",
        "callback",
        "target",
        "callback",
        "target",
        "callback",
        "target",
        "callback",
        "target",
        "Sprite",
        "others",
        "target",
        "target",
        "pInst",
        "pInst",
        "others",
        "pInst",
        "target",
        "others",
        "others",
        "target",
        "i",
        "others",
        "i",
        "result",
        "others",
        "i",
        "callback",
        "result",
        "result",
        "other",
        "callback",
        "other",
        "other",
        "other",
        "other",
        "other",
        "other",
        "displacement",
        "displacement",
        "displacement",
        "displacement",
        "displacement",
        "displacement",
        "other",
        "other",
        "displacement",
        "displacement",
        "createVector",
        "createVector",
        "other",
        "other",
        "originalType",
        "other",
        "other",
        "originalType",
        "other",
        "p5",
        "displacement",
        "p5",
        "other",
        "displacement",
        "other",
        "thisMass",
        "otherMass",
        "other",
        "thisMass",
        "otherMass",
        "thisMass",
        "otherMass",
        "other",
        "p5",
        "p5",
        "thisInitialVelocity",
        "thisMass",
        "p5",
        "otherInitialVelocity",
        "otherMass",
        "p5",
        "otherInitialVelocity",
        "thisInitialVelocity",
        "otherMass",
        "coefficientOfRestitution",
        "initialMomentum",
        "combinedMass",
        "p5",
        "thisInitialVelocity",
        "otherInitialVelocity",
        "thisMass",
        "coefficientOfRestitution",
        "initialMomentum",
        "combinedMass",
        "thisInitialVelocity",
        "thisFinalVelocity",
        "other",
        "otherInitialVelocity",
        "otherFinalVelocity",
        "originalType",
        "originalThisImmovable",
        "other",
        "originalOtherImmovable",
        "other",
        "originalOtherRestitution",
        "callback",
        "callback",
        "other",
        "target",
        "target",
        "target",
        "p5",
        "target",
        "radiusOnVelocityAxis",
        "relativeVelocity",
        "timestep",
        "target",
        "target",
        "target",
        "p5",
        "thisOriginalPosition",
        "timestep",
        "p5",
        "targetOriginalPosition",
        "target",
        "timestep",
        "i",
        "i",
        "timestep",
        "thisDelta",
        "target",
        "targetDelta",
        "target",
        "target",
        "target",
        "displacement",
        "displacement",
        "thisOriginalPosition",
        "target",
        "target",
        "targetOriginalPosition",
        "displacement",
        "thisOriginalPosition",
        "target",
        "targetOriginalPosition",
        "target",
        "target",
        "target",
        "defineLazyP5Property",
        "boundConstructorFactory",
        "Sprite",
        "pInst",
        "x",
        "y",
        "zoom",
        "pInst",
        "x",
        "y",
        "value",
        "value",
        "value",
        "value",
        "zoom",
        "pInst",
        "pInst",
        "cameraPush",
        "pInst",
        "cameraPop",
        "pInst",
        "defineLazyP5Property",
        "boundConstructorFactory",
        "Camera",
        "pInst",
        "camera",
        "camera",
        "camera",
        "camera",
        "pInst",
        "camera",
        "pInst",
        "camera",
        "camera",
        "pInst",
        "camera",
        "pInst",
        "camera",
        "pInst",
        "camera",
        "pInst",
        "camera",
        "camera",
        "pInst",
        "pInst",
        "camera",
        "pInst",
        "camera",
        "pInst",
        "camera",
        "camera",
        "pInst",
        "camera",
        "pInst",
        "pInst",
        "pInst",
        "array",
        "i",
        "array",
        "i",
        "array",
        "sprite",
        "sprite",
        "array",
        "item",
        "array",
        "i",
        "len",
        "i",
        "virtEquals",
        "item",
        "array",
        "i",
        "i",
        "array",
        "s",
        "s",
        "Sprite",
        "s",
        "array",
        "s",
        "s",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "item",
        "item",
        "Sprite",
        "i",
        "array",
        "i",
        "i",
        "array",
        "i",
        "item",
        "array",
        "i",
        "removed",
        "removed",
        "i",
        "item",
        "i",
        "i",
        "item",
        "i",
        "item",
        "i",
        "removed",
        "array",
        "array",
        "array",
        "array",
        "array",
        "maxDepth",
        "sprite",
        "maxDepth",
        "sprite",
        "Infinity",
        "array",
        "array",
        "array",
        "minDepth",
        "sprite",
        "minDepth",
        "sprite",
        "Infinity",
        "array",
        "a",
        "b",
        "a",
        "b",
        "i",
        "i",
        "i",
        "obj",
        "other",
        "obj",
        "other",
        "obj",
        "other",
        "obj",
        "obj",
        "other",
        "obj",
        "obj",
        "other",
        "obj",
        "obj",
        "other",
        "obj",
        "other",
        "target",
        "callback",
        "i",
        "i",
        "didCollide",
        "i",
        "target",
        "callback",
        "didCollide",
        "didCollide",
        "array",
        "_groupCollide",
        "array",
        "array",
        "array",
        "array",
        "_groupCollide",
        "array",
        "array",
        "_groupCollide",
        "array",
        "array",
        "_groupCollide",
        "array",
        "array",
        "_groupCollide",
        "array",
        "array",
        "propName",
        "value",
        "i",
        "i",
        "i",
        "propName",
        "value",
        "array",
        "methodName",
        "arguments",
        "i",
        "elements",
        "i",
        "elements",
        "i",
        "methodName",
        "elements",
        "i",
        "methodArgs",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "array",
        "p5",
        "Group",
        "p5",
        "edgeThickness",
        "height",
        "edgeThickness",
        "height",
        "width",
        "edgeThickness",
        "height",
        "edgeThickness",
        "height",
        "width",
        "edgeThickness",
        "width",
        "edgeThickness",
        "width",
        "height",
        "edgeThickness",
        "width",
        "edgeThickness",
        "pInst",
        "arguments",
        "p5",
        "frameArguments",
        "frameArguments",
        "frameArguments",
        "frameArguments",
        "frameArguments",
        "ext1",
        "pInst",
        "to",
        "to",
        "to",
        "ext2",
        "pInst",
        "to",
        "to",
        "to",
        "i",
        "i",
        "i",
        "i",
        "i",
        "digits1",
        "i",
        "to",
        "i",
        "i",
        "to",
        "i",
        "to",
        "i",
        "digits2",
        "digits1",
        "to",
        "to",
        "digits2",
        "parseInt",
        "digits1",
        "parseInt",
        "to",
        "to",
        "digits2",
        "to",
        "number2",
        "number1",
        "number2",
        "number1",
        "number1",
        "t",
        "prefix1",
        "prefix2",
        "pInst",
        "pInst",
        "to",
        "digits1",
        "digits2",
        "i",
        "number1",
        "i",
        "number2",
        "i",
        "fileName",
        "prefix1",
        "pInst",
        "i",
        "digits1",
        "pInst",
        "fileName",
        "i",
        "number1",
        "i",
        "number2",
        "i",
        "fileName",
        "prefix1",
        "i",
        "pInst",
        "fileName",
        "frameArguments",
        "frameArguments",
        "SpriteSheet",
        "frameArguments",
        "f",
        "f",
        "f",
        "f",
        "f",
        "f",
        "f",
        "f",
        "f",
        "f",
        "f",
        "frameArguments",
        "i",
        "i",
        "frameArguments",
        "i",
        "frameArguments",
        "i",
        "p5",
        "frameArguments",
        "i",
        "pInst",
        "frameArguments",
        "i",
        "Animation",
        "pInst",
        "myClone",
        "myClone",
        "myClone",
        "myClone",
        "myClone",
        "myClone",
        "myClone",
        "myClone",
        "myClone",
        "x",
        "y",
        "r",
        "x",
        "y",
        "r",
        "pInst",
        "pInst",
        "CENTER",
        "frame",
        "image",
        "frame_info",
        "frame_info",
        "frame_info",
        "frame_info",
        "frame_info",
        "frame_info",
        "frame_info",
        "xTranslate",
        "frame_info",
        "missingX",
        "yTranslate",
        "frame_info",
        "missingY",
        "pInst",
        "xTranslate",
        "yTranslate",
        "pInst",
        "pInst",
        "pInst",
        "radians",
        "pInst",
        "frame_info",
        "Image",
        "pInst",
        "frame_info",
        "frame_info",
        "frame_info",
        "frame_info",
        "frame_info",
        "frame_info",
        "pInst",
        "frame_info",
        "frame_info",
        "frame_info",
        "frame_info",
        "frame_info",
        "frame_info",
        "image",
        "image",
        "Image",
        "pInst",
        "image",
        "pInst",
        "image",
        "pInst",
        "frame",
        "pInst",
        "cycles",
        "frame",
        "cycles",
        "targetFrame",
        "frame",
        "targetFrame",
        "frame",
        "targetFrame",
        "frame",
        "targetFrame",
        "frame",
        "targetFrame",
        "frame",
        "targetFrame",
        "frame",
        "frame",
        "frame",
        "frame",
        "frame",
        "previousFrame",
        "frame",
        "targetFrame",
        "frame",
        "f",
        "f",
        "frame",
        "f",
        "frame",
        "targetFrame",
        "frame",
        "frame",
        "frame",
        "frame",
        "targetFrame",
        "frame",
        "frame",
        "frame",
        "frame",
        "targetFrame",
        "toFrame",
        "toFrame",
        "toFrame",
        "targetFrame",
        "toFrame",
        "targetFrame",
        "frame",
        "frame",
        "frame",
        "f",
        "f",
        "frame",
        "frame",
        "frame",
        "frame",
        "frame",
        "frame",
        "defineLazyP5Property",
        "boundConstructorFactory",
        "Animation",
        "pInst",
        "arguments",
        "i",
        "i",
        "i",
        "sX",
        "sY",
        "sX",
        "sX",
        "sX",
        "sY",
        "sY",
        "sY",
        "spriteSheetArgs",
        "spriteSheetArgs",
        "spriteSheetArgs",
        "spriteSheetArgs",
        "shortArgs",
        "spriteSheetArgs",
        "spriteSheetArgs",
        "longArgs",
        "spriteSheetArgs",
        "spriteSheetArgs",
        "spriteSheetArgs",
        "spriteSheetArgs",
        "spriteSheetArgs",
        "spriteSheetArgs",
        "spriteSheetArgs",
        "p5",
        "spriteSheetArgs",
        "Image",
        "spriteSheetArgs",
        "longArgs",
        "shortArgs",
        "spriteSheetArgs",
        "spriteSheetArgs",
        "callback",
        "spriteSheetArgs",
        "pInst",
        "spriteSheetArgs",
        "img",
        "callback",
        "callback",
        "img",
        "callback",
        "callback",
        "pInst",
        "spriteSheetArgs",
        "longArgs",
        "spriteSheetArgs",
        "spriteSheetArgs",
        "callback",
        "spriteSheetArgs",
        "pInst",
        "spriteSheetArgs",
        "img",
        "generateSheetFrames",
        "img",
        "callback",
        "callback",
        "img",
        "callback",
        "callback",
        "pInst",
        "spriteSheetArgs",
        "generateSheetFrames",
        "frame_name",
        "x",
        "y",
        "width",
        "height",
        "frame_name",
        "frameToDraw",
        "frame_name",
        "i",
        "i",
        "i",
        "frame_name",
        "frameToDraw",
        "i",
        "frameToDraw",
        "frameToDraw",
        "frameToDraw",
        "frameToDraw",
        "width",
        "frameWidth",
        "height",
        "frameHeight",
        "frameToDraw",
        "frameToDraw",
        "frameWidth",
        "frameToDraw",
        "frameHeight",
        "frameToDraw",
        "width",
        "x",
        "frameToDraw",
        "dWidth",
        "frameToDraw",
        "dWidth",
        "width",
        "frameSizeScaleX",
        "x",
        "frameToDraw",
        "height",
        "y",
        "frameToDraw",
        "dHeight",
        "frameToDraw",
        "dHeight",
        "height",
        "frameSizeScaleY",
        "y",
        "frameToDraw",
        "Image",
        "pInst",
        "frameToDraw",
        "frameToDraw",
        "frameToDraw",
        "frameToDraw",
        "x",
        "y",
        "dWidth",
        "dHeight",
        "pInst",
        "frameToDraw",
        "frameToDraw",
        "frameToDraw",
        "frameToDraw",
        "x",
        "y",
        "dWidth",
        "dHeight",
        "SpriteSheet",
        "pInst",
        "i",
        "i",
        "i",
        "frame",
        "frame",
        "frame",
        "frame",
        "frame",
        "myClone",
        "cloneFrame",
        "myClone",
        "myClone",
        "myClone",
        "myClone",
        "myClone",
        "defineLazyP5Property",
        "boundConstructorFactory",
        "SpriteSheet",
        "args",
        "args",
        "F",
        "F",
        "bounds",
        "max_objects",
        "max_levels",
        "level",
        "max_objects",
        "max_levels",
        "level",
        "bounds",
        "Quadtree",
        "i",
        "objects",
        "i",
        "objects",
        "i",
        "x",
        "x",
        "objects",
        "i",
        "objects",
        "i",
        "y",
        "y",
        "objects",
        "i",
        "objects",
        "i",
        "w",
        "w",
        "objects",
        "i",
        "objects",
        "i",
        "h",
        "h",
        "objects",
        "i",
        "x",
        "y",
        "w",
        "h",
        "Quadtree",
        "Quadtree",
        "x",
        "subWidth",
        "y",
        "subWidth",
        "subHeight",
        "nextLevel",
        "Quadtree",
        "x",
        "y",
        "subWidth",
        "subHeight",
        "nextLevel",
        "Quadtree",
        "x",
        "y",
        "subHeight",
        "subWidth",
        "subHeight",
        "nextLevel",
        "Quadtree",
        "x",
        "subWidth",
        "y",
        "subHeight",
        "subWidth",
        "subHeight",
        "nextLevel",
        "Quadtree",
        "pRect",
        "pRect",
        "pRect",
        "colliderBounds",
        "horizontalMidpoint",
        "colliderBounds",
        "horizontalMidpoint",
        "colliderBounds",
        "horizontalMidpoint",
        "colliderBounds",
        "verticalMidpoint",
        "colliderBounds",
        "verticalMidpoint",
        "topQuadrant",
        "index",
        "bottomQuadrant",
        "index",
        "colliderBounds",
        "verticalMidpoint",
        "topQuadrant",
        "index",
        "bottomQuadrant",
        "index",
        "index",
        "Quadtree",
        "obj",
        "obj",
        "index",
        "obj",
        "index",
        "index",
        "obj",
        "obj",
        "i",
        "index",
        "i",
        "index",
        "index",
        "i",
        "i",
        "i",
        "Quadtree",
        "pRect",
        "pRect",
        "index",
        "returnObjects",
        "returnObjects",
        "index",
        "pRect",
        "i",
        "i",
        "i",
        "returnObjects",
        "returnObjects",
        "i",
        "pRect",
        "returnObjects",
        "Quadtree",
        "pRect",
        "group",
        "pRect",
        "i",
        "candidates",
        "i",
        "group",
        "candidates",
        "i",
        "results",
        "candidates",
        "i",
        "results",
        "Quadtree",
        "i",
        "i",
        "i",
        "objects",
        "objects",
        "i",
        "objects",
        "Quadtree",
        "obj",
        "index",
        "obj",
        "index",
        "index",
        "obj",
        "node",
        "node",
        "Quadtree",
        "obj",
        "obj",
        "node",
        "obj",
        "index",
        "node",
        "index",
        "Quadtree",
        "i",
        "i",
        "i",
        "i",
        "Quadtree",
        "i",
        "objects",
        "i",
        "objects",
        "i",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "updateTree",
        "p5",
        "cameraPush",
        "p5",
        "cameraPop",
        "p5",
        "p5",
        "p5",
        "message",
        "message",
        "message",
        "p5",
        "center",
        "rotation",
        "p5",
        "rotation",
        "rotation",
        "center",
        "center",
        "p5",
        "p5",
        "p5",
        "p5",
        "c",
        "p5",
        "c",
        "o",
        "p5",
        "o",
        "r",
        "r",
        "s",
        "s",
        "p5",
        "sprite",
        "sprite",
        "p5",
        "parent",
        "parent",
        "Sprite",
        "parent",
        "parent",
        "radians",
        "parent",
        "parent",
        "parent",
        "p5",
        "parent",
        "parent",
        "p5",
        "p5",
        "other",
        "p5",
        "displacer",
        "displacee",
        "p5",
        "displacee",
        "displacer",
        "i",
        "candidateAxes",
        "i",
        "axis",
        "candidateAxes",
        "i",
        "deltaOfCentersOnAxis",
        "p5",
        "deltaOfCenters",
        "axis",
        "distanceOfCentersOnAxis",
        "deltaOfCentersOnAxis",
        "displacee",
        "axis",
        "displacer",
        "axis",
        "r1",
        "r2",
        "distanceOfCentersOnAxis",
        "overlap",
        "p5",
        "overlap",
        "smallestOverlap",
        "smallestOverlap",
        "overlap",
        "deltaOfCentersOnAxis",
        "deltaOfCentersOnAxis",
        "smallestOverlapAxis",
        "axis",
        "smallestOverlapAxis",
        "deltaOfCentersOnAxis",
        "smallestOverlapAxis",
        "smallestOverlap",
        "p5",
        "other",
        "other",
        "displacement",
        "displacement",
        "p5",
        "shape1",
        "shape2",
        "shape1",
        "shape2",
        "shape2",
        "shape1",
        "axis",
        "axis",
        "axis",
        "p5",
        "axis",
        "deduplicateParallelVectors",
        "axes",
        "array",
        "array",
        "item",
        "itemPos",
        "array",
        "other",
        "otherPos",
        "itemPos",
        "otherPos",
        "item",
        "other",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "radiusOnY",
        "radiusOnY",
        "radiusOnX",
        "radiusOnX",
        "radiusOnX",
        "radiusOnY",
        "p5",
        "center",
        "p5",
        "center",
        "p5",
        "p5",
        "p5",
        "sprite",
        "offset",
        "p5",
        "offset",
        "shape",
        "sprite",
        "shape",
        "p5",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "p5",
        "center",
        "radius",
        "p5",
        "center",
        "radius",
        "p5",
        "p5",
        "p5",
        "sprite",
        "offset",
        "radius",
        "radius",
        "p5",
        "offset",
        "customSize",
        "radius",
        "shape",
        "customSize",
        "shape",
        "sprite",
        "shape",
        "p5",
        "sprite",
        "sprite",
        "sprite",
        "sprite",
        "sprite",
        "sprite",
        "sprite",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "p5",
        "parent",
        "parent",
        "Sprite",
        "parent",
        "parent",
        "radians",
        "parent",
        "parent",
        "parent",
        "p5",
        "parent",
        "parent",
        "p5",
        "other",
        "other",
        "p5",
        "other",
        "p5",
        "other",
        "p5",
        "other",
        "halfDiagonals",
        "p5",
        "other",
        "halfDiagonals",
        "p5",
        "other",
        "halfDiagonals",
        "p5",
        "other",
        "halfDiagonals",
        "vertex",
        "vertex",
        "vector",
        "vector",
        "squareDistance",
        "smallestSquareDistance",
        "smallestSquareDistance",
        "squareDistance",
        "axisToClosestVertex",
        "vector",
        "axisToClosestVertex",
        "p5",
        "other",
        "p5",
        "p5",
        "p5",
        "center",
        "width",
        "height",
        "p5",
        "center",
        "width",
        "height",
        "w",
        "w",
        "h",
        "h",
        "p5",
        "p5",
        "p5",
        "sprite",
        "offset",
        "width",
        "height",
        "width",
        "height",
        "p5",
        "offset",
        "customSize",
        "width",
        "customSize",
        "height",
        "box",
        "customSize",
        "box",
        "sprite",
        "box",
        "p5",
        "sprite",
        "sprite",
        "sprite",
        "sprite",
        "sprite",
        "sprite",
        "sprite",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "vertex",
        "vertex",
        "composedTransform",
        "transformedDiagonals",
        "transformedDiagonals",
        "transformedDiagonals",
        "transformedDiagonals",
        "p5",
        "halfWidth",
        "halfHeight",
        "p5",
        "halfWidth",
        "halfHeight",
        "p5",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "p5",
        "p5",
        "p5",
        "axis",
        "p5",
        "axis",
        "p5",
        "axis",
        "p5",
        "p5",
        "center",
        "width",
        "height",
        "rotation",
        "p5",
        "center",
        "rotation",
        "width",
        "height",
        "w",
        "w",
        "h",
        "h",
        "p5",
        "p5",
        "p5",
        "sprite",
        "offset",
        "width",
        "height",
        "rotation",
        "width",
        "height",
        "p5",
        "offset",
        "customSize",
        "width",
        "customSize",
        "height",
        "rotation",
        "box",
        "customSize",
        "box",
        "sprite",
        "box",
        "p5",
        "p5",
        "p5",
        "sprite",
        "sprite",
        "p5",
        "sprite",
        "sprite",
        "vMagnitude",
        "sprite",
        "sprite",
        "sprite",
        "vPerpendicular",
        "radians",
        "sprite",
        "p5",
        "sprite",
        "sprite",
        "sprite",
        "sprite",
        "newRotation",
        "p5",
        "newCenter",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "vertex",
        "vertex",
        "composedTransform",
        "p5",
        "transformedVertices",
        "p5",
        "transformedVertices",
        "p5",
        "transformedVertices",
        "transformedVertices",
        "p5",
        "transformedVertices",
        "transformedVertices",
        "p5",
        "sketch",
        "p5",
        "composedTransform",
        "composedTransform",
        "sketch",
        "sketch",
        "sketch",
        "scale",
        "scale",
        "sketch",
        "sketch",
        "sketch",
        "rotation",
        "sketch",
        "degrees",
        "rotation",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "sketch",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "source",
        "source",
        "source",
        "source",
        "source",
        "source",
        "source",
        "source",
        "source",
        "source",
        "p5",
        "p5",
        "p5",
        "p5",
        "p5",
        "other",
        "other",
        "p5",
        "other",
        "i",
        "i",
        "i",
        "other",
        "i",
        "p5",
        "t1",
        "t2",
        "dest",
        "dest",
        "dest",
        "p5",
        "t1_0",
        "t1",
        "t1_1",
        "t1",
        "t1_2",
        "t1",
        "t1_3",
        "t1",
        "t1_4",
        "t1",
        "t1_5",
        "t1",
        "t2_0",
        "t2",
        "t2_1",
        "t2",
        "t2_2",
        "t2",
        "t2_3",
        "t2",
        "t2_4",
        "t2",
        "t2_5",
        "t2",
        "dest",
        "t1_0",
        "t2_0",
        "t1_1",
        "t2_3",
        "dest",
        "t1_0",
        "t2_1",
        "t1_1",
        "t2_4",
        "dest",
        "t1_0",
        "t2_2",
        "t1_1",
        "t2_5",
        "t1_2",
        "dest",
        "t1_3",
        "t2_0",
        "t1_4",
        "t2_3",
        "dest",
        "t1_3",
        "t2_1",
        "t1_4",
        "t2_4",
        "dest",
        "t1_3",
        "t2_2",
        "t1_4",
        "t2_5",
        "t1_5",
        "dest",
        "p5",
        "other",
        "p5",
        "other",
        "p5",
        "arg0",
        "arg1",
        "arg0",
        "p5",
        "x",
        "arg0",
        "y",
        "arg0",
        "arg0",
        "arg1",
        "x",
        "arg0",
        "y",
        "arg1",
        "i",
        "arguments",
        "i",
        "args",
        "arguments",
        "i",
        "args",
        "p5",
        "x",
        "y",
        "p5",
        "p5",
        "p5",
        "arg0",
        "arg1",
        "arg0",
        "p5",
        "sx",
        "arg0",
        "sy",
        "arg0",
        "arg0",
        "arg1",
        "sx",
        "arg0",
        "sy",
        "arg1",
        "arg0",
        "sx",
        "arg0",
        "sy",
        "arg0",
        "arguments",
        "p5",
        "sx",
        "sy",
        "p5",
        "p5",
        "sign",
        "a",
        "a",
        "a",
        "b",
        "b",
        "sign",
        "d",
        "c",
        "c",
        "d",
        "d",
        "x",
        "x",
        "x",
        "x",
        "isNaN",
        "x",
        "x",
        "x",
        "p5",
        "radians",
        "radians",
        "arguments",
        "radians",
        "radians",
        "p5",
        "cosR",
        "sinR",
        "sinR",
        "cosR",
        "p5",
        "p5",
        "v",
        "t",
        "v",
        "t",
        "p5",
        "transform",
        "transform",
        "x",
        "transform",
        "y",
        "transform",
        "transform",
        "x",
        "transform",
        "y",
        "transform"
    ],
    "literals": [
        "'function'",
        "'p5.play'",
        "'@code-dot-org/p5'",
        "'object'",
        "'@code-dot-org/p5'",
        "'init'",
        "'canvas'",
        "'undefined'",
        "'function'",
        "'constructor must be a function'",
        "'function'",
        "'\"'",
        "'\" is not a p5 method'",
        "'touchIsDown'",
        "'function'",
        "'function'",
        "'mousedown'",
        "'mousemove'",
        "'mouseup'",
        "'touches'",
        "'touchX'",
        "'touchY'",
        "'_hasTouchInteracted'",
        "'isMousePressed'",
        "'mouseIsPressed'",
        "'function'",
        "'function'",
        "'touchstart'",
        "'touchmove'",
        "'touchend'",
        "'mouseX'",
        "'mouseY'",
        "'winMouseX'",
        "'winMouseY'",
        "'_hasMouseInteracted'",
        "'number'",
        "'function'",
        "'function'",
        "'data:image/'",
        "'Anonymous'",
        "'Wrong number of arguments to imageElement()'",
        "'2d'",
        "'allSprites'",
        "'rgba(0,0,0,0)'",
        "'undefined'",
        "'regularPolygon'",
        "'Number'",
        "'Number'",
        "'Number'",
        "'Number'",
        "'Number'",
        "'Number'",
        "'Number'",
        "'Number'",
        "'Number'",
        "'World'",
        "'width'",
        "'height'",
        "'mouseX'",
        "'mouseY'",
        "'allSprites'",
        "'frameCount'",
        "'frameRate'",
        "'seconds'",
        "'function'",
        "'Error: with drawSprites you can only draw all sprites or a group'",
        "'_p5play'",
        "'string'",
        "'leftButton'",
        "'rightButton'",
        "'centerButton'",
        "'BACKSPACE'",
        "'TAB'",
        "'ENTER'",
        "'SHIFT'",
        "'CTRL'",
        "'ALT'",
        "'PAUSE'",
        "'CAPS_LOCK'",
        "'ESC'",
        "'SPACE'",
        "' '",
        "'PAGE_UP'",
        "'PAGE_DOWN'",
        "'END'",
        "'HOME'",
        "'LEFT_ARROW'",
        "'LEFT'",
        "'UP_ARROW'",
        "'UP'",
        "'RIGHT_ARROW'",
        "'RIGHT'",
        "'DOWN_ARROW'",
        "'DOWN'",
        "'INSERT'",
        "'DELETE'",
        "'0'",
        "'1'",
        "'2'",
        "'3'",
        "'4'",
        "'5'",
        "'6'",
        "'7'",
        "'8'",
        "'9'",
        "'A'",
        "'B'",
        "'C'",
        "'D'",
        "'E'",
        "'F'",
        "'G'",
        "'H'",
        "'I'",
        "'J'",
        "'K'",
        "'L'",
        "'M'",
        "'N'",
        "'O'",
        "'P'",
        "'Q'",
        "'R'",
        "'S'",
        "'T'",
        "'U'",
        "'V'",
        "'W'",
        "'X'",
        "'Y'",
        "'Z'",
        "'0NUMPAD'",
        "'1NUMPAD'",
        "'2NUMPAD'",
        "'3NUMPAD'",
        "'4NUMPAD'",
        "'5NUMPAD'",
        "'6NUMPAD'",
        "'7NUMPAD'",
        "'8NUMPAD'",
        "'9NUMPAD'",
        "'MULTIPLY'",
        "'PLUS'",
        "'MINUS'",
        "'DOT'",
        "'SLASH1'",
        "'F1'",
        "'F2'",
        "'F3'",
        "'F4'",
        "'F5'",
        "'F6'",
        "'F7'",
        "'F8'",
        "'F9'",
        "'F10'",
        "'F11'",
        "'F12'",
        "'EQUAL'",
        "'COMMA'",
        "'SLASH'",
        "'BACKSLASH'",
        "'MINUT'",
        "'MINUS'",
        "'COMA'",
        "'COMMA'",
        "'Key literal \"'",
        "'\" is deprecated and may be removed '",
        "'in a future version of p5.play. '",
        "'Please use \"'",
        "'\" instead.'",
        "'quadTree'",
        "'createVector'",
        "'color'",
        "'print'",
        "'push'",
        "'pop'",
        "'colorMode'",
        "'tint'",
        "'lerpColor'",
        "'noStroke'",
        "'rectMode'",
        "'ellipseMode'",
        "'imageMode'",
        "'translate'",
        "'scale'",
        "'rotate'",
        "'stroke'",
        "'strokeWeight'",
        "'line'",
        "'noFill'",
        "'fill'",
        "'textAlign'",
        "'textSize'",
        "'text'",
        "'rect'",
        "'cos'",
        "'sin'",
        "'atan2'",
        "'rotation'",
        "'width'",
        "'height'",
        "''",
        "'x'",
        "'y'",
        "'velocityX'",
        "'velocityY'",
        "'lifetime'",
        "'bounciness'",
        "'frameDelay'",
        "'function'",
        "'function'",
        "'function'",
        "'function'",
        "'rectangle'",
        "'function'",
        "'Warning: onMouseOver should be a function'",
        "'function'",
        "'Warning: onMouseOut should be a function'",
        "'function'",
        "'Warning: onMousePressed should be a function'",
        "'function'",
        "'Warning: onMouseReleased should be a function'",
        "''",
        "'rectangle'",
        "'obb'",
        "'point'",
        "'circle'",
        "'obb'",
        "'aabb'",
        "'setCollider expects the first argument to be one of \"point\", \"circle\", \"rectangle\", \"aabb\" or \"obb\"'",
        "'point'",
        "'Usage: setCollider(\"'",
        "'\"[, offsetX, offsetY])'",
        "'circle'",
        "'Usage: setCollider(\"'",
        "'\"[, offsetX, offsetY[, radius]])'",
        "'aabb'",
        "'Usage: setCollider(\"'",
        "'\"[, offsetX, offsetY[, width, height]])'",
        "'obb'",
        "'Usage: setCollider(\"'",
        "'\"[, offsetX, offsetY[, width, height[, rotation]]])'",
        "'point'",
        "'circle'",
        "'aabb'",
        "'obb'",
        "''",
        "''",
        "'addToGroup error: '",
        "' is not a group'",
        "'undefined'",
        "'string'",
        "'normal'",
        "'addImage error: allowed usages are <image> or <label>, <image>'",
        "'string'",
        "'Sprite.addAnimation error: the first argument must be a label (String)'",
        "'addAnimation error: you must specify a label and n frame images'",
        "''",
        "''",
        "'changeAnimation error: no animation labeled '",
        "'undefined'",
        "'Unable to find an animation named \"'",
        "'\".  Please make sure the animation exists.'",
        "'Error: overlapPixel doesn\\'t work with scaled or rotated sprites yet'",
        "'overlap'",
        "'collide'",
        "'displace'",
        "'bounce'",
        "'bounceOff'",
        "'Error: overlap can only be checked between sprites or groups'",
        "'displace'",
        "'collide'",
        "'bounce'",
        "'bounceOff'",
        "'collide'",
        "'bounce'",
        "'bounceOff'",
        "'bounce'",
        "'bounce'",
        "'function'",
        "'isTouching'",
        "'Sprite'",
        "'x'",
        "'y'",
        "'Camera'",
        "'Error: you can only add sprites to a group'",
        "'Error: you can only remove sprites from a group'",
        "'string'",
        "'object'",
        "'overlap'",
        "'collide'",
        "'displace'",
        "'bounce'",
        "'bounceOff'",
        "'depth'",
        "'lifetime'",
        "'rotateToDirection'",
        "'rotation'",
        "'rotationSpeed'",
        "'scale'",
        "'shapeColor'",
        "'tint'",
        "'visible'",
        "'velocityX'",
        "'velocityY'",
        "'height'",
        "'width'",
        "'destroy'",
        "'pointTo'",
        "'setAnimation'",
        "'setCollider'",
        "'setSpeedAndDirection'",
        "'setVelocity'",
        "'mirrorX'",
        "'mirrorY'",
        "'string'",
        "'string'",
        "'.png'",
        "'Animation error: you need to use .png files (filename '",
        "')'",
        "'.png'",
        "'Animation error: you need to use .png files (filename '",
        "')'",
        "'0'",
        "'9'",
        "'0'",
        "'9'",
        "'.png'",
        "'.png'",
        "'Warning undefined frame '",
        "'Animation'",
        "'name'",
        "'frame'",
        "'x'",
        "'y'",
        "'width'",
        "'height'",
        "'number'",
        "'number'",
        "'number'",
        "'function'",
        "'function'",
        "'number'",
        "'name'",
        "'frame'",
        "'x'",
        "'y'",
        "'width'",
        "'height'",
        "'SpriteSheet'",
        "'undefined'",
        "'undefined'",
        "'undefined'",
        "'pre'",
        "'pre'",
        "'post'",
        "'pre'",
        "'post'",
        "'loadImageElement'",
        "'function'",
        "'function'",
        "'Warning: '",
        "'center'",
        "'offset'",
        "'rotation'",
        "'scale'",
        "'Bad argument to setParentTransform: '",
        "'number'",
        "'Bad argument to setParentTransform: '",
        "'width'",
        "'height'",
        "'halfDiagonals'",
        "'number'",
        "'number'",
        "'width'",
        "'height'",
        "'halfDiagonals'",
        "'number'",
        "'number'",
        "'Transform2D must have six components'",
        "'number'",
        "'number'",
        "''",
        "', '",
        "'Invalid arguments to Transform2D.translate: '",
        "'number'",
        "'number'",
        "'number'",
        "'Invalid arguments to Transform2D.scale: '",
        "'number'",
        "'Invalid arguments to Transform2D.rotate: '"
    ],
    "variables": [
        "DEFAULT_FRAME_RATE",
        "startDate",
        "context",
        "pInst",
        "args",
        "method",
        "abs",
        "radians",
        "degrees",
        "result",
        "validTouch",
        "i",
        "context",
        "executeDefault",
        "x",
        "y",
        "touchInfo",
        "touches",
        "touchIndex",
        "i",
        "rect",
        "touch",
        "xPos",
        "yPos",
        "context",
        "executeDefault",
        "x",
        "y",
        "mousePos",
        "rect",
        "xPos",
        "yPos",
        "img",
        "decrementPreload",
        "vals",
        "context",
        "mousePosition",
        "styleEmpty",
        "ctx",
        "doFill",
        "doStroke",
        "i",
        "angle",
        "args",
        "i",
        "ctx",
        "doFill",
        "doStroke",
        "numCoords",
        "i",
        "World",
        "currentDate",
        "currentTime",
        "s",
        "i",
        "arr",
        "j",
        "i",
        "KEY_IS_UP",
        "KEY_WENT_DOWN",
        "KEY_IS_DOWN",
        "KEY_WENT_UP",
        "keyCode",
        "keyStates",
        "mouseStates",
        "keyStates",
        "mouseStates",
        "quadTree",
        "pInstBind",
        "createVector",
        "color",
        "push",
        "pop",
        "colorMode",
        "tint",
        "lerpColor",
        "noStroke",
        "rectMode",
        "ellipseMode",
        "imageMode",
        "translate",
        "scale",
        "rotate",
        "stroke",
        "strokeWeight",
        "line",
        "noFill",
        "fill",
        "textAlign",
        "textSize",
        "text",
        "rect",
        "cos",
        "sin",
        "atan2",
        "quadTree",
        "camera",
        "RGB",
        "CENTER",
        "LEFT",
        "BOTTOM",
        "dirX",
        "dirY",
        "animations",
        "currentAnimation",
        "displacement",
        "mouseWasOver",
        "mouseWasPressed",
        "mousePosition",
        "_type",
        "offset",
        "fillColor",
        "direction",
        "speed",
        "k",
        "a",
        "yDelta",
        "xDelta",
        "radiansAngle",
        "a",
        "angle",
        "anim",
        "sourceAnimation",
        "newAnimation",
        "animFrames",
        "i",
        "animation",
        "point",
        "img",
        "values",
        "point",
        "others",
        "result",
        "i",
        "displacement",
        "originalType",
        "originalThisImmovable",
        "originalOtherImmovable",
        "originalOtherRestitution",
        "thisInitialVelocity",
        "otherInitialVelocity",
        "thisMass",
        "otherMass",
        "combinedMass",
        "coefficientOfRestitution",
        "initialMomentum",
        "thisFinalVelocity",
        "otherFinalVelocity",
        "radiusOnVelocityAxis",
        "relativeVelocity",
        "timestep",
        "thisOriginalPosition",
        "targetOriginalPosition",
        "thisDelta",
        "targetDelta",
        "i",
        "timestep",
        "displacement",
        "pInst",
        "camera",
        "pInst",
        "array",
        "i",
        "len",
        "i",
        "removed",
        "i",
        "didCollide",
        "i",
        "i",
        "methodArgs",
        "elements",
        "i",
        "edgeThickness",
        "width",
        "height",
        "frameArguments",
        "i",
        "CENTER",
        "frame",
        "cycles",
        "targetFrame",
        "to",
        "ext1",
        "ext2",
        "digits1",
        "digits2",
        "prefix1",
        "prefix2",
        "number1",
        "number2",
        "t",
        "number2",
        "fileName",
        "myClone",
        "xTranslate",
        "yTranslate",
        "image",
        "frame_info",
        "missingX",
        "missingY",
        "previousFrame",
        "frame",
        "spriteSheetArgs",
        "sX",
        "sY",
        "i",
        "shortArgs",
        "longArgs",
        "callback",
        "generateSheetFrames",
        "frameToDraw",
        "i",
        "frameWidth",
        "frameHeight",
        "dWidth",
        "dHeight",
        "frameSizeScaleX",
        "frameSizeScaleY",
        "myClone",
        "i",
        "frame",
        "cloneFrame",
        "objects",
        "x",
        "y",
        "w",
        "h",
        "i",
        "nextLevel",
        "subWidth",
        "subHeight",
        "x",
        "y",
        "colliderBounds",
        "index",
        "verticalMidpoint",
        "horizontalMidpoint",
        "topQuadrant",
        "bottomQuadrant",
        "i",
        "index",
        "index",
        "returnObjects",
        "i",
        "results",
        "candidates",
        "i",
        "objects",
        "i",
        "index",
        "node",
        "node",
        "index",
        "i",
        "objects",
        "i",
        "displacee",
        "displacer",
        "other",
        "smallestOverlap",
        "Infinity",
        "smallestOverlapAxis",
        "deltaOfCenters",
        "candidateAxes",
        "axis",
        "deltaOfCentersOnAxis",
        "distanceOfCentersOnAxis",
        "i",
        "r1",
        "r2",
        "overlap",
        "displacement",
        "axes",
        "radiusOnX",
        "radiusOnY",
        "shape",
        "customSize",
        "shape",
        "smallestSquareDistance",
        "Infinity",
        "axisToClosestVertex",
        "halfDiagonals",
        "squareDistance",
        "customSize",
        "box",
        "composedTransform",
        "transformedDiagonals",
        "halfWidth",
        "halfHeight",
        "customSize",
        "box",
        "vMagnitude",
        "vPerpendicular",
        "newRotation",
        "newCenter",
        "composedTransform",
        "transformedVertices",
        "composedTransform",
        "scale",
        "rotation",
        "i",
        "t1_0",
        "t1_1",
        "t1_2",
        "t1_3",
        "t1_4",
        "t1_5",
        "t2_0",
        "t2_1",
        "t2_2",
        "t2_3",
        "t2_4",
        "t2_5",
        "x",
        "y",
        "args",
        "i",
        "sx",
        "sy",
        "a",
        "b",
        "c",
        "d",
        "sinR",
        "cosR",
        "x",
        "y"
    ],
    "comments": [
        "p5.play\nby Paolo Pedercini/molleindustria, 2015\nhttp://molleindustria.org/",
        "=============================================================================",
        "initialization",
        "=============================================================================",
        "This is the new way to initialize custom p5 properties for any p5 instance.",
        "The goal is to migrate lazy P5 properties over to this method.",
        "@see https://github.com/molleindustria/p5.play/issues/46",
        "Temporary canvas for supporting tint operations from image elements;",
        "see p5.prototype.imageElement()",
        "This provides a way for us to lazily define properties that",
        "are global to p5 instances.",
        "",
        "Note that this isn't just an optimization: p5 currently provides no",
        "way for add-ons to be notified when new p5 instances are created, so",
        "lazily creating these properties is the *only* mechanism available",
        "to us. For more information, see:",
        "",
        "https://github.com/processing/p5.js/issues/1263",
        "This returns a factory function, suitable for passing to",
        "defineLazyP5Property, that returns a subclass of the given",
        "constructor that is always bound to a particular p5 instance.",
        "This is a utility that makes it easy to define convenient aliases to",
        "pre-bound p5 instance methods.",
        "",
        "For example:",
        "",
        "var pInstBind = createPInstBinder(pInst);",
        "",
        "var createVector = pInstBind('createVector');",
        "var loadImage = pInstBind('loadImage');",
        "",
        "The above will create functions createVector and loadImage, which can be",
        "used similar to p5 global mode--however, they're bound to specific p5",
        "instances, and can thus be used outside of global mode.",
        "These are utility p5 functions that don't depend on p5 instance state in",
        "order to work properly, so we'll go ahead and make them easy to",
        "access without needing to bind them to a p5 instance.",
        "=============================================================================",
        "p5 overrides",
        "=============================================================================",
        "Make the fill color default to gray (127, 127, 127) each time a new canvas is",
        "created.",
        "Make width and height optional for ellipse() - default to 50",
        "Save the original implementation to allow for optional parameters.",
        "Make width and height optional for rect() - default to 50",
        "Save the original implementation to allow for optional parameters.",
        "Modify p5 to ignore out-of-bounds positions before setting touchIsDown",
        "No in-bounds (valid) touches, return and ignore:",
        "this._setMouseButton(e);",
        "Modify p5 to handle CSS transforms (scale) and ignore out-of-bounds",
        "positions before reporting touch coordinates",
        "",
        "NOTE: _updateNextTouchCoords() is nearly identical, but calls a modified",
        "getTouchInfo() function below that scales the touch postion with the play",
        "space and can return undefined",
        "Only some touches are valid - only push valid touches into the",
        "array for the `touches` property.",
        "For first draw, make previous and next equal",
        "NOTE: returns undefined if the position is outside of the valid range",
        "Modify p5 to ignore out-of-bounds positions before setting mouseIsPressed",
        "and isMousePressed",
        "Not in-bounds, return and ignore:",
        "Modify p5 to handle CSS transforms (scale) and ignore out-of-bounds",
        "positions before reporting mouse coordinates",
        "",
        "NOTE: _updateNextMouseCoords() is nearly identical, but calls a modified",
        "getMousePos() function below that scales the mouse position with the play",
        "space and can return undefined.",
        "For first draw, make previous and next equal",
        "NOTE: returns undefined if the position is outside of the valid range",
        "=============================================================================",
        "p5 extensions",
        "TODO: It'd be nice to get these accepted upstream in p5",
        "=============================================================================",
        "=============================================================================",
        "p5 additions",
        "=============================================================================",
        "don't get failure callback mixed up with decrementPreload",
        "set crossOrigin in case image is served which CORS headers",
        "this will let us draw to canvas without tainting it.",
        "see https://developer.mozilla.org/en-US/docs/HTML/CORS_Enabled_Image",
        "When using data-uris the file will be loaded locally",
        "so we don't need to worry about crossOrigin with base64 file types",
        "start loading the image",
        "Just-in-time create/draw into a temp canvas so tinting can",
        "work within the renderer as it would for a p5.Image",
        "Only resize canvas if it's too small",
        "Call the renderer's image() method with an object that contains the Image",
        "as an 'elt' property and the temp canvas as well (when needed):",
        "NOTE: only implemented for non-3D",
        "NOTE: only implemented for non-3D",
        "TODO: call this._validateParameters, once it is working in p5.js and",
        "we understand if it can be used for var args functions like this",
        "convert a from 0 to 255 to 0 to 1",
        "draw everything",
        "for every tag",
        "If no group is provided, draw the allSprites group.",
        "variable to detect instant presses",
        "if undefined start checking it",
        "Map of strings to constants for mouse states.",
        "undefined = not tracked yet, start tracking",
        "pre draw: detect keyStates",
        "if is down",
        "and was up",
        "now is simply down",
        "if it's up",
        "and was up",
        "now is simply down",
        "mouse",
        "if is down",
        "and was up",
        "now is simply down",
        "if it's up",
        "and was up",
        "now is simply down",
        "the actual quadTree",
        "//framerate independent delta, doesn't really work\np5.prototype.deltaTime = 1;\n\nvar now = Date.now();\nvar then = Date.now();\nvar INTERVAL_60 = 0.0166666; //60 fps\n\nfunction updateDelta() {\nthen = now;\nnow = Date.now();\ndeltaTime = ((now - then) / 1000)/INTERVAL_60; // seconds since last frame\n}",
        "For details on why these docs aren't in a YUIDoc comment block, see:",
        "",
        "https://github.com/molleindustria/p5.play/pull/67",
        "",
        "@param {Number} x Initial x coordinate",
        "@param {Number} y Initial y coordinate",
        "@param {Number} width Width of the placeholder rectangle and of the",
        "collider until an image or new collider are set",
        "@param {Number} height Height of the placeholder rectangle and of the",
        "collider until an image or new collider are set",
        "These are p5 constants that we'd like easy access to.",
        "The sprite's position at the end of the last update as a vector (x,y).\n  Note: this will differ from position whenever the position is changed\n  directly by assignment.",
        "Position displacement on the x coordinate since the last update",
        "Coefficient of restitution - velocity lost in the bouncing",
        "0 perfectly inelastic , 1 elastic, > 1 hyper elastic",
        "The current animation's label.",
        "if there has been a change somewhere after the last update",
        "the old position is the last position registered in the update",
        "if there is an animation",
        "update it",
        "a collider is created either manually with setCollider or",
        "when I check this sprite for collisions or overlaps",
        "mouse actions",
        "if no collider set it",
        "if a mouse function is set",
        "it's implied we want to have it mouse active so",
        "we do this automatically",
        "if no collider set it",
        "self destruction countdown",
        "end update",
        "animation is still loading",
        "rollover",
        "global p5 var",
        "event change - call functions",
        "Map 'rectangle' to AABB.  Change this if you want it to default to OBB.",
        "Check correct arguments, provide context-sensitive usage message if wrong.",
        "var center = this.position;",
        "Disabled for Code.org, since perf seems better without the quadtree:",
        "quadTree.insert(this);",
        "draw debug info",
        "draw the anchor point",
        "depth number",
        "Draw collision shape",
        "when removed from the \"scene\" also remove all the references in all the groups",
        "Unlike Math.atan2, the atan2 method above will return degrees if",
        "the current p5 angleMode is DEGREES, and radians if the p5 angleMode is",
        "RADIANS.  This method should always return degrees (for now).",
        "See https://github.com/molleindustria/p5.play/issues/94",
        "update linear speed",
        "find reduction factor",
        "Normally this just sets the 'playing' flag without changing the animation",
        "frame, which will cause the animation to continue on the next update().",
        "If the animation is non-looping and is stopped at the last frame",
        "we also rewind the animation to the beginning.",
        "convert point to img relative position",
        "out of the image entirely",
        "true if full opacity",
        "offscreen printing to be implemented bleurch",
        "If the quadtree is disabled -or- no sprites in this group are in the",
        "quadtree yet (because their default colliders haven't been created)",
        "we should just check all of them.",
        "Never collide with self",
        "We were unable to create a collider for one of the sprites.",
        "This usually means its animation is not available yet; it will be soon.",
        "Don't collide for now.",
        "Actually compute the overlap of the two colliders",
        "These sprites are not overlapping.",
        "Apply displacement out of collision",
        "Create special behaviors for certain collision types by temporarily",
        "overriding type and sprite properties.",
        "See another block near the end of this method that puts them back.",
        "If this is a 'bounce' collision, determine the new velocities for each sprite",
        "We are concerned only with velocities parallel to the collision normal,",
        "so project our sprite velocities onto that normal (captured in the",
        "displacement vector) and use these throughout the calculation",
        "We only care about relative mass values, so if one of the sprites",
        "is considered 'immovable' treat the _other_ sprite's mass as zero",
        "to get the correct results.",
        "Remove velocity before and apply velocity after to both members.",
        "Restore sprite properties now that velocity changes have been made.",
        "See another block before velocity changes that sets these up.",
        "Finally, for all collision types except 'isTouching', call the callback",
        "and record that collision occurred.",
        "Multisample if tunneling occurs:",
        "Do broad-phase detection. Check if the swept colliders overlap.",
        "In that case, test interpolations between their last positions and their",
        "current positions, and check for tunneling that way.",
        "Use multisampling to catch collisions we might otherwise miss.",
        "Figure out how many samples we should take.",
        "We want to limit this so that we don't take an absurd number of samples",
        "when objects end up at very high velocities (as happens sometimes in",
        "game engines).",
        "If the objects are small enough to benefit from multisampling at this",
        "relative velocity",
        "Move sprites back to previous positions",
        "(We jump through some hoops here to avoid creating too many new",
        "vector objects)",
        "Scale deltas down to timestep-deltas",
        "Note: We don't have to check the original position, we can assume it's",
        "non-colliding (or it would have been handled on the last frame).",
        "Move the sprites forward by the sub-frame timestep",
        "Check for collision at the new sub-frame position",
        "These sprites are overlapping - we have a displacement, and a",
        "point-in-time for the collision.",
        "If either sprite is immovable, it should move back to its final",
        "position.  Otherwise, leave the sprites at their interpolated",
        "position when the collision occurred.",
        "If we didn't find a displacement partway through,",
        "restore the sprites to their original positions and fall through",
        "to do the collision check at their final position.",
        "Ensure the colliders are properly updated to match their parent",
        "sprites. Maybe someday we won't have to do this, but for now",
        "sprites aren't guaranteed to be internally consistent we do a",
        "last-minute update to make sure.",
        "end Sprite class",
        "end camera class",
        "called pre draw by default",
        "awkward but necessary in order to have the camera at the center",
        "of the canvas by default",
        "called postdraw by default",
        "basically extending the array",
        "sort by depth",
        "internal use",
        "Copy all arguments after the first parameter into methodArgs:",
        "Use a copy of the array in case the method modifies the group",
        "is the collider defined manually or defined",
        "by the current frame size",
        "sequence mode",
        "print(\"sequence mode \"+from+\" -> \"+to);",
        "make sure the extensions are fine",
        "extensions are fine",
        "skip extension work backwards to find the numbers",
        "Our numbers likely have leading zeroes, which means that some",
        "browsers (e.g., PhantomJS) will interpret them as base 8 (octal)",
        "instead of decimal. To fix this, we'll explicity tell parseInt to",
        "use a base of 10 (decimal). For more details on this issue, see",
        "http://stackoverflow.com/a/8763427/2422398.",
        "swap if inverted",
        "two different frames",
        "print(\"2 separate images\");",
        "same digits: case img0001, img0002",
        "load all images",
        "Use nf() to number format 'i' into four digits",
        "case: case img1, img2",
        "print(\"from \"+prefix1+\" \"+number1 +\" to \"+number2);",
        "Use nf() to number format 'i' into four digits",
        "end no ext error",
        "end sequence mode",
        "Sprite sheet mode",
        "arbitrary list of images",
        "print(\"Animation arbitrary mode\");",
        "print(\"loading \"+fileNames[i]);",
        "empty",
        "only connection with the sprite class",
        "if animation is used independently draw and update are the sam",
        "this.currentImageMode = g.imageMode;",
        "Adjust translation if we're dealing with a texture packed spritesheet",
        "(with sourceW, sourceH, sourceX, sourceY props on our images array)",
        "If the count of missing (transparent) pixels is not equally balanced on",
        "the left vs. right or top vs. bottom, we adjust the translation:",
        "this.isActive = false;",
        "called by draw",
        "go to frame",
        "going to target frame up",
        "going to taget frame down",
        "advance frame",
        "if next frame is too high",
        "if next frame is too high",
        "end update",
        "this.playing = false;",
        "targetFrame gets used by the update() method to decide what frame to",
        "select next.  When it's not being used it gets set to -1.",
        "When the final argument is present (either the 3rd or the 5th), it indicates",
        "whether we should load the URL as an Image element (as opposed to the default",
        "behavior, which is to load it as a p5.Image). If that argument is a function,",
        "it will be called back once the load succeeds or fails. On success, the Image",
        "will be supplied as the only parameter. On failure, null will be supplied.",
        "Adjust how we draw if we're dealing with a texture packed spritesheet",
        "(in particular, we treat supplied width and height params as an intention",
        "to scale versus the sourceSize [before packing])",
        "empty",
        "Deep clone the frames by value not reference",
        "clone other fields",
        "general constructor to be able to feed arguments as array",
        "find maximum area",
        "print(this.bounds);",
        "top right node",
        "top left node",
        "bottom left node",
        "bottom right node",
        "pRect can completely fit within the top quadrants",
        "pRect can completely fit within the bottom quadrants",
        "pRect can completely fit within the left quadrants",
        "pRect can completely fit within the right quadrants",
        "avoid double insertion",
        "if we have subnodes ...",
        "split if we don't already have subnodes",
        "add all objects to there corresponding subnodes",
        "if we have subnodes ...",
        "if pRect fits into a subnode ..",
        "if pRect does not fit into a subnode, check it against all subnodes",
        "if there are no subnodes, object must be here",
        "if the object does not fit into a subnode, it must be here",
        "if it fits into a subnode, continue deeper search there",
        "keyboard input",
        "automatic sprite update",
        "quadtree update",
        "camera push and pop",
        "deltaTime",
        "p5.prototype.registerMethod('pre', updateDelta);",
        "Public getters/setters",
        "Recompute internal properties from transforms",
        "Rotation in local space",
        "Scale in local space",
        "Offset in local-space",
        "Center in world-space",
        "Compute a displacement vector using the Separating Axis Theorem",
        "(Valid only for convex shapes)",
        "",
        "If a line (axis) exists on which the two shapes' orthogonal projections",
        "do not overlap, then the shapes do not overlap.  If the shapes'",
        "projections do overlap on all candidate axes, the axis that had the",
        "smallest overlap gives us the smallest possible displacement.",
        "",
        "@see http://www.dyn4j.org/2010/01/sat/",
        "We speed things up with an additional assumption that all collision",
        "shapes are centrosymmetric: Circles, ellipses, and rectangles",
        "are OK.  This lets us only compare the shapes' radii to the",
        "distance between their centers, even for non-circular shapes.",
        "Other convex shapes, (triangles, pentagons) will require more",
        "complex use of their projections' positions on the axis.",
        "It turns out we only need to check a few axes, defined by the shapes",
        "being checked.  For a polygon, the normal of each face is a possible",
        "separating axis.",
        "If distance between the shape's centers as projected onto the",
        "separating axis is larger than the combined radii of the shapes",
        "projected onto the axis, the shapes do not overlap on this axis.",
        "These shapes are separated along this axis.",
        "Early-out, returning a zero-vector displacement.",
        "This is the smallest overlap we've found so far - store some",
        "information about it, which we can use to give the smallest",
        "displacement when we're done.",
        "Normally use the delta of centers, which gives us direction along",
        "with an axis.  In the rare case that the centers exactly overlap,",
        "just use the original axis",
        "If we make it here, we overlap on all possible axes and we",
        "can compute the smallest vector that will displace this out of other.",
        "Create the collision shape at the transformed offset",
        "A circle has infinite potential candidate axes, so the ones we pick",
        "depend on what we're colliding against.",
        "TODO: If we can ask the other shape for a list of vertices, then we can",
        "generalize this algorithm by always using the closest one, and",
        "remove the special knowledge of OBB and AABB.",
        "There are four possible separating axes with a box - one for each",
        "of its vertices, through the center of the circle.",
        "We need the closest one.",
        "Generate the set of vertices for the other shape",
        "Transform each vertex into a vector from this collider center to",
        "that vertex, which defines an axis we might want to check.",
        "Figure out which vertex is closest and use its axis",
        "When checking against another circle or a point we only need to check the",
        "axis through both shapes' centers.",
        "We transform the rectangle (which may scale and rotate it) then compute",
        "an axis-aligned bounding box _around_ it.",
        "How to project a rect onto an axis:",
        "Project the center-corner vectors for two adjacent corners (cached here)",
        "onto the axis.  The larger magnitude of the two is your projection's radius.",
        "Perform this.rotation = newRotation and this.center = newCenter;",
        "Transform each vertex by the local and global matrices",
        "then use their differences to determine width, height, and halfDiagonals",
        "An oriented bounding box always provides two of its face normals,",
        "which we've precomputed.",
        "We can reuse the AABB version of this method because both are projecting",
        "cached half-diagonals - the same code works.",
        "We only store the first six values.",
        "the last row in a 2D transform matrix is always \"0 0 1\" so we can",
        "save space and speed up certain calculations with this assumption.",
        "Never equal to other types.",
        "Capture values of original matrices in local variables, in case one of",
        "them is the one we're mutating.",
        "convert to a number",
        "Clockwise!",
        "see http://math.stackexchange.com/a/13165",
        "Note: We cheat a whole bunch here since this is just 2D!",
        "Use a different method if looking for true matrix multiplication."
    ],
    "docstrings": [
        "* p5.play is a library for p5.js to facilitate the creation of games and gamelike\n * projects.\n *\n * It provides a flexible Sprite class to manage visual objects in 2D space\n * and features such as animation support, basic collision detection\n * and resolution, mouse and keyboard interactions, and a virtual camera.\n *\n * p5.play is not a box2D-derived physics engine, it doesn't use events, and it's\n * designed to be understood and possibly modified by intermediate programmers.\n *\n * See the examples folder for more info on how to use this library.\n *\n * @module p5.play\n * @submodule p5.play\n * @for p5.play\n * @main",
        "* The sketch camera automatically created at the beginning of a sketch.\n   * A camera facilitates scrolling and zooming for scenes extending beyond\n   * the canvas. A camera has a position, a zoom factor, and the mouse\n   * coordinates relative to the view.\n   *\n   * In p5.js terms the camera wraps the whole drawing cycle in a\n   * transformation matrix but it can be disabled anytime during the draw\n   * cycle, for example to draw interface elements in an absolute position.\n   *\n   * @property camera\n   * @type {camera}",
        "* Projects a vector onto the line parallel to a second vector, giving a third\n * vector which is the orthogonal projection of that vector onto the line.\n * @see https://en.wikipedia.org/wiki/Vector_projection\n * @method project\n * @for p5.Vector\n * @static\n * @param {p5.Vector} a - vector being projected\n * @param {p5.Vector} b - vector defining the projection target line.\n * @return {p5.Vector} projection of a onto the line parallel to b.",
        "* Ask whether a vector is parallel to this one.\n * @method isParallel\n * @for p5.Vector\n * @param {p5.Vector} v2\n * @param {number} [tolerance] - margin of error for comparisons, comes into\n *        play when comparing rotated vectors.  For example, we want\n *        <1, 0> to be parallel to <0, 1>.rot(Math.PI/2) but float imprecision\n *        can get in the way of that.\n * @return {boolean}",
        "* Loads an image from a path and creates an Image from it.\n * <br><br>\n * The image may not be immediately available for rendering\n * If you want to ensure that the image is ready before doing\n * anything with it, place the loadImageElement() call in preload().\n * You may also supply a callback function to handle the image when it's ready.\n * <br><br>\n * The path to the image should be relative to the HTML file\n * that links in your sketch. Loading an from a URL or other\n * remote location may be blocked due to your browser's built-in\n * security.\n *\n * @method loadImageElement\n * @param  {String} path Path of the image to be loaded\n * @param  {Function(Image)} [successCallback] Function to be called once\n *                                the image is loaded. Will be passed the\n *                                Image.\n * @param  {Function(Event)}    [failureCallback] called with event error if\n *                                the image fails to load.\n * @return {Image}                the Image object",
        "* Draw an image element to the main canvas of the p5js sketch\n *\n * @method imageElement\n * @param  {Image}    imgEl    the image to display\n * @param  {Number}   [sx=0]   The X coordinate of the top left corner of the\n *                             sub-rectangle of the source image to draw into\n *                             the destination canvas.\n * @param  {Number}   [sy=0]   The Y coordinate of the top left corner of the\n *                             sub-rectangle of the source image to draw into\n *                             the destination canvas.\n * @param {Number} [sWidth=imgEl.width] The width of the sub-rectangle of the\n *                                      source image to draw into the destination\n *                                      canvas.\n * @param {Number} [sHeight=imgEl.height] The height of the sub-rectangle of the\n *                                        source image to draw into the\n *                                        destination context.\n * @param  {Number}   [dx=0]    The X coordinate in the destination canvas at\n *                              which to place the top-left corner of the\n *                              source image.\n * @param  {Number}   [dy=0]    The Y coordinate in the destination canvas at\n *                              which to place the top-left corner of the\n *                              source image.\n * @param  {Number}   [dWidth]  The width to draw the image in the destination\n *                              canvas. This allows scaling of the drawn image.\n * @param  {Number}   [dHeight] The height to draw the image in the destination\n *                              canvas. This allows scaling of the drawn image.\n * @example\n * <div>\n * <code>\n * var imgEl;\n * function preload() {\n *   imgEl = loadImageElement(\"assets/laDefense.jpg\");\n * }\n * function setup() {\n *   imageElement(imgEl, 0, 0);\n *   imageElement(imgEl, 0, 0, 100, 100);\n *   imageElement(imgEl, 0, 0, 100, 100, 0, 0, 100, 100);\n * }\n * </code>\n * </div>\n * <div>\n * <code>\n * function setup() {\n *   // here we use a callback to display the image after loading\n *   loadImageElement(\"assets/laDefense.jpg\", function(imgEl) {\n *     imageElement(imgEl, 0, 0);\n *   });\n * }\n * </code>\n * </div>\n *\n * @alt\n * image of the underside of a white umbrella and grided ceiling above\n * image of the underside of a white umbrella and grided ceiling above\n *",
        "* Validates clipping params. Per drawImage spec sWidth and sHight cannot be\n   * negative or greater than image intrinsic width and height\n   * @private\n   * @param {Number} sVal\n   * @param {Number} iVal\n   * @returns {Number}\n   * @private",
        "* A Group containing all the sprites in the sketch.\n*\n* @property allSprites\n* @for p5.play\n* @type {Group}",
        "* A Sprite is the main building block of p5.play:\n   * an element able to store images or animations with a set of\n   * properties such as position and visibility.\n   * A Sprite can have a collider that defines the active area to detect\n   * collisions or overlappings with other sprites and mouse interactions.\n   *\n   * Sprites created using createSprite (the preferred way) are added to the\n   * allSprites group and given a depth value that puts it in front of all\n   * other sprites.\n   *\n   * @method createSprite\n   * @param {Number} x Initial x coordinate\n   * @param {Number} y Initial y coordinate\n   * @param {Number} width Width of the placeholder rectangle and of the\n   *                       collider until an image or new collider are set\n   * @param {Number} height Height of the placeholder rectangle and of the\n   *                       collider until an image or new collider are set\n   * @return {Object} The new sprite instance",
        "* Removes a Sprite from the sketch.\n   * The removed Sprite won't be drawn or updated anymore.\n   * Equivalent to Sprite.remove()\n   *\n   * @method removeSprite\n   * @param {Object} sprite Sprite to be removed",
        "* Updates all the sprites in the sketch (position, animation...)\n* it's called automatically at every draw().\n* It can be paused by passing a parameter true or false;\n* Note: it does not render the sprites.\n*\n* @method updateSprites\n* @param {Boolean} updating false to pause the update, true to resume",
        "* Returns all the sprites in the sketch as an array\n*\n* @method getSprites\n* @return {Array} Array of Sprites",
        "* Displays a Group of sprites.\n* If no parameter is specified, draws all sprites in the\n* sketch.\n* The drawing order is determined by the Sprite property \"depth\"\n*\n* @method drawSprites\n* @param {Group} [group] Group of Sprites to be displayed",
        "* Displays a Sprite.\n* To be typically used in the main draw function.\n*\n* @method drawSprite\n* @param {Sprite} sprite Sprite to be displayed",
        "* Loads an animation.\n* To be typically used in the preload() function of the sketch.\n*\n* @method loadAnimation\n* @param {Sprite} sprite Sprite to be displayed",
        "* Loads a Sprite Sheet.\n * To be typically used in the preload() function of the sketch.\n *\n * @method loadSpriteSheet",
        "* Displays an animation.\n*\n* @method animation\n* @param {Animation} anim Animation to be displayed\n* @param {Number} x X coordinate\n* @param {Number} y Y coordinate\n*",
        "* Detects if a key was pressed during the last cycle.\n* It can be used to trigger events once, when a key is pressed or released.\n* Example: Super Mario jumping.\n*\n* @method keyWentDown\n* @param {Number|String} key Key code or character\n* @return {Boolean} True if the key was pressed",
        "* Detects if a key was released during the last cycle.\n* It can be used to trigger events once, when a key is pressed or released.\n* Example: Spaceship shooting.\n*\n* @method keyWentUp\n* @param {Number|String} key Key code or character\n* @return {Boolean} True if the key was released",
        "* Detects if a key is currently pressed\n* Like p5 keyIsDown but accepts strings and codes\n*\n* @method keyDown\n* @param {Number|String} key Key code or character\n* @return {Boolean} True if the key is down",
        "* Detects if a key is in the given state during the last cycle.\n * Helper method encapsulating common key state logic; it may be preferable\n * to call keyDown or other methods directly.\n *\n * @private\n * @method _isKeyInState\n * @param {Number|String} key Key code or character\n * @param {Number} state Key state to check against\n * @return {Boolean} True if the key is in the given state",
        "* Detects if a mouse button is currently down\n* Combines mouseIsPressed and mouseButton of p5\n*\n* @method mouseDown\n* @param {Number} [buttonCode] Mouse button constant LEFT, RIGHT or CENTER\n* @return {Boolean} True if the button is down",
        "* Detects if a mouse button is currently up\n* Combines mouseIsPressed and mouseButton of p5\n*\n* @method mouseUp\n* @param {Number} [buttonCode] Mouse button constant LEFT, RIGHT or CENTER\n* @return {Boolean} True if the button is up",
        "* Detects if a mouse button was released during the last cycle.\n * It can be used to trigger events once, to be checked in the draw cycle\n *\n * @method mouseWentUp\n * @param {Number} [buttonCode] Mouse button constant LEFT, RIGHT or CENTER\n * @return {Boolean} True if the button was just released",
        "* Detects if a mouse button was pressed during the last cycle.\n * It can be used to trigger events once, to be checked in the draw cycle\n *\n * @method mouseWentDown\n * @param {Number} [buttonCode] Mouse button constant LEFT, RIGHT or CENTER\n * @return {Boolean} True if the button was just pressed",
        "* Returns a constant for a mouse state given a string or a mouse button constant.\n *\n * @private\n * @method _clickKeyFromString\n * @param {Number|String} [buttonCode] Mouse button constant LEFT, RIGHT or CENTER\n *   or string 'leftButton', 'rightButton', or 'centerButton'\n * @return {Number} Mouse button constant LEFT, RIGHT or CENTER or value of buttonCode",
        "* Detects if a mouse button is in the given state during the last cycle.\n * Helper method encapsulating common mouse button state logic; it may be\n * preferable to call mouseWentUp, etc, directly.\n *\n * @private\n * @method _isMouseButtonInState\n * @param {Number|String} [buttonCode] Mouse button constant LEFT, RIGHT or CENTER\n *   or string 'leftButton', 'rightButton', or 'centerButton'\n * @param {Number} state\n * @return {boolean} True if the button was in the given state",
        "* An object storing all useful keys for easy access\n * Key.tab = 9\n *\n * @private\n * @property KEY\n * @type {Object}",
        "* An object storing deprecated key aliases, which we still support but\n * should be mapped to valid aliases and generate warnings.\n *\n * @private\n * @property KEY_DEPRECATIONS\n * @type {Object}",
        "* Given a string key alias (as defined in the KEY property above), look up\n * and return the numeric JavaScript key code for that key.  If a deprecated\n * alias is passed (as defined in the KEY_DEPRECATIONS property) it will be\n * mapped to a valid key code, but will also generate a warning about use\n * of the deprecated alias.\n *\n * @private\n * @method _keyCodeFromAlias\n * @param {!string} alias - a case-insensitive key alias\n * @return {number|undefined} a numeric JavaScript key code, or undefined\n *          if no key code matching the given alias is found.",
        "* Turns the quadTree on or off.\n* A quadtree is a data structure used to optimize collision detection.\n* It can improve performance when there is a large number of Sprites to be\n* checked continuously for overlapping.\n*\n* p5.play will create and update a quadtree automatically, however it is\n* inactive by default.\n*\n* @method useQuadTree\n* @param {Boolean} use Pass true to enable, false to disable",
        "* A Sprite is the main building block of p5.play:\n   * an element able to store images or animations with a set of\n   * properties such as position and visibility.\n   * A Sprite can have a collider that defines the active area to detect\n   * collisions or overlappings with other sprites and mouse interactions.\n   *\n   * To create a Sprite, use\n   * {{#crossLink \"p5.play/createSprite:method\"}}{{/crossLink}}.\n   *\n   * @class Sprite",
        "* The sprite's position of the sprite as a vector (x,y).\n  * @property position\n  * @type {p5.Vector}",
        "* The sprite's position at the beginning of the last update as a vector (x,y).\n  * @property previousPosition\n  * @type {p5.Vector}",
        "* The sprite's velocity as a vector (x,y)\n  * Velocity is speed broken down to its vertical and horizontal components.\n  *\n  * @property velocity\n  * @type {p5.Vector}",
        "* Set a limit to the sprite's scalar speed regardless of the direction.\n  * The value can only be positive. If set to -1, there's no limit.\n  *\n  * @property maxSpeed\n  * @type {Number}\n  * @default -1",
        "* Friction factor, reduces the sprite's velocity.\n  * The friction should be close to 0 (eg. 0.01)\n  * 0: no friction\n  * 1: full friction\n  *\n  * @property friction\n  * @type {Number}\n  * @default 0",
        "* The sprite's current collider.\n  * It can either be an Axis Aligned Bounding Box (a non-rotated rectangle)\n  * or a circular collider.\n  * If the sprite is checked for collision, bounce, overlapping or mouse events the\n  * collider is automatically created from the width and height\n  * of the sprite or from the image dimension in case of animate sprites\n  *\n  * You can set a custom collider with Sprite.setCollider\n  *\n  * @property collider\n  * @type {Object}",
        "* Object containing information about the most recent collision/overlapping\n  * To be typically used in combination with Sprite.overlap or Sprite.collide\n  * functions.\n  * The properties are touching.left, touching.right, touching.top,\n  * touching.bottom and are either true or false depending on the side of the\n  * collider.\n  *\n  * @property touching\n  * @type {Object}",
        "* The mass determines the velocity transfer when sprites bounce\n  * against each other. See Sprite.bounce\n  * The higher the mass the least the sprite will be affected by collisions.\n  *\n  * @property mass\n  * @type {Number}\n  * @default 1",
        "* If set to true the sprite won't bounce or be displaced by collisions\n  * Simulates an infinite mass or an anchored object.\n  *\n  * @property immovable\n  * @type {Boolean}\n  * @default false",
        "* Coefficient of restitution. The velocity lost after bouncing.\n  * 1: perfectly elastic, no energy is lost\n  * 0: perfectly inelastic, no bouncing\n  * less than 1: inelastic, this is the most common in nature\n  * greater than 1: hyper elastic, energy is increased like in a pinball bumper\n  *\n  * @property restitution\n  * @type {Number}\n  * @default 1",
        "* Rotation in degrees of the visual element (image or animation)\n  * Note: this is not the movement's direction, see getDirection.\n  *\n  * @property rotation\n  * @type {Number}\n  * @default 0",
        "* Internal rotation variable (expressed in degrees).\n  * Note: external callers access this through the rotation property above.\n  *\n  * @private\n  * @property _rotation\n  * @type {Number}\n  * @default 0",
        "* Rotation change in degrees per frame of thevisual element (image or animation)\n  * Note: this is not the movement's direction, see getDirection.\n  *\n  * @property rotationSpeed\n  * @type {Number}\n  * @default 0",
        "* Automatically lock the rotation property of the visual element\n  * (image or animation) to the sprite's movement direction and vice versa.\n  *\n  * @property rotateToDirection\n  * @type {Boolean}\n  * @default false",
        "* Determines the rendering order within a group: a sprite with\n  * lower depth will appear below the ones with higher depth.\n  *\n  * Note: drawing a group before another with drawSprites will make\n  * its members appear below the second one, like in normal p5 canvas\n  * drawing.\n  *\n  * @property depth\n  * @type {Number}\n  * @default One more than the greatest existing sprite depth, when calling\n  *          createSprite().  When calling new Sprite() directly, depth will\n  *          initialize to 0 (not recommended).",
        "* Determines the sprite's scale.\n  * Example: 2 will be twice the native size of the visuals,\n  * 0.5 will be half. Scaling up may make images blurry.\n  *\n  * @property scale\n  * @type {Number}\n  * @default 1",
        "* The sprite's visibility.\n  *\n  * @property visible\n  * @type {Boolean}\n  * @default true",
        "* If set to true sprite will track its mouse state.\n  * the properties mouseIsPressed and mouseIsOver will be updated.\n  * Note: automatically set to true if the functions\n  * onMouseReleased or onMousePressed are set.\n  *\n  * @property mouseActive\n  * @type {Boolean}\n  * @default false",
        "* True if mouse is on the sprite's collider.\n  * Read only.\n  *\n  * @property mouseIsOver\n  * @type {Boolean}",
        "* True if mouse is pressed on the sprite's collider.\n  * Read only.\n  *\n  * @property mouseIsPressed\n  * @type {Boolean}",
        "* Width of the sprite's current image.\n  * If no images or animations are set it's the width of the\n  * placeholder rectangle.\n  * Used internally to make calculations and draw the sprite.\n  *\n  * @private\n  * @property _internalWidth\n  * @type {Number}\n  * @default 100",
        "* Height of the sprite's current image.\n  * If no images or animations are set it's the height of the\n  * placeholder rectangle.\n  * Used internally to make calculations and draw the sprite.\n  *\n  * @private\n  * @property _internalHeight\n  * @type {Number}\n  * @default 100",
        "* @type {number}\n   * @private\n   * _horizontalStretch is the value to scale animation sprites in the X direction",
        "* @type {number}\n   * @private\n   * _verticalStretch is the value to scale animation sprites in the Y direction",
        "* _internalWidth and _internalHeight are used for all p5.play\n   * calculations, but width and height can be extended. For example,\n   * you may want users to always get and set a scaled width:\n      Object.defineProperty(this, 'width', {\n        enumerable: true,\n        configurable: true,\n        get: function() {\n          return this._internalWidth * this.scale;\n        },\n        set: function(value) {\n          this._internalWidth = value / this.scale;\n        }\n      });",
        "* Width of the sprite's current image.\n  * If no images or animations are set it's the width of the\n  * placeholder rectangle.\n  *\n  * @property width\n  * @type {Number}\n  * @default 100",
        "* Height of the sprite's current image.\n  * If no images or animations are set it's the height of the\n  * placeholder rectangle.\n  *\n  * @property height\n  * @type {Number}\n  * @default 100",
        "* Unscaled width of the sprite\n  * If no images or animations are set it's the width of the\n  * placeholder rectangle.\n  *\n  * @property originalWidth\n  * @type {Number}\n  * @default 100",
        "* Unscaled height of the sprite\n  * If no images or animations are set it's the height of the\n  * placeholder rectangle.\n  *\n  * @property originalHeight\n  * @type {Number}\n  * @default 100",
        "* Gets the scaled width of the sprite.\n   *\n   * @method getScaledWidth\n   * @return {Number} Scaled width",
        "* Gets the scaled height of the sprite.\n   *\n   * @method getScaledHeight\n   * @return {Number} Scaled height",
        "* True if the sprite has been removed.\n  *\n  * @property removed\n  * @type {Boolean}",
        "* Cycles before self removal.\n  * Set it to initiate a countdown, every draw cycle the property is\n  * reduced by 1 unit. At 0 it will call a sprite.remove()\n  * Disabled if set to -1.\n  *\n  * @property life\n  * @type {Number}\n  * @default -1",
        "* If set to true, draws an outline of the collider, the depth, and center.\n  *\n  * @property debug\n  * @type {Boolean}\n  * @default false",
        "* If no image or animations are set this is the color of the\n  * placeholder rectangle\n  *\n  * @property shapeColor\n  * @type {color}",
        "* Groups the sprite belongs to, including allSprites\n  *\n  * @property groups\n  * @type {Array}",
        "* Reference to the current animation.\n  *\n  * @property animation\n  * @type {Animation}",
        "* Swept collider oriented along the current velocity vector, extending to\n   * cover the old and new positions of the sprite.\n   *\n   * The corners of the swept collider will extend beyond the actual swept\n   * shape, but it should be sufficient for broad-phase detection of collision\n   * candidates.\n   *\n   * Note that this collider will have no dimensions if the source sprite has no\n   * velocity.",
        "* Sprite x position (alias to position.x).\n  *\n  * @property x\n  * @type {Number}",
        "* Sprite y position (alias to position.y).\n  *\n  * @property y\n  * @type {Number}",
        "* Sprite x velocity (alias to velocity.x).\n  *\n  * @property velocityX\n  * @type {Number}",
        "* Sprite y velocity (alias to velocity.y).\n  *\n  * @property velocityY\n  * @type {Number}",
        "* Sprite lifetime (alias to life).\n  *\n  * @property lifetime\n  * @type {Number}",
        "* Sprite bounciness (alias to restitution).\n  *\n  * @property bounciness\n  * @type {Number}",
        "* Sprite animation frame delay (alias to animation.frameDelay).\n  *\n  * @property frameDelay\n  * @type {Number}",
        "* If the sprite is moving, use the swept collider. Otherwise use the actual\n   * collider.",
        "* Returns true if the two sprites crossed paths in the current frame,\n   * indicating a possible collision.",
        "* @private\n   * Keep animation properties in sync with how the animation changes.",
        "* Updates the sprite.\n  * Called automatically at the beginning of the draw cycle.\n  *\n  * @method update",
        "* Creates a default collider matching the size of the\n   * placeholder rectangle or the bounding box of the image.\n   *\n   * @method setDefaultCollider",
        "* Updates the sprite mouse states and triggers the mouse events:\n   * onMouseOver, onMouseOut, onMousePressed, onMouseReleased\n   *\n   * @method mouseUpdate",
        "* Sets a collider for the sprite.\n  *\n  * In p5.play a Collider is an invisible circle or rectangle\n  * that can have any size or position relative to the sprite and which\n  * will be used to detect collisions and overlapping with other sprites,\n  * or the mouse cursor.\n  *\n  * If the sprite is checked for collision, bounce, overlapping or mouse events\n  * a rectangle collider is automatically created from the width and height\n  * parameter passed at the creation of the sprite or the from the image\n  * dimension in case of animated sprites.\n  *\n  * Often the image bounding box is not appropriate as the active area for\n  * collision detection so you can set a circular or rectangular sprite with\n  * different dimensions and offset from the sprite's center.\n  *\n  * There are many ways to call this method.  The first argument determines the\n  * type of collider you are creating, which in turn changes the remaining\n  * arguments.  Valid collider types are:\n  *\n  * * `point` - A point collider with no dimensions, only a position.\n  *\n  *   `setCollider(\"point\"[, offsetX, offsetY])`\n  *\n  * * `circle` - A circular collider with a set radius.\n  *\n  *   `setCollider(\"circle\"[, offsetX, offsetY[, radius])`\n  *\n  * * `rectangle` - An alias for `aabb`, below.\n  *\n  * * `aabb` - An axis-aligned bounding box - has width and height but no rotation.\n  *\n  *   `setCollider(\"aabb\"[, offsetX, offsetY[, width, height]])`\n  *\n  * * `obb` - An oriented bounding box - has width, height, and rotation.\n  *\n  *   `setCollider(\"obb\"[, offsetX, offsetY[, width, height[, rotation]]])`\n  *\n  *\n  * @method setCollider\n  * @param {String} type One of \"point\", \"circle\", \"rectangle\", \"aabb\" or \"obb\"\n  * @param {Number} [offsetX] Collider x position from the center of the sprite\n  * @param {Number} [offsetY] Collider y position from the center of the sprite\n  * @param {Number} [width] Collider width or radius\n  * @param {Number} [height] Collider height\n  * @param {Number} [rotation] Collider rotation in degrees\n  * @throws {TypeError} if given invalid parameters.",
        "* Sets the sprite's horizontal mirroring.\n  * If 1 the images displayed normally\n  * If -1 the images are flipped horizontally\n  * If no argument returns the current x mirroring\n  *\n  * @method mirrorX\n  * @param {Number} dir Either 1 or -1\n  * @return {Number} Current mirroring if no parameter is specified",
        "* Sets the sprite's vertical mirroring.\n  * If 1 the images displayed normally\n  * If -1 the images are flipped vertically\n  * If no argument returns the current y mirroring\n  *\n  * @method mirrorY\n  * @param {Number} dir Either 1 or -1\n  * @return {Number} Current mirroring if no parameter is specified",
        "* Returns the value the sprite should be scaled in the X direction.\n   * Used to calculate rendering and collisions.\n   * When _fixedSpriteAnimationFrameSizes is set, the scale value should\n   * include the horizontal stretch for animations.\n   * @private",
        "* Returns the value the sprite should be scaled in the Y direction.\n   * Used to calculate rendering and collisions.\n   * When _fixedSpriteAnimationFrameSizes is set, the scale value should\n   * include the vertical stretch for animations.\n   * @private",
        "* Manages the positioning, scale and rotation of the sprite\n   * Called automatically, it should not be overridden\n   * @private\n   * @final\n   * @method display",
        "* Manages the visuals of the sprite.\n  * It can be overridden with a custom drawing function.\n  * The 0,0 point will be the center of the sprite.\n  * Example:\n  * sprite.draw = function() { ellipse(0,0,10,10) }\n  * Will display the sprite as circle.\n  *\n  * @method draw",
        "* Removes the Sprite from the sketch.\n   * The removed Sprite won't be drawn or updated anymore.\n   *\n   * @method remove",
        "* Alias for <a href='#method-remove'>remove()</a>\n   *\n   * @method destroy",
        "* Sets the velocity vector.\n  *\n  * @method setVelocity\n  * @param {Number} x X component\n  * @param {Number} y Y component",
        "* Calculates the scalar speed.\n  *\n  * @method getSpeed\n  * @return {Number} Scalar speed",
        "* Calculates the movement's direction in degrees.\n  *\n  * @method getDirection\n  * @return {Number} Angle in degrees",
        "* Adds the sprite to an existing group\n  *\n  * @method addToGroup\n  * @param {Object} group",
        "* Limits the scalar speed.\n  *\n  * @method limitSpeed\n  * @param {Number} max Max speed: positive number",
        "* Set the speed and direction of the sprite.\n  * The action overwrites the current velocity.\n  * If direction is not supplied, the current direction is maintained.\n  * If direction is not supplied and there is no current velocity, the current\n  * rotation angle used for the direction.\n  *\n  * @method setSpeed\n  * @param {Number}  speed Scalar speed\n  * @param {Number}  [angle] Direction in degrees",
        "* Alias for <a href='#method-setSpeed'>setSpeed()</a>\n   *\n   * @method setSpeedAndDirection\n   * @param {Number}  speed Scalar speed\n   * @param {Number}  [angle] Direction in degrees",
        "* Alias for <a href='Animation.html#method-changeFrame'>animation.changeFrame()</a>\n  *\n  * @method setFrame\n  * @param {Number} frame Frame number (starts from 0).",
        "* Alias for <a href='Animation.html#method-nextFrame'>animation.nextFrame()</a>\n  *\n  * @method nextFrame",
        "* Alias for <a href='Animation.html#method-previousFrame'>animation.previousFrame()</a>\n  *\n  * @method previousFrame",
        "* Alias for <a href='Animation.html#method-stop'>animation.stop()</a>\n  *\n  * @method pause",
        "* Alias for <a href='Animation.html#method-play'>animation.play()</a> with extra logic\n   *\n   * Plays/resumes the sprite's current animation.\n   * If the animation is currently playing this has no effect.\n   * If the animation has stopped at its last frame, this will start it over\n   * at the beginning.\n   *\n   * @method play",
        "* Wrapper to access <a href='Animation.html#prop-frameChanged'>animation.frameChanged</a>\n   *\n   * @method frameDidChange\n   * @return {Boolean} true if the animation frame has changed",
        "* Rotate the sprite towards a specific position\n  *\n  * @method setFrame\n  * @param {Number} x Horizontal coordinate to point to\n  * @param {Number} y Vertical coordinate to point to",
        "* Pushes the sprite in a direction defined by an angle.\n  * The force is added to the current velocity.\n  *\n  * @method addSpeed\n  * @param {Number}  speed Scalar speed to add\n  * @param {Number}  angle Direction in degrees",
        "* Pushes the sprite toward a point.\n  * The force is added to the current velocity.\n  *\n  * @method attractionPoint\n  * @param {Number}  magnitude Scalar speed to add\n  * @param {Number}  pointX Direction x coordinate\n  * @param {Number}  pointY Direction y coordinate",
        "* Adds an image to the sprite.\n  * An image will be considered a one-frame animation.\n  * The image should be preloaded in the preload() function using p5 loadImage.\n  * Animations require a identifying label (string) to change them.\n  * The image is stored in the sprite but not necessarily displayed\n  * until Sprite.changeAnimation(label) is called\n  *\n  * Usages:\n  * - sprite.addImage(label, image);\n  * - sprite.addImage(image);\n  *\n  * If only an image is passed no label is specified\n  *\n  * @method addImage\n  * @param {String|p5.Image} label Label or image\n  * @param {p5.Image} [img] Image",
        "* Adds an animation to the sprite.\n  * The animation should be preloaded in the preload() function\n  * using loadAnimation.\n  * Animations require a identifying label (string) to change them.\n  * Animations are stored in the sprite but not necessarily displayed\n  * until Sprite.changeAnimation(label) is called.\n  *\n  * Usage:\n  * - sprite.addAnimation(label, animation);\n  *\n  * Alternative usages. See Animation for more information on file sequences:\n  * - sprite.addAnimation(label, firstFrame, lastFrame);\n  * - sprite.addAnimation(label, frame1, frame2, frame3...);\n  *\n  * @method addAnimation\n  * @param {String} label Animation identifier\n  * @param {Animation} animation The preloaded animation",
        "* Changes the displayed image/animation.\n  * Equivalent to changeAnimation\n  *\n  * @method changeImage\n  * @param {String} label Image/Animation identifier",
        "* Returns the label of the current animation\n  *\n  * @method getAnimationLabel\n  * @return {String} label Image/Animation identifier",
        "* Changes the displayed animation.\n  * See Animation for more control over the sequence.\n  *\n  * @method changeAnimation\n  * @param {String} label Animation identifier",
        "* Sets the animation from a list in _predefinedSpriteAnimations.\n  *\n  * @method setAnimation\n  * @private\n  * @param {String} label Animation identifier",
        "* Checks if the given point corresponds to a transparent pixel\n  * in the sprite's current image. It can be used to check a point collision\n  * against only the visible part of the sprite.\n  *\n  * @method overlapPixel\n  * @param {Number} pointX x coordinate of the point to check\n  * @param {Number} pointY y coordinate of the point to check\n  * @return {Boolean} result True if non-transparent",
        "* Checks if the given point is inside the sprite's collider.\n  *\n  * @method overlapPoint\n  * @param {Number} pointX x coordinate of the point to check\n  * @param {Number} pointY y coordinate of the point to check\n  * @return {Boolean} result True if inside",
        "* Checks if the the sprite is overlapping another sprite or a group.\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the overlap occours.\n  * If the target is a group the function will be called for each single\n  * sprite overlapping. The parameter of the function are respectively the\n  * current sprite and the colliding sprite.\n  *\n  * @example\n  *     sprite.overlap(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method overlap\n  * @param {Object} target Sprite or group to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping",
        "* Alias for <a href='#method-overlap'>overlap()</a>, except without a\n   * callback parameter.\n   * The check is performed using the colliders. If colliders are not set\n   * they will be created automatically from the image/animation bounding box.\n   *\n   * Returns whether or not this sprite is overlapping another sprite\n   * or group. Modifies the sprite's touching property object.\n   *\n   * @method isTouching\n   * @param {Object} target Sprite or group to check against the current one\n   * @return {Boolean} True if touching",
        "* Checks if the the sprite is overlapping another sprite or a group.\n  * If the overlap is positive the sprite will bounce with the target(s)\n  * treated as immovable with a restitution coefficient of zero.\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the collision occours.\n  * If the target is a group the function will be called for each single\n  * sprite colliding. The parameter of the function are respectively the\n  * current sprite and the colliding sprite.\n  *\n  * @example\n  *     sprite.collide(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method collide\n  * @param {Object} target Sprite or group to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping",
        "* Checks if the the sprite is overlapping another sprite or a group.\n  * If the overlap is positive the current sprite will displace\n  * the colliding one to the closest non-overlapping position.\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the collision occours.\n  * If the target is a group the function will be called for each single\n  * sprite colliding. The parameter of the function are respectively the\n  * current sprite and the colliding sprite.\n  *\n  * @example\n  *     sprite.displace(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method displace\n  * @param {Object} target Sprite or group to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping",
        "* Checks if the the sprite is overlapping another sprite or a group.\n  * If the overlap is positive the sprites will bounce affecting each\n  * other's trajectories depending on their .velocity, .mass and .restitution\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the collision occours.\n  * If the target is a group the function will be called for each single\n  * sprite colliding. The parameter of the function are respectively the\n  * current sprite and the colliding sprite.\n  *\n  * @example\n  *     sprite.bounce(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method bounce\n  * @param {Object} target Sprite or group to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping",
        "* Checks if the the sprite is overlapping another sprite or a group.\n  * If the overlap is positive the sprite will bounce with the target(s)\n  * treated as immovable.\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the collision occours.\n  * If the target is a group the function will be called for each single\n  * sprite colliding. The parameter of the function are respectively the\n  * current sprite and the colliding sprite.\n  *\n  * @example\n  *     sprite.bounceOff(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method bounceOff\n  * @param {Object} target Sprite or group to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping",
        "* Internal collision detection function. Do not use directly.\n   *\n   * Handles collision with individual sprites or with groups, using the\n   * quadtree to optimize the latter.\n   *\n   * @method _collideWith\n   * @private\n   * @param {string} type - 'overlap', 'isTouching', 'displace', 'collide',\n   *   'bounce' or 'bounceOff'\n   * @param {Sprite|Group} target\n   * @param {function} callback - if collision occurred (ignored for 'isTouching')\n   * @return {boolean} true if a collision occurred",
        "* Helper collision method for colliding this sprite with one other sprite.\n   *\n   * Has the side effect of setting this.touching properties to TRUE if collisions\n   * occur.\n   *\n   * @method _collideWithOne\n   * @private\n   * @param {string} type - 'overlap', 'isTouching', 'displace', 'collide',\n   *   'bounce' or 'bounceOff'\n   * @param {Sprite} other\n   * @param {function} callback - if collision occurred (ignored for 'isTouching')\n   * @return {boolean} true if a collision occurred",
        "* A camera facilitates scrolling and zooming for scenes extending beyond\n   * the canvas. A camera has a position, a zoom factor, and the mouse\n   * coordinates relative to the view.\n   * The camera is automatically created on the first draw cycle.\n   *\n   * In p5.js terms the camera wraps the whole drawing cycle in a\n   * transformation matrix but it can be disable anytime during the draw\n   * cycle for example to draw interface elements in an absolute position.\n   *\n   * @class Camera\n   * @constructor\n   * @param {Number} x Initial x coordinate\n   * @param {Number} y Initial y coordinate\n   * @param {Number} zoom magnification\n   *",
        "* Camera position. Defines the global offset of the sketch.\n  *\n  * @property position\n  * @type {p5.Vector}",
        "* Camera x position. Defines the horizontal global offset of the sketch.\n  *\n  * @property x\n  * @type {Number}",
        "* Camera y position. Defines the horizontal global offset of the sketch.\n  *\n  * @property y\n  * @type {Number}",
        "* Camera zoom. Defines the global scale of the sketch.\n  * A scale of 1 will be the normal size. Setting it to 2 will make everything\n  * twice the size. .5 will make everything half size.\n  *\n  * @property zoom\n  * @type {Number}",
        "* MouseX translated to the camera view.\n  * Offsetting and scaling the canvas will not change the sprites' position\n  * nor the mouseX and mouseY variables. Use this property to read the mouse\n  * position if the camera moved or zoomed.\n  *\n  * @property mouseX\n  * @type {Number}",
        "* MouseY translated to the camera view.\n  * Offsetting and scaling the canvas will not change the sprites' position\n  * nor the mouseX and mouseY variables. Use this property to read the mouse\n  * position if the camera moved or zoomed.\n  *\n  * @property mouseY\n  * @type {Number}",
        "* True if the camera is active.\n  * Read only property. Use the methods Camera.on() and Camera.off()\n  * to enable or disable the camera.\n  *\n  * @property active\n  * @type {Boolean}",
        "* Check to see if the camera is active.\n  * Use the methods Camera.on() and Camera.off()\n  * to enable or disable the camera.\n  *\n  * @method isActive\n  * @return {Boolean} true if the camera is active",
        "* Activates the camera.\n  * The canvas will be drawn according to the camera position and scale until\n  * Camera.off() is called\n  *\n  * @method on",
        "* Deactivates the camera.\n  * The canvas will be drawn normally, ignoring the camera's position\n  * and scale until Camera.on() is called\n  *\n  * @method off",
        "* In p5.play groups are collections of sprites with similar behavior.\n   * For example a group may contain all the sprites in the background\n   * or all the sprites that \"kill\" the player.\n   *\n   * Groups are \"extended\" arrays and inherit all their properties\n   * e.g. group.length\n   *\n   * Since groups contain only references, a sprite can be in multiple\n   * groups and deleting a group doesn't affect the sprites themselves.\n   *\n   * Sprite.remove() will also remove the sprite from all the groups\n   * it belongs to.\n   *\n   * @class Group\n   * @constructor",
        "* Gets the member at index i.\n  *\n  * @method get\n  * @param {Number} i The index of the object to retrieve",
        "* Checks if the group contains a sprite.\n  *\n  * @method contains\n  * @param {Sprite} sprite The sprite to search\n  * @return {Number} Index or -1 if not found",
        "* Same as Group.contains\n   * @method indexOf",
        "* Adds a sprite to the group.\n  *\n  * @method add\n  * @param {Sprite} s The sprite to be added",
        "* Same as group.length\n   * @method size",
        "* Removes all the sprites in the group\n  * from the scene.\n  *\n  * @method removeSprites",
        "* Removes all references to the group.\n  * Does not remove the actual sprites.\n  *\n  * @method clear",
        "* Removes a sprite from the group.\n  * Does not remove the actual sprite, only the affiliation (reference).\n  *\n  * @method remove\n  * @param {Sprite} item The sprite to be removed\n  * @return {Boolean} True if sprite was found and removed",
        "* Returns a copy of the group as standard array.\n   * @method toArray",
        "* Returns the highest depth in a group\n  *\n  * @method maxDepth\n  * @return {Number} The depth of the sprite drawn on the top",
        "* Returns the lowest depth in a group\n  *\n  * @method minDepth\n  * @return {Number} The depth of the sprite drawn on the bottom",
        "* Draws all the sprites in the group.\n  *\n  * @method draw",
        "* Collide each member of group against the target using the given collision\n   * type.  Return true if any collision occurred.\n   * Internal use\n   *\n   * @private\n   * @method _groupCollide\n   * @param {!string} type one of 'overlap', 'collide', 'displace', 'bounce' or 'bounceOff'\n   * @param {Object} target Group or Sprite\n   * @param {Function} [callback] on collision.\n   * @return {boolean} True if any collision/overlap occurred",
        "* Checks if the the group is overlapping another group or sprite.\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the overlap occurs.\n  * The function will be called for each single sprite overlapping.\n  * The parameter of the function are respectively the\n  * member of the current group and the other sprite passed as parameter.\n  *\n  * @example\n  *     group.overlap(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method overlap\n  * @param {Object} target Group or Sprite to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping",
        "* Alias for <a href='#method-overlap'>overlap()</a>\n   *\n   * Returns whether or not this group will bounce or collide with another sprite\n   * or group. Modifies the each sprite's touching property object.\n   *\n   * @method isTouching\n   * @param {Object} target Group or Sprite to check against the current one\n   * @return {Boolean} True if touching",
        "* Checks if the the group is overlapping another group or sprite.\n  * If the overlap is positive the sprites will bounce with the target(s)\n  * treated as immovable with a restitution coefficient of zero.\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the overlap occours.\n  * The function will be called for each single sprite overlapping.\n  * The parameter of the function are respectively the\n  * member of the current group and the other sprite passed as parameter.\n  *\n  * @example\n  *     group.collide(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method collide\n  * @param {Object} target Group or Sprite to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping",
        "* Checks if the the group is overlapping another group or sprite.\n  * If the overlap is positive the sprites in the group will displace\n  * the colliding ones to the closest non-overlapping positions.\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the overlap occurs.\n  * The function will be called for each single sprite overlapping.\n  * The parameter of the function are respectively the\n  * member of the current group and the other sprite passed as parameter.\n  *\n  * @example\n  *     group.displace(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method displace\n  * @param {Object} target Group or Sprite to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping",
        "* Checks if the the group is overlapping another group or sprite.\n  * If the overlap is positive the sprites will bounce affecting each\n  * other's trajectories depending on their .velocity, .mass and .restitution.\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the overlap occours.\n  * The function will be called for each single sprite overlapping.\n  * The parameter of the function are respectively the\n  * member of the current group and the other sprite passed as parameter.\n  *\n  * @example\n  *     group.bounce(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method bounce\n  * @param {Object} target Group or Sprite to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping",
        "* Checks if the the group is overlapping another group or sprite.\n  * If the overlap is positive the sprites will bounce with the target(s)\n  * treated as immovable.\n  *\n  * The check is performed using the colliders. If colliders are not set\n  * they will be created automatically from the image/animation bounding box.\n  *\n  * A callback function can be specified to perform additional operations\n  * when the overlap occours.\n  * The function will be called for each single sprite overlapping.\n  * The parameter of the function are respectively the\n  * member of the current group and the other sprite passed as parameter.\n  *\n  * @example\n  *     group.bounceOff(otherSprite, explosion);\n  *\n  *     function explosion(spriteA, spriteB) {\n  *       spriteA.remove();\n  *       spriteB.score++;\n  *     }\n  *\n  * @method bounceOff\n  * @param {Object} target Group or Sprite to check against the current one\n  * @param {Function} [callback] The function to be called if overlap is positive\n  * @return {Boolean} True if overlapping",
        "* Creates four edge sprites and adds them to a group. Each edge is just outside\n * of the canvas and has a thickness of 100. After calling this function,\n * the following properties are exposed and populated with sprites:\n * leftEdge, rightEdge, topEdge, bottomEdge\n *\n * The 'edges' property is populated with a group containing those four sprites.\n *\n * If this edge sprites have already been created, the function returns the\n * existing edges group immediately.\n *\n * @method createEdgeSprites\n * @return {Group} The edges group",
        "* An Animation object contains a series of images (p5.Image) that\n * can be displayed sequentially.\n *\n * All files must be png images. You must include the directory from the sketch root,\n * and the extension .png\n *\n * A sprite can have multiple labeled animations, see Sprite.addAnimation\n * and Sprite.changeAnimation, however an animation can be used independently.\n *\n * An animation can be created either by passing a series of file names,\n * no matter how many or by passing the first and the last file name\n * of a numbered sequence.\n * p5.play will try to detect the sequence pattern.\n *\n * For example if the given filenames are\n * \"data/file0001.png\" and \"data/file0005.png\" the images\n * \"data/file0003.png\" and \"data/file0004.png\" will be loaded as well.\n *\n * @example\n *     var sequenceAnimation;\n *     var glitch;\n *\n *     function preload() {\n *       sequenceAnimation = loadAnimation(\"data/walking0001.png\", \"data/walking0005.png\");\n *       glitch = loadAnimation(\"data/dog.png\", \"data/horse.png\", \"data/cat.png\", \"data/snake.png\");\n *     }\n *\n *     function setup() {\n *       createCanvas(800, 600);\n *     }\n *\n *     function draw() {\n *       background(0);\n *       animation(sequenceAnimation, 100, 100);\n *       animation(glitch, 200, 100);\n *     }\n *\n * @class Animation\n * @constructor\n * @param {String} fileName1 First file in a sequence OR first image file\n * @param {String} fileName2 Last file in a sequence OR second image file\n * @param {String} [...fileNameN] Any number of image files after the first two",
        "* Array of frames (p5.Image)\n  *\n  * @property images\n  * @type {Array}",
        "* Delay between frames in number of draw cycles.\n  * If set to 4 the framerate of the anymation would be the\n  * sketch framerate divided by 4 (60fps = 15fps)\n  *\n  * @property frameDelay\n  * @type {Number}\n  * @default 2",
        "* True if the animation is currently playing.\n  *\n  * @property playing\n  * @type {Boolean}\n  * @default true",
        "* Animation visibility.\n  *\n  * @property visible\n  * @type {Boolean}\n  * @default true",
        "* If set to false the animation will stop after reaching the last frame\n  *\n  * @property looping\n  * @type {Boolean}\n  * @default true",
        "* True if frame changed during the last draw cycle\n  *\n  * @property frameChanged\n  * @type {Boolean}",
        "* Objects are passed by reference so to have different sprites\n  * using the same animation you need to clone it.\n  *\n  * @method clone\n  * @return {Animation} A clone of the current animation",
        "* Draws the animation at coordinate x and y.\n   * Updates the frames automatically.\n   *\n   * @method draw\n   * @param {Number} x x coordinate\n   * @param {Number} y y coordinate\n   * @param {Number} [r=0] rotation",
        "* Plays the animation.\n  *\n  * @method play",
        "* Stops the animation.\n  *\n  * @method stop",
        "* Rewinds the animation to the first frame.\n  *\n  * @method rewind",
        "* Changes the current frame.\n  *\n  * @method changeFrame\n  * @param {Number} frame Frame number (starts from 0).",
        "* Goes to the next frame and stops.\n   *\n   * @method nextFrame",
        "* Goes to the previous frame and stops.\n   *\n   * @method previousFrame",
        "* Plays the animation forward or backward toward a target frame.\n  *\n  * @method goToFrame\n  * @param {Number} toFrame Frame number destination (starts from 0)",
        "* Returns the current frame number.\n  *\n  * @method getFrame\n  * @return {Number} Current frame (starts from 0)",
        "* Returns the last frame number.\n  *\n  * @method getLastFrame\n  * @return {Number} Last frame number (starts from 0)",
        "* Returns the current frame image as p5.Image.\n  *\n  * @method getFrameImage\n  * @return {p5.Image} Current frame image",
        "* Returns the frame image at the specified frame number.\n  *\n  * @method getImageAt\n  * @param {Number} frame Frame number\n  * @return {p5.Image} Frame image",
        "* Returns the current frame width in pixels.\n  * If there is no image loaded, returns 1.\n  *\n  * @method getWidth\n  * @return {Number} Frame width",
        "* Returns the current frame height in pixels.\n  * If there is no image loaded, returns 1.\n  *\n  * @method getHeight\n  * @return {Number} Frame height",
        "* Represents a sprite sheet and all it's frames.  To be used with Animation,\n * or static drawing single frames.\n *\n *  There are two different ways to load a SpriteSheet\n *\n * 1. Given width, height that will be used for every frame and the\n *    number of frames to cycle through. The sprite sheet must have a\n *    uniform grid with consistent rows and columns.\n *\n * 2. Given an array of frame objects that define the position and\n *    dimensions of each frame.  This is Flexible because you can use\n *    sprite sheets that don't have uniform rows and columns.\n *\n * @example\n *     // Method 1 - Using width, height for each frame and number of frames\n *     explode_sprite_sheet = loadSpriteSheet('assets/explode_sprite_sheet.png', 171, 158, 11);\n *\n *     // Method 2 - Using an array of objects that define each frame\n *     var player_frames = loadJSON('assets/tiles.json');\n *     player_sprite_sheet = loadSpriteSheet('assets/player_spritesheet.png', player_frames);\n *\n * @class SpriteSheet\n * @constructor\n * @param image String image path or p5.Image object",
        "* Generate the frames data for this sprite sheet baesd on user params\n   * @private\n   * @method _generateSheetFrames",
        "* Draws a specific frame to the canvas.\n   * @param frame_name  Can either be a string name, or a numeric index.\n   * @param x   x position to draw the frame at\n   * @param y   y position to draw the frame at\n   * @param [width]   optional width to draw the frame\n   * @param [height]  optional height to draw the frame\n   * @method drawFrame",
        "* Objects are passed by reference so to have different sprites\n   * using the same animation you need to clone it.\n   *\n   * @method clone\n   * @return {SpriteSheet} A clone of the current SpriteSheet",
        "* Javascript Quadtree\n * based on\n * https://github.com/timohausmann/quadtree-js/\n * Copyright © 2012 Timo Hausmann",
        "* Split the node into 4 subnodes",
        "* Determine the quadtrant for an area in this node",
        "* Insert an object into the node. If the node\n\t * exceeds the capacity, it will split and add all\n\t * objects to their corresponding subnodes.",
        "* Return all objects that could collide with a given area",
        "* Get all objects stored in the quadtree",
        "* Get the node in which a certain object is stored",
        "* Removes a specific object from the quadtree\n\t * Does not delete empty subnodes. See cleanup-function",
        "* Clear the quadtree and delete all objects",
        "* Clean up the quadtree\n\t * Like clear, but objects won't be deleted but re-inserted",
        "* Log a warning message to the host console, using native `console.warn`\n * if it is available but falling back on `console.log` if not.  If no\n * console is available, this method will fail silently.\n * @method _warn\n * @param {!string} message\n * @private",
        "* Collision Shape Base Class\n   *\n   * We have a set of collision shapes available that all conform to\n   * a simple interface so that they can be checked against one another\n   * using the Separating Axis Theorem.\n   *\n   * This base class implements all the required methods for a collision\n   * shape and can be used as a collision point with no changes.\n   * Other shapes should inherit from this and override most methods.\n   *\n   * @class p5.CollisionShape\n   * @constructor\n   * @param {p5.Vector} [center] (zero if omitted)\n   * @param {number} [rotation] (zero if omitted)",
        "* Transform of this shape relative to its parent.  If there is no parent,\n     * this is pretty much the world-space transform.\n     * This should stay consistent with _offset, _rotation and _scale properties.\n     * @property _localTransform\n     * @type {p5.Transform2D}\n     * @protected",
        "* Transform of whatever parent object (probably a sprite) this shape is\n     * associated with.  If this is a free-floating shape, the parent transform\n     * will remain an identity matrix.\n     * @property _parentTransform\n     * @type {p5.Transform2D}\n     * @protected",
        "* The center of the collision shape in world-space.\n     * @property _center\n     * @private\n     * @type {p5.Vector}",
        "* The center of the collision shape in local-space; also, the offset of the\n     * collision shape's center from its parent sprite's center.\n     * @property _offset\n     * @type {p5.Vector}\n     * @private",
        "* Rotation in radians in local space (relative to parent).\n     * Note that this will only be meaningful for shapes that can rotate,\n     * i.e. Oriented Bounding Boxes\n     * @property _rotation\n     * @private\n     * @type {number}",
        "* Scale X and Y in local space.  Note that this will only be meaningful\n     * for shapes that have dimensions (e.g. not for point colliders)\n     * @property _scale\n     * @type {p5.Vector}\n     * @private",
        "* If true, when calling `updateFromSprite` this collider will adopt the\n     * base dimensions of the sprite in addition to adopting its transform.\n     * If false, only the transform (position/rotation/scale) will be adopted.\n     * @property getsDimensionsFromSprite\n     * @type {boolean}",
        "* The center of the collision shape in world-space.\n       * Note: You can set this property with a value in world-space, but it will\n       * actually modify the collision shape's local transform.\n       * @property center\n       * @type {p5.Vector}",
        "* The center of the collision shape in local-space - if this collider is\n       * owned by a sprite, the offset of the collider center from the sprite center.\n       * @property offset\n       * @type {p5.Vector}",
        "* The local-space rotation of the collider, in radians.\n       * @property rotation\n       * @type {number}",
        "* The local-space scale of the collider\n       * @property scale\n       * @type {p5.Vector}",
        "* Update this collider based on the properties of a parent Sprite.\n   * Descendant classes should override this method to adopt the dimensions\n   * of the sprite if `getsDimensionsFromSprite` is true.\n   * @method updateFromSprite\n   * @param {Sprite} sprite\n   * @see p5.CollisionShape.prototype.getsDimensionsFromSprite",
        "* Update this collider's parent transform, which will in turn adjust its\n   * position, rotation and scale in world-space and recompute cached values\n   * if necessary.\n   * If a Sprite is passed as the 'parent' then a new transform will be computed\n   * from the sprite's position/rotation/scale and used.\n   * @method setParentTransform\n   * @param {p5.Transform2D|Sprite} parent",
        "* Recalculate cached properties, relevant vectors, etc. when at least one\n   * of the shape's transforms changes.  The base CollisionShape (and PointCollider)\n   * only need to recompute the shape's center, but other shapes may need to\n   * override this method and do additional recomputation.\n   * @method _onTransformChanged\n   * @protected",
        "* Compute the smallest movement needed to move this collision shape out of\n   * another collision shape.  If the shapes are not overlapping, returns a\n   * zero vector to indicate that no displacement is necessary.\n   * @method collide\n   * @param {p5.CollisionShape} other\n   * @return {p5.Vector}",
        "* Check whether this shape overlaps another.\n   * @method overlap\n   * @param {p5.CollisionShape} other\n   * @return {boolean}",
        "* @method _getCanididateAxesForShapes\n   * @private\n   * @static\n   * @param {p5.CollisionShape} shape1\n   * @param {p5.CollisionShape} shape2\n   * @return {Array.<p5.Vector>}",
        "* Reduce an array of vectors to a set of unique axes (that is, no two vectors\n   * in the array should be parallel).\n   * @param {Array.<p5.Vector>} array\n   * @return {Array}",
        "* Compute candidate separating axes relative to another object.\n   * Override this method in subclasses to implement collision behavior.\n   * @method _getCandidateAxes\n   * @protected\n   * @return {Array.<p5.Vector>}",
        "* Get this shape's radius (half-width of its projection) along the given axis.\n   * Override this method in subclasses to implement collision behavior.\n   * @method _getRadiusOnAxis\n   * @protected\n   * @param {p5.Vector} axis\n   * @return {number}",
        "* Get the shape's minimum radius on any axis for tunneling checks.\n   * @method _getMinRadius\n   * @protected\n   * @param {p5.Vector} axis\n   * @return {number}",
        "* @property X_AXIS\n   * @type {p5.Vector}\n   * @static\n   * @final",
        "* @property Y_AXIS\n   * @type {p5.Vector}\n   * @static\n   * @final",
        "* @property WORLD_AXES\n   * @type {Array.<p5.Vector>}\n   * @static\n   * @final",
        "* Get world-space axis-aligned bounds information for this collision shape.\n   * Used primarily for the quadtree.\n   * @method getBoundingBox\n   * @return {{top: number, bottom: number, left: number, right: number, width: number, height: number}}",
        "* A point collision shape, used to detect overlap and displacement vectors\n   * vs other collision shapes.\n   * @class p5.PointCollider\n   * @constructor\n   * @extends p5.CollisionShape\n   * @param {p5.Vector} center",
        "* Construct a new PointCollider with given offset for the given sprite.\n   * @method createFromSprite\n   * @static\n   * @param {Sprite} sprite\n   * @param {p5.Vector} [offset] from the sprite's center\n   * @return {p5.PointCollider}",
        "* Debug-draw this point collider\n   * @method draw\n   * @param {p5} sketch instance to use for drawing",
        "* A Circle collision shape, used to detect overlap and displacement vectors\n   * with other collision shapes.\n   * @class p5.CircleCollider\n   * @constructor\n   * @extends p5.CollisionShape\n   * @param {p5.Vector} center\n   * @param {number} radius",
        "* The unscaled radius of the circle collider.\n     * @property radius\n     * @type {number}",
        "* Final radius of this circle after being scaled by parent and local transforms,\n     * cached so we don't recalculate it all the time.\n     * @property _scaledRadius\n     * @type {number}\n     * @private",
        "* Construct a new CircleCollider with given offset for the given sprite.\n   * @method createFromSprite\n   * @static\n   * @param {Sprite} sprite\n   * @param {p5.Vector} [offset] from the sprite's center\n   * @param {number} [radius]\n   * @return {p5.CircleCollider}",
        "* Update this collider based on the properties of a parent Sprite.\n   * @method updateFromSprite\n   * @param {Sprite} sprite\n   * @see p5.CollisionShape.prototype.getsDimensionsFromSprite",
        "* Recalculate cached properties, relevant vectors, etc. when at least one\n   * of the shape's transforms changes.  The base CollisionShape (and PointCollider)\n   * only need to recompute the shape's center, but other shapes may need to\n   * override this method and do additional recomputation.\n   * @method _onTransformChanged\n   * @protected",
        "* Call to update the cached scaled radius value.\n   * @method _computeScaledRadius\n   * @private",
        "* Debug-draw this collision shape.\n   * @method draw\n   * @param {p5} sketch instance to use for drawing",
        "* Overrides CollisionShape.setParentTransform\n   * Update this collider's parent transform, which will in turn adjust its\n   * position, rotation and scale in world-space and recompute cached values\n   * if necessary.\n   * If a Sprite is passed as the 'parent' then a new transform will be computed\n   * from the sprite's position/rotation/scale and used.\n   * Use the max of the x and y scales values so the circle encompasses the sprite.\n   * @method setParentTransform\n   * @param {p5.Transform2D|Sprite} parent",
        "* Compute candidate separating axes relative to another object.\n   * @method _getCandidateAxes\n   * @protected\n   * @param {p5.CollisionShape} other\n   * @return {Array.<p5.Vector>}",
        "* Get this shape's radius (half-width of its projection) along the given axis.\n   * @method _getRadiusOnAxis\n   * @protected\n   * @return {number}",
        "* Get the shape's minimum radius on any axis for tunneling checks.\n   * @method _getMinRadius\n   * @protected\n   * @param {p5.Vector} axis\n   * @return {number}",
        "* An Axis-Aligned Bounding Box (AABB) collision shape, used to detect overlap\n   * and compute minimum displacement vectors with other collision shapes.\n   *\n   * Cannot be rotated - hence the name.  You might use this in place of an\n   * OBB because it simplifies some of the math and may improve performance.\n   *\n   * @class p5.AxisAlignedBoundingBoxCollider\n   * @constructor\n   * @extends p5.CollisionShape\n   * @param {p5.Vector} center\n   * @param {number} width\n   * @param {number} height",
        "* Unscaled box width.\n     * @property _width\n     * @private\n     * @type {number}",
        "* Unscaled box height.\n     * @property _width\n     * @private\n     * @type {number}",
        "* Cached half-diagonals, used for computing a projected radius.\n     * Already transformed into world-space.\n     * @property _halfDiagonals\n     * @private\n     * @type {Array.<p5.Vector>}",
        "* The untransformed width of the box collider.\n       * Recomputes diagonals when set.\n       * @property width\n       * @type {number}",
        "* The unrotated height of the box collider.\n       * Recomputes diagonals when set.\n       * @property height\n       * @type {number}",
        "* Two vectors representing adjacent half-diagonals of the box at its\n       * current dimensions and orientation.\n       * @property halfDiagonals\n       * @readOnly\n       * @type {Array.<p5.Vector>}",
        "* Construct a new AxisAlignedBoundingBoxCollider with given offset for the given sprite.\n   * @method createFromSprite\n   * @static\n   * @param {Sprite} sprite\n   * @param {p5.Vector} [offset] from the sprite's center\n   * @return {p5.CircleCollider}",
        "* Update this collider based on the properties of a parent Sprite.\n   * @method updateFromSprite\n   * @param {Sprite} sprite\n   * @see p5.CollisionShape.prototype.getsDimensionsFromSprite",
        "* Recalculate cached properties, relevant vectors, etc. when at least one\n   * of the shape's transforms changes.  The base CollisionShape (and PointCollider)\n   * only need to recompute the shape's center, but other shapes may need to\n   * override this method and do additional recomputation.\n   * @method _onTransformChanged\n   * @protected",
        "* Recompute this bounding box's half-diagonal vectors.\n   * @method _computeHalfDiagonals\n   * @private\n   * @return {Array.<p5.Vector>}",
        "* Debug-draw this collider.\n   * @method draw\n   * @param {p5} sketch - p5 instance to use for drawing",
        "* Compute candidate separating axes relative to another object.\n   * @method _getCandidateAxes\n   * @protected\n   * @return {Array.<p5.Vector>}",
        "* Get this shape's radius (half-width of its projection) along the given axis.\n   * @method _getRadiusOnAxis\n   * @protected\n   * @param {p5.Vector} axis\n   * @return {number}",
        "* Get the shape's minimum radius on any axis for tunneling checks.\n   * @method _getMinRadius\n   * @protected\n   * @param {p5.Vector} axis\n   * @return {number}",
        "* An Oriented Bounding Box (OBB) collision shape, used to detect overlap and\n   * compute minimum displacement vectors with other collision shapes.\n   * @class p5.OrientedBoundingBoxCollider\n   * @constructor\n   * @extends p5.CollisionShape\n   * @param {p5.Vector} center of the rectangle in world-space\n   * @param {number} width of the rectangle (when not rotated)\n   * @param {number} height of the rectangle (when not rotated)\n   * @param {number} rotation about center, in radians",
        "* Unscaled box width.\n     * @property _width\n     * @private\n     * @type {number}",
        "* Unscaled box height.\n     * @property _width\n     * @private\n     * @type {number}",
        "* Cached separating axes this shape contributes to a collision.\n     * @property _potentialAxes\n     * @private\n     * @type {Array.<p5.Vector>}",
        "* Cached half-diagonals, used for computing a projected radius.\n     * Already transformed into world-space.\n     * @property _halfDiagonals\n     * @private\n     * @type {Array.<p5.Vector>}",
        "* The unrotated width of the box collider.\n       * Recomputes diagonals when set.\n       * @property width\n       * @type {number}",
        "* The unrotated height of the box collider.\n       * Recomputes diagonals when set.\n       * @property height\n       * @type {number}",
        "* Two vectors representing adjacent half-diagonals of the box at its\n       * current dimensions and orientation.\n       * @property halfDiagonals\n       * @readOnly\n       * @type {Array.<p5.Vector>}",
        "* Construct a new AxisAlignedBoundingBoxCollider with given offset for the given sprite.\n   * @method createFromSprite\n   * @static\n   * @param {Sprite} sprite\n   * @param {p5.Vector} [offset] from the sprite's center\n   * @param {number} [width]\n   * @param {number} [height]\n   * @param {number} [rotation] in radians\n   * @return {p5.CircleCollider}",
        "* Update this collider based on the properties of a parent Sprite.\n   * @method updateFromSprite\n   * @param {Sprite} sprite\n   * @see p5.CollisionShape.prototype.getsDimensionsFromSprite",
        "* Assuming this collider is a sprite's swept collider, update it based on\n   * the properties of the parent sprite so that it encloses the sprite's\n   * current position and its projected position.\n   * @method updateSweptColliderFromSprite\n   * @param {Sprite} sprite",
        "* Recalculate cached properties, relevant vectors, etc. when at least one\n   * of the shape's transforms changes.  The base CollisionShape (and PointCollider)\n   * only need to recompute the shape's center, but other shapes may need to\n   * override this method and do additional recomputation.\n   * @method _onTransformChanged\n   * @protected",
        "* Debug-draw this collider.\n   * @method draw\n   * @param {p5} sketch - p5 instance to use for drawing",
        "* Compute candidate separating axes relative to another object.\n   * @method _getCandidateAxes\n   * @protected\n   * @return {Array.<p5.Vector>}",
        "* Get this shape's radius (half-width of its projection) along the given axis.\n   * @method _getRadiusOnAxis\n   * @protected\n   * @param {p5.Vector} axis\n   * @return {number}",
        "* When checking for tunneling through a OrientedBoundingBoxCollider use a\n   * worst-case of zero (e.g. if the other sprite is passing through a corner).\n   * @method _getMinRadius\n   * @protected\n   * @param {p5.Vector} axis\n   * @return {number}",
        "* A 2D affine transformation (translation, rotation, scale) stored as a\n   * 3x3 matrix that uses homogeneous coordinates.  Used to quickly transform\n   * points or vectors between reference frames.\n   * @class p5.Transform2D\n   * @constructor\n   * @extends Array\n   * @param {p5.Transform2D|Array.<number>} [source]",
        "* Reset this transform to an identity transform, in-place.\n   * @method clear\n   * @return {p5.Transform2D} this transform",
        "* Make a copy of this transform.\n   * @method copy\n   * @return {p5.Transform2D}",
        "* Check whether two transforms are the same.\n   * @method equals\n   * @param {p5.Transform2D|Array.<number>} other\n   * @return {boolean}",
        "* Multiply two transforms together, combining them.\n   * Does not modify original transforms.  Assigns result into dest argument if\n   * provided and returns it.  Otherwise returns a new transform.\n   * @method mult\n   * @static\n   * @param {p5.Transform2D|Array.<number>} t1\n   * @param {p5.Transform2D|Array.<number>} t2\n   * @param {p5.Transform2D} [dest]\n   * @return {p5.Transform2D}",
        "* Multiply this transform by another, combining them.\n   * Modifies this transform and returns it.\n   * @method mult\n   * @param {p5.Transform2D|Float32Array|Array.<number>} other\n   * @return {p5.Transform2D}",
        "* Modify this transform, translating it by a certain amount.\n   * Returns this transform.\n   * @method translate\n   * @return {p5.Transform2D}\n   * @example\n   *     // Two different ways to call this method.\n   *     var t = new p5.Transform();\n   *     // 1. Two numbers\n   *     t.translate(x, y);\n   *     // 2. One vector\n   *     t.translate(new p5.Vector(x, y));",
        "* Retrieve the resolved translation of this transform.\n   * @method getTranslation\n   * @return {p5.Vector}",
        "* Modify this transform, scaling it by a certain amount.\n   * Returns this transform.\n   * @method scale\n   * @return {p5.Transform2D}\n   * @example\n   *     // Three different ways to call this method.\n   *     var t = new p5.Transform();\n   *     // 1. One scalar value\n   *     t.scale(uniformScale);\n   *     // 1. Two scalar values\n   *     t.scale(scaleX, scaleY);\n   *     // 2. One vector\n   *     t.translate(new p5.Vector(scaleX, scaleY));",
        "* Retrieve the scale vector of this transform.\n   * @method getScale\n   * @return {p5.Vector}",
        "* Return -1, 0, or 1 depending on whether a number is negative, zero, or positive.",
        "* Modify this transform, rotating it by a certain amount.\n   * @method rotate\n   * @param {number} radians\n   * @return {p5.Transform2D}",
        "* Retrieve the angle of this transform in radians.\n   * @method getRotation\n   * @return {number}",
        "* Applies a 2D transformation matrix (using homogeneous coordinates, so 3x3)\n   * to a Vector2 (<x, y, 1>) and returns a new vector2.\n   * @method transform\n   * @for p5.Vector\n   * @static\n   * @param {p5.Vector} v\n   * @param {p5.Transform2D} t\n   * @return {p5.Vector} a new vector",
        "* Transforms this vector by a 2D transformation matrix.\n   * @method transform\n   * @for p5.Vector\n   * @param {p5.Transform2D} transform\n   * @return {p5.Vector} this, after the change"
    ],
    "functions": [
        "defineLazyP5Property",
        "boundConstructorFactory",
        "F",
        "createPInstBinder",
        "getTouchInfo",
        "getMousePos",
        "_sAssign",
        "modeAdjust",
        "createReadOnlyP5PropertyAlias",
        "Sprite",
        "Camera",
        "cameraPush",
        "cameraPop",
        "Group",
        "virtEquals",
        "_groupCollide",
        "Animation",
        "SpriteSheet",
        "construct",
        "F",
        "Quadtree",
        "updateTree",
        "deduplicateParallelVectors",
        "sign"
    ],
    "classes": []
}