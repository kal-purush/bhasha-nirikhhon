{
    "identifiers": [
        "numpy",
        "np",
        "metrology_file",
        "np",
        "genfromtxt",
        "metrology_file",
        "met",
        "shape",
        "IOError",
        "metrology_file",
        "np",
        "array",
        "np",
        "vsplit",
        "met",
        "quad_metrologies",
        "v",
        "w",
        "two_by_one_index",
        "tol",
        "np",
        "degrees",
        "np",
        "arcsin",
        "np",
        "dot",
        "v",
        "w",
        "np",
        "linalg",
        "norm",
        "v",
        "np",
        "linalg",
        "norm",
        "w",
        "np",
        "abs",
        "value",
        "tol",
        "verbose",
        "two_by_one_index",
        "value",
        "tol",
        "passed",
        "quad_metrology",
        "quad_index",
        "two_by_one_index",
        "quad_metrology",
        "shape",
        "ValueError",
        "quad_metrology",
        "shape",
        "np",
        "array",
        "np",
        "where",
        "scan_sequence",
        "two_by_one_index",
        "quad_metrology",
        "i",
        "i",
        "np",
        "sqrt",
        "fl",
        "fl",
        "sl",
        "sl",
        "two_by_one_index",
        "_unit",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "_unit",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "two_by_one_index",
        "_unit",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "_unit",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "two_by_one_index",
        "_unit",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "_unit",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "xyz_2x1",
        "ValueError",
        "np",
        "mean",
        "xyz_2x1",
        "axis",
        "np",
        "linalg",
        "norm",
        "diagonal",
        "h",
        "r",
        "offset",
        "_unit",
        "diagonal",
        "p0",
        "shape",
        "f",
        "_unit",
        "f",
        "_qc_angle",
        "s",
        "f",
        "two_by_one_index",
        "np",
        "cross",
        "s",
        "f",
        "np",
        "arccos",
        "np",
        "dot",
        "s",
        "f",
        "np",
        "linalg",
        "norm",
        "s",
        "np",
        "linalg",
        "norm",
        "f",
        "np",
        "pi",
        "theta",
        "utils",
        "ER_rotation_matrix",
        "axis",
        "rot",
        "utils",
        "ER_rotation_matrix",
        "axis",
        "rot",
        "np",
        "dot",
        "Rs",
        "s",
        "np",
        "dot",
        "Rf",
        "f",
        "np",
        "abs",
        "np",
        "dot",
        "s",
        "f",
        "p0",
        "copy",
        "s",
        "copy",
        "f",
        "copy",
        "shape",
        "p1",
        "copy",
        "s",
        "copy",
        "f",
        "copy",
        "shape",
        "bgs"
    ],
    "literals": [
        "'metrology file appears to be in the wrong format... '",
        "'could not understand file format of: %s'",
        "\"WARNING: Metrology quality control failed for 2x1: %d\"",
        "'--> s/f vectors are not orthogonal :: enforcing orthogonality!'",
        "\"    Angle: %f // tol: %f\"",
        "'Invalid quad_metrology, must be shape (32,3), got: %s'",
        "'two_by_one_index must be in 0...7'"
    ],
    "variables": [
        "met",
        "quad_metrologies",
        "value",
        "passed",
        "passed",
        "scan_sequence",
        "shape",
        "i",
        "xyz_2x1",
        "fl",
        "sl",
        "h",
        "s",
        "f",
        "diagonal",
        "r",
        "s",
        "f",
        "diagonal",
        "r",
        "s",
        "f",
        "diagonal",
        "r",
        "center",
        "offset",
        "p0",
        "p1",
        "axis",
        "theta",
        "rot",
        "Rs",
        "Rf",
        "s",
        "f",
        "bgs"
    ],
    "comments": [
        "read the metrology and discard the first col",
        "compute the angle between the vectors",
        "below is the sequence in which each 2x1 is optically measured, and",
        "thus this sequence is read out of the metrology",
        "always the same, for each ASIC",
        "rip out the correct corner positions for the 2x1 we want",
        "the four corners of the 2x1",
        "The metrology is for sensor points that are actually *outside* the",
        "physical ASIC chip. To account for this, we apply a `p_offset`,",
        "which effectively centers the ASIC between these measured points.",
        "Practically, we take the average center of each side of the rectangle",
        "measured in the metrology",
        "0.10992 mm : pixel size",
        "0.27480 mm : gap between ASICS in a 2x1",
        "length of the long side of a 2x1",
        "length of the short side of a 2x1",
        "length of hypothenuse of an ASIC",
        "Next, we build a basis grid representation of each 2x1, which consists",
        "of two individual ASICS. Each ASIC has an \"origin\" which denotes the",
        "position of the first pixel in memory -- this is denoted p0 for the",
        "first ASIC and p1 for the second. The values \"s\" and \"f\" define the",
        "grid of pixels along the slow and fast scan directions (here, short",
        "and long sizes) of the 2x1 respectively.",
        "The s/f vectors are computed by averaging the vectors that define each",
        "side in the optical measurement.",
        "The p vector is measured based on placing a point the correct distance",
        "along the diagonal between two measured points. This is checked for",
        "correctness by ensuring that the diagonal used is orthogonal to the",
        "other 2x1 diagonal measured",
        "NOTE : later, we swap x to reach CXI convention -- this is done after",
        "we position the quads in _generate_positional_basis()",
        "this is a magnitude",
        "for 3px gap",
        "--- perform some quality control checks ---",
        "(1) ensure s/f orthogonal",
        "--- end QC ---------------------------------",
        "no matter what, correct the s/f vectors so they are orthogonal",
        "the angle between s/f",
        "rotate each vector -- below `rot` is deg ccw wrt x-axis in the ref",
        "frame of '+axis'",
        "return a tuple of basis grid objects"
    ],
    "docstrings": [
        "\"\"\"\nmetrology.py\n\ncode for interpreting CSPAD, and hopefully later ePix, optical metrologies\ngenerated by the detector group at LCLS\n\"\"\"",
        "\"\"\"\n    Parse a flat text file containing a metrology. We assume the metrology\n    is of the form:\n    \n    # quad 0\n    1 x1 y1 z1\n    2 x2 y2 z2\n    3 ...\n    \n    # quad 1\n    1 x1 y1 z1\n    2 x2 y2 z2\n    3 ...\n    \n    ...\n    \n    \"\"\"",
        "\"\"\"\n    Perform a quality control check on the angle between two basis vectors.\n    \n    A note on the `tol` value:\n    \n    The longest 2x1 side is 388 pixels long. Therefore to achive single\n    pixel accuracy in the metrology, the angle between the two 2x1 sides\n    should be less than\n    \n        theta = | arctan( 1 pixel / 388 pixels ) - pi / 2 |\n    \n    which is ~0.0026 rad = 0.148 and this is what we've\n    set the tolerance to for now.\n    \"\"\"",
        "\"\"\"\n    Convert a 2x1 in the optical metrology into two basis grid elements.\n\n    Parameters\n    ----------\n    quad_metrology : np.ndarray, float\n        A 32 x 3 array of the corner positions of each 2x1 on the quad.\n\n    two_by_one_index : int\n        The index of the 2x1 to check out.\n        \n    Optional Parameters\n    -------------------\n    tol : float\n        The tolerance for a quality control assessment that is performed on\n        the optical measurement, including checking things that should be\n        orthogonal are, distances are correct, etc. The float `tol` can be\n        interpreted as a tolerane for error for each of these in units of\n        mm.\n        \n    Returns\n    -------\n    bgs : tuple\n        A 2-tuple of (p,s,f,shape) for each ASIC in the two by one.\n    \"\"\""
    ],
    "functions": [
        "_read_metrology",
        "_qc_angle",
        "_twobyone_to_bg"
    ],
    "classes": []
}