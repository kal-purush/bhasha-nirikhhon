{
    "identifiers": [
        "ng",
        "args",
        "ng",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "value",
        "obj",
        "DependencyAnnotation",
        "newList",
        "obj",
        "callback",
        "callback",
        "parent",
        "distanceToParent",
        "protoElementInjector",
        "componentDirective",
        "eventBindings",
        "boundElementIndex",
        "directiveIndex",
        "changeDetector",
        "elementInjectors",
        "rootElementInjectors",
        "preBuiltObjects",
        "componentChildViews",
        "contextName",
        "value",
        "eventName",
        "eventObj",
        "binderIndex",
        "b",
        "currentValue",
        "directive",
        "directive",
        "elementIndex",
        "methodName",
        "args",
        "elementIndex",
        "eventName",
        "locals",
        "definition",
        "obj",
        "cdRef",
        "existingPipe",
        "obj",
        "value",
        "args",
        "obs",
        "cdRef",
        "BasePipe",
        "obj",
        "value",
        "args",
        "obj",
        "cdRef",
        "ChangeDetection",
        "definition",
        "ChangeDetection",
        "definition",
        "ChangeDetection",
        "definition",
        "dispatcher",
        "bindingRecord",
        "value",
        "cd",
        "cd",
        "cd",
        "cd",
        "context",
        "locals",
        "directives",
        "name",
        "name",
        "name",
        "value",
        "obj",
        "value",
        "args",
        "forwardRef",
        "forwardRefFn",
        "resolveForwardRef",
        "token",
        "token",
        "index",
        "bindings",
        "depProvider",
        "bindings",
        "depProvider",
        "index",
        "bind",
        "token",
        "AbstractBindingError",
        "key",
        "AbstractBindingError",
        "AbstractBindingError",
        "AbstractBindingError",
        "value",
        "aliasToken",
        "factoryFunction",
        "dependencies",
        "injector",
        "binding",
        "dependency",
        "parent",
        "path",
        "errorCode",
        "path",
        "errorCode",
        "path",
        "AbstractControl",
        "value",
        "fn",
        "AbstractControl",
        "name",
        "c",
        "name",
        "controlName",
        "controlName",
        "controlName",
        "AbstractControl",
        "index",
        "control",
        "index",
        "control",
        "index",
        "NgControl",
        "c",
        "newValue",
        "NgControl",
        "c",
        "newValue",
        "NgControl",
        "c",
        "newValue",
        "newValue",
        "ControlContainer",
        "ControlContainer",
        "_",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "value",
        "ControlContainer",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "value",
        "obj",
        "fn",
        "fn",
        "value",
        "fn",
        "fn",
        "value",
        "fn",
        "fn",
        "value",
        "fn",
        "fn",
        "NgValidator",
        "controlsConfig",
        "extra",
        "value",
        "validator",
        "controlsConfig",
        "validator",
        "Renderer",
        "hostProtoViewRef",
        "hostElementSelector",
        "protoViewRef",
        "view",
        "location",
        "location",
        "componentViewRef",
        "componentViewRef",
        "rootNodes",
        "viewRef",
        "location",
        "componentViewRef",
        "location",
        "atIndex",
        "viewRef",
        "location",
        "atIndex",
        "viewRef",
        "viewRef",
        "viewRef",
        "location",
        "propertyName",
        "propertyValue",
        "location",
        "attributeName",
        "attributeValue",
        "location",
        "className",
        "isAdd",
        "location",
        "styleName",
        "styleValue",
        "location",
        "methodName",
        "args",
        "viewRef",
        "textNodeIndex",
        "text",
        "viewRef",
        "dispatcher",
        "DirectiveAnnotation",
        "Injectable",
        "DependencyAnnotation",
        "DependencyAnnotation",
        "changes",
        "Class",
        "clsDef",
        "cls",
        "unusedKey",
        "index",
        "name",
        "name",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "selector",
        "selector",
        "bootstrap",
        "appComponentType",
        "componentInjectableBindings",
        "errorReporter",
        "baseUrl",
        "url",
        "component",
        "componentTypeOrBinding",
        "hostLocation",
        "location",
        "hostViewRef",
        "hostLocation",
        "variableName",
        "hostLocation",
        "hostProtoViewRef",
        "overrideSelector",
        "injector",
        "hostViewRef",
        "viewContainerLocation",
        "atIndex",
        "protoViewRef",
        "context",
        "bindings",
        "viewContainerLocation",
        "atIndex",
        "viewContainerLocation",
        "atIndex",
        "viewRef",
        "viewContainerLocation",
        "atIndex",
        "BaseQueryList",
        "callback",
        "callback",
        "contextName",
        "value",
        "index",
        "protoViewRef",
        "atIndex",
        "context",
        "bindings",
        "viewRef",
        "atIndex",
        "viewRef",
        "atIndex",
        "atIndex",
        "typeOrBinding",
        "overrideSelector",
        "injector",
        "typeOrBinding",
        "hostLocation",
        "anchorName",
        "bindings",
        "typeOrBinding",
        "location",
        "bindings",
        "fn",
        "fn",
        "generator",
        "Observable",
        "generator",
        "Rx",
        "Rx",
        "value",
        "error",
        "value",
        "hostComponentBinding",
        "rootRenderProtoView",
        "allDirectives",
        "directiveMetadata",
        "view",
        "component",
        "protoView",
        "component",
        "component",
        "protoView",
        "component",
        "res",
        "res",
        "err",
        "req",
        "request",
        "RequestOptions",
        "options",
        "ResponseOptions",
        "options",
        "request",
        "url",
        "options",
        "url",
        "options",
        "url",
        "body",
        "options",
        "url",
        "body",
        "options",
        "url",
        "options",
        "url",
        "body",
        "options",
        "url",
        "options",
        "name",
        "value",
        "name",
        "fn",
        "header",
        "header",
        "header",
        "value",
        "header",
        "ResponseTypes",
        "ReadyStates",
        "RequestMethods",
        "RequestCredentialsOpts",
        "RequestCacheOpts",
        "RequestModesOpts",
        "param",
        "param",
        "param",
        "param",
        "val",
        "param",
        "PropertyBindingType",
        "ViewType",
        "hostProtoViewRef",
        "hostElementSelector",
        "protoViewRef",
        "viewRef",
        "location",
        "componentViewRef",
        "location",
        "componentViewRef",
        "location",
        "atIndex",
        "viewRef",
        "location",
        "atIndex",
        "viewRef",
        "viewRef",
        "viewRef",
        "location",
        "location",
        "propertyName",
        "propertyValue",
        "location",
        "attributeName",
        "attributeValue",
        "location",
        "className",
        "isAdd",
        "location",
        "styleName",
        "styleValue",
        "location",
        "methodName",
        "args",
        "viewRef",
        "textNodeIndex",
        "text",
        "viewRef",
        "dispatcher",
        "elementIndex",
        "eventName",
        "locals",
        "child",
        "child",
        "prevSibling",
        "Dependency",
        "ResolvedBinding",
        "view",
        "boundElementIndex",
        "directive",
        "view",
        "boundElementIndex",
        "directive",
        "parent",
        "index",
        "TreeNode",
        "imperativelyCreatedInjector",
        "host",
        "preBuiltObjects",
        "name",
        "name",
        "token",
        "key",
        "injector",
        "binding",
        "dep",
        "query",
        "parent",
        "parent",
        "prevSibling",
        "index",
        "inj",
        "aggregator",
        "context",
        "locals",
        "context",
        "locals",
        "value",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "context",
        "locals",
        "value",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "context",
        "locals",
        "value",
        "visitor",
        "AST",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "context",
        "locals",
        "value",
        "visitor",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "asts",
        "ast",
        "ast",
        "ast",
        "ng"
    ],
    "literals": [
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "\"angular2/angular2\""
    ],
    "variables": [
        "ON_PUSH",
        "DEFAULT",
        "defaultPipes",
        "preGeneratedProtoDetectors",
        "defaultPipeRegistry",
        "Inject",
        "Optional",
        "Self",
        "Parent",
        "Ancestor",
        "Unbounded",
        "formDirectives",
        "formInjectables",
        "DOCUMENT_TOKEN",
        "onDestroy",
        "onChange",
        "onCheck",
        "onInit",
        "onAllChangesDone",
        "Attribute",
        "Component",
        "Directive",
        "View",
        "appComponentTypeToken",
        "coreDirectives",
        "httpInjectables"
    ],
    "comments": [
        "Type definitions for Angular v2.0.0-alpha.30",
        "Project: http://angular.io/",
        "Definitions by: angular team <https://github.com/angular/>",
        "Definitions: https://github.com/borisyankov/DefinitelyTyped",
        "This file is generated by the Angular build process.",
        "Please do not create manual edits or send pull requests",
        "modifying this file.",
        "Angular depends transitively on these libraries.",
        "If you don't have them installed you can run",
        "$ tsd query es6-promise rx rx-lite --action install --save",
        "<reference path=\"../es6-promise/es6-promise.d.ts\"/>",
        "<reference path=\"../rx/rx.d.ts\"/>",
        "See https://github.com/Microsoft/TypeScript/issues/1168",
        "extends Error",
        "node",
        "node",
        "() => void",
        "() => void",
        "(error, stack) => void"
    ],
    "docstrings": [
        "***********************************************************",
        "***********************************************************",
        "* `DependencyAnnotation` is used by the framework to extend DI.\n* \n   * \n* \n   * Only annotations implementing `DependencyAnnotation` are added to the list of dependency\n* \n   * properties.\n* \n   * \n* \n   * For example:\n* \n   * \n* \n   * ```\n* \n   * class Parent extends DependencyAnnotation {}\n* \n   * class NotDependencyProperty {}\n* \n   * \n* \n   * class AComponent {\n* \n   *   constructor(@Parent @NotDependencyProperty aService:AService) {}\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * will create the following dependency:\n* \n   * \n* \n   * ```\n* \n   * new Dependency(Key.get(AService), [new Parent()])\n* \n   * ```\n* \n   * \n* \n   * The framework can use `new Parent()` to handle the `aService` dependency\n* \n   * in a specific way.\n* \n   * \n* \n   * @exportedAs angular2/di_annotations",
        "* Lifecycle events are guaranteed to be called in the following order:\n* \n   * - `onChange` (optional if any bindings have changed),\n* \n   * - `onInit` (optional after the first check only),\n* \n   * - `onCheck`,\n* \n   * - `onAllChangesDone`",
        "* An interface that <a href='/angular2/angular2.api/NgFormModel'><code>NgFormModel</code></a> and <a href='/angular2/angular2.api/NgForm'><code>NgForm</code></a> implement.\n* \n   * \n* \n   * Only used by the forms module.",
        "* An interface implemented by all Angular type decorators, which allows them to be used as ES7\n* \n   * decorators as well as\n* \n   * Angular DSL syntax.\n* \n   * \n* \n   * DSL syntax:\n* \n   * \n* \n   * ```\n* \n   * var MyClass = ng\n* \n   *   .Component({...})\n* \n   *   .View({...})\n* \n   *   .Class({...});\n* \n   * ```\n* \n   * \n* \n   * ES7 syntax:\n* \n   * \n* \n   * ```\n* \n   * @ng.Component({...})\n* \n   * @ng.View({...})\n* \n   * class MyClass {...}\n* \n   * ```",
        "* Invoke as ES7 decorator.",
        "* Storage for the accumulated annotations so far used by the DSL syntax.\n* \n     * \n* \n     * Used by <a href='/angular2/angular2.api/Class'><code>Class</code></a> to annotate the generated class.",
        "* Generate a class from the definition and annotate it with <a href='/angular2/angular2.api/TypeDecorator#annotations'><code>TypeDecorator</code></a>.",
        "* Declares the interface to be used with <a href='/angular2/angular2.api/Class'><code>Class</code></a>.",
        "* Optional argument for specifying the superclass.",
        "* Required constructor function for a class.\n* \n     * \n* \n     * The function may be optionall wrapped in an `Array`, in which case additional parameter\n* \n     * annotations may be\n* \n     * specified. The number of arguments and the number of paramater annotations must match.\n* \n     * \n* \n     * See <a href='/angular2/angular2.api/Class'><code>Class</code></a> for example of usage.",
        "* Specifies that a <a href='/angular2/angular2.api/QueryList'><code>QueryList</code></a> should be injected.\n* \n   * \n* \n   * See <a href='/angular2/angular2.api/QueryList'><code>QueryList</code></a> for usage and example.\n* \n   * \n* \n   * @exportedAs angular2/annotations",
        "* A directive that contains a group of [NgControl].\n* \n   * \n* \n   * Only used by the forms module.",
        "* A marker annotation that marks a class as available to `Injector` for creation. Used by tooling\n* \n   * for generating constructor stubs.\n* \n   * \n* \n   * ```\n* \n   * class NeedsService {\n* \n   *   constructor(svc:UsefulService) {}\n* \n   * }\n* \n   * \n* \n   * @Injectable\n* \n   * class UsefulService {}\n* \n   * ```\n* \n   * @exportedAs angular2/di_annotations",
        "* Specifies how injector should resolve a dependency.\n* \n   * \n* \n   * See <a href='/angular2/angular2.api/Self'><code>Self</code></a>, <a href='/angular2/angular2.api/Parent'><code>Parent</code></a>, <a href='/angular2/angular2.api/Ancestor'><code>Ancestor</code></a>, <a href='/angular2/angular2.api/Unbounded'><code>Unbounded</code></a>.\n* \n   * \n* \n   * @exportedAs angular2/di_annotations",
        "* Injectable Objects that contains a live list of child directives in the light Dom of a directive.\n* \n   * The directives are kept in depth-first pre-order traversal of the DOM.\n* \n   * \n* \n   * In the future this class will implement an Observable interface.\n* \n   * For now it uses a plain list of observable callbacks.\n* \n   * \n* \n   * @exportedAs angular2/view",
        "* Adds an event binding for the last created ElementBinder via bindElement.\n* \n     * \n* \n     * If the directive index is a positive integer, the event is evaluated in the context of\n* \n     * the given directive.\n* \n     * \n* \n     * If the directive index is -1, the event is evaluated in the context of the enclosing view.\n* \n     * \n* \n     * @param {string} eventName\n* \n     * @param {AST} expression\n* \n     * @param {int} directiveIndex The directive index in the binder or -1 when the event is not bound\n* \n     *                             to a directive",
        "* Cost of making objects: http://jsperf.com/instantiate-size-of-object",
        "* The context against which data-binding expressions in this view are evaluated against.\n* \n     * This is always a component instance.",
        "* Variables, local to this view, that can be used in binding expressions (in addition to the\n* \n     * context). This is used for thing like `<video #player>` or\n* \n     * `<li template=\"for #item of items\">`, where \"player\" and \"item\" are locals, respectively.",
        "* Triggers the event handlers for the element and the directives.\n* \n     * \n* \n     * This method is intended to be called from directive EventEmitters.\n* \n     * \n* \n     * @param {string} eventName\n* \n     * @param {*} eventObj\n* \n     * @param {int} binderIndex",
        "* Interface used by Angular to control the change detection strategy for an application.\n* \n   * \n* \n   * Angular implements the following change detection strategies by default:\n* \n   * \n* \n   * - <a href='/angular2/angular2.api/DynamicChangeDetection'><code>DynamicChangeDetection</code></a>: slower, but does not require `eval()`.\n* \n   * - <a href='/angular2/angular2.api/JitChangeDetection'><code>JitChangeDetection</code></a>: faster, but requires `eval()`.\n* \n   * \n* \n   * In JavaScript, you should always use `JitChangeDetection`, unless you are in an environment that\n* \n   * has\n* \n   * [CSP](https://developer.mozilla.org/en-US/docs/Web/Security/CSP), such as a Chrome Extension.\n* \n   * \n* \n   * In Dart, use `DynamicChangeDetection` during development. The Angular transformer generates an\n* \n   * analog to the\n* \n   * `JitChangeDetection` strategy at compile time.\n* \n   * \n* \n   * \n* \n   * See: <a href='/angular2/angular2.api/DynamicChangeDetection'><code>DynamicChangeDetection</code></a>, <a href='/angular2/angular2.api/JitChangeDetection'><code>JitChangeDetection</code></a>,\n* \n   * <a href='/angular2/angular2.api/PreGeneratedChangeDetection'><code>PreGeneratedChangeDetection</code></a>\n* \n   * \n* \n   * # Example\n* \n   * ```javascript\n* \n   * bootstrap(MyApp, [bind(ChangeDetection).toClass(DynamicChangeDetection)]);\n* \n   * ```\n* \n   * @exportedAs angular2/change_detection",
        "* ON_PUSH means that the change detector's mode will be set to CHECK_ONCE during hydration.",
        "* DEFAULT means that the change detector's mode will be set to CHECK_ALWAYS during hydration.",
        "* Controls change detection.\n* \n   * \n* \n   * <a href='/angular2/angular2.api/ChangeDetectorRef'><code>ChangeDetectorRef</code></a> allows requesting checks for detectors that rely on observables. It\n* \n   * also allows detaching and\n* \n   * attaching change detector subtrees.\n* \n   * \n* \n   * @exportedAs angular2/change_detection",
        "* Request to check all ON_PUSH ancestors.",
        "* Detaches the change detector from the change detector tree.\n* \n     * \n* \n     * The detached change detector will not be checked until it is reattached.",
        "* Reattach the change detector to the change detector tree.\n* \n     * \n* \n     * This also requests a check of this change detector. This reattached change detector will be\n* \n     * checked during the\n* \n     * next change detection run.",
        "* Indicates that the result of a <a href='/angular2/angular2.api/Pipe'><code>Pipe</code></a> transformation has changed even though the reference\n* \n   * has not changed.\n* \n   * \n* \n   * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.\n* \n   * \n* \n   * @exportedAs angular2/pipes",
        "* An interface for extending the list of pipes known to Angular.\n* \n   * \n* \n   * If you are writing a custom <a href='/angular2/angular2.api/Pipe'><code>Pipe</code></a>, you must extend this interface.\n* \n   * \n* \n   * #Example\n* \n   * \n* \n   * ```\n* \n   * class DoublePipe implements Pipe {\n* \n   *  supports(obj) {\n* \n   *    return true;\n* \n   *  }\n* \n   * \n* \n   *  onDestroy() {}\n* \n   * \n* \n   *  transform(value, args = []) {\n* \n   *    return `${value}${value}`;\n* \n   *  }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/pipes",
        "* @exportedAs angular2/pipes",
        "* @exportedAs angular2/pipes",
        "* Implements change detection that does not require `eval()`.\n* \n   * \n* \n   * This is slower than <a href='/angular2/angular2.api/JitChangeDetection'><code>JitChangeDetection</code></a>.\n* \n   * \n* \n   * @exportedAs angular2/change_detection",
        "* Implements faster change detection by generating source code.\n* \n   * \n* \n   * This requires `eval()`. For change detection that does not require `eval()`, see\n* \n   * <a href='/angular2/angular2.api/DynamicChangeDetection'><code>DynamicChangeDetection</code></a> and <a href='/angular2/angular2.api/PreGeneratedChangeDetection'><code>PreGeneratedChangeDetection</code></a>.\n* \n   * \n* \n   * @exportedAs angular2/change_detection",
        "* Implements change detection using a map of pregenerated proto detectors.\n* \n   * \n* \n   * @exportedAs angular2/change_detection",
        "* Map from <a href='/angular2/angular2.api/ChangeDetectorDefinition#id'><code>ChangeDetectorDefinition</code></a> to a factory method which takes a\n* \n   * <a href='/angular2/angular2.api/PipeRegistry'><code>PipeRegistry</code></a> and a <a href='/angular2/angular2.api/ChangeDetectorDefinition'><code>ChangeDetectorDefinition</code></a> and generates a\n* \n   * <a href='/angular2/angular2.api/ProtoChangeDetector'><code>ProtoChangeDetector</code></a> associated with the definition.",
        "* Provides default implementation of supports and onDestroy.\n* \n   * \n* \n   * #Example\n* \n   * \n* \n   * ```\n* \n   * class DoublePipe extends BasePipe {*\n* \n   *  transform(value) {\n* \n   *    return `${value}${value}`;\n* \n   *  }\n* \n   * }\n* \n   * ```",
        "* Allows to refer to references which are not yet defined.\n* \n   * \n* \n   * This situation arises when the key which we need te refer to for the purposes of DI is declared,\n* \n   * but not yet defined.\n* \n   * \n* \n   * ## Example:\n* \n   * \n* \n   * ```\n* \n   * class Door {\n* \n   *   // Incorrect way to refer to a reference which is defined later.\n* \n   *   // This fails because `Lock` is undefined at this point.\n* \n   *   constructor(lock:Lock) { }\n* \n   * \n* \n   *   // Correct way to refer to a reference which is defined later.\n* \n   *   // The reference needs to be captured in a closure.\n* \n   *   constructor(@Inject(forwardRef(() => Lock)) lock:Lock) { }\n* \n   * }\n* \n   * \n* \n   * // Only at this point the lock is defined.\n* \n   * class Lock {\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/di",
        "* Lazily retrieve the reference value.\n* \n   * \n* \n   * See: <a href='/angular2/angular2.api/forwardRef'><code>forwardRef</code></a>\n* \n   * \n* \n   * @exportedAs angular2/di",
        "* A dependency injection container used for resolving dependencies.\n* \n   * \n* \n   * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n* \n   * constructor dependencies.\n* \n   * In typical use, application code asks for the dependencies in the constructor and they are\n* \n   * resolved by the `Injector`.\n* \n   * \n* \n   * ## Example:\n* \n   * \n* \n   * Suppose that we want to inject an `Engine` into class `Car`, we would define it like this:\n* \n   * \n* \n   * ```javascript\n* \n   * class Engine {\n* \n   * }\n* \n   * \n* \n   * class Car {\n* \n   *   constructor(@Inject(Engine) engine) {\n* \n   *   }\n* \n   * }\n* \n   * \n* \n   * ```\n* \n   * \n* \n   * Next we need to write the code that creates and instantiates the `Injector`. We then ask for the\n* \n   * `root` object, `Car`, so that the `Injector` can recursively build all of that object's\n* \n   * dependencies.\n* \n   * \n* \n   * ```javascript\n* \n   * main() {\n* \n   *   var injector = Injector.resolveAndCreate([Car, Engine]);\n* \n   * \n* \n   *   // Get a reference to the `root` object, which will recursively instantiate the tree.\n* \n   *   var car = injector.get(Car);\n* \n   * }\n* \n   * ```\n* \n   * Notice that we don't use the `new` operator because we explicitly want to have the `Injector`\n* \n   * resolve all of the object's dependencies automatically.\n* \n   * \n* \n   * @exportedAs angular2/di",
        "* Retrieves an instance from the injector.\n* \n     * \n* \n     * @param `token`: usually the `Type` of an object. (Same as the token used while setting up a\n* \n     * binding).\n* \n     * @returns an instance represented by the token. Throws if not found.",
        "* Retrieves an instance from the injector.\n* \n     * \n* \n     * @param `token`: usually a `Type`. (Same as the token used while setting up a binding).\n* \n     * @returns an instance represented by the token. Returns `null` if not found.",
        "* Retrieves an instance from the injector.\n* \n     * \n* \n     * @param `index`: index of an instance.\n* \n     * @returns an instance represented by the index. Throws if not found.",
        "* Direct parent of this injector.",
        "* Internal. Do not use.\n* \n     * \n* \n     * We return `any` not to export the InjectorStrategy type.",
        "* Creates a child injector and loads a new set of bindings into it.\n* \n     * \n* \n     * A resolution is a process of flattening multiple nested lists and converting individual\n* \n     * bindings into a list of <a href='/angular2/angular2.api/ResolvedBinding'><code>ResolvedBinding</code></a>s. The resolution can be cached by `resolve`\n* \n     * for the <a href='/angular2/angular2.api/Injector'><code>Injector</code></a> for performance-sensitive code.\n* \n     * \n* \n     * @param `bindings` can be a list of `Type`, <a href='/angular2/angular2.api/Binding'><code>Binding</code></a>, <a href='/angular2/angular2.api/ResolvedBinding'><code>ResolvedBinding</code></a>, or a\n* \n     * recursive list of more bindings.\n* \n     * @param `depProvider`",
        "* Creates a child injector and loads a new set of <a href='/angular2/angular2.api/ResolvedBinding'><code>ResolvedBinding</code></a>s into it.\n* \n     * \n* \n     * @param `bindings`: A sparse list of <a href='/angular2/angular2.api/ResolvedBinding'><code>ResolvedBinding</code></a>s.\n* \n     * See `resolve` for the <a href='/angular2/angular2.api/Injector'><code>Injector</code></a>.\n* \n     * @param `depProvider`\n* \n     * @returns a new child <a href='/angular2/angular2.api/Injector'><code>Injector</code></a>.",
        "* Describes how the <a href='/angular2/angular2.api/Injector'><code>Injector</code></a> should instantiate a given token.\n* \n   * \n* \n   * See <a href='/angular2/angular2.api/bind'><code>bind</code></a>.\n* \n   * \n* \n   * ## Example\n* \n   * \n* \n   * ```javascript\n* \n   * var injector = Injector.resolveAndCreate([\n* \n   *   new Binding(String, { toValue: 'Hello' })\n* \n   * ]);\n* \n   * \n* \n   * expect(injector.get(String)).toEqual('Hello');\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/di",
        "* Token used when retrieving this binding. Usually the `Type`.",
        "* Binds an interface to an implementation / subclass.\n* \n     * \n* \n     * ## Example\n* \n     * \n* \n     * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy\n* \n     * comparison.\n* \n     * \n* \n     * ```javascript\n* \n     * \n* \n     * class Vehicle {}\n* \n     * \n* \n     * class Car extends Vehicle {}\n* \n     * \n* \n     * var injectorClass = Injector.resolveAndCreate([\n* \n     *   Car,\n* \n     *   new Binding(Vehicle, { toClass: Car })\n* \n     * ]);\n* \n     * var injectorAlias = Injector.resolveAndCreate([\n* \n     *   Car,\n* \n     *   new Binding(Vehicle, { toAlias: Car })\n* \n     * ]);\n* \n     * \n* \n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n* \n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n* \n     * \n* \n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n* \n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n* \n     * ```",
        "* Binds a key to a value.\n* \n     * \n* \n     * ## Example\n* \n     * \n* \n     * ```javascript\n* \n     * var injector = Injector.resolveAndCreate([\n* \n     *   new Binding(String, { toValue: 'Hello' })\n* \n     * ]);\n* \n     * \n* \n     * expect(injector.get(String)).toEqual('Hello');\n* \n     * ```",
        "* Binds a key to the alias for an existing key.\n* \n     * \n* \n     * An alias means that <a href='/angular2/angular2.api/Injector'><code>Injector</code></a> returns the same instance as if the alias token was used.\n* \n     * This is in contrast to `toClass` where a separate instance of `toClass` is returned.\n* \n     * \n* \n     * ## Example\n* \n     * \n* \n     * Becuse `toAlias` and `toClass` are often confused the example contains both use cases for easy\n* \n     * comparison.\n* \n     * \n* \n     * ```javascript\n* \n     * \n* \n     * class Vehicle {}\n* \n     * \n* \n     * class Car extends Vehicle {}\n* \n     * \n* \n     * var injectorAlias = Injector.resolveAndCreate([\n* \n     *   Car,\n* \n     *   new Binding(Vehicle, { toAlias: Car })\n* \n     * ]);\n* \n     * var injectorClass = Injector.resolveAndCreate([\n* \n     *   Car,\n* \n     *   new Binding(Vehicle, { toClass: Car })\n* \n     * ]);\n* \n     * \n* \n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n* \n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n* \n     * \n* \n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n* \n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n* \n     * ```",
        "* Binds a key to a function which computes the value.\n* \n     * \n* \n     * ## Example\n* \n     * \n* \n     * ```javascript\n* \n     * var injector = Injector.resolveAndCreate([\n* \n     *   new Binding(Number, { toFactory: () => { return 1+2; }}),\n* \n     *   new Binding(String, { toFactory: (value) => { return \"Value: \" + value; },\n* \n     *                         dependencies: [Number] })\n* \n     * ]);\n* \n     * \n* \n     * expect(injector.get(Number)).toEqual(3);\n* \n     * expect(injector.get(String)).toEqual('Value: 3');\n* \n     * ```",
        "* Used in conjunction with `toFactory` and specifies a set of dependencies\n* \n     * (as `token`s) which should be injected into the factory function.\n* \n     * \n* \n     * ## Example\n* \n     * \n* \n     * ```javascript\n* \n     * var injector = Injector.resolveAndCreate([\n* \n     *   new Binding(Number, { toFactory: () => { return 1+2; }}),\n* \n     *   new Binding(String, { toFactory: (value) => { return \"Value: \" + value; },\n* \n     *                         dependencies: [Number] })\n* \n     * ]);\n* \n     * \n* \n     * expect(injector.get(Number)).toEqual(3);\n* \n     * expect(injector.get(String)).toEqual('Value: 3');\n* \n     * ```",
        "* Converts the <a href='/angular2/angular2.api/Binding'><code>Binding</code></a> into <a href='/angular2/angular2.api/ResolvedBinding'><code>ResolvedBinding</code></a>.\n* \n     * \n* \n     * <a href='/angular2/angular2.api/Injector'><code>Injector</code></a> internally only uses <a href='/angular2/angular2.api/ResolvedBinding'><code>ResolvedBinding</code></a>, <a href='/angular2/angular2.api/Binding'><code>Binding</code></a> contains\n* \n     * convenience binding syntax.",
        "* Provides an API for imperatively constructing <a href='/angular2/angular2.api/Binding'><code>Binding</code></a>s.\n* \n   * \n* \n   * This is only relevant for JavaScript. See <a href='/angular2/angular2.api/BindingBuilder'><code>BindingBuilder</code></a>.\n* \n   * \n* \n   * ## Example\n* \n   * \n* \n   * ```javascript\n* \n   * bind(MyInterface).toClass(MyClass)\n* \n   * \n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/di",
        "* A unique object used for retrieving items from the <a href='/angular2/angular2.api/Injector'><code>Injector</code></a>.\n* \n   * \n* \n   * Keys have:\n* \n   * - a system-wide unique `id`.\n* \n   * - a `token`, usually the `Type` of the instance.\n* \n   * \n* \n   * Keys are used internally by the <a href='/angular2/angular2.api/Injector'><code>Injector</code></a> because their system-wide unique `id`s allow the\n* \n   * injector to index in arrays rather than looking up items in maps.\n* \n   * \n* \n   * @exportedAs angular2/di",
        "* Thrown when trying to retrieve a dependency by `Key` from <a href='/angular2/angular2.api/Injector'><code>Injector</code></a>, but the\n* \n   * <a href='/angular2/angular2.api/Injector'><code>Injector</code></a> does not have a <a href='/angular2/angular2.api/Binding'><code>Binding</code></a> for <a href='/angular2/angular2.api/Key'><code>Key</code></a>.\n* \n   * \n* \n   * @exportedAs angular2/di_errors",
        "* Base class for all errors arising from misconfigured bindings.\n* \n   * \n* \n   * @exportedAs angular2/di_errors",
        "* Thrown when trying to retrieve an async <a href='/angular2/angular2.api/Binding'><code>Binding</code></a> using the sync API.\n* \n   * \n* \n   * ## Example\n* \n   * \n* \n   * ```javascript\n* \n   * var injector = Injector.resolveAndCreate([\n* \n   *   bind(Number).toAsyncFactory(() => {\n* \n   *     return new Promise((resolve) => resolve(1 + 2));\n* \n   *   }),\n* \n   *   bind(String).toFactory((v) => { return \"Value: \" + v; }, [String])\n* \n   * ]);\n* \n   * \n* \n   * injector.asyncGet(String).then((v) => expect(v).toBe('Value: 3'));\n* \n   * expect(() => {\n* \n   *   injector.get(String);\n* \n   * }).toThrowError(AsycBindingError);\n* \n   * ```\n* \n   * \n* \n   * The above example throws because `String` depends on `Number` which is async. If any binding in\n* \n   * the dependency graph is async then the graph can only be retrieved using the `asyncGet` API.\n* \n   * \n* \n   * @exportedAs angular2/di_errors",
        "* Thrown when dependencies form a cycle.\n* \n   * \n* \n   * ## Example:\n* \n   * \n* \n   * ```javascript\n* \n   * class A {\n* \n   *   constructor(b:B) {}\n* \n   * }\n* \n   * class B {\n* \n   *   constructor(a:A) {}\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n* \n   * \n* \n   * @exportedAs angular2/di_errors",
        "* Thrown when a constructing type returns with an Error.\n* \n   * \n* \n   * The `InstantiationError` class contains the original error plus the dependency graph which caused\n* \n   * this object to be instantiated.\n* \n   * \n* \n   * @exportedAs angular2/di_errors",
        "* Thrown when an object other then <a href='/angular2/angular2.api/Binding'><code>Binding</code></a> (or `Type`) is passed to <a href='/angular2/angular2.api/Injector'><code>Injector</code></a>\n* \n   * creation.\n* \n   * \n* \n   * @exportedAs angular2/di_errors",
        "* Thrown when the class has no annotation information.\n* \n   * \n* \n   * Lack of annotation information prevents the <a href='/angular2/angular2.api/Injector'><code>Injector</code></a> from determining which dependencies\n* \n   * need to be injected into the constructor.\n* \n   * \n* \n   * @exportedAs angular2/di_errors",
        "* @exportedAs angular2/di",
        "* An internal resolved representation of a <a href='/angular2/angular2.api/Binding'><code>Binding</code></a> used by the <a href='/angular2/angular2.api/Injector'><code>Injector</code></a>.\n* \n   * \n* \n   * A <a href='/angular2/angular2.api/Binding'><code>Binding</code></a> is resolved when it has a factory function. Binding to a class, alias, or\n* \n   * value, are just convenience methods, as <a href='/angular2/angular2.api/Injector'><code>Injector</code></a> only operates on calling factory\n* \n   * functions.\n* \n   * \n* \n   * @exportedAs angular2/di",
        "* A key, usually a `Type`.",
        "* Factory function which can return an instance of an object represented by a key.",
        "* Arguments (dependencies) to the `factory` function.",
        "* Helper class for the <a href='/angular2/angular2.api/bind'><code>bind</code></a> function.\n* \n   * \n* \n   * @exportedAs angular2/di",
        "* Binds an interface to an implementation / subclass.\n* \n     * \n* \n     * ## Example\n* \n     * \n* \n     * Because `toAlias` and `toClass` are often confused, the example contains both use cases for\n* \n     * easy comparison.\n* \n     * \n* \n     * ```javascript\n* \n     * \n* \n     * class Vehicle {}\n* \n     * \n* \n     * class Car extends Vehicle {}\n* \n     * \n* \n     * var injectorClass = Injector.resolveAndCreate([\n* \n     *   Car,\n* \n     *   bind(Vehicle).toClass(Car)\n* \n     * ]);\n* \n     * var injectorAlias = Injector.resolveAndCreate([\n* \n     *   Car,\n* \n     *   bind(Vehicle).toAlias(Car)\n* \n     * ]);\n* \n     * \n* \n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n* \n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n* \n     * \n* \n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n* \n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n* \n     * ```",
        "* Binds a key to a value.\n* \n     * \n* \n     * ## Example\n* \n     * \n* \n     * ```javascript\n* \n     * var injector = Injector.resolveAndCreate([\n* \n     *   bind(String).toValue('Hello')\n* \n     * ]);\n* \n     * \n* \n     * expect(injector.get(String)).toEqual('Hello');\n* \n     * ```",
        "* Binds a key to the alias for an existing key.\n* \n     * \n* \n     * An alias means that we will return the same instance as if the alias token was used. (This is\n* \n     * in contrast to `toClass` where a separet instance of `toClass` will be returned.)\n* \n     * \n* \n     * ## Example\n* \n     * \n* \n     * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy\n* \n     * comparison.\n* \n     * \n* \n     * ```javascript\n* \n     * \n* \n     * class Vehicle {}\n* \n     * \n* \n     * class Car extends Vehicle {}\n* \n     * \n* \n     * var injectorAlias = Injector.resolveAndCreate([\n* \n     *   Car,\n* \n     *   bind(Vehicle).toAlias(Car)\n* \n     * ]);\n* \n     * var injectorClass = Injector.resolveAndCreate([\n* \n     *   Car,\n* \n     *   bind(Vehicle).toClass(Car)\n* \n     * ]);\n* \n     * \n* \n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n* \n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n* \n     * \n* \n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n* \n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n* \n     * ```",
        "* Binds a key to a function which computes the value.\n* \n     * \n* \n     * ## Example\n* \n     * \n* \n     * ```javascript\n* \n     * var injector = Injector.resolveAndCreate([\n* \n     *   bind(Number).toFactory(() => { return 1+2; }),\n* \n     *   bind(String).toFactory((v) => { return \"Value: \" + v; }, [Number])\n* \n     * ]);\n* \n     * \n* \n     * expect(injector.get(Number)).toEqual(3);\n* \n     * expect(injector.get(String)).toEqual('Value: 3');\n* \n     * ```",
        "* @private",
        "* Used to provide dependencies that cannot be easily expressed as bindings.",
        "* Omitting from external API doc as this is really an abstract internal concept.",
        "* Defines a part of a form that cannot be divided into other controls.\n* \n   * \n* \n   * `Control` is one of the three fundamental building blocks used to define forms in Angular, along\n* \n   * with\n* \n   * <a href='/angular2/angular2.api/ControlGroup'><code>ControlGroup</code></a> and <a href='/angular2/angular2.api/ControlArray'><code>ControlArray</code></a>.\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* Defines a part of a form, of fixed length, that can contain other controls.\n* \n   * \n* \n   * A ControlGroup aggregates the values and errors of each <a href='/angular2/angular2.api/Control'><code>Control</code></a> in the group. Thus, if\n* \n   * one of the controls\n* \n   * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,\n* \n   * the entire group\n* \n   * changes as well.\n* \n   * \n* \n   * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,\n* \n   * along with\n* \n   * <a href='/angular2/angular2.api/Control'><code>Control</code></a> and <a href='/angular2/angular2.api/ControlArray'><code>ControlArray</code></a>. <a href='/angular2/angular2.api/ControlArray'><code>ControlArray</code></a> can also contain other controls,\n* \n   * but is of variable\n* \n   * length.\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* Defines a part of a form, of variable length, that can contain other controls.\n* \n   * \n* \n   * A `ControlArray` aggregates the values and errors of each <a href='/angular2/angular2.api/Control'><code>Control</code></a> in the group. Thus, if\n* \n   * one of the controls\n* \n   * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,\n* \n   * the entire group\n* \n   * changes as well.\n* \n   * \n* \n   * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,\n* \n   * along with\n* \n   * <a href='/angular2/angular2.api/Control'><code>Control</code></a> and <a href='/angular2/angular2.api/ControlGroup'><code>ControlGroup</code></a>. <a href='/angular2/angular2.api/ControlGroup'><code>ControlGroup</code></a> can also contain other controls,\n* \n   * but is of fixed\n* \n   * length.\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* Creates and binds a control with a specified name to a DOM element.\n* \n   * \n* \n   * This directive can only be used as a child of <a href='/angular2/angular2.api/NgForm'><code>NgForm</code></a> or <a href='/angular2/angular2.api/NgFormModel'><code>NgFormModel</code></a>.\n* \n   * \n* \n   * # Example\n* \n   * \n* \n   * In this example, we create the login and password controls.\n* \n   * We can work with each control separately: check its validity, get its value, listen to its\n* \n   *  changes.\n* \n   * \n* \n   *  ```\n* \n   * @Component({selector: \"login-comp\"})\n* \n   * @View({\n* \n   *      directives: [formDirectives],\n* \n   *      template: `\n* \n   *              <form #f=\"form\" (submit)='onLogIn(f.value)'>\n* \n   *                Login <input type='text' ng-control='login' #l=\"form\">\n* \n   *                <div *ng-if=\"!l.valid\">Login is invalid</div>\n* \n   * \n* \n   *                Password <input type='password' ng-control='password'>\n* \n   * \n* \n   *                <button type='submit'>Log in!</button>\n* \n   *              </form>\n* \n   *      `})\n* \n   * class LoginComp {\n* \n   *  onLogIn(value) {\n* \n   *    // value === {login: 'some login', password: 'some password'}\n* \n   *  }\n* \n   * }\n* \n   *  ```\n* \n   * \n* \n   * We can also use ng-model to bind a domain model to the form.\n* \n   * \n* \n   *  ```\n* \n   * @Component({selector: \"login-comp\"})\n* \n   * @View({\n* \n   *      directives: [formDirectives],\n* \n   *      template: `\n* \n   *              <form (submit)='onLogIn()'>\n* \n   *                Login <input type='text' ng-control='login' [(ng-model)]=\"credentials.login\">\n* \n   *                Password <input type='password' ng-control='password'\n* \n   *  [(ng-model)]=\"credentials.password\">\n* \n   *                <button type='submit'>Log in!</button>\n* \n   *              </form>\n* \n   *      `})\n* \n   * class LoginComp {\n* \n   *  credentials: {login:string, password:string};\n* \n   * \n* \n   *  onLogIn() {\n* \n   *    // this.credentials.login === \"some login\"\n* \n   *    // this.credentials.password === \"some password\"\n* \n   *  }\n* \n   * }\n* \n   *  ```\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* Binds an existing control to a DOM element.\n* \n   * \n* \n   * # Example\n* \n   * \n* \n   * In this example, we bind the control to an input element. When the value of the input element\n* \n   * changes, the value of\n* \n   * the control will reflect that change. Likewise, if the value of the control changes, the input\n* \n   * element reflects that\n* \n   * change.\n* \n   * \n* \n   *  ```\n* \n   * @Component({selector: \"login-comp\"})\n* \n   * @View({\n* \n   *      directives: [formDirectives],\n* \n   *      template: \"<input type='text' [ng-form-control]='loginControl'>\"\n* \n   *      })\n* \n   * class LoginComp {\n* \n   *  loginControl:Control;\n* \n   * \n* \n   *  constructor() {\n* \n   *    this.loginControl = new Control('');\n* \n   *  }\n* \n   * }\n* \n   * \n* \n   *  ```\n* \n   * \n* \n   * We can also use ng-model to bind a domain model to the form.\n* \n   * \n* \n   *  ```\n* \n   * @Component({selector: \"login-comp\"})\n* \n   * @View({\n* \n   *      directives: [formDirectives],\n* \n   *      template: \"<input type='text' [ng-form-control]='loginControl' [(ng-model)]='login'>\"\n* \n   *      })\n* \n   * class LoginComp {\n* \n   *  loginControl:Control;\n* \n   *  login:string;\n* \n   * \n* \n   *  constructor() {\n* \n   *    this.loginControl = new Control('');\n* \n   *  }\n* \n   * }\n* \n   *  ```\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* Binds a domain model to the form.\n* \n   * \n* \n   * # Example\n* \n   *  ```\n* \n   * @Component({selector: \"search-comp\"})\n* \n   * @View({\n* \n   *      directives: [formDirectives],\n* \n   *      template: `\n* \n   *               <input type='text' [(ng-model)]=\"searchQuery\">\n* \n   *      `})\n* \n   * class SearchComp {\n* \n   *  searchQuery: string;\n* \n   * }\n* \n   *  ```\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* An abstract class that all control directive extend.\n* \n   * \n* \n   * It binds a <a href='/angular2/angular2.api/Control'><code>Control</code></a> object to a DOM element.\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* Creates and binds a control group to a DOM element.\n* \n   * \n* \n   * This directive can only be used as a child of <a href='/angular2/angular2.api/NgForm'><code>NgForm</code></a> or <a href='/angular2/angular2.api/NgFormModel'><code>NgFormModel</code></a>.\n* \n   * \n* \n   * # Example\n* \n   * \n* \n   * In this example, we create the credentials and personal control groups.\n* \n   * We can work with each group separately: check its validity, get its value, listen to its changes.\n* \n   * \n* \n   *  ```\n* \n   * @Component({selector: \"signup-comp\"})\n* \n   * @View({\n* \n   *      directives: [formDirectives],\n* \n   *      template: `\n* \n   *              <form #f=\"form\" (submit)='onSignUp(f.value)'>\n* \n   *                <div ng-control-group='credentials' #credentials=\"form\">\n* \n   *                  Login <input type='text' ng-control='login'>\n* \n   *                  Password <input type='password' ng-control='password'>\n* \n   *                </div>\n* \n   *                <div *ng-if=\"!credentials.valid\">Credentials are invalid</div>\n* \n   * \n* \n   *                <div ng-control-group='personal'>\n* \n   *                  Name <input type='text' ng-control='name'>\n* \n   *                </div>\n* \n   *                <button type='submit'>Sign Up!</button>\n* \n   *              </form>\n* \n   *      `})\n* \n   * class SignupComp {\n* \n   *  onSignUp(value) {\n* \n   *    // value === {personal: {name: 'some name'},\n* \n   *    //  credentials: {login: 'some login', password: 'some password'}}\n* \n   *  }\n* \n   * }\n* \n   * \n* \n   *  ```\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* Binds an existing control group to a DOM element.\n* \n   * \n* \n   * # Example\n* \n   * \n* \n   * In this example, we bind the control group to the form element, and we bind the login and\n* \n   * password controls to the\n* \n   * login and password elements.\n* \n   * \n* \n   *  ```\n* \n   * @Component({selector: \"login-comp\"})\n* \n   * @View({\n* \n   *      directives: [formDirectives],\n* \n   *      template: \"<form [ng-form-model]='loginForm'>\" +\n* \n   *              \"Login <input type='text' ng-control='login'>\" +\n* \n   *              \"Password <input type='password' ng-control='password'>\" +\n* \n   *              \"<button (click)=\"onLogin()\">Login</button>\" +\n* \n   *              \"</form>\"\n* \n   *      })\n* \n   * class LoginComp {\n* \n   *  loginForm:ControlGroup;\n* \n   * \n* \n   *  constructor() {\n* \n   *    this.loginForm = new ControlGroup({\n* \n   *      login: new Control(\"\"),\n* \n   *      password: new Control(\"\")\n* \n   *    });\n* \n   *  }\n* \n   * \n* \n   *  onLogin() {\n* \n   *    // this.loginForm.value\n* \n   *  }\n* \n   * }\n* \n   * \n* \n   *  ```\n* \n   * \n* \n   * We can also use ng-model to bind a domain model to the form.\n* \n   * \n* \n   *  ```\n* \n   * @Component({selector: \"login-comp\"})\n* \n   * @View({\n* \n   *      directives: [formDirectives],\n* \n   *      template: \"<form [ng-form-model]='loginForm'>\" +\n* \n   *              \"Login <input type='text' ng-control='login' [(ng-model)]='login'>\" +\n* \n   *              \"Password <input type='password' ng-control='password' [(ng-model)]='password'>\" +\n* \n   *              \"<button (click)=\"onLogin()\">Login</button>\" +\n* \n   *              \"</form>\"\n* \n   *      })\n* \n   * class LoginComp {\n* \n   *  credentials:{login:string, password:string}\n* \n   *  loginForm:ControlGroup;\n* \n   * \n* \n   *  constructor() {\n* \n   *    this.loginForm = new ControlGroup({\n* \n   *      login: new Control(\"\"),\n* \n   *      password: new Control(\"\")\n* \n   *    });\n* \n   *  }\n* \n   * \n* \n   *  onLogin() {\n* \n   *    // this.credentials.login === 'some login'\n* \n   *    // this.credentials.password === 'some password'\n* \n   *  }\n* \n   * }\n* \n   *  ```\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* Creates and binds a form object to a DOM element.\n* \n   * \n* \n   * # Example\n* \n   * \n* \n   *  ```\n* \n   * @Component({selector: \"signup-comp\"})\n* \n   * @View({\n* \n   *      directives: [formDirectives],\n* \n   *      template: `\n* \n   *              <form #f=\"form\" (submit)='onSignUp(f.value)'>\n* \n   *                <div ng-control-group='credentials' #credentials=\"form\">\n* \n   *                  Login <input type='text' ng-control='login'>\n* \n   *                  Password <input type='password' ng-control='password'>\n* \n   *                </div>\n* \n   *                <div *ng-if=\"!credentials.valid\">Credentials are invalid</div>\n* \n   * \n* \n   *                <div ng-control-group='personal'>\n* \n   *                  Name <input type='text' ng-control='name'>\n* \n   *                </div>\n* \n   *                <button type='submit'>Sign Up!</button>\n* \n   *              </form>\n* \n   *      `})\n* \n   * class SignupComp {\n* \n   *  onSignUp(value) {\n* \n   *    // value === {personal: {name: 'some name'},\n* \n   *    //  credentials: {login: 'some login', password: 'some password'}}\n* \n   *  }\n* \n   * }\n* \n   * \n* \n   *  ```\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* A bridge between a control and a native element.\n* \n   * \n* \n   * Please see <a href='/angular2/angular2.api/DefaultValueAccessor'><code>DefaultValueAccessor</code></a> for more information.",
        "* The default accessor for writing a value and listening to changes that is used by the\n* \n   * <a href='/angular2/angular2.api/NgModel'><code>NgModel</code></a>, <a href='/angular2/angular2.api/NgFormControl'><code>NgFormControl</code></a>, and <a href='/angular2/angular2.api/NgControlName'><code>NgControlName</code></a> directives.\n* \n   * \n* \n   *  # Example\n* \n   *  ```\n* \n   *  <input type=\"text\" [(ng-model)]=\"searchQuery\">\n* \n   *  ```\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* The accessor for writing a value and listening to changes on a checkbox input element.\n* \n   * \n* \n   *  # Example\n* \n   *  ```\n* \n   *  <input type=\"checkbox\" [ng-control]=\"rememberLogin\">\n* \n   *  ```\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* The accessor for writing a value and listening to changes on a select element.\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* A list of all the form directives used as part of a `@View` annotation.\n* \n   * \n* \n   *  This is a shorthand for importing them each individually.\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* Provides a set of validators used by form controls.\n* \n   * \n* \n   * # Example\n* \n   * \n* \n   * ```\n* \n   * var loginControl = new Control(\"\", Validators.required)\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/forms",
        "* Creates a form object from a user-specified configuration.\n* \n   * \n* \n   * # Example\n* \n   * \n* \n   * ```\n* \n   * import {Component, View, bootstrap} from 'angular2/angular2';\n* \n   * import {FormBuilder, Validators, formDirectives, ControlGroup} from 'angular2/forms';\n* \n   * \n* \n   * @Component({\n* \n   *   selector: 'login-comp',\n* \n   *   viewInjector: [\n* \n   *     FormBuilder\n* \n   *   ]\n* \n   * })\n* \n   * @View({\n* \n   *   template: `\n* \n   *     <form [control-group]=\"loginForm\">\n* \n   *       Login <input control=\"login\">\n* \n   * \n* \n   *       <div control-group=\"passwordRetry\">\n* \n   *         Password <input type=\"password\" control=\"password\">\n* \n   *         Confirm password <input type=\"password\" control=\"passwordConfirmation\">\n* \n   *       </div>\n* \n   *     </form>\n* \n   *   `,\n* \n   *   directives: [\n* \n   *     formDirectives\n* \n   *   ]\n* \n   * })\n* \n   * class LoginComp {\n* \n   *   loginForm: ControlGroup;\n* \n   * \n* \n   *   constructor(builder: FormBuilder) {\n* \n   *     this.loginForm = builder.group({\n* \n   *       login: [\"\", Validators.required],\n* \n   * \n* \n   *       passwordRetry: builder.group({\n* \n   *         password: [\"\", Validators.required],\n* \n   *         passwordConfirmation: [\"\", Validators.required]\n* \n   *       })\n* \n   *     });\n* \n   *   }\n* \n   * }\n* \n   * \n* \n   * bootstrap(LoginComp)\n* \n   * ```\n* \n   * \n* \n   * This example creates a <a href='/angular2/angular2.api/ControlGroup'><code>ControlGroup</code></a> that consists of a `login` <a href='/angular2/angular2.api/Control'><code>Control</code></a>, and a\n* \n   * nested\n* \n   * <a href='/angular2/angular2.api/ControlGroup'><code>ControlGroup</code></a> that defines a `password` and a `passwordConfirmation` <a href='/angular2/angular2.api/Control'><code>Control</code></a>:\n* \n   * \n* \n   * ```\n* \n   *  var loginForm = builder.group({\n* \n   *    login: [\"\", Validators.required],\n* \n   * \n* \n   *    passwordRetry: builder.group({\n* \n   *      password: [\"\", Validators.required],\n* \n   *      passwordConfirmation: [\"\", Validators.required]\n* \n   *    })\n* \n   *  });\n* \n   * \n* \n   *  ```\n* \n   * @exportedAs angular2/forms",
        "* Declare reusable UI building blocks for an application.\n* \n   * \n* \n   * Each Angular component requires a single `@Component` and at least one `@View` annotation. The\n* \n   * `@Component`\n* \n   * annotation specifies when a component is instantiated, and which properties and hostListeners it\n* \n   * binds to.\n* \n   * \n* \n   * When a component is instantiated, Angular\n* \n   * - creates a shadow DOM for the component.\n* \n   * - loads the selected template into the shadow DOM.\n* \n   * - creates all the injectable objects configured with `hostInjector` and `viewInjector`.\n* \n   * \n* \n   * All template expressions and statements are then evaluated against the component instance.\n* \n   * \n* \n   * For details on the `@View` annotation, see <a href='/angular2/angular2.api/View'><code>View</code></a>.\n* \n   * \n* \n   * ## Example\n* \n   * \n* \n   * ```\n* \n   * @Component({\n* \n   *   selector: 'greet'\n* \n   * })\n* \n   * @View({\n* \n   *   template: 'Hello {{name}}!'\n* \n   * })\n* \n   * class Greet {\n* \n   *   name: string;\n* \n   * \n* \n   *   constructor() {\n* \n   *     this.name = 'World';\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * \n* \n   * @exportedAs angular2/annotations",
        "* Defines the used change detection strategy.\n* \n     * \n* \n     * When a component is instantiated, Angular creates a change detector, which is responsible for\n* \n     * propagating\n* \n     * the component's bindings.\n* \n     * \n* \n     * The `changeDetection` property defines, whether the change detection will be checked every time\n* \n     * or only when the component\n* \n     * tells it to do so.",
        "* Defines the set of injectable objects that are visible to its view dom children.\n* \n     * \n* \n     * ## Simple Example\n* \n     * \n* \n     * Here is an example of a class that can be injected:\n* \n     * \n* \n     * ```\n* \n     * class Greeter {\n* \n     *    greet(name:string) {\n* \n     *      return 'Hello ' + name + '!';\n* \n     *    }\n* \n     * }\n* \n     * \n* \n     * @Directive({\n* \n     *   selector: 'needs-greeter'\n* \n     * })\n* \n     * class NeedsGreeter {\n* \n     *   greeter:Greeter;\n* \n     * \n* \n     *   constructor(greeter:Greeter) {\n* \n     *     this.greeter = greeter;\n* \n     *   }\n* \n     * }\n* \n     * \n* \n     * @Component({\n* \n     *   selector: 'greet',\n* \n     *   viewInjector: [\n* \n     *     Greeter\n* \n     *   ]\n* \n     * })\n* \n     * @View({\n* \n     *   template: `<needs-greeter></needs-greeter>`,\n* \n     *   directives: [NeedsGreeter]\n* \n     * })\n* \n     * class HelloWorld {\n* \n     * }\n* \n     * \n* \n     * ```",
        "* Directives allow you to attach behavior to elements in the DOM.\n* \n   * \n* \n   * <a href='/angular2/angular2.api/Directive'><code>Directive</code></a>s with an embedded view are called <a href='/angular2/angular2.api/Component'><code>Component</code></a>s.\n* \n   * \n* \n   * A directive consists of a single directive annotation and a controller class. When the\n* \n   * directive's `selector` matches\n* \n   * elements in the DOM, the following steps occur:\n* \n   * \n* \n   * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor\n* \n   * arguments.\n* \n   * 2. Angular instantiates directives for each matched element using `ElementInjector` in a\n* \n   * depth-first order,\n* \n   *    as declared in the HTML.\n* \n   * \n* \n   * ## Understanding How Injection Works\n* \n   * \n* \n   * There are three stages of injection resolution.\n* \n   * - *Pre-existing Injectors*:\n* \n   *   - The terminal <a href='/angular2/angular2.api/Injector'><code>Injector</code></a> cannot resolve dependencies. It either throws an error or, if\n* \n   * the dependency was\n* \n   *     specified as `@Optional`, returns `null`.\n* \n   *   - The platform injector resolves browser singleton resources, such as: cookies, title,\n* \n   * location, and others.\n* \n   * - *Component Injectors*: Each component instance has its own <a href='/angular2/angular2.api/Injector'><code>Injector</code></a>, and they follow\n* \n   * the same parent-child hierarchy\n* \n   *     as the component instances in the DOM.\n* \n   * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each\n* \n   * element has an `ElementInjector`\n* \n   *     which follow the same parent-child hierarchy as the DOM elements themselves.\n* \n   * \n* \n   * When a template is instantiated, it also must instantiate the corresponding directives in a\n* \n   * depth-first order. The\n* \n   * current `ElementInjector` resolves the constructor dependencies for each directive.\n* \n   * \n* \n   * Angular then resolves dependencies as follows, according to the order in which they appear in the\n* \n   * <a href='/angular2/angular2.api/View'><code>View</code></a>:\n* \n   * \n* \n   * 1. Dependencies on the current element\n* \n   * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary\n* \n   * 3. Dependencies on component injectors and their parents until it encounters the root component\n* \n   * 4. Dependencies on pre-existing injectors\n* \n   * \n* \n   * \n* \n   * The `ElementInjector` can inject other directives, element-specific special objects, or it can\n* \n   * delegate to the parent\n* \n   * injector.\n* \n   * \n* \n   * To inject other directives, declare the constructor parameter as:\n* \n   * - `directive:DirectiveType`: a directive on the current element only\n* \n   * - `@Ancestor() directive:DirectiveType`: any directive that matches the type between the current\n* \n   * element and the\n* \n   *    Shadow DOM root. Current element is not included in the resolution, therefore even if it could\n* \n   * resolve it, it will\n* \n   *    be ignored.\n* \n   * - `@Parent() directive:DirectiveType`: any directive that matches the type on a direct parent\n* \n   * element only.\n* \n   * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child\n* \n   * directives.\n* \n   * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any\n* \n   * child directives.\n* \n   * \n* \n   * To inject element-specific special objects, declare the constructor parameter as:\n* \n   * - `element: ElementRef` to obtain a reference to logical element in the view.\n* \n   * - `viewContainer: ViewContainerRef` to control child template instantiation, for\n* \n   * <a href='/angular2/angular2.api/Directive'><code>Directive</code></a> directives only\n* \n   * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.\n* \n   * \n* \n   * ## Example\n* \n   * \n* \n   * The following example demonstrates how dependency injection resolves constructor arguments in\n* \n   * practice.\n* \n   * \n* \n   * \n* \n   * Assume this HTML template:\n* \n   * \n* \n   * ```\n* \n   * <div dependency=\"1\">\n* \n   *   <div dependency=\"2\">\n* \n   *     <div dependency=\"3\" my-directive>\n* \n   *       <div dependency=\"4\">\n* \n   *         <div dependency=\"5\"></div>\n* \n   *       </div>\n* \n   *       <div dependency=\"6\"></div>\n* \n   *     </div>\n* \n   *   </div>\n* \n   * </div>\n* \n   * ```\n* \n   * \n* \n   * With the following `dependency` decorator and `SomeService` injectable class.\n* \n   * \n* \n   * ```\n* \n   * @Injectable()\n* \n   * class SomeService {\n* \n   * }\n* \n   * \n* \n   * @Directive({\n* \n   *   selector: '[dependency]',\n* \n   *   properties: [\n* \n   *     'id: dependency'\n* \n   *   ]\n* \n   * })\n* \n   * class Dependency {\n* \n   *   id:string;\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * Let's step through the different ways in which `MyDirective` could be declared...\n* \n   * \n* \n   * \n* \n   * ### No injection\n* \n   * \n* \n   * Here the constructor is declared with no arguments, therefore nothing is injected into\n* \n   * `MyDirective`.\n* \n   * \n* \n   * ```\n* \n   * @Directive({ selector: '[my-directive]' })\n* \n   * class MyDirective {\n* \n   *   constructor() {\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * This directive would be instantiated with no dependencies.\n* \n   * \n* \n   * \n* \n   * ### Component-level injection\n* \n   * \n* \n   * Directives can inject any injectable instance from the closest component injector or any of its\n* \n   * parents.\n* \n   * \n* \n   * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type\n* \n   * from the parent\n* \n   * component's injector.\n* \n   * ```\n* \n   * @Directive({ selector: '[my-directive]' })\n* \n   * class MyDirective {\n* \n   *   constructor(someService: SomeService) {\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * This directive would be instantiated with a dependency on `SomeService`.\n* \n   * \n* \n   * \n* \n   * ### Injecting a directive from the current element\n* \n   * \n* \n   * Directives can inject other directives declared on the current element.\n* \n   * \n* \n   * ```\n* \n   * @Directive({ selector: '[my-directive]' })\n* \n   * class MyDirective {\n* \n   *   constructor(dependency: Dependency) {\n* \n   *     expect(dependency.id).toEqual(3);\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * This directive would be instantiated with `Dependency` declared at the same element, in this case\n* \n   * `dependency=\"3\"`.\n* \n   * \n* \n   * \n* \n   * ### Injecting a directive from a direct parent element\n* \n   * \n* \n   * Directives can inject other directives declared on a direct parent element. By definition, a\n* \n   * directive with a\n* \n   * `@Parent` annotation does not attempt to resolve dependencies for the current element, even if\n* \n   * this would satisfy\n* \n   * the dependency.\n* \n   * \n* \n   * ```\n* \n   * @Directive({ selector: '[my-directive]' })\n* \n   * class MyDirective {\n* \n   *   constructor(@Parent() dependency: Dependency) {\n* \n   *     expect(dependency.id).toEqual(2);\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * This directive would be instantiated with `Dependency` declared at the parent element, in this\n* \n   * case `dependency=\"2\"`.\n* \n   * \n* \n   * \n* \n   * ### Injecting a directive from any ancestor elements\n* \n   * \n* \n   * Directives can inject other directives declared on any ancestor element (in the current Shadow\n* \n   * DOM), i.e. on the\n* \n   * parent element and its parents. By definition, a directive with an `@Ancestor` annotation does\n* \n   * not attempt to\n* \n   * resolve dependencies for the current element, even if this would satisfy the dependency.\n* \n   * \n* \n   * ```\n* \n   * @Directive({ selector: '[my-directive]' })\n* \n   * class MyDirective {\n* \n   *   constructor(@Ancestor() dependency: Dependency) {\n* \n   *     expect(dependency.id).toEqual(2);\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * Unlike the `@Parent` which only checks the parent, `@Ancestor` checks the parent, as well as its\n* \n   * parents recursively. If `dependency=\"2\"` didn't exist on the direct parent, this injection would\n* \n   * have returned\n* \n   * `dependency=\"1\"`.\n* \n   * \n* \n   * \n* \n   * ### Injecting a live collection of direct child directives\n* \n   * \n* \n   * \n* \n   * A directive can also query for other child directives. Since parent directives are instantiated\n* \n   * before child directives, a directive can't simply inject the list of child directives. Instead,\n* \n   * the directive injects a <a href='/angular2/angular2.api/QueryList'><code>QueryList</code></a>, which updates its contents as children are added,\n* \n   * removed, or moved by a directive that uses a <a href='/angular2/angular2.api/ViewContainerRef'><code>ViewContainerRef</code></a> such as a `ng-for`, an\n* \n   * `ng-if`, or an `ng-switch`.\n* \n   * \n* \n   * ```\n* \n   * @Directive({ selector: '[my-directive]' })\n* \n   * class MyDirective {\n* \n   *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * This directive would be instantiated with a <a href='/angular2/angular2.api/QueryList'><code>QueryList</code></a> which contains `Dependency` 4 and\n* \n   * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.\n* \n   * \n* \n   * ### Injecting a live collection of descendant directives\n* \n   * \n* \n   * By passing the descendant flag to `@Query` above, we can include the children of the child\n* \n   * elements.\n* \n   * \n* \n   * ```\n* \n   * @Directive({ selector: '[my-directive]' })\n* \n   * class MyDirective {\n* \n   *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.\n* \n   * \n* \n   * ### Optional injection\n* \n   * \n* \n   * The normal behavior of directives is to return an error when a specified dependency cannot be\n* \n   * resolved. If you\n* \n   * would like to inject `null` on unresolved dependency instead, you can annotate that dependency\n* \n   * with `@Optional()`.\n* \n   * This explicitly permits the author of a template to treat some of the surrounding directives as\n* \n   * optional.\n* \n   * \n* \n   * ```\n* \n   * @Directive({ selector: '[my-directive]' })\n* \n   * class MyDirective {\n* \n   *   constructor(@Optional() dependency:Dependency) {\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * This directive would be instantiated with a `Dependency` directive found on the current element.\n* \n   * If none can be\n* \n   * found, the injector supplies `null` instead of throwing an error.\n* \n   * \n* \n   * ## Example\n* \n   * \n* \n   * Here we use a decorator directive to simply define basic tool-tip behavior.\n* \n   * \n* \n   * ```\n* \n   * @Directive({\n* \n   *   selector: '[tooltip]',\n* \n   *   properties: [\n* \n   *     'text: tooltip'\n* \n   *   ],\n* \n   *   hostListeners: {\n* \n   *     'onmouseenter': 'onMouseEnter()',\n* \n   *     'onmouseleave': 'onMouseLeave()'\n* \n   *   }\n* \n   * })\n* \n   * class Tooltip{\n* \n   *   text:string;\n* \n   *   overlay:Overlay; // NOT YET IMPLEMENTED\n* \n   *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED\n* \n   * \n* \n   *   constructor(overlayManager:OverlayManager) {\n* \n   *     this.overlay = overlay;\n* \n   *   }\n* \n   * \n* \n   *   onMouseEnter() {\n* \n   *     // exact signature to be determined\n* \n   *     this.overlay = this.overlayManager.open(text, ...);\n* \n   *   }\n* \n   * \n* \n   *   onMouseLeave() {\n* \n   *     this.overlay.close();\n* \n   *     this.overlay = null;\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * In our HTML template, we can then add this behavior to a `<div>` or any other element with the\n* \n   * `tooltip` selector,\n* \n   * like so:\n* \n   * \n* \n   * ```\n* \n   * <div tooltip=\"some text here\"></div>\n* \n   * ```\n* \n   * \n* \n   * Directives can also control the instantiation, destruction, and positioning of inline template\n* \n   * elements:\n* \n   * \n* \n   * A directive uses a <a href='/angular2/angular2.api/ViewContainerRef'><code>ViewContainerRef</code></a> to instantiate, insert, move, and destroy views at\n* \n   * runtime.\n* \n   * The <a href='/angular2/angular2.api/ViewContainerRef'><code>ViewContainerRef</code></a> is created as a result of `<template>` element, and represents a\n* \n   * location in the current view\n* \n   * where these actions are performed.\n* \n   * \n* \n   * Views are always created as children of the current <a href='/angular2/angular2.api/View'><code>View</code></a>, and as siblings of the\n* \n   * `<template>` element. Thus a\n* \n   * directive in a child view cannot inject the directive that created it.\n* \n   * \n* \n   * Since directives that create views via ViewContainers are common in Angular, and using the full\n* \n   * `<template>` element syntax is wordy, Angular\n* \n   * also supports a shorthand notation: `<li *foo=\"bar\">` and `<li template=\"foo: bar\">` are\n* \n   * equivalent.\n* \n   * \n* \n   * Thus,\n* \n   * \n* \n   * ```\n* \n   * <ul>\n* \n   *   <li *foo=\"bar\" title=\"text\"></li>\n* \n   * </ul>\n* \n   * ```\n* \n   * \n* \n   * Expands in use to:\n* \n   * \n* \n   * ```\n* \n   * <ul>\n* \n   *   <template [foo]=\"bar\">\n* \n   *     <li title=\"text\"></li>\n* \n   *   </template>\n* \n   * </ul>\n* \n   * ```\n* \n   * \n* \n   * Notice that although the shorthand places `*foo=\"bar\"` within the `<li>` element, the binding for\n* \n   * the directive\n* \n   * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.\n* \n   * \n* \n   * \n* \n   * ## Example\n* \n   * \n* \n   * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.\n* \n   * \n* \n   * Here is a simple directive that triggers on an `unless` selector:\n* \n   * \n* \n   * ```\n* \n   * @Directive({\n* \n   *   selector: '[unless]',\n* \n   *   properties: ['unless']\n* \n   * })\n* \n   * export class Unless {\n* \n   *   viewContainer: ViewContainerRef;\n* \n   *   protoViewRef: ProtoViewRef;\n* \n   *   prevCondition: boolean;\n* \n   * \n* \n   *   constructor(viewContainer: ViewContainerRef, protoViewRef: ProtoViewRef) {\n* \n   *     this.viewContainer = viewContainer;\n* \n   *     this.protoViewRef = protoViewRef;\n* \n   *     this.prevCondition = null;\n* \n   *   }\n* \n   * \n* \n   *   set unless(newCondition) {\n* \n   *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {\n* \n   *       this.prevCondition = true;\n* \n   *       this.viewContainer.clear();\n* \n   *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {\n* \n   *       this.prevCondition = false;\n* \n   *       this.viewContainer.create(this.protoViewRef);\n* \n   *     }\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * We can then use this `unless` selector in a template:\n* \n   * ```\n* \n   * <ul>\n* \n   *   <li *unless=\"expr\"></li>\n* \n   * </ul>\n* \n   * ```\n* \n   * \n* \n   * Once the directive instantiates the child view, the shorthand notation for the template expands\n* \n   * and the result is:\n* \n   * \n* \n   * ```\n* \n   * <ul>\n* \n   *   <template [unless]=\"exp\">\n* \n   *     <li></li>\n* \n   *   </template>\n* \n   *   <li></li>\n* \n   * </ul>\n* \n   * ```\n* \n   * \n* \n   * Note also that although the `<li></li>` template still exists inside the `<template></template>`,\n* \n   * the instantiated\n* \n   * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.\n* \n   * \n* \n   * @exportedAs angular2/annotations",
        "* The CSS selector that triggers the instantiation of a directive.\n* \n     * \n* \n     * Angular only allows directives to trigger on CSS selectors that do not cross element\n* \n     * boundaries.\n* \n     * \n* \n     * `selector` may be declared as one of the following:\n* \n     * \n* \n     * - `element-name`: select by element name.\n* \n     * - `.class`: select by class name.\n* \n     * - `[attribute]`: select by attribute name.\n* \n     * - `[attribute=value]`: select by attribute name and value.\n* \n     * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.\n* \n     * - `selector1, selector2`: select if either `selector1` or `selector2` matches.\n* \n     * \n* \n     * \n* \n     * ## Example\n* \n     * \n* \n     * Suppose we have a directive with an `input[type=text]` selector.\n* \n     * \n* \n     * And the following HTML:\n* \n     * \n* \n     * ```html\n* \n     * <form>\n* \n     *   <input type=\"text\">\n* \n     *   <input type=\"radio\">\n* \n     * <form>\n* \n     * ```\n* \n     * \n* \n     * The directive would only be instantiated on the `<input type=\"text\">` element.",
        "* Enumerates the set of properties that accept data binding for a directive.\n* \n     * \n* \n     * The `properties` property defines a set of `directiveProperty` to `bindingProperty`\n* \n     * configuration:\n* \n     * \n* \n     * - `directiveProperty` specifies the component property where the value is written.\n* \n     * - `bindingProperty` specifies the DOM property where the value is read from.\n* \n     * \n* \n     * You can include a <a href='/angular2/angular2.api/Pipe'><code>Pipe</code></a> when specifying a `bindingProperty` to allow for data\n* \n     * transformation and structural change detection of the value. These pipes will be evaluated in\n* \n     * the context of this component.\n* \n     * \n* \n     * ## Syntax\n* \n     * \n* \n     * There is no need to specify both `directiveProperty` and `bindingProperty` when they both have\n* \n     * the same value.\n* \n     * \n* \n     * ```\n* \n     * @Directive({\n* \n     *   properties: [\n* \n     *     'propertyName', // shorthand notation for 'propertyName: propertyName'\n* \n     *     'directiveProperty1: bindingProperty1',\n* \n     *     'directiveProperty2: bindingProperty2 | pipe1 | ...',\n* \n     *     ...\n* \n     *   ]\n* \n     * }\n* \n     * ```\n* \n     * \n* \n     * \n* \n     * ## Basic Property Binding\n* \n     * \n* \n     * We can easily build a simple `Tooltip` directive that exposes a `tooltip` property, which can\n* \n     * be used in templates with standard Angular syntax. For example:\n* \n     * \n* \n     * ```\n* \n     * @Directive({\n* \n     *   selector: '[tooltip]',\n* \n     *   properties: [\n* \n     *     'text: tooltip'\n* \n     *   ]\n* \n     * })\n* \n     * class Tooltip {\n* \n     *   set text(value: string) {\n* \n     *     // This will get called every time with the new value when the 'tooltip' property changes\n* \n     *   }\n* \n     * }\n* \n     * ```\n* \n     * \n* \n     * We can then bind to the `tooltip' property as either an expression (`someExpression`) or as a\n* \n     * string literal, as shown in the HTML template below:\n* \n     * \n* \n     * ```html\n* \n     * <div [tooltip]=\"someExpression\">...</div>\n* \n     * <div tooltip=\"Some Text\">...</div>\n* \n     * ```\n* \n     * \n* \n     * Whenever the `someExpression` expression changes, the `properties` declaration instructs\n* \n     * Angular to update the `Tooltip`'s `text` property.\n* \n     * \n* \n     * ## Bindings With Pipes\n* \n     * \n* \n     * You can also use pipes when writing binding definitions for a directive.\n* \n     * \n* \n     * For example, we could write a binding that updates the directive on structural changes, rather\n* \n     * than on reference changes, as normally occurs in change detection.\n* \n     * \n* \n     * See <a href='/angular2/angular2.api/Pipe'><code>Pipe</code></a> and <a href='/angular2/pipes/KeyValueChanges'><code>KeyValueChanges</code></a> documentation for more details.\n* \n     * \n* \n     * ```\n* \n     * @Directive({\n* \n     *   selector: '[class-set]',\n* \n     *   properties: [\n* \n     *     'classChanges: classSet | keyValDiff'\n* \n     *   ]\n* \n     * })\n* \n     * class ClassSet {\n* \n     *   set classChanges(changes: KeyValueChanges) {\n* \n     *     // This will get called every time the `class-set` expressions changes its structure.\n* \n     *   }\n* \n     * }\n* \n     * ```\n* \n     * \n* \n     * The template that this directive is used in may also contain its own pipes. For example:\n* \n     * \n* \n     * ```html\n* \n     * <div [class-set]=\"someExpression | somePipe\">\n* \n     * ```\n* \n     * \n* \n     * In this case, the two pipes compose as if they were inlined: `someExpression | somePipe |\n* \n     * keyValDiff`.",
        "* Enumerates the set of emitted events.\n* \n     * \n* \n     * ## Syntax\n* \n     * \n* \n     * ```\n* \n     * @Component({\n* \n     *   events: ['statusChange']\n* \n     * })\n* \n     * class TaskComponent {\n* \n     *   statusChange: EventEmitter;\n* \n     * \n* \n     *   constructor() {\n* \n     *     this.statusChange = new EventEmitter();\n* \n     *   }\n* \n     * \n* \n     *   onComplete() {\n* \n     *     this.statusChange.next('completed');\n* \n     *   }\n* \n     * }\n* \n     * ```\n* \n     * \n* \n     * Use `propertyName: eventName` when the event emitter property name is different from the name\n* \n     * of the emitted event:\n* \n     * \n* \n     * ```\n* \n     * @Component({\n* \n     *   events: ['status: statusChange']\n* \n     * })\n* \n     * class TaskComponent {\n* \n     *   status: EventEmitter;\n* \n     * \n* \n     *   constructor() {\n* \n     *     this.status = new EventEmitter();\n* \n     *   }\n* \n     * \n* \n     *   onComplete() {\n* \n     *     this.status.next('completed');\n* \n     *   }\n* \n     * }\n* \n     * ```",
        "* Specifiy the events, actions, properties and attributes related to the host element.\n* \n     * \n* \n     * ## Events\n* \n     * \n* \n     * Specifies which DOM hostListeners a directive listens to via a set of `(event)` to `method`\n* \n     * key-value pairs:\n* \n     * \n* \n     * - `event1`: the DOM event that the directive listens to.\n* \n     * - `statement`: the statement to execute when the event occurs.\n* \n     * If the evalutation of the statement returns `false`, then `preventDefault`is applied on the DOM\n* \n     * event.\n* \n     * \n* \n     * To listen to global events, a target must be added to the event name.\n* \n     * The target can be `window`, `document` or `body`.\n* \n     * \n* \n     * When writing a directive event binding, you can also refer to the following local variables:\n* \n     * - `$event`: Current event object which triggered the event.\n* \n     * - `$target`: The source of the event. This will be either a DOM element or an Angular\n* \n     * directive. (will be implemented in later release)\n* \n     * \n* \n     * ## Syntax\n* \n     * \n* \n     * ```\n* \n     * @Directive({\n* \n     *   host: {\n* \n     *     '(event1)': 'onMethod1(arguments)',\n* \n     *     '(target:event2)': 'onMethod2(arguments)',\n* \n     *     ...\n* \n     *   }\n* \n     * }\n* \n     * ```\n* \n     * \n* \n     * ## Basic Event Binding:\n* \n     * \n* \n     * Suppose you want to write a directive that reacts to `change` events in the DOM and on\n* \n     * `resize` events in window.\n* \n     * You would define the event binding as follows:\n* \n     * \n* \n     * ```\n* \n     * @Directive({\n* \n     *   selector: 'input',\n* \n     *   host: {\n* \n     *     '(change)': 'onChange($event)',\n* \n     *     '(window:resize)': 'onResize($event)'\n* \n     *   }\n* \n     * })\n* \n     * class InputDirective {\n* \n     *   onChange(event:Event) {\n* \n     *     // invoked when the input element fires the 'change' event\n* \n     *   }\n* \n     *   onResize(event:Event) {\n* \n     *     // invoked when the window fires the 'resize' event\n* \n     *   }\n* \n     * }\n* \n     * ```\n* \n     * \n* \n     * ## Properties\n* \n     * \n* \n     * Specifies which DOM properties a directives updates.\n* \n     * \n* \n     * ## Syntax\n* \n     * \n* \n     * ```\n* \n     * @Directive({\n* \n     *   selector: 'input',\n* \n     *   host: {\n* \n     *     '[prop]': 'expression'\n* \n     *   }\n* \n     * })\n* \n     * class InputDirective {\n* \n     *   value:string;\n* \n     * }\n* \n     * ```\n* \n     * \n* \n     * In this example the prop property of the host element is updated with the expression value\n* \n     * every time it changes.\n* \n     * \n* \n     * ## Attributes\n* \n     * \n* \n     * Specifies static attributes that should be propagated to a host element. Attributes specified\n* \n     * in `hostAttributes` are propagated only if a given attribute is not present on a host element.\n* \n     * \n* \n     * ## Syntax\n* \n     * \n* \n     * ```\n* \n     * @Directive({\n* \n     *   selector: '[my-button]',\n* \n     *   host: {\n* \n     *     'role': 'button'\n* \n     *   }\n* \n     * })\n* \n     * class MyButton {\n* \n     * }\n* \n     * ```\n* \n     * \n* \n     * In this example using `my-button` directive (ex.: `<div my-button></div>`) on a host element\n* \n     * (here: `<div>` ) will ensure that this element will get the \"button\" role.\n* \n     * \n* \n     * ## Actions\n* \n     * \n* \n     * Specifies which DOM methods a directive can invoke.\n* \n     * \n* \n     * ## Syntax\n* \n     * \n* \n     * ```\n* \n     * @Directive({\n* \n     *   selector: 'input',\n* \n     *   host: {\n* \n     *     '@emitFocus': 'focus()'\n* \n     *   }\n* \n     * })\n* \n     * class InputDirective {\n* \n     *   constructor() {\n* \n     *     this.emitFocus = new EventEmitter();\n* \n     *   }\n* \n     * \n* \n     *   focus() {\n* \n     *     this.emitFocus.next();\n* \n     *   }\n* \n     * }\n* \n     * ```\n* \n     * \n* \n     * In this example calling focus on InputDirective will result in calling focus on the input.",
        "* Specifies which lifecycle should be notified to the directive.\n* \n     * \n* \n     * See <a href='/angular2/angular2.api/LifecycleEvent'><code>LifecycleEvent</code></a> for details.",
        "* If set to false the compiler does not compile the children of this directive.",
        "* Defines the set of injectable objects that are visible to a Directive and its light dom\n* \n     * children.\n* \n     * \n* \n     * ## Simple Example\n* \n     * \n* \n     * Here is an example of a class that can be injected:\n* \n     * \n* \n     * ```\n* \n     * class Greeter {\n* \n     *    greet(name:string) {\n* \n     *      return 'Hello ' + name + '!';\n* \n     *    }\n* \n     * }\n* \n     * \n* \n     * @Directive({\n* \n     *   selector: 'greet',\n* \n     *   hostInjector: [\n* \n     *     Greeter\n* \n     *   ]\n* \n     * })\n* \n     * class HelloWorld {\n* \n     *   greeter:Greeter;\n* \n     * \n* \n     *   constructor(greeter:Greeter) {\n* \n     *     this.greeter = greeter;\n* \n     *   }\n* \n     * }\n* \n     * ```",
        "* Defines the name that can be used in the template to assign this directive to a variable.\n* \n     * \n* \n     * ## Simple Example\n* \n     * \n* \n     * ```\n* \n     * @Directive({\n* \n     *   selector: 'child-dir',\n* \n     *   exportAs: 'child'\n* \n     * })\n* \n     * class ChildDir {\n* \n     * }\n* \n     * \n* \n     * @Component({\n* \n     *   selector: 'main',\n* \n     * })\n* \n     * @View({\n* \n     *   template: `<child-dir #c=\"child\"></child-dir>`,\n* \n     *   directives: [ChildDir]\n* \n     * })\n* \n     * class MainComponent {\n* \n     * }\n* \n     * \n* \n     * ```",
        "* Notify a directive whenever a <a href='/angular2/angular2.api/View'><code>View</code></a> that contains it is destroyed.\n* \n   * \n* \n   * ## Example\n* \n   * \n* \n   * ```\n* \n   * @Directive({\n* \n   *   ...,\n* \n   *   lifecycle: [onDestroy]\n* \n   * })\n* \n   * class ClassSet {\n* \n   *   onDestroy() {\n* \n   *     // invoked to notify directive of the containing view destruction.\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * @exportedAs angular2/annotations",
        "* Notify a directive when any of its bindings have changed.\n* \n   * \n* \n   * This method is called right after the directive's bindings have been checked,\n* \n   * and before any of its children's bindings have been checked.\n* \n   * \n* \n   * It is invoked only if at least one of the directive's bindings has changed.\n* \n   * \n* \n   * ## Example:\n* \n   * \n* \n   * ```\n* \n   * @Directive({\n* \n   *   selector: '[class-set]',\n* \n   *   properties: [\n* \n   *     'propA',\n* \n   *     'propB'\n* \n   *   ],\n* \n   *   lifecycle: [onChange]\n* \n   * })\n* \n   * class ClassSet {\n* \n   *   propA;\n* \n   *   propB;\n* \n   *   onChange(changes:{[idx: string, PropertyUpdate]}) {\n* \n   *     // This will get called after any of the properties have been updated.\n* \n   *     if (changes['propA']) {\n* \n   *       // if propA was updated\n* \n   *     }\n* \n   *     if (changes['propA']) {\n* \n   *       // if propB was updated\n* \n   *     }\n* \n   *   }\n* \n   * }\n* \n   *  ```\n* \n   * @exportedAs angular2/annotations",
        "* Notify a directive when it has been checked.\n* \n   * \n* \n   * This method is called right after the directive's bindings have been checked,\n* \n   * and before any of its children's bindings have been checked.\n* \n   * \n* \n   * It is invoked every time even when none of the directive's bindings has changed.\n* \n   * \n* \n   * ## Example:\n* \n   * \n* \n   * ```\n* \n   * @Directive({\n* \n   *   selector: '[class-set]',\n* \n   *   lifecycle: [onCheck]\n* \n   * })\n* \n   * class ClassSet {\n* \n   *   onCheck() {\n* \n   *   }\n* \n   * }\n* \n   *  ```\n* \n   * @exportedAs angular2/annotations",
        "* Notify a directive when it has been checked the first itme.\n* \n   * \n* \n   * This method is called right after the directive's bindings have been checked,\n* \n   * and before any of its children's bindings have been checked.\n* \n   * \n* \n   * It is invoked only once.\n* \n   * \n* \n   * ## Example:\n* \n   * \n* \n   * ```\n* \n   * @Directive({\n* \n   *   selector: '[class-set]',\n* \n   *   lifecycle: [onInit]\n* \n   * })\n* \n   * class ClassSet {\n* \n   *   onInit() {\n* \n   *   }\n* \n   * }\n* \n   *  ```\n* \n   * @exportedAs angular2/annotations",
        "* Notify a directive when the bindings of all its children have been checked (whether they have\n* \n   * changed or not).\n* \n   * \n* \n   * ## Example:\n* \n   * \n* \n   * ```\n* \n   * @Directive({\n* \n   *   selector: '[class-set]',\n* \n   *   lifecycle: [onAllChangesDone]\n* \n   * })\n* \n   * class ClassSet {\n* \n   * \n* \n   *   onAllChangesDone() {\n* \n   *   }\n* \n   * \n* \n   * }\n* \n   *  ```\n* \n   * @exportedAs angular2/annotations",
        "* Declares the available HTML templates for an application.\n* \n   * \n* \n   * Each angular component requires a single `@Component` and at least one `@View` annotation. The\n* \n   * `@View` annotation specifies the HTML template to use, and lists the directives that are active\n* \n   * within the template.\n* \n   * \n* \n   * When a component is instantiated, the template is loaded into the component's shadow root, and\n* \n   * the expressions and statements in the template are evaluated against the component.\n* \n   * \n* \n   * For details on the `@Component` annotation, see <a href='/angular2/angular2.api/Component'><code>Component</code></a>.\n* \n   * \n* \n   * ## Example\n* \n   * \n* \n   * ```\n* \n   * @Component({\n* \n   *   selector: 'greet'\n* \n   * })\n* \n   * @View({\n* \n   *   template: 'Hello {{name}}!',\n* \n   *   directives: [GreetUser, Bold]\n* \n   * })\n* \n   * class Greet {\n* \n   *   name: string;\n* \n   * \n* \n   *   constructor() {\n* \n   *     this.name = 'World';\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/annotations",
        "* Specifies an inline template for an angular component.\n* \n     * \n* \n     * NOTE: either `templateUrl` or `template` should be used, but not both.",
        "* Specifies a template URL for an angular component.\n* \n     * \n* \n     * NOTE: either `templateUrl` or `template` should be used, but not both.",
        "* Specifies stylesheet URLs for an angular component.",
        "* Specifies an inline stylesheet for an angular component.",
        "* Specifies a list of directives that can be used within a template.\n* \n     * \n* \n     * Directives must be listed explicitly to provide proper component encapsulation.\n* \n     * \n* \n     * ## Example\n* \n     * \n* \n     * ```javascript\n* \n     * @Component({\n* \n     *     selector: 'my-component'\n* \n     *   })\n* \n     * @View({\n* \n     *   directives: [For]\n* \n     *   template: '\n* \n     *   <ul>\n* \n     *     <li *ng-for=\"#item of items\">{{item}}</li>\n* \n     *   </ul>'\n* \n     * })\n* \n     * class MyComponent {\n* \n     * }\n* \n     * ```",
        "* Specify a custom renderer for this View.\n* \n     * If this is set, neither `template`, `templateUrl`, `styles`, `styleUrls` nor `directives` are\n* \n     * used.",
        "* Specifies that a <a href='/angular2/angular2.api/QueryList'><code>QueryList</code></a> should be injected.\n* \n   * \n* \n   * See <a href='/angular2/angular2.api/QueryList'><code>QueryList</code></a> for usage and example.\n* \n   * \n* \n   * @exportedAs angular2/annotations",
        "* Specifies that a constant attribute value should be injected.\n* \n   * \n* \n   * The directive can inject constant string literals of host element attributes.\n* \n   * \n* \n   * ## Example\n* \n   * \n* \n   * Suppose we have an `<input>` element and want to know its `type`.\n* \n   * \n* \n   * ```html\n* \n   * <input type=\"text\">\n* \n   * ```\n* \n   * \n* \n   * A decorator can inject string literal `text` like so:\n* \n   * \n* \n   * ```javascript\n* \n   * @Directive({\n* \n   *   selector: `input'\n* \n   * })\n* \n   * class InputDirective {\n* \n   *   constructor(@Attribute('type') type) {\n* \n   *     // type would be `text` in this example\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/annotations",
        "* Defines lifecycle method [onAllChangesDone ] called when the bindings of all its children have\n* \n   * been changed.",
        "* Defines lifecycle method [onChange] called after all of component's bound\n* \n   * properties are updated.",
        "* Defines lifecycle method [onDestroy] called when a directive is being destroyed.",
        "* Defines lifecycle method [onInit] called when a directive is being checked the first time.",
        "* Defines lifecycle method [onCheck] called when a directive is being checked.",
        "* Provides a way for expressing ES6 classes with parameter annotations in ES5.\n* \n   * \n* \n   * ## Basic Example\n* \n   * \n* \n   * ```\n* \n   * var Greeter = ng.Class({\n* \n   *   constructor: function(name) {\n* \n   *     this.name = name;\n* \n   *   },\n* \n   * \n* \n   *   greet: function() {\n* \n   *     alert('Hello ' + this.name + '!');\n* \n   *   }\n* \n   * });\n* \n   * ```\n* \n   * \n* \n   * is equivalent to ES6:\n* \n   * \n* \n   * ```\n* \n   * class Greeter {\n* \n   *   constructor(name) {\n* \n   *     this.name = name;\n* \n   *   }\n* \n   * \n* \n   *   greet() {\n* \n   *     alert('Hello ' + this.name + '!');\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * or equivalent to ES5:\n* \n   * \n* \n   * ```\n* \n   * var Greeter = function (name) {\n* \n   *   this.name = name;\n* \n   * }\n* \n   * \n* \n   * Greeter.prototype.greet = function () {\n* \n   *   alert('Hello ' + this.name + '!');\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * ## Example with parameter annotations\n* \n   * \n* \n   * ```\n* \n   * var MyService = neg.Class({\n* \n   *   constructor: [String, [new Query(), QueryList], function(name, queryList) {\n* \n   *     ...\n* \n   *   }];\n* \n   * });\n* \n   * ```\n* \n   * \n* \n   * is equivalent to ES6:\n* \n   * \n* \n   * ```\n* \n   * class MyService {\n* \n   *   constructor(name: string, @Query() queryList: QueryList) {\n* \n   *     ...\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * ## Example with inheritance\n* \n   * \n* \n   * ```\n* \n   * var Shape = ng.Class({\n* \n   *   constructor: (color) {\n* \n   *     this.color = color;\n* \n   *   }\n* \n   * });\n* \n   * \n* \n   * var Square = ng.Class({\n* \n   *   extends: Shape,\n* \n   *   constructor: function(color, size) {\n* \n   *     Shape.call(this, color);\n* \n   *     this.size = size;\n* \n   *   }\n* \n   * });\n* \n   * ```",
        "* An interface implemented by all Angular parameter decorators, which allows them to be used as ES7\n* \n   * decorators.",
        "* Invoke as ES7 decorator.",
        "* <a href='/angular2/angular2.api/Attribute'><code>Attribute</code></a> factory function.",
        "* <a href='/angular2/angular2.api/Attribute'><code>Attribute</code></a> factory for creating annotations, decorators or DSL.\n* \n   * \n* \n   * ## Example as TypeScript Decorator\n* \n   * \n* \n   * ```\n* \n   * import {Attribute, Component, View} from \"angular2/angular2\";\n* \n   * \n* \n   * @Component({...})\n* \n   * @View({...})\n* \n   * class MyComponent {\n* \n   *   constructor(@Attribute('title') title: string) {\n* \n   *     ...\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * ## Example as ES5 DSL\n* \n   * \n* \n   * ```\n* \n   * var MyComponent = ng\n* \n   *   .Component({...})\n* \n   *   .View({...})\n* \n   *   .Class({\n* \n   *     constructor: [new ng.Attribute('title'), function(title) {\n* \n   *       ...\n* \n   *     }]\n* \n   *   })\n* \n   * ```\n* \n   * \n* \n   * ## Example as ES5 annotation\n* \n   * \n* \n   * ```\n* \n   * var MyComponent = function(title) {\n* \n   *   ...\n* \n   * };\n* \n   * \n* \n   * MyComponent.annotations = [\n* \n   *   new ng.Component({...})\n* \n   *   new ng.View({...})\n* \n   * ]\n* \n   * MyComponent.parameters = [\n* \n   *   [new ng.Attribute('title')]\n* \n   * ]\n* \n   * ```",
        "* <a href='/angular2/angular2.api/Component'><code>Component</code></a> factory function.",
        "* Interface for the <a href='/angular2/angular2.api/Component'><code>Component</code></a> decorator function.\n* \n   * \n* \n   * See <a href='/angular2/angular2.api/ComponentFactory'><code>ComponentFactory</code></a>.",
        "* Chain <a href='/angular2/angular2.api/View'><code>View</code></a> annotation.",
        "* <a href='/angular2/angular2.api/ComponentAnnotation'><code>ComponentAnnotation</code></a> factory for creating annotations, decorators or DSL.\n* \n   * \n* \n   * ## Example as TypeScript Decorator\n* \n   * \n* \n   * ```\n* \n   * import {Component, View} from \"angular2/angular2\";\n* \n   * \n* \n   * @Component({...})\n* \n   * @View({...})\n* \n   * class MyComponent {\n* \n   *   constructor() {\n* \n   *     ...\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * ## Example as ES5 DSL\n* \n   * \n* \n   * ```\n* \n   * var MyComponent = ng\n* \n   *   .Component({...})\n* \n   *   .View({...})\n* \n   *   .Class({\n* \n   *     constructor: function() {\n* \n   *       ...\n* \n   *     }\n* \n   *   })\n* \n   * ```\n* \n   * \n* \n   * ## Example as ES5 annotation\n* \n   * \n* \n   * ```\n* \n   * var MyComponent = function() {\n* \n   *   ...\n* \n   * };\n* \n   * \n* \n   * MyComponent.annotations = [\n* \n   *   new ng.Component({...})\n* \n   *   new ng.View({...})\n* \n   * ]\n* \n   * ```",
        "* <a href='/angular2/angular2.api/Directive'><code>Directive</code></a> factory function.",
        "* Interface for the <a href='/angular2/angular2.api/Directive'><code>Directive</code></a> decorator function.\n* \n   * \n* \n   * See <a href='/angular2/angular2.api/DirectiveFactory'><code>DirectiveFactory</code></a>.",
        "* <a href='/angular2/angular2.api/Directive'><code>Directive</code></a> factory for creating annotations, decorators or DSL.\n* \n   * \n* \n   * ## Example as TypeScript Decorator\n* \n   * \n* \n   * ```\n* \n   * import {Directive} from \"angular2/angular2\";\n* \n   * \n* \n   * @Directive({...})\n* \n   * class MyDirective {\n* \n   *   constructor() {\n* \n   *     ...\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * ## Example as ES5 DSL\n* \n   * \n* \n   * ```\n* \n   * var MyDirective = ng\n* \n   *   .Directive({...})\n* \n   *   .Class({\n* \n   *     constructor: function() {\n* \n   *       ...\n* \n   *     }\n* \n   *   })\n* \n   * ```\n* \n   * \n* \n   * ## Example as ES5 annotation\n* \n   * \n* \n   * ```\n* \n   * var MyDirective = function() {\n* \n   *   ...\n* \n   * };\n* \n   * \n* \n   * MyDirective.annotations = [\n* \n   *   new ng.Directive({...})\n* \n   * ]\n* \n   * ```",
        "* <a href='/angular2/angular2.api/View'><code>View</code></a> factory function.",
        "* Interface for the <a href='/angular2/angular2.api/View'><code>View</code></a> decorator function.\n* \n   * \n* \n   * See <a href='/angular2/angular2.api/ViewFactory'><code>ViewFactory</code></a>.",
        "* Chain <a href='/angular2/angular2.api/View'><code>View</code></a> annotation.",
        "* <a href='/angular2/angular2.api/ViewAnnotation'><code>ViewAnnotation</code></a> factory for creating annotations, decorators or DSL.\n* \n   * \n* \n   * ## Example as TypeScript Decorator\n* \n   * \n* \n   * ```\n* \n   * import {Component, View} from \"angular2/angular2\";\n* \n   * \n* \n   * @Component({...})\n* \n   * @View({...})\n* \n   * class MyComponent {\n* \n   *   constructor() {\n* \n   *     ...\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * ## Example as ES5 DSL\n* \n   * \n* \n   * ```\n* \n   * var MyComponent = ng\n* \n   *   .Component({...})\n* \n   *   .View({...})\n* \n   *   .Class({\n* \n   *     constructor: function() {\n* \n   *       ...\n* \n   *     }\n* \n   *   })\n* \n   * ```\n* \n   * \n* \n   * ## Example as ES5 annotation\n* \n   * \n* \n   * ```\n* \n   * var MyComponent = function() {\n* \n   *   ...\n* \n   * };\n* \n   * \n* \n   * MyComponent.annotations = [\n* \n   *   new ng.Component({...})\n* \n   *   new ng.View({...})\n* \n   * ]\n* \n   * ```",
        "* <a href='/angular2/angular2.api/Query'><code>Query</code></a> factory for creating annotations, decorators or DSL.\n* \n   * \n* \n   * ## Example as TypeScript Decorator\n* \n   * \n* \n   * ```\n* \n   * import {Query, QueryList, Component, View} from \"angular2/angular2\";\n* \n   * \n* \n   * @Component({...})\n* \n   * @View({...})\n* \n   * class MyComponent {\n* \n   *   constructor(@Query(SomeType) queryList: QueryList) {\n* \n   *     ...\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * ## Example as ES5 DSL\n* \n   * \n* \n   * ```\n* \n   * var MyComponent = ng\n* \n   *   .Component({...})\n* \n   *   .View({...})\n* \n   *   .Class({\n* \n   *     constructor: [new ng.Query(SomeType), function(queryList) {\n* \n   *       ...\n* \n   *     }]\n* \n   *   })\n* \n   * ```\n* \n   * \n* \n   * ## Example as ES5 annotation\n* \n   * \n* \n   * ```\n* \n   * var MyComponent = function(queryList) {\n* \n   *   ...\n* \n   * };\n* \n   * \n* \n   * MyComponent.annotations = [\n* \n   *   new ng.Component({...})\n* \n   *   new ng.View({...})\n* \n   * ]\n* \n   * MyComponent.parameters = [\n* \n   *   [new ng.Query(SomeType)]\n* \n   * ]\n* \n   * ```",
        "* Bootstrapping for Angular applications.\n* \n   * \n* \n   * You instantiate an Angular application by explicitly specifying a component to use as the root\n* \n   * component for your\n* \n   * application via the `bootstrap()` method.\n* \n   * \n* \n   * ## Simple Example\n* \n   * \n* \n   * Assuming this `index.html`:\n* \n   * \n* \n   * ```html\n* \n   * <html>\n* \n   *   <!-- load Angular script tags here. -->\n* \n   *   <body>\n* \n   *     <my-app>loading...</my-app>\n* \n   *   </body>\n* \n   * </html>\n* \n   * ```\n* \n   * \n* \n   * An application is bootstrapped inside an existing browser DOM, typically `index.html`. Unlike\n* \n   * Angular 1, Angular 2\n* \n   * does not compile/process bindings in `index.html`. This is mainly for security reasons, as well\n* \n   * as architectural\n* \n   * changes in Angular 2. This means that `index.html` can safely be processed using server-side\n* \n   * technologies such as\n* \n   * bindings. Bindings can thus use double-curly `{{ syntax }}` without collision from Angular 2\n* \n   * component double-curly\n* \n   * `{{ syntax }}`.\n* \n   * \n* \n   * We can use this script code:\n* \n   * \n* \n   * ```\n* \n   * @Component({\n* \n   *    selector: 'my-app'\n* \n   * })\n* \n   * @View({\n* \n   *    template: 'Hello {{ name }}!'\n* \n   * })\n* \n   * class MyApp {\n* \n   *   name:string;\n* \n   * \n* \n   *   constructor() {\n* \n   *     this.name = 'World';\n* \n   *   }\n* \n   * }\n* \n   * \n* \n   * main() {\n* \n   *   return bootstrap(MyApp);\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * When the app developer invokes `bootstrap()` with the root component `MyApp` as its argument,\n* \n   * Angular performs the\n* \n   * following tasks:\n* \n   * \n* \n   *  1. It uses the component's `selector` property to locate the DOM element which needs to be\n* \n   * upgraded into\n* \n   *     the angular component.\n* \n   *  2. It creates a new child injector (from the platform injector). Optionally, you can also\n* \n   * override the injector configuration for an app by\n* \n   * invoking `bootstrap` with the `componentInjectableBindings` argument.\n* \n   *  3. It creates a new `Zone` and connects it to the angular application's change detection domain\n* \n   * instance.\n* \n   *  4. It creates a shadow DOM on the selected component's host element and loads the template into\n* \n   * it.\n* \n   *  5. It instantiates the specified component.\n* \n   *  6. Finally, Angular performs change detection to apply the initial data bindings for the\n* \n   * application.\n* \n   * \n* \n   * \n* \n   * ## Instantiating Multiple Applications on a Single Page\n* \n   * \n* \n   * There are two ways to do this.\n* \n   * \n* \n   * \n* \n   * ### Isolated Applications\n* \n   * \n* \n   * Angular creates a new application each time that the `bootstrap()` method is invoked. When\n* \n   * multiple applications\n* \n   * are created for a page, Angular treats each application as independent within an isolated change\n* \n   * detection and\n* \n   * `Zone` domain. If you need to share data between applications, use the strategy described in the\n* \n   * next\n* \n   * section, \"Applications That Share Change Detection.\"\n* \n   * \n* \n   * \n* \n   * ### Applications That Share Change Detection\n* \n   * \n* \n   * If you need to bootstrap multiple applications that share common data, the applications must\n* \n   * share a common\n* \n   * change detection and zone. To do that, create a meta-component that lists the application\n* \n   * components in its template.\n* \n   * By only invoking the `bootstrap()` method once, with the meta-component as its argument, you\n* \n   * ensure that only a\n* \n   * single change detection zone is created and therefore data can be shared across the applications.\n* \n   * \n* \n   * \n* \n   * ## Platform Injector\n* \n   * \n* \n   * When working within a browser window, there are many singleton resources: cookies, title,\n* \n   * location, and others.\n* \n   * Angular services that represent these resources must likewise be shared across all Angular\n* \n   * applications that\n* \n   * occupy the same browser window.  For this reason, Angular creates exactly one global platform\n* \n   * injector which stores\n* \n   * all shared services, and each angular application injector has the platform injector as its\n* \n   * parent.\n* \n   * \n* \n   * Each application has its own private injector as well. When there are multiple applications on a\n* \n   * page, Angular treats\n* \n   * each application injector's services as private to that application.\n* \n   * \n* \n   * \n* \n   * # API\n* \n   * - `appComponentType`: The root component which should act as the application. This is a reference\n* \n   * to a `Type`\n* \n   *   which is annotated with `@Component(...)`.\n* \n   * - `componentInjectableBindings`: An additional set of bindings that can be added to the app\n* \n   * injector\n* \n   * to override default injection behavior.\n* \n   * - `errorReporter`: `function(exception:any, stackTrace:string)` a default error reporter for\n* \n   * unhandled exceptions.\n* \n   * \n* \n   * Returns a `Promise` of <a href='/angular2/angular2.api/ApplicationRef'><code>ApplicationRef</code></a>.\n* \n   * \n* \n   * @exportedAs angular2/core",
        "* Represents a Angular's representation of an Application.\n* \n   * \n* \n   * `ApplicationRef` represents a running application instance. Use it to retrieve the host\n* \n   * component, injector,\n* \n   * or dispose of an application.",
        "* Returns the current <a href='/angular2/angular2.api/Component'><code>Component</code></a> type.",
        "* Returns the current <a href='/angular2/angular2.api/Component'><code>Component</code></a> instance.",
        "* Dispose (un-load) the application.",
        "* Returns the root application <a href='/angular2/angular2.api/Injector'><code>Injector</code></a>.",
        "* An opaque token representing the application root type in the <a href='/angular2/angular2.api/Injector'><code>Injector</code></a>.\n* \n   * \n* \n   * ```\n* \n   * @Component(...)\n* \n   * @View(...)\n* \n   * class MyApp {\n* \n   *   ...\n* \n   * }\n* \n   * \n* \n   * bootstrap(MyApp).then((appRef:ApplicationRef) {\n* \n   *   expect(appRef.injector.get(appComponentTypeToken)).toEqual(MyApp);\n* \n   * });\n* \n   * \n* \n   * ```",
        "* Specifies app root url for the application.\n* \n   * \n* \n   * Used by the <a href='/angular2/angular2.api/Compiler'><code>Compiler</code></a> when resolving HTML and CSS template URLs.\n* \n   * \n* \n   * This interface can be overridden by the application developer to create custom behavior.\n* \n   * \n* \n   * See <a href='/angular2/angular2.api/Compiler'><code>Compiler</code></a>",
        "* Returns the base URL of the currently running application.",
        "* Used by the <a href='/angular2/angular2.api/Compiler'><code>Compiler</code></a> when resolving HTML and CSS template URLs.\n* \n   * \n* \n   * This interface can be overridden by the application developer to create custom behavior.\n* \n   * \n* \n   * See <a href='/angular2/angular2.api/Compiler'><code>Compiler</code></a>",
        "* Resolves the `url` given the `baseUrl`:\n* \n     * - when the `url` is null, the `baseUrl` is returned,\n* \n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n* \n     * `baseUrl` and `url`,\n* \n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n* \n     * returned as is (ignoring the `baseUrl`)\n* \n     * \n* \n     * @param {string} baseUrl\n* \n     * @param {string} url\n* \n     * @returns {string} the resolved URL",
        "* Resolve a <a href='/angular2/src/facade/lang/Type'><code>Type</code></a> from a <a href='/angular2/angular2.api/Component'><code>Component</code></a> into a URL.\n* \n   * \n* \n   * This interface can be overridden by the application developer to create custom behavior.\n* \n   * \n* \n   * See <a href='/angular2/angular2.api/Compiler'><code>Compiler</code></a>",
        "* Returns the base URL to the component source file.\n* \n     * The returned URL could be:\n* \n     * - an absolute URL,\n* \n     * - a path relative to the application",
        "* Resolve a <a href='/angular2/src/facade/lang/Type'><code>Type</code></a> for <a href='/angular2/angular2.api/Directive'><code>Directive</code></a>.\n* \n   * \n* \n   * This interface can be overridden by the application developer to create custom behavior.\n* \n   * \n* \n   * See <a href='/angular2/angular2.api/Compiler'><code>Compiler</code></a>",
        "* Return <a href='/angular2/angular2.api/Directive'><code>Directive</code></a> for a given <a href='/angular2/src/facade/lang/Type'><code>Type</code></a>.",
        "* ## URL Resolution\n* \n   * \n* \n   * ```\n* \n   * var appRootUrl: AppRootUrl = ...;\n* \n   * var componentUrlMapper: ComponentUrlMapper = ...;\n* \n   * var urlResolver: UrlResolver = ...;\n* \n   * \n* \n   * var componentType: Type = ...;\n* \n   * var componentAnnotation: ComponentAnnotation = ...;\n* \n   * var viewAnnotation: ViewAnnotation = ...;\n* \n   * \n* \n   * // Resolving a URL\n* \n   * \n* \n   * var url = viewAnnotation.templateUrl;\n* \n   * var componentUrl = componentUrlMapper.getUrl(componentType);\n* \n   * var componentResolvedUrl = urlResolver.resolve(appRootUrl.value, componentUrl);\n* \n   * var templateResolvedUrl = urlResolver.resolve(componetResolvedUrl, url);\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/view",
        "* Entry point for creating, moving views in the view hierarchy and destroying views.\n* \n   * This manager contains all recursion and delegates to helper methods\n* \n   * in AppViewManagerUtils and the Renderer, so unit tests get simpler.",
        "* Returns associated Component <a href='/angular2/angular2.api/ViewRef'><code>ViewRef</code></a> from <a href='/angular2/angular2.api/ElementRef'><code>ElementRef</code></a>.\n* \n     * \n* \n     * If an <a href='/angular2/angular2.api/ElementRef'><code>ElementRef</code></a> is from an element which has a component, this method returns\n* \n     * the component's <a href='/angular2/angular2.api/ViewRef'><code>ViewRef</code></a>.",
        "* Returns a <a href='/angular2/angular2.api/ViewContainerRef'><code>ViewContainerRef</code></a> at the <a href='/angular2/angular2.api/ElementRef'><code>ElementRef</code></a> location.",
        "* Return the first child element of the host element view.",
        "* Returns an ElementRef for the element with the given variable name\n* \n     * in the current view.\n* \n     * \n* \n     * - `hostLocation`: <a href='/angular2/angular2.api/ElementRef'><code>ElementRef</code></a> of any element in the View which defines the scope of\n* \n     *   search.\n* \n     * - `variableName`: Name of the variable to locate.\n* \n     * - Returns <a href='/angular2/angular2.api/ElementRef'><code>ElementRef</code></a> of the found element or null. (Throws if not found.)",
        "* Returns the component instance for a given element.\n* \n     * \n* \n     * The component is the execution context as seen by an expression at that <a href='/angular2/angular2.api/ElementRef'><code>ElementRef</code></a>\n* \n     * location.",
        "* Load component view into existing element.\n* \n     * \n* \n     * Use this if a host element is already in the DOM and it is necessary to upgrade\n* \n     * the element into Angular component by attaching a view but reusing the existing element.\n* \n     * \n* \n     * - `hostProtoViewRef`: <a href='/angular2/angular2.api/ProtoViewRef'><code>ProtoViewRef</code></a> Proto view to use in creating a view for this\n* \n     *   component.\n* \n     * - `overrideSelector`: (optional) selector to use in locating the existing element to load\n* \n     *   the view into. If not specified use the selector in the component definition of the\n* \n     *   `hostProtoView`.\n* \n     * - injector: <a href='/angular2/angular2.api/Injector'><code>Injector</code></a> to use as parent injector for the view.\n* \n     * \n* \n     * See <a href='/angular2/angular2.api/AppViewManager#destroyRootHostView'><code>AppViewManager</code></a>.\n* \n     * \n* \n     * ## Example\n* \n     * \n* \n     * ```\n* \n     * @ng.Component({\n* \n     *   selector: 'child-component'\n* \n     * })\n* \n     * @ng.View({\n* \n     *   template: 'Child'\n* \n     * })\n* \n     * class ChildComponent {\n* \n     * \n* \n     * }\n* \n     * \n* \n     * @ng.Component({\n* \n     *   selector: 'my-app'\n* \n     * })\n* \n     * @ng.View({\n* \n     *   template: `\n* \n     *     Parent (<some-component></some-component>)\n* \n     *   `\n* \n     * })\n* \n     * class MyApp {\n* \n     *   viewRef: ng.ViewRef;\n* \n     * \n* \n     *   constructor(public appViewManager: ng.AppViewManager, compiler: ng.Compiler) {\n* \n     *     compiler.compileInHost(ChildComponent).then((protoView: ng.ProtoViewRef) => {\n* \n     *       this.viewRef = appViewManager.createRootHostView(protoView, 'some-component', null);\n* \n     *     })\n* \n     *   }\n* \n     * \n* \n     *   onDestroy() {\n* \n     *     this.appViewManager.destroyRootHostView(this.viewRef);\n* \n     *     this.viewRef = null;\n* \n     *   }\n* \n     * }\n* \n     * \n* \n     * ng.bootstrap(MyApp);\n* \n     * ```",
        "* Remove the View created with <a href='/angular2/angular2.api/AppViewManager#createRootHostView'><code>AppViewManager</code></a>.",
        "* See <a href='/angular2/angular2.api/AppViewManager#destroyViewInContainer'><code>AppViewManager</code></a>.",
        "* See <a href='/angular2/angular2.api/AppViewManager#createViewInContainer'><code>AppViewManager</code></a>.",
        "* See <a href='/angular2/angular2.api/AppViewManager#detachViewInContainer'><code>AppViewManager</code></a>.",
        "* See <a href='/angular2/angular2.api/AppViewManager#attachViewInContainer'><code>AppViewManager</code></a>.",
        "* An iterable live list of components in the Light DOM.\n* \n   * \n* \n   * Injectable Objects that contains a live list of child directives in the light DOM of a directive.\n* \n   * The directives are kept in depth-first pre-order traversal of the DOM.\n* \n   * \n* \n   * The `QueryList` is iterable, therefore it can be used in both javascript code with `for..of` loop\n* \n   * as well as in\n* \n   * template with `*ng-for=\"of\"` directive.\n* \n   * \n* \n   * NOTE: In the future this class will implement an `Observable` interface. For now it uses a plain\n* \n   * list of observable\n* \n   * callbacks.\n* \n   * \n* \n   * # Example:\n* \n   * \n* \n   * Assume that `<tabs>` component would like to get a list its children which are `<pane>`\n* \n   * components as shown in this\n* \n   * example:\n* \n   * \n* \n   * ```html\n* \n   * <tabs>\n* \n   *   <pane title=\"Overview\">...</pane>\n* \n   *   <pane *ng-for=\"#o of objects\" [title]=\"o.title\">{{o.text}}</pane>\n* \n   * </tabs>\n* \n   * ```\n* \n   * \n* \n   * In the above example the list of `<tabs>` elements needs to get a list of `<pane>` elements so\n* \n   * that it could render\n* \n   * tabs with the correct titles and in the correct order.\n* \n   * \n* \n   * A possible solution would be for a `<pane>` to inject `<tabs>` component and then register itself\n* \n   * with `<tabs>`\n* \n   * component's on `hydrate` and deregister on `dehydrate` event. While a reasonable approach, this\n* \n   * would only work\n* \n   * partialy since `*ng-for` could rearrange the list of `<pane>` components which would not be\n* \n   * reported to `<tabs>`\n* \n   * component and thus the list of `<pane>` components would be out of sync with respect to the list\n* \n   * of `<pane>` elements.\n* \n   * \n* \n   * A preferred solution is to inject a `QueryList` which is a live list of directives in the\n* \n   * component`s light DOM.\n* \n   * \n* \n   * ```javascript\n* \n   * @Component({\n* \n   *   selector: 'tabs'\n* \n   * })\n* \n   * @View({\n* \n   *  template: `\n* \n   *    <ul>\n* \n   *      <li *ng-for=\"#pane of panes\">{{pane.title}}</li>\n* \n   *    </ul>\n* \n   *    <content></content>\n* \n   *  `\n* \n   * })\n* \n   * class Tabs {\n* \n   *   panes: QueryList<Pane>\n* \n   * \n* \n   *   constructor(@Query(Pane) panes:QueryList<Pane>) {\n* \n   *     this.panes = panes;\n* \n   *   }\n* \n   * }\n* \n   * \n* \n   * @Component({\n* \n   *   selector: 'pane',\n* \n   *   properties: ['title']\n* \n   * })\n* \n   * @View(...)\n* \n   * class Pane {\n* \n   *   title:string;\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/view",
        "* Reference to the element.\n* \n   * \n* \n   * Represents an opeque refference to the underlying element. The element is a DOM ELement in\n* \n   * a Browser, but may represent other types on other rendering platforms. In the browser the\n* \n   * `ElementRef` can be sent to the web-worker. Web Workers can not have references to the\n* \n   * DOM Elements.\n* \n   * \n* \n   * @exportedAs angular2/view",
        "* Reference to the <a href='/angular2/angular2.api/ViewRef'><code>ViewRef</code></a> where the `ElementRef` is inside of.",
        "* Index of the element inside the <a href='/angular2/angular2.api/ViewRef'><code>ViewRef</code></a>.\n* \n     * \n* \n     * This is used internally by the Angular framework to locate elements.",
        "* Returns the native Element implementation.\n* \n     * \n* \n     * In the browser this represents the DOM Element.\n* \n     * \n* \n     * The `nativeElement` can be used as an escape hatch when direct DOM manipulation is needed. Use\n* \n     * this with caution, as it creates tight coupling between your application and the Browser, which\n* \n     * will not work in WebWorkers.\n* \n     * \n* \n     * NOTE: This method will return null in the webworker scenario!",
        "* Abstract reference to the element which can be marshaled across web-worker boundry.\n* \n   * \n* \n   * This interface is used by the <a href='/angular2/angular2.api/Renderer'><code>Renderer</code></a> api.",
        "* Reference to the <a href='/angular2/angular2.api/RenderViewRef'><code>RenderViewRef</code></a> where the `RenderElementRef` is inside of.",
        "* Index of the element inside the <a href='/angular2/angular2.api/ViewRef'><code>ViewRef</code></a>.\n* \n     * \n* \n     * This is used internally by the Angular framework to locate elements.",
        "* A reference to an Angular View.\n* \n   * \n* \n   * A View is a fundemental building block of Application UI. A View is the smallest set of\n* \n   * elements which are created and destroyed together. A View can chane properties on the elements\n* \n   * within the view, but it can not change the structure of those elements.\n* \n   * \n* \n   * To change structure of the elements, the Views can contain zero or more <a href='/angular2/angular2.api/ViewContainerRef'><code>ViewContainerRef</code></a>s\n* \n   * which allow the views to be nested.\n* \n   * \n* \n   * ## Example\n* \n   * \n* \n   * Given this template\n* \n   * \n* \n   * ```\n* \n   * Count: {{items.length}}\n* \n   * <ul>\n* \n   *   <li *ng-for=\"var item of items\">{{item}}</li>\n* \n   * </ul>\n* \n   * ```\n* \n   * \n* \n   * The above example we have two <a href='/angular2/angular2.api/ProtoViewRef'><code>ProtoViewRef</code></a>s:\n* \n   * \n* \n   * Outter <a href='/angular2/angular2.api/ProtoViewRef'><code>ProtoViewRef</code></a>:\n* \n   * ```\n* \n   * Count: {{items.length}}\n* \n   * <ul>\n* \n   *   <template ng-for var-item [ng-for-of]=\"items\"></template>\n* \n   * </ul>\n* \n   * ```\n* \n   * \n* \n   * Inner <a href='/angular2/angular2.api/ProtoViewRef'><code>ProtoViewRef</code></a>:\n* \n   * ```\n* \n   *   <li>{{item}}</li>\n* \n   * ```\n* \n   * \n* \n   * Notice that the original template is broken down into two separet <a href='/angular2/angular2.api/ProtoViewRef'><code>ProtoViewRef</code></a>s.\n* \n   * \n* \n   * The outter/inner <a href='/angular2/angular2.api/ProtoViewRef'><code>ProtoViewRef</code></a>s are then assambled into views like so:\n* \n   * \n* \n   * ```\n* \n   * <!-- ViewRef: outter-0 -->\n* \n   * Count: 2\n* \n   * <ul>\n* \n   *   <template view-container-ref></template>\n* \n   *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->\n* \n   *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->\n* \n   * </ul>\n* \n   * <!-- /ViewRef: outter-0 -->\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/view",
        "* Return <a href='/angular2/angular2.api/RenderViewRef'><code>RenderViewRef</code></a>",
        "* Set local variable for a view.",
        "* A reference to an an Angular ProtoView.\n* \n   * \n* \n   * A ProtoView is a reference to a template for easy creation of views.\n* \n   * (See <a href='/angular2/angular2.api/AppViewManager#createViewInContainer'><code>AppViewManager</code></a> and <a href='/angular2/angular2.api/AppViewManager#createRootHostView'><code>AppViewManager</code></a>).\n* \n   * \n* \n   * A `ProtoView` is a foctary for creating `View`s.\n* \n   * \n* \n   * ## Example\n* \n   * \n* \n   * Given this template\n* \n   * \n* \n   * ```\n* \n   * Count: {{items.length}}\n* \n   * <ul>\n* \n   *   <li *ng-for=\"var item of items\">{{item}}</li>\n* \n   * </ul>\n* \n   * ```\n* \n   * \n* \n   * The above example we have two <a href='/angular2/angular2.api/ProtoViewRef'><code>ProtoViewRef</code></a>s:\n* \n   * \n* \n   * Outter <a href='/angular2/angular2.api/ProtoViewRef'><code>ProtoViewRef</code></a>:\n* \n   * ```\n* \n   * Count: {{items.length}}\n* \n   * <ul>\n* \n   *   <template ng-for var-item [ng-for-of]=\"items\"></template>\n* \n   * </ul>\n* \n   * ```\n* \n   * \n* \n   * Inner <a href='/angular2/angular2.api/ProtoViewRef'><code>ProtoViewRef</code></a>:\n* \n   * ```\n* \n   *   <li>{{item}}</li>\n* \n   * ```\n* \n   * \n* \n   * Notice that the original template is broken down into two separet <a href='/angular2/angular2.api/ProtoViewRef'><code>ProtoViewRef</code></a>s.\n* \n   * \n* \n   * @exportedAs angular2/view",
        "* @exportedAs angular2/core",
        "* The method can be used together with insert to implement a view move, i.e.\n* \n     * moving the dom nodes while the directives in the view stay intact.",
        "* Service for dynamically loading a Component into an arbitrary position in the internal Angular\n* \n   * application tree.\n* \n   * \n* \n   * @exportedAs angular2/view",
        "* Loads a root component that is placed at the first element that matches the component's\n* \n     * selector.\n* \n     * \n* \n     * The loaded component receives injection normally as a hosted view.",
        "* Loads a component into the component view of the provided ElementRef\n* \n     * next to the element with the given name\n* \n     * The loaded component receives\n* \n     * injection normally as a hosted view.",
        "* Loads a component next to the provided ElementRef. The loaded component receives\n* \n     * injection normally as a hosted view.",
        "* @exportedAs angular2/view",
        "* A wrapper around zones that lets you schedule tasks after it has executed a task.\n* \n   * \n* \n   * The wrapper maintains an \"inner\" and an \"mount\" `Zone`. The application code will executes\n* \n   * in the \"inner\" zone unless `runOutsideAngular` is explicitely called.\n* \n   * \n* \n   * A typical application will create a singleton `NgZone`. The outer `Zone` is a fork of the root\n* \n   * `Zone`. The default `onTurnDone` runs the Angular change detection.\n* \n   * \n* \n   * @exportedAs angular2/core",
        "* Initializes the zone hooks.\n* \n     * \n* \n     * @param {() => void} onTurnStart called before code executes in the inner zone for each VM turn\n* \n     * @param {() => void} onTurnDone called at the end of a VM turn if code has executed in the inner\n* \n     * zone\n* \n     * @param {(error, stack) => void} onErrorHandler called when an exception is thrown by a macro or\n* \n     * micro task",
        "* Runs `fn` in the inner zone and returns whatever it returns.\n* \n     * \n* \n     * In a typical app where the inner zone is the Angular zone, this allows one to make use of the\n* \n     * Angular's auto digest mechanism.\n* \n     * \n* \n     * ```\n* \n     * var zone: NgZone = [ref to the application zone];\n* \n     * \n* \n     * zone.run(() => {\n* \n     *   // the change detection will run after this function and the microtasks it enqueues have\n* \n     * executed.\n* \n     * });\n* \n     * ```",
        "* Runs `fn` in the outer zone and returns whatever it returns.\n* \n     * \n* \n     * In a typical app where the inner zone is the Angular zone, this allows one to escape Angular's\n* \n     * auto-digest mechanism.\n* \n     * \n* \n     * ```\n* \n     * var zone: NgZone = [ref to the application zone];\n* \n     * \n* \n     * zone.runOusideAngular(() => {\n* \n     *   element.onClick(() => {\n* \n     *     // Clicking on the element would not trigger the change detection\n* \n     *   });\n* \n     * });\n* \n     * ```",
        "* Use Rx.Observable but provides an adapter to make it work as specified here:\n* \n   * https://github.com/jhusain/observable-spec\n* \n   * \n* \n   * Once a reference implementation of the spec is available, switch to it.",
        "* Creats a ProtoViewDto that contains a single nested component with the given componentId.",
        "* Compiles a single DomProtoView. Non recursive so that\n* \n     * we don't need to serialize all possible components over the wire,\n* \n     * but only the needed ones based on previous calls.",
        "* Cache that stores the AppProtoView of the template of a component.\n* \n   * Used to prevent duplicate work and resolve cyclic dependencies.",
        "* A collection of the Angular core directives that are likely to be used in each and every Angular\n* \n   * application.\n* \n   * \n* \n   * This collection can be used to quickly enumerate all the built-in directives in the `@View`\n* \n   * annotation. For example,\n* \n   * instead of writing:\n* \n   * \n* \n   * ```\n* \n   * import {If, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/angular2';\n* \n   * import {OtherDirective} from 'myDirectives';\n* \n   * \n* \n   * @Component({\n* \n   *  selector: 'my-component'\n* \n   * })\n* \n   * @View({\n* \n   *   templateUrl: 'myComponent.html',\n* \n   *   directives: [If, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]\n* \n   * })\n* \n   * export class MyComponent {\n* \n   *   ...\n* \n   * }\n* \n   * ```\n* \n   * one could enumerate all the core directives at once:\n* \n   * \n* \n   * ```\n* \n   * import {coreDirectives} from 'angular2/angular2';\n* \n   * import {OtherDirective} from 'myDirectives';\n* \n   * \n* \n   * @Component({\n* \n   *  selector: 'my-component'\n* \n   * })\n* \n   * @View({\n* \n   *   templateUrl: 'myComponent.html',\n* \n   *   directives: [coreDirectives, OtherDirective]\n* \n   * })\n* \n   * export class MyComponent {\n* \n   *   ...\n* \n   * }\n* \n   * ```",
        "* The `NgFor` directive instantiates a template once per item from an iterable. The context for\n* \n   * each instantiated template inherits from the outer context with the given loop variable set\n* \n   * to the current item from the iterable.\n* \n   * \n* \n   * It is possible to alias the `index` to a local variable that will be set to the current loop\n* \n   * iteration in the template context.\n* \n   * \n* \n   * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:\n* \n   * \n* \n   * * When an item is added, a new instance of the template is added to the DOM.\n* \n   * * When an item is removed, its template instance is removed from the DOM.\n* \n   * * When items are reordered, their respective templates are reordered in the DOM.\n* \n   * \n* \n   * # Example\n* \n   * \n* \n   * ```\n* \n   * <ul>\n* \n   *   <li *ng-for=\"#error of errors; #i = index\">\n* \n   *     Error {{i}} of {{errors.length}}: {{error.message}}\n* \n   *   </li>\n* \n   * </ul>\n* \n   * ```\n* \n   * \n* \n   * # Syntax\n* \n   * \n* \n   * - `<li *ng-for=\"#item of items; #i = index\">...</li>`\n* \n   * - `<li template=\"ng-for #item of items; #i = index\">...</li>`\n* \n   * - `<template ng-for #item [ng-for-of]=\"items\" #i=\"index\"><li>...</li></template>`\n* \n   * \n* \n   * @exportedAs angular2/directives",
        "* Removes or recreates a portion of the DOM tree based on an {expression}.\n* \n   * \n* \n   * If the expression assigned to `ng-if` evaluates to a false value then the element\n* \n   * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.\n* \n   * \n* \n   * # Example:\n* \n   * \n* \n   * ```\n* \n   * <div *ng-if=\"errorCount > 0\" class=\"error\">\n* \n   *   <!-- Error message displayed when the errorCount property on the current context is greater\n* \n   * than 0. -->\n* \n   *   {{errorCount}} errors detected\n* \n   * </div>\n* \n   * ```\n* \n   * \n* \n   * # Syntax\n* \n   * \n* \n   * - `<div *ng-if=\"condition\">...</div>`\n* \n   * - `<div template=\"ng-if condition\">...</div>`\n* \n   * - `<template [ng-if]=\"condition\"><div>...</div></template>`\n* \n   * \n* \n   * @exportedAs angular2/directives",
        "* The `NgNonBindable` directive tells Angular not to compile or bind the contents of the current\n* \n   * DOM element. This is useful if the element contains what appears to be Angular directives and\n* \n   * bindings but which should be ignored by Angular. This could be the case if you have a site that\n* \n   * displays snippets of code, for instance.\n* \n   * \n* \n   * Example:\n* \n   * \n* \n   * ```\n* \n   * <div>Normal: {{1 + 2}}</div> // output \"Normal: 3\"\n* \n   * <div non-bindable>Ignored: {{1 + 2}}</div> // output \"Ignored: {{1 + 2}}\"\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/directives",
        "* The `NgSwitch` directive is used to conditionally swap DOM structure on your template based on a\n* \n   * scope expression.\n* \n   * Elements within `NgSwitch` but without `NgSwitchWhen` or `NgSwitchDefault` directives will be\n* \n   * preserved at the location as specified in the template.\n* \n   * \n* \n   * `NgSwitch` simply chooses nested elements and makes them visible based on which element matches\n* \n   * the value obtained from the evaluated expression. In other words, you define a container element\n* \n   * (where you place the directive), place an expression on the **`[ng-switch]=\"...\"` attribute**),\n* \n   * define any inner elements inside of the directive and place a `[ng-switch-when]` attribute per\n* \n   * element.\n* \n   * The when attribute is used to inform NgSwitch which element to display when the expression is\n* \n   * evaluated. If a matching expression is not found via a when attribute then an element with the\n* \n   * default attribute is displayed.\n* \n   * \n* \n   * # Example:\n* \n   * \n* \n   * ```\n* \n   * <ANY [ng-switch]=\"expression\">\n* \n   *   <template [ng-switch-when]=\"whenExpression1\">...</template>\n* \n   *   <template [ng-switch-when]=\"whenExpression1\">...</template>\n* \n   *   <template ng-switch-default>...</template>\n* \n   * </ANY>\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/directives",
        "* Defines a case statement as an expression.\n* \n   * \n* \n   * If multiple `NgSwitchWhen` match the `NgSwitch` value, all of them are displayed.\n* \n   * \n* \n   * Example:\n* \n   * \n* \n   * ```\n* \n   * // match against a context variable\n* \n   * <template [ng-switch-when]=\"contextVariable\">...</template>\n* \n   * \n* \n   * // match against a constant string\n* \n   * <template ng-switch-when=\"stringValue\">...</template>\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/directives",
        "* Defines a default case statement.\n* \n   * \n* \n   * Default case statements are displayed when no `NgSwitchWhen` match the `ng-switch` value.\n* \n   * \n* \n   * Example:\n* \n   * \n* \n   * ```\n* \n   * <template ng-switch-default>...</template>\n* \n   * ```\n* \n   * \n* \n   * @exportedAs angular2/directives",
        "* Mock Connection to represent a <a href='/angular2/angular2.api/Connection'><code>Connection</code></a> for tests.",
        "* Describes the state of the connection, based on `XMLHttpRequest.readyState`, but with\n* \n     * additional states. For example, state 5 indicates an aborted connection.",
        "* <a href='/angular2/angular2.api/Request'><code>Request</code></a> instance used to create the connection.",
        "* <a href='/angular2/angular2.api/EventEmitter'><code>EventEmitter</code></a> of <a href='/angular2/angular2.api/Response'><code>Response</code></a>. Can be subscribed to in order to be notified when a\n* \n     * response is available.",
        "* Changes the `readyState` of the connection to a custom state of 5 (cancelled).",
        "* Sends a mock response to the connection. This response is the value that is emitted to the\n* \n     * <a href='/angular2/angular2.api/EventEmitter'><code>EventEmitter</code></a> returned by <a href='/angular2/angular2.api/Http'><code>Http</code></a>.\n* \n     * \n* \n     * #Example\n* \n     * \n* \n     * ```\n* \n     * var connection;\n* \n     * backend.connections.subscribe(c => connection = c);\n* \n     * http.request('data.json').subscribe(res => console.log(res.text()));\n* \n     * connection.mockRespond(new Response('fake response')); //logs 'fake response'\n* \n     * ```",
        "* Not yet implemented!\n* \n     * \n* \n     * Sends the provided <a href='/angular2/angular2.api/Response'><code>Response</code></a> to the `downloadObserver` of the `Request`\n* \n     * associated with this connection.",
        "* Emits the provided error object as an error to the <a href='/angular2/angular2.api/Response'><code>Response</code></a> <a href='/angular2/angular2.api/EventEmitter'><code>EventEmitter</code></a>\n* \n     * returned\n* \n     * from <a href='/angular2/angular2.api/Http'><code>Http</code></a>.",
        "* A mock backend for testing the <a href='/angular2/angular2.api/Http'><code>Http</code></a> service.\n* \n   * \n* \n   * This class can be injected in tests, and should be used to override bindings\n* \n   * to other backends, such as <a href='/angular2/angular2.api/XHRBackend'><code>XHRBackend</code></a>.\n* \n   * \n* \n   * #Example\n* \n   * \n* \n   * ```\n* \n   * import {MockBackend, DefaultOptions, Http} from 'angular2/http';\n* \n   * it('should get some data', inject([AsyncTestCompleter], (async) => {\n* \n   *   var connection;\n* \n   *   var injector = Injector.resolveAndCreate([\n* \n   *     MockBackend,\n* \n   *     bind(Http).toFactory((backend, defaultOptions) => {\n* \n   *       return new Http(backend, defaultOptions)\n* \n   *     }, [MockBackend, DefaultOptions])]);\n* \n   *   var http = injector.get(Http);\n* \n   *   var backend = injector.get(MockBackend);\n* \n   *   //Assign any newly-created connection to local variable\n* \n   *   backend.connections.subscribe(c => connection = c);\n* \n   *   http.request('data.json').subscribe((res) => {\n* \n   *     expect(res.text()).toBe('awesome');\n* \n   *     async.done();\n* \n   *   });\n* \n   *   connection.mockRespond(new Response('awesome'));\n* \n   * }));\n* \n   * ```\n* \n   * \n* \n   * This method only exists in the mock implementation, not in real Backends.",
        "* <a href='/angular2/angular2.api/EventEmitter'><code>EventEmitter</code></a>\n* \n     * of <a href='/angular2/angular2.api/MockConnection'><code>MockConnection</code></a> instances that have been created by this backend. Can be subscribed\n* \n     * to in order to respond to connections.\n* \n     * \n* \n     * #Example\n* \n     * \n* \n     * ```\n* \n     * import {MockBackend, Http, BaseRequestOptions} from 'angular2/http';\n* \n     * import {Injector} from 'angular2/di';\n* \n     * \n* \n     * it('should get a response', () => {\n* \n     *   var connection; //this will be set when a new connection is emitted from the backend.\n* \n     *   var text; //this will be set from mock response\n* \n     *   var injector = Injector.resolveAndCreate([\n* \n     *     MockBackend,\n* \n     *     bind(Http).toFactory(backend, options) {\n* \n     *       return new Http(backend, options);\n* \n     *     }, [MockBackend, BaseRequestOptions]]);\n* \n     *   var backend = injector.get(MockBackend);\n* \n     *   var http = injector.get(Http);\n* \n     *   backend.connections.subscribe(c => connection = c);\n* \n     *   http.request('something.json').subscribe(res => {\n* \n     *     text = res.text();\n* \n     *   });\n* \n     *   connection.mockRespond(new Response({body: 'Something'}));\n* \n     *   expect(text).toBe('Something');\n* \n     * });\n* \n     * ```\n* \n     * \n* \n     * This property only exists in the mock implementation, not in real Backends.",
        "* An array representation of `connections`. This array will be updated with each connection that\n* \n     * is created by this backend.\n* \n     * \n* \n     * This property only exists in the mock implementation, not in real Backends.",
        "* <a href='/angular2/angular2.api/EventEmitter'><code>EventEmitter</code></a> of <a href='/angular2/angular2.api/MockConnection'><code>MockConnection</code></a> instances that haven't yet been resolved (i.e.\n* \n     * with a `readyState`\n* \n     * less than 4). Used internally to verify that no connections are pending via the\n* \n     * `verifyNoPendingRequests` method.\n* \n     * \n* \n     * This property only exists in the mock implementation, not in real Backends.",
        "* Checks all connections, and raises an exception if any connection has not received a response.\n* \n     * \n* \n     * This method only exists in the mock implementation, not in real Backends.",
        "* Can be used in conjunction with `verifyNoPendingRequests` to resolve any not-yet-resolve\n* \n     * connections, if it's expected that there are connections that have not yet received a response.\n* \n     * \n* \n     * This method only exists in the mock implementation, not in real Backends.",
        "* Creates a new <a href='/angular2/angular2.api/MockConnection'><code>MockConnection</code></a>. This is equivalent to calling `new\n* \n     * MockConnection()`, except that it also will emit the new `Connection` to the `connections`\n* \n     * emitter of this `MockBackend` instance. This method will usually only be used by tests\n* \n     * against the framework itself, not by end-users.",
        "* Creates `Request` instances from provided values.\n* \n   * \n* \n   * The Request's interface is inspired by the Request constructor defined in the [Fetch\n* \n   * Spec](https://fetch.spec.whatwg.org/#request-class),\n* \n   * but is considered a static value whose body can be accessed many times. There are other\n* \n   * differences in the implementation, but this is the most significant.",
        "* Http method with which to perform the request.\n* \n     * \n* \n     * Defaults to GET.",
        "* Headers object based on the `Headers` class in the [Fetch\n* \n     * Spec](https://fetch.spec.whatwg.org/#headers-class). <a href='/angular2/angular2.api/Headers'><code>Headers</code></a> class reference.",
        "* Url of the remote resource",
        "* Returns the request's body as string, assuming that body exists. If body is undefined, return\n* \n     * empty\n* \n     * string.",
        "* Creates `Response` instances from provided values.\n* \n   * \n* \n   * Though this object isn't\n* \n   * usually instantiated by end-users, it is the primary object interacted with when it comes time to\n* \n   * add data to a view.\n* \n   * \n* \n   * #Example\n* \n   * \n* \n   * ```\n* \n   * http.request('my-friends.txt').subscribe(response => this.friends = response.text());\n* \n   * ```\n* \n   * \n* \n   * The Response's interface is inspired by the Response constructor defined in the [Fetch\n* \n   * Spec](https://fetch.spec.whatwg.org/#response-class), but is considered a static value whose body\n* \n   * can be accessed many times. There are other differences in the implementation, but this is the\n* \n   * most significant.",
        "* One of \"basic\", \"cors\", \"default\", \"error, or \"opaque\".\n* \n     * \n* \n     * Defaults to \"default\".",
        "* True if the response's status is within 200-299",
        "* URL of response.\n* \n     * \n* \n     * Defaults to empty string.",
        "* Status code returned by server.\n* \n     * \n* \n     * Defaults to 200.",
        "* Text representing the corresponding reason phrase to the `status`, as defined in [ietf rfc 2616\n* \n     * section 6.1.1](https://tools.ietf.org/html/rfc2616#section-6.1.1)\n* \n     * \n* \n     * Defaults to \"OK\"",
        "* Non-standard property\n* \n     * \n* \n     * Denotes how many of the response body's bytes have been loaded, for example if the response is\n* \n     * the result of a progress event.",
        "* Non-standard property\n* \n     * \n* \n     * Denotes how many bytes are expected in the final response body.",
        "* Headers object based on the `Headers` class in the [Fetch\n* \n     * Spec](https://fetch.spec.whatwg.org/#headers-class).",
        "* Not yet implemented",
        "* Attempts to return body as parsed `JSON` object, or raises an exception.",
        "* Returns the body as a string, presuming `toString()` can be called on the response body.",
        "* Not yet implemented",
        "* Interface for options to construct a Request, based on\n* \n   * [RequestInit](https://fetch.spec.whatwg.org/#requestinit) from the Fetch spec.",
        "* Interface for options to construct a Response, based on\n* \n   * [ResponseInit](https://fetch.spec.whatwg.org/#responseinit) from the Fetch spec.",
        "* Abstract class from which real connections are derived.",
        "* Abstract class from which real backends are derived.\n* \n   * \n* \n   * The primary purpose of a `ConnectionBackend` is to create new connections to fulfill a given\n* \n   * <a href='/angular2/angular2.api/Request'><code>Request</code></a>.",
        "* Injectable version of <a href='/angular2/angular2.api/RequestOptions'><code>RequestOptions</code></a>, with overridable default values.\n* \n   * \n* \n   * #Example\n* \n   * \n* \n   * ```\n* \n   * import {Http, BaseRequestOptions, Request} from 'angular2/http';\n* \n   * ...\n* \n   * class MyComponent {\n* \n   *   constructor(baseRequestOptions:BaseRequestOptions, http:Http) {\n* \n   *     var options = baseRequestOptions.merge({body: 'foobar', url: 'https://foo'});\n* \n   *     var request = new Request(options);\n* \n   *     http.request(request).subscribe(res => this.bars = res.json());\n* \n   *   }\n* \n   * }\n* \n   * \n* \n   * ```",
        "* Creates a request options object similar to the `RequestInit` description\n* \n   * in the [Fetch\n* \n   * Spec](https://fetch.spec.whatwg.org/#requestinit) to be optionally provided when instantiating a\n* \n   * <a href='/angular2/angular2.api/Request'><code>Request</code></a>.\n* \n   * \n* \n   * All values are null by default.",
        "* Http method with which to execute the request.\n* \n     * \n* \n     * Defaults to \"GET\".",
        "* Headers object based on the `Headers` class in the [Fetch\n* \n     * Spec](https://fetch.spec.whatwg.org/#headers-class).",
        "* Body to be used when creating the request.",
        "* Creates a copy of the `RequestOptions` instance, using the optional input as values to override\n* \n     * existing values.",
        "* Injectable version of <a href='/angular2/angular2.api/ResponseOptions'><code>ResponseOptions</code></a>, with overridable default values.",
        "* Creates a response options object similar to the\n* \n   * [ResponseInit](https://fetch.spec.whatwg.org/#responseinit) description\n* \n   * in the Fetch\n* \n   * Spec to be optionally provided when instantiating a\n* \n   * <a href='/angular2/angular2.api/Response'><code>Response</code></a>.\n* \n   * \n* \n   * All values are null by default.",
        "* Creates <a href='/angular2/angular2.api/XHRConnection'><code>XHRConnection</code></a> instances.\n* \n   * \n* \n   * This class would typically not be used by end users, but could be\n* \n   * overridden if a different backend implementation should be used,\n* \n   * such as in a node backend.\n* \n   * \n* \n   * #Example\n* \n   * \n* \n   * ```\n* \n   * import {Http, MyNodeBackend, httpInjectables, BaseRequestOptions} from 'angular2/http';\n* \n   * @Component({\n* \n   *   viewInjector: [\n* \n   *     httpInjectables,\n* \n   *     bind(Http).toFactory((backend, options) => {\n* \n   *       return new Http(backend, options);\n* \n   *     }, [MyNodeBackend, BaseRequestOptions])]\n* \n   * })\n* \n   * class MyComponent {\n* \n   *   constructor(http:Http) {\n* \n   *     http('people.json').subscribe(res => this.people = res.json());\n* \n   *   }\n* \n   * }\n* \n   * ```",
        "* Creates connections using `XMLHttpRequest`. Given a fully-qualified\n* \n   * request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the\n* \n   * request.\n* \n   * \n* \n   * This class would typically not be created or interacted with directly inside applications, though\n* \n   * the <a href='/angular2/angular2.api/MockConnection'><code>MockConnection</code></a> may be interacted with in tests.",
        "* Response <a href='/angular2/angular2.api/EventEmitter'><code>EventEmitter</code></a> which emits a single <a href='/angular2/angular2.api/Response'><code>Response</code></a> value on load event of\n* \n     * `XMLHttpRequest`.",
        "* Calls abort on the underlying XMLHttpRequest.",
        "* Performs http requests using `XMLHttpRequest` as the default backend.\n* \n   * \n* \n   * `Http` is available as an injectable class, with methods to perform http requests. Calling\n* \n   * `request` returns an <a href='/angular2/angular2.api/EventEmitter'><code>EventEmitter</code></a> which will emit a single <a href='/angular2/angular2.api/Response'><code>Response</code></a> when a\n* \n   * response is received.\n* \n   * \n* \n   * \n* \n   * ## Breaking Change\n* \n   * \n* \n   * Previously, methods of `Http` would return an RxJS Observable directly. For now,\n* \n   * the `toRx()` method of <a href='/angular2/angular2.api/EventEmitter'><code>EventEmitter</code></a> needs to be called in order to get the RxJS\n* \n   * Subject. `EventEmitter` does not provide combinators like `map`, and has different semantics for\n* \n   * subscribing/observing. This is temporary; the result of all `Http` method calls will be either an\n* \n   * Observable\n* \n   * or Dart Stream when [issue #2794](https://github.com/angular/angular/issues/2794) is resolved.\n* \n   * \n* \n   * #Example\n* \n   * \n* \n   * ```\n* \n   * import {Http, httpInjectables} from 'angular2/http';\n* \n   * @Component({selector: 'http-app', viewInjector: [httpInjectables]})\n* \n   * @View({templateUrl: 'people.html'})\n* \n   * class PeopleComponent {\n* \n   *   constructor(http: Http) {\n* \n   *     http.get('people.json')\n* \n   *       //Get the RxJS Subject\n* \n   *       .toRx()\n* \n   *       // Call map on the response observable to get the parsed people object\n* \n   *       .map(res => res.json())\n* \n   *       // Subscribe to the observable to get the parsed people object and attach it to the\n* \n   *       // component\n* \n   *       .subscribe(people => this.people = people);\n* \n   *   }\n* \n   * }\n* \n   * ```\n* \n   * \n* \n   * To use the <a href='/angular2/angular2.api/EventEmitter'><code>EventEmitter</code></a> returned by `Http`, simply pass a generator (See \"interface\n* \n   * Generator\" in the Async Generator spec: https://github.com/jhusain/asyncgenerator) to the\n* \n   * `observer` method of the returned emitter, with optional methods of `next`, `throw`, and `return`.\n* \n   * \n* \n   * #Example\n* \n   * \n* \n   * ```\n* \n   * http.get('people.json').observer({next: (value) => this.people = people});\n* \n   * ```\n* \n   * \n* \n   * The default construct used to perform requests, `XMLHttpRequest`, is abstracted as a \"Backend\" (\n* \n   * <a href='/angular2/angular2.api/XHRBackend'><code>XHRBackend</code></a> in this case), which could be mocked with dependency injection by replacing\n* \n   * the <a href='/angular2/angular2.api/XHRBackend'><code>XHRBackend</code></a> binding, as in the following example:\n* \n   * \n* \n   * #Example\n* \n   * \n* \n   * ```\n* \n   * import {MockBackend, BaseRequestOptions, Http} from 'angular2/http';\n* \n   * var injector = Injector.resolveAndCreate([\n* \n   *   BaseRequestOptions,\n* \n   *   MockBackend,\n* \n   *   bind(Http).toFactory(\n* \n   *       function(backend, defaultOptions) {\n* \n   *         return new Http(backend, defaultOptions);\n* \n   *       },\n* \n   *       [MockBackend, BaseRequestOptions])\n* \n   * ]);\n* \n   * var http = injector.get(Http);\n* \n   * http.get('request-from-mock-backend.json').toRx().subscribe((res:Response) => doSomething(res));\n* \n   * ```",
        "* Performs any type of http request. First argument is required, and can either be a url or\n* \n     * a <a href='/angular2/angular2.api/Request'><code>Request</code></a> instance. If the first argument is a url, an optional <a href='/angular2/angular2.api/RequestOptions'><code>RequestOptions</code></a>\n* \n     * object can be provided as the 2nd argument. The options object will be merged with the values\n* \n     * of <a href='/angular2/angular2.api/BaseRequestOptions'><code>BaseRequestOptions</code></a> before performing the request.",
        "* Performs a request with `get` http method.",
        "* Performs a request with `post` http method.",
        "* Performs a request with `put` http method.",
        "* Performs a request with `delete` http method.",
        "* Performs a request with `patch` http method.",
        "* Performs a request with `head` http method.",
        "* Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as\n* \n   * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class). The only known\n* \n   * difference from the spec is the lack of an `entries` method.",
        "* Appends a header to existing list of header values for a given header name.",
        "* Deletes all header values for the given name.",
        "* Returns first header that matches given name.",
        "* Check for existence of header by given name.",
        "* Provides names of set headers",
        "* Sets or overrides header value for given name.",
        "* Returns values of all headers.",
        "* Returns list of header values for a given name.",
        "* This method is not implemented.",
        "* Acceptable response types to be associated with a <a href='/angular2/angular2.api/Response'><code>Response</code></a>, based on\n* \n   * [ResponseType](https://fetch.spec.whatwg.org/#responsetype) from the Fetch spec.",
        "* All possible states in which a connection can be, based on\n* \n   * [States](http://www.w3.org/TR/XMLHttpRequest/#states) from the `XMLHttpRequest` spec, but with an\n* \n   * additional \"CANCELLED\" state.",
        "* Supported http methods.",
        "* Acceptable credentials option to be associated with a <a href='/angular2/angular2.api/Request'><code>Request</code></a>, based on\n* \n   * [RequestCredentials](https://fetch.spec.whatwg.org/#requestcredentials) from the Fetch spec.",
        "* Acceptable cache option to be associated with a <a href='/angular2/angular2.api/Request'><code>Request</code></a>, based on\n* \n   * [RequestCache](https://fetch.spec.whatwg.org/#requestcache) from the Fetch spec.",
        "* Acceptable origin modes to be associated with a <a href='/angular2/angular2.api/Request'><code>Request</code></a>, based on\n* \n   * [RequestMode](https://fetch.spec.whatwg.org/#requestmode) from the Fetch spec.",
        "* Map-like representation of url search parameters, based on\n* \n   * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard.",
        "* Provides a basic set of injectables to use the <a href='/angular2/angular2.api/Http'><code>Http</code></a> service in any application.\n* \n   * \n* \n   * #Example\n* \n   * \n* \n   * ```\n* \n   * import {httpInjectables, Http} from 'angular2/http';\n* \n   * @Component({selector: 'http-app', viewInjector: [httpInjectables]})\n* \n   * @View({template: '{{data}}'})\n* \n   * class MyApp {\n* \n   *   constructor(http:Http) {\n* \n   *     http.request('data.txt').subscribe(res => this.data = res.text());\n* \n   *   }\n* \n   * }\n* \n   * ```",
        "* General notes:\n* \n   * \n* \n   * The methods for creating / destroying views in this API are used in the AppViewHydrator\n* \n   * and RenderViewHydrator as well.\n* \n   * \n* \n   * We are already parsing expressions on the render side:\n* \n   * - this makes the ElementBinders more compact\n* \n   *   (e.g. no need to distinguish interpolations from regular expressions from literals)\n* \n   * - allows to retrieve which properties should be accessed from the event\n* \n   *   by looking at the expression\n* \n   * - we need the parse at least for the `template` attribute to match\n* \n   *   directives in it\n* \n   * - render compiler is not on the critical path as\n* \n   *   its output will be stored in precompiled templates.",
        "* Creates a root host view that includes the given element.\n* \n     * @param {RenderProtoViewRef} hostProtoViewRef a RenderProtoViewRef of type\n* \n     * ProtoViewDto.HOST_VIEW_TYPE\n* \n     * @param {any} hostElementSelector css selector for the host element (will be queried against the\n* \n     * main document)\n* \n     * @return {RenderViewRef} the created view",
        "* Creates a regular view out of the given ProtoView",
        "* Destroys the given view after it has been dehydrated and detached",
        "* Attaches a componentView into the given hostView at the given element",
        "* Detaches a componentView into the given hostView at the given element",
        "* Attaches a view into a ViewContainer (in the given parentView at the given element) at the\n* \n     * given index.",
        "* Detaches a view into a ViewContainer (in the given parentView at the given element) at the\n* \n     * given index.",
        "* Hydrates a view after it has been attached. Hydration/dehydration is used for reusing views\n* \n     * inside of the view pool.",
        "* Dehydrates a view after it has been attached. Hydration/dehydration is used for reusing views\n* \n     * inside of the view pool.",
        "* Returns the native element at the given location.\n* \n     * Attention: In a WebWorker scenario, this should always return null!",
        "* Sets a property on an element.",
        "* Sets an attribute on an element.",
        "* Sets a class on an element.",
        "* Sets a style on an element.",
        "* Calls a method on an element.",
        "* Sets the value of a text node.",
        "* Sets the dispatcher for all events of the given view",
        "* A dispatcher for all events happening in a view.",
        "* Called when an event was triggered for a on-* attribute on an element.\n* \n     * @param {Map<string, any>} locals Locals to be used to evaluate the\n* \n     *   event expressions",
        "* Adds a child to the parent node. The child MUST NOT be a part of a tree.",
        "* Adds a child to the parent node after a given sibling.\n* \n     * The child MUST NOT be a part of a tree and the sibling must be present.",
        "* Detaches a node from the parent's tree.",
        "* Multiple expressions separated by a semicolon."
    ],
    "functions": [],
    "classes": [
        "DependencyAnnotation",
        "LifecycleEvent",
        "Query",
        "ControlContainer",
        "Injectable",
        "Visibility",
        "BaseQueryList",
        "AppProtoView",
        "AppView",
        "AppViewContainer",
        "DehydratedException",
        "ExpressionChangedAfterItHasBeenChecked",
        "ChangeDetectionError",
        "ChangeDetection",
        "ChangeDetectorRef",
        "PipeRegistry",
        "WrappedValue",
        "NullPipe",
        "NullPipeFactory",
        "DynamicChangeDetection",
        "JitChangeDetection",
        "PreGeneratedChangeDetection",
        "DirectiveIndex",
        "BindingRecord",
        "Locals",
        "ChangeDetectorDefinition",
        "BasePipe",
        "DirectiveRecord",
        "Injector",
        "ProtoInjector",
        "Binding",
        "Key",
        "NoBindingError",
        "AbstractBindingError",
        "AsyncBindingError",
        "CyclicDependencyError",
        "InstantiationError",
        "InvalidBindingError",
        "NoAnnotationError",
        "OpaqueToken",
        "ResolvedBinding",
        "BindingBuilder",
        "Dependency",
        "AbstractControl",
        "Control",
        "ControlGroup",
        "ControlArray",
        "NgControlName",
        "NgFormControl",
        "NgModel",
        "NgControl",
        "NgControlGroup",
        "NgFormModel",
        "NgForm",
        "DefaultValueAccessor",
        "CheckboxControlValueAccessor",
        "SelectControlValueAccessor",
        "Validators",
        "NgValidator",
        "NgRequiredValidator",
        "FormBuilder",
        "DomRenderer",
        "ComponentAnnotation",
        "DirectiveAnnotation",
        "ViewAnnotation",
        "QueryAnnotation",
        "AttributeAnnotation",
        "ApplicationRef",
        "AppRootUrl",
        "UrlResolver",
        "ComponentUrlMapper",
        "DirectiveResolver",
        "Compiler",
        "AppViewManager",
        "QueryList",
        "ElementRef",
        "ViewRef",
        "ProtoViewRef",
        "ViewContainerRef",
        "DynamicComponentLoader",
        "ComponentRef",
        "NgZone",
        "Observable",
        "EventEmitter",
        "ProtoViewFactory",
        "RenderCompiler",
        "CompilerCache",
        "CSSClass",
        "NgFor",
        "NgIf",
        "NgNonBindable",
        "NgStyle",
        "SwitchView",
        "NgSwitch",
        "NgSwitchWhen",
        "NgSwitchDefault",
        "MockConnection",
        "MockBackend",
        "Request",
        "Response",
        "Connection",
        "ConnectionBackend",
        "BaseRequestOptions",
        "RequestOptions",
        "BaseResponseOptions",
        "ResponseOptions",
        "XHRBackend",
        "XHRConnection",
        "Http",
        "Headers",
        "URLSearchParams",
        "EventBinding",
        "ElementPropertyBinding",
        "ElementBinder",
        "DirectiveBinder",
        "ProtoViewDto",
        "DirectiveMetadata",
        "RenderProtoViewRef",
        "RenderViewRef",
        "ViewDefinition",
        "Renderer",
        "TreeNode",
        "DirectiveDependency",
        "DirectiveBinding",
        "PreBuiltObjects",
        "EventEmitterAccessor",
        "HostActionAccessor",
        "ProtoElementInjector",
        "ElementInjector",
        "QueryError",
        "QueryRef",
        "AST",
        "EmptyExpr",
        "ImplicitReceiver",
        "Chain",
        "Conditional",
        "If",
        "AccessMember",
        "SafeAccessMember",
        "KeyedAccess",
        "BindingPipe",
        "LiteralPrimitive",
        "LiteralArray",
        "LiteralMap",
        "Interpolation",
        "Binary",
        "PrefixNot",
        "Assignment",
        "MethodCall",
        "SafeMethodCall",
        "FunctionCall",
        "ASTWithSource",
        "TemplateBinding",
        "AstTransformer"
    ]
}