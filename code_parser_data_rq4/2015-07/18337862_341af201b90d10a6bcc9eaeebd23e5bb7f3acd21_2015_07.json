{
    "identifiers": [
        "e",
        "t",
        "n",
        "r",
        "o",
        "u",
        "n",
        "o",
        "t",
        "o",
        "require",
        "require",
        "u",
        "a",
        "a",
        "o",
        "i",
        "i",
        "o",
        "o",
        "f",
        "f",
        "n",
        "o",
        "t",
        "o",
        "l",
        "e",
        "t",
        "o",
        "e",
        "s",
        "n",
        "n",
        "e",
        "l",
        "l",
        "e",
        "t",
        "n",
        "r",
        "n",
        "o",
        "require",
        "require",
        "o",
        "r",
        "o",
        "s",
        "r",
        "o",
        "s",
        "require",
        "exports",
        "require",
        "require",
        "exports",
        "require",
        "layer",
        "Infinity",
        "Infinity",
        "Infinity",
        "Infinity",
        "each",
        "layer",
        "coord",
        "extent",
        "coord",
        "extent",
        "coord",
        "extent",
        "coord",
        "extent",
        "coord",
        "extent",
        "coord",
        "extent",
        "coord",
        "extent",
        "coord",
        "extent",
        "coord",
        "extent",
        "require",
        "exports",
        "layer",
        "callback",
        "excludeWrapCoord",
        "layer",
        "layer",
        "isFeatureCollection",
        "layer",
        "i",
        "i",
        "stop",
        "i",
        "geometryMaybeCollection",
        "isFeatureCollection",
        "layer",
        "i",
        "isFeature",
        "layer",
        "layer",
        "isGeometryCollection",
        "geometryMaybeCollection",
        "stopG",
        "isGeometryCollection",
        "geometryMaybeCollection",
        "g",
        "g",
        "stopG",
        "g",
        "geometry",
        "isGeometryCollection",
        "geometryMaybeCollection",
        "g",
        "geometryMaybeCollection",
        "coords",
        "geometry",
        "wrapShrink",
        "excludeWrapCoord",
        "geometry",
        "geometry",
        "geometry",
        "callback",
        "coords",
        "geometry",
        "geometry",
        "j",
        "j",
        "coords",
        "j",
        "callback",
        "coords",
        "j",
        "geometry",
        "geometry",
        "j",
        "j",
        "coords",
        "j",
        "k",
        "k",
        "coords",
        "j",
        "wrapShrink",
        "k",
        "callback",
        "coords",
        "j",
        "k",
        "geometry",
        "j",
        "j",
        "coords",
        "j",
        "k",
        "k",
        "coords",
        "j",
        "k",
        "l",
        "l",
        "coords",
        "j",
        "k",
        "wrapShrink",
        "l",
        "callback",
        "coords",
        "j",
        "k",
        "l",
        "coordEach",
        "layer",
        "callback",
        "memo",
        "excludeWrapCoord",
        "coordEach",
        "layer",
        "coord",
        "memo",
        "callback",
        "memo",
        "coord",
        "excludeWrapCoord",
        "memo",
        "coordReduce",
        "layer",
        "callback",
        "layer",
        "features",
        "layer",
        "i",
        "i",
        "layer",
        "i",
        "callback",
        "layer",
        "i",
        "callback",
        "layer",
        "propEach",
        "layer",
        "callback",
        "memo",
        "propEach",
        "layer",
        "prop",
        "memo",
        "callback",
        "memo",
        "prop",
        "memo",
        "propReduce"
    ],
    "literals": [
        "\"function\"",
        "\"Cannot find module '\"",
        "\"'\"",
        "\"MODULE_NOT_FOUND\"",
        "\"function\"",
        "'turf-extent'",
        "\"undefined\"",
        "\"undefined\"",
        "\"undefined\"",
        "\"turf-extent\"",
        "'turf-meta'",
        "\"turf-meta\"",
        "'FeatureCollection'",
        "'Feature'",
        "'GeometryCollection'",
        "'Polygon'",
        "'MultiPolygon'",
        "'Point'",
        "'LineString'",
        "'MultiPoint'",
        "'Polygon'",
        "'MultiLineString'",
        "'MultiPolygon'",
        "'Unknown Geometry Type'",
        "'FeatureCollection'",
        "'Feature'"
    ],
    "variables": [
        "a",
        "f",
        "l",
        "n",
        "i",
        "o",
        "each",
        "extent",
        "i",
        "j",
        "k",
        "g",
        "geometry",
        "stopG",
        "coords",
        "geometryMaybeCollection",
        "wrapShrink",
        "isGeometryCollection",
        "isFeatureCollection",
        "isFeature",
        "stop",
        "i"
    ],
    "comments": [
        "This logic may look a little weird. The reason why it is that way",
        "is because it's trying to be fast. GeoJSON supports multiple kinds",
        "of objects at its root: FeatureCollection, Features, Geometries.",
        "This function has the responsibility of handling all of them, and that",
        "means that some of the `for` loops you see below actually just don't apply",
        "to certain inputs. For instance, if you give this just a",
        "Point geometry, then both loops are short-circuited and all we do",
        "is gradually rename the input until it's called 'geometry'.",
        "",
        "This also aims to allocate as few resources as possible: just a",
        "few numbers and booleans, rather than any temporary arrays as would",
        "be required with the normalization approach."
    ],
    "docstrings": [
        "* Takes any {@link GeoJSON} object, calculates the extent of all input features, and returns a bounding box.\n *\n * @module turf/extent\n * @category measurement\n * @param {GeoJSON} input any valid GeoJSON Object\n * @return {Array<number>} the bounding box of `input` given\n * as an array in WSEN order (west, south, east, north)\n * @example\n * var input = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [\n *     {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [114.175329, 22.2524]\n *       }\n *     }, {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [114.170007, 22.267969]\n *       }\n *     }, {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [114.200649, 22.274641]\n *       }\n *     }, {\n *       \"type\": \"Feature\",\n *       \"properties\": {},\n *       \"geometry\": {\n *         \"type\": \"Point\",\n *         \"coordinates\": [114.186744, 22.265745]\n *       }\n *     }\n *   ]\n * };\n *\n * var bbox = turf.extent(input);\n *\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * var resultFeatures = input.features.concat(bboxPolygon);\n * var result = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": resultFeatures\n * };\n *\n * //=result",
        "* Lazily iterate over coordinates in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var point = { type: 'Point', coordinates: [0, 0] };\n * coordEach(point, function(coords) {\n *   // coords is equal to [0, 0]\n * });",
        "* Lazily reduce coordinates in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all coordinates is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, value) and returns\n * a new memo\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @param {*} memo the starting value of memo: can be any type.",
        "* Lazily iterate over property objects in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @example\n * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };\n * propEach(point, function(props) {\n *   // props is equal to { foo: 1}\n * });",
        "* Lazily reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, coord) and returns\n * a new memo\n * @param {*} memo the starting value of memo: can be any type."
    ],
    "functions": [
        "s",
        "coordEach",
        "coordReduce",
        "propEach",
        "propReduce"
    ],
    "classes": []
}