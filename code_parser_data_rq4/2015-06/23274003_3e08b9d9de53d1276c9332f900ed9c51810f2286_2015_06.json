{
    "identifiers": [
        "collections",
        "defaultdict",
        "math",
        "log",
        "numpy",
        "numpy",
        "linalg",
        "LOTlib",
        "Miscellaneous",
        "Infinity",
        "p",
        "sum",
        "p",
        "sum",
        "pi",
        "z",
        "log",
        "pi",
        "z",
        "pi",
        "p",
        "grammar",
        "nt",
        "grammar",
        "nonterminals",
        "r",
        "p",
        "r",
        "grammar",
        "get_rules",
        "nt",
        "min",
        "p",
        "h",
        "H",
        "p",
        "h",
        "grammar",
        "ts",
        "grammar",
        "nonterminals",
        "ts",
        "nts",
        "n",
        "i",
        "i",
        "n",
        "nts",
        "ts",
        "len",
        "name2idx",
        "keys",
        "numpy",
        "zeros",
        "n",
        "n",
        "nt",
        "nts",
        "sum",
        "r",
        "p",
        "r",
        "grammar",
        "get_rules",
        "nt",
        "defaultdict",
        "r",
        "grammar",
        "get_rules",
        "nt",
        "r",
        "to",
        "len",
        "r",
        "to",
        "cnt",
        "ts",
        "r",
        "p",
        "z",
        "a",
        "r",
        "to",
        "grammar",
        "is_nonterminal",
        "a",
        "cnt",
        "a",
        "r",
        "p",
        "z",
        "nt2",
        "name2idx",
        "keys",
        "m",
        "name2idx",
        "nt",
        "name2idx",
        "nt2",
        "cnt",
        "nt2",
        "m",
        "name2idx",
        "ts",
        "name2idx",
        "ts",
        "numpy",
        "matrix",
        "m",
        "numpy",
        "linalg",
        "eig",
        "m",
        "m",
        "mp",
        "name2idx",
        "grammar",
        "start",
        "name2idx",
        "ts",
        "grammar",
        "branching_bound",
        "x",
        "len",
        "r",
        "r",
        "grammar",
        "len",
        "x",
        "r",
        "x",
        "grammar",
        "x",
        "x",
        "entropy",
        "grammar",
        "branching_factor",
        "grammar",
        "branching_bound",
        "random",
        "random",
        "r",
        "p",
        "random",
        "r",
        "grammar",
        "scipy",
        "optimize",
        "minimize",
        "minimize",
        "objective_function",
        "p",
        "method",
        "res",
        "success",
        "res",
        "RuntimeError",
        "r",
        "x",
        "grammar",
        "res",
        "x",
        "x",
        "grammar",
        "renormalize",
        "grammar",
        "LOTlib",
        "Examples",
        "AnBnCn",
        "Model",
        "Grammar",
        "grammar",
        "grammar",
        "maximize_entropy",
        "grammar",
        "_",
        "xrange",
        "grammar",
        "generate",
        "grammar",
        "display_rules",
        "entropy",
        "grammar",
        "branching_factor",
        "grammar",
        "pickle",
        "pickle",
        "dump",
        "grammar",
        "open"
    ],
    "literals": [
        "\"<TERMINAL>\"",
        "\"*** Terminal symbol cannot be in nonterminals!\"",
        "\"Powell\"",
        "\"Fit did not converge!\"",
        "\"__main__\"",
        "\"fit-grammar.pkl\"",
        "'w'"
    ],
    "variables": [
        "z",
        "h",
        "p",
        "nts",
        "name2idx",
        "n",
        "m",
        "z",
        "cnt",
        "m",
        "e",
        "v",
        "mp",
        "r",
        "p",
        "p",
        "res",
        "r",
        "p",
        "grammar"
    ],
    "comments": [
        "just get us out of here",
        "nt will go to each n2 how many times?",
        "terminals always go to terminals",
        "convert to a matrix or else power does not work right!",
        "add 1 to diagonal to give the total number",
        "print (m**100)[:,-1]",
        "print e",
        "print v",
        "for nt, x in zip(nts+[ts],  v[:,numpy.argmax(e)]):",
        "print \"\\t\", nt, x",
        "We really want to know how many STARTs will go to terminals",
        "A HACK",
        "Max entropy with a squared penalty on branching factor",
        "print branching_factor(grammar)",
        "Wow very sensitive to the method. Powell works well",
        "Set to the solution",
        "and renormalize it",
        "from LOTlib.Examples.Number import grammar",
        "from LOTlib.Examples.RationalRules.Model import grammar",
        "from LOTlib.Examples.Number2015.Model.Grammars import grammarnton as grammar",
        "grammar = Grammar()",
        "grammar.add_rule('START', 'f', ['WORD'], 1.0)",
        "grammar.add_rule('START', 'f', None, 2.0)",
        "grammar.add_rule('WORD',  'g', ['WORD', 'WORD'], 2.0)",
        "grammar.add_rule('WORD',  'g2', [],      1.000)",
        "print branching_factor(grammar)"
    ],
    "docstrings": [
        "\"\"\"\n    Maximize grammar entropy for constraind length\n\"\"\"",
        "\"\"\" For now, we'll maximize the entropy over each nonterminal, NOT trees \"\"\"",
        "\"\"\"\n    Returns the branching factor of the grammar.\n     # TODO: THIS DOESN'T COUNT REACHABILITY, OR BV\n    \"\"\"",
        "\"\"\"\n    Take a grammar and change it so that its parameters were maximum entropy, with the given branching bound.\n    \"\"\""
    ],
    "functions": [
        "H",
        "entropy",
        "branching_factor",
        "maximize_entropy",
        "objective_function"
    ],
    "classes": []
}