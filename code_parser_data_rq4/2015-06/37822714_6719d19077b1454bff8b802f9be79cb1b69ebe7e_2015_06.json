{
    "identifiers": [
        "p",
        "p",
        "p",
        "p",
        "path",
        "p",
        "path",
        "p",
        "p",
        "path",
        "idx",
        "components",
        "idx",
        "components",
        "idx",
        "c",
        "c",
        "absolute",
        "absolute",
        "goodComponents",
        "goodComponents",
        "goodComponents",
        "goodComponents",
        "c",
        "absolute",
        "goodComponents",
        "goodComponents",
        "goodComponents",
        "goodComponents",
        "goodComponents",
        "p",
        "goodComponents",
        "path",
        "absolute",
        "p",
        "path",
        "p",
        "path",
        "p",
        "p",
        "paths",
        "i",
        "paths",
        "i",
        "paths",
        "i",
        "segment",
        "segment",
        "segment",
        "processed",
        "segment",
        "path",
        "processed",
        "path",
        "paths",
        "i",
        "paths",
        "i",
        "paths",
        "i",
        "p",
        "p",
        "p",
        "p",
        "path",
        "processed",
        "processed",
        "p",
        "path",
        "processed",
        "path",
        "resolved",
        "resolved",
        "resolved",
        "path",
        "resolved",
        "resolved",
        "resolved",
        "path",
        "resolved",
        "resolved",
        "resolved",
        "path",
        "resolved",
        "resolved",
        "resolved",
        "process",
        "resolved",
        "resolved",
        "cwd",
        "cwd",
        "path",
        "resolved",
        "resolved",
        "cwd",
        "resolved",
        "to",
        "path",
        "to",
        "path",
        "to",
        "path",
        "to",
        "path",
        "toSegs",
        "fromSegs",
        "i",
        "i",
        "fromSegs",
        "i",
        "fromSegs",
        "i",
        "seg",
        "toSegs",
        "i",
        "upCount",
        "fromSegs",
        "i",
        "downSegs",
        "toSegs",
        "i",
        "fromSegs",
        "fromSegs",
        "upCount",
        "upCount",
        "fromSegs",
        "upCount",
        "fromSegs",
        "i",
        "i",
        "upCount",
        "i",
        "rv",
        "rv",
        "downSegs",
        "path",
        "rv",
        "rv",
        "rv",
        "path",
        "rv",
        "rv",
        "rv",
        "rv",
        "p",
        "p",
        "path",
        "p",
        "p",
        "path",
        "p",
        "path",
        "sections",
        "sections",
        "sections",
        "sections",
        "sections",
        "absolute",
        "sections",
        "path",
        "absolute",
        "path",
        "p",
        "ext",
        "p",
        "p",
        "p",
        "path",
        "p",
        "p",
        "path",
        "sections",
        "sections",
        "lastPart",
        "sections",
        "sections",
        "sections",
        "ext",
        "lastPart",
        "lastPart",
        "ext",
        "lastPartExt",
        "ext",
        "lastPart",
        "lastPart",
        "ext",
        "lastPart",
        "p",
        "p",
        "path",
        "p",
        "p",
        "path",
        "p",
        "sections",
        "p",
        "sections",
        "p",
        "sections",
        "p",
        "p",
        "i",
        "i",
        "p",
        "i",
        "p",
        "p",
        "p",
        "path",
        "p",
        "p",
        "p",
        "p",
        "p",
        "p",
        "path"
    ],
    "literals": [
        "string",
        "string",
        "''",
        "'.'",
        "string",
        "'.'",
        "'..'",
        "'..'",
        "''",
        "'.'",
        "'.'",
        "string",
        "string",
        "'string'",
        "\"Invalid argument type to path.join: \"",
        "''",
        "string",
        "string",
        "string",
        "'string'",
        "\"Invalid argument type to path.join: \"",
        "''",
        "'.'",
        "''",
        "''",
        "'/'",
        "''",
        "string",
        "string",
        "string",
        "string",
        "''",
        "''",
        "'../'",
        "string",
        "string",
        "''",
        "'.'",
        "string",
        "string",
        "\"\"",
        "string",
        "''",
        "''",
        "string",
        "string",
        "''",
        "'..'",
        "''",
        "'.'",
        "''",
        "string",
        "string",
        "string",
        "string",
        "'/'",
        "\"//+\"",
        "'g'",
        "string",
        "string",
        "':'"
    ],
    "variables": [
        "absolute",
        "components",
        "goodComponents",
        "idx",
        "c",
        "processed",
        "i",
        "segment",
        "processed",
        "i",
        "p",
        "resolved",
        "cwd",
        "i",
        "fromSegs",
        "toSegs",
        "upCount",
        "downSegs",
        "seg",
        "rv",
        "absolute",
        "sections",
        "sections",
        "lastPart",
        "lastPartExt",
        "sections",
        "i"
    ],
    "comments": [
        "<reference path=\"../typings/tsd.d.ts\" />",
        "Special case: '' -> '.'",
        "It's very important to know if the path is relative or not, since it",
        "changes how we process .. and reconstruct the split string.",
        "Remove repeated //s",
        "Try to remove as many '../' as possible, and remove '.' completely.",
        "In the absolute case: Path is relative to root, so we may pop even if",
        "goodComponents is empty (e.g. /../ => /)",
        "In the relative case: We're getting rid of a directory that preceded",
        "it (e.g. /foo/../bar -> /bar)",
        "Add in '.' when it's a relative path with no other nonempty components.",
        "Possible results: '.' and './' (input: [''] or [])",
        "@todo Can probably simplify this logic.",
        "Required: Prune any non-strings from the path. I also prune empty segments",
        "so we can do a simple join of the array.",
        "Monitor for invalid paths, throw out empty paths, and look for the *last*",
        "absolute path that we see.",
        "Remove anything that has occurred before this absolute path, as it",
        "doesn't matter.",
        "Special: Remove trailing slash unless it's the root",
        "Special: If it doesn't start with '/', it's relative and we need to append",
        "the current directory.",
        "Remove ./, since we're going to append the current directory.",
        "Append the current directory, which *must* be an absolute path.",
        "cwd will never end in a /... unless it's the root.",
        "Alright. Let's resolve these two to absolute paths and remove any",
        "weirdness.",
        "Remove the first segment on both, as it's '' (both are absolute paths)",
        "There are two segments to this path:",
        "Figure out how many things in 'from' are shared with 'to'.",
        "The rest of 'from', including the current element, indicates how many",
        "directories we need to go up.",
        "The rest of 'to' indicates where we need to change to. We place this",
        "outside of the loop, as toSegs.length may be greater than fromSegs.length.",
        "Special case: If 'from' is '/'",
        "upCount can't be greater than the number of fromSegs",
        "(cd .. from / is still /)",
        "Create the final string!",
        "Special case: Remove trailing '/'. Happens if it's all up and no down.",
        "We get rid of //, but we don't modify anything else (e.g. any extraneous .",
        "and ../ are kept intact)",
        "Do 1 if it's /foo/bar, 2 if it's /foo/bar/",
        "# of sections needs to be > 1 if absolute, since the first section is '' for '/'.",
        "If not absolute, the first section is the first part of the path, and is OK",
        "to return.",
        "Special case: Normalize will modify this to '.'",
        "Normalize the string first to remove any weirdness.",
        "Get the last part of the string.",
        "Special case: If it's empty, then we have a string like so: foo/",
        "Meaning, 'foo' is guaranteed to be a directory.",
        "Remove the extension, if need be.",
        "Special case: foo/file.ext/ should return '.ext'",
        "The platform-specific file separator. BrowserFS uses `/`.",
        "The platform-specific path delimiter. BrowserFS uses `:`."
    ],
    "docstrings": [
        "* Emulates Node's `path` module. This module contains utilities for handling and\n * transforming file paths. **All** of these methods perform only string\n * transformations. The file system is not consulted to check whether paths are\n * valid.\n * @see http://nodejs.org/api/path.html\n * @class",
        "* Normalize a string path, taking care of '..' and '.' parts.\n   *\n   * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\n   * @example Usage example\n   *   path.normalize('/foo/bar//baz/asdf/quux/..')\n   *   // returns\n   *   '/foo/bar/baz/asdf'\n   * @param {String} p The path to normalize.\n   * @return {String}",
        "* Join all arguments together and normalize the resulting path.\n   *\n   * Arguments must be strings.\n   * @example Usage\n   *   path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\n   *   // returns\n   *   '/foo/bar/baz/asdf'\n   *\n   *   path.join('foo', {}, 'bar')\n   *   // throws exception\n   *   TypeError: Arguments to path.join must be strings\n   * @param [String,...] paths Each component of the path\n   * @return [String]",
        "* Resolves to to an absolute path.\n   *\n   * If to isn't already absolute from arguments are prepended in right to left\n   * order, until an absolute path is found. If after using all from paths still\n   * no absolute path is found, the current working directory is used as well.\n   * The resulting path is normalized, and trailing slashes are removed unless\n   * the path gets resolved to the root directory. Non-string arguments are\n   * ignored.\n   *\n   * Another way to think of it is as a sequence of cd commands in a shell.\n   *\n   *     path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\n   *\n   * Is similar to:\n   *\n   *     cd foo/bar\n   *     cd /tmp/file/\n   *     cd ..\n   *     cd a/../subfile\n   *     pwd\n   *\n   * The difference is that the different paths don't need to exist and may also\n   * be files.\n   * @example Usage example\n   *   path.resolve('/foo/bar', './baz')\n   *   // returns\n   *   '/foo/bar/baz'\n   *\n   *   path.resolve('/foo/bar', '/tmp/file/')\n   *   // returns\n   *   '/tmp/file'\n   *\n   *   path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\n   *   // if currently in /home/myself/node, it returns\n   *   '/home/myself/node/wwwroot/static_files/gif/image.gif'\n   * @param [String,...] paths\n   * @return [String]",
        "* Solve the relative path from from to to.\n   *\n   * At times we have two absolute paths, and we need to derive the relative path\n   * from one to the other. This is actually the reverse transform of\n   * path.resolve, which means we see that:\n   *\n   *    path.resolve(from, path.relative(from, to)) == path.resolve(to)\n   *\n   * @example Usage example\n   *   path.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\n   *   // returns\n   *   '..\\\\..\\\\impl\\\\bbb'\n   *\n   *   path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\n   *   // returns\n   *   '../../impl/bbb'\n   * @param {String} from\n   * @param {String} to\n   * @return [String]",
        "* Going *up* the directory hierarchy with '..'",
        "* Going *down* the directory hierarchy with foo/baz/bat.",
        "* Return the directory name of a path. Similar to the Unix `dirname` command.\n   *\n   * Note that BrowserFS does not validate if the path is actually a valid\n   * directory.\n   * @example Usage example\n   *   path.dirname('/foo/bar/baz/asdf/quux')\n   *   // returns\n   *   '/foo/bar/baz/asdf'\n   * @param [String] p The path to get the directory name of.\n   * @return [String]",
        "* Return the last portion of a path. Similar to the Unix basename command.\n   * @example Usage example\n   *   path.basename('/foo/bar/baz/asdf/quux.html')\n   *   // returns\n   *   'quux.html'\n   *\n   *   path.basename('/foo/bar/baz/asdf/quux.html', '.html')\n   *   // returns\n   *   'quux'\n   * @param [String] p\n   * @param [String?] ext\n   * @return [String]",
        "* Return the extension of the path, from the last '.' to end of string in the\n   * last portion of the path. If there is no '.' in the last portion of the path\n   * or the first character of it is '.', then it returns an empty string.\n   * @example Usage example\n   *   path.extname('index.html')\n   *   // returns\n   *   '.html'\n   *\n   *   path.extname('index.')\n   *   // returns\n   *   '.'\n   *\n   *   path.extname('index')\n   *   // returns\n   *   ''\n   * @param [String] p\n   * @return [String]",
        "* Checks if the given path is an absolute path.\n   *\n   * Despite not being documented, this is a tested part of Node's path API.\n   * @param [String] p\n   * @return [Boolean] True if the path appears to be an absolute path.",
        "* Unknown. Undocumented."
    ],
    "functions": [
        "normalize",
        "join",
        "resolve",
        "relative",
        "dirname",
        "basename",
        "extname",
        "isAbsolute",
        "_makeLong",
        "_removeDuplicateSeps"
    ],
    "classes": [
        "path"
    ]
}