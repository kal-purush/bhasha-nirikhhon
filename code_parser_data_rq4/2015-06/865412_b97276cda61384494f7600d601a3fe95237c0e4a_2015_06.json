{
    "identifiers": [
        "net",
        "opentsdb",
        "query",
        "java",
        "lang",
        "reflect",
        "Constructor",
        "java",
        "lang",
        "reflect",
        "Field",
        "java",
        "lang",
        "reflect",
        "InvocationTargetException",
        "java",
        "lang",
        "reflect",
        "Method",
        "java",
        "util",
        "java",
        "util",
        "Collections",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "com",
        "fasterxml",
        "jackson",
        "annotation",
        "JsonProperty",
        "org",
        "hbase",
        "async",
        "Bytes",
        "org",
        "slf4j",
        "Logger",
        "org",
        "slf4j",
        "LoggerFactory",
        "net",
        "opentsdb",
        "core",
        "TSDB",
        "net",
        "opentsdb",
        "uid",
        "UniqueId",
        "UniqueIdType",
        "net",
        "opentsdb",
        "utils",
        "Config",
        "net",
        "opentsdb",
        "utils",
        "Pair",
        "net",
        "opentsdb",
        "utils",
        "PluginLoader",
        "com",
        "fasterxml",
        "jackson",
        "annotation",
        "JsonIgnore",
        "com",
        "fasterxml",
        "jackson",
        "databind",
        "annotation",
        "JsonDeserialize",
        "com",
        "fasterxml",
        "jackson",
        "databind",
        "annotation",
        "JsonPOJOBuilder",
        "com",
        "stumbleupon",
        "async",
        "Callback",
        "com",
        "stumbleupon",
        "async",
        "Deferred",
        "JsonDeserialize",
        "builder",
        "LOG",
        "LoggerFactory",
        "getLogger",
        "tagv_filter_map",
        "tagv_filter_map",
        "put",
        "TagVLiteralOrFilter",
        "FILTER_NAME",
        "getDeclaredConstructor",
        "tagv_filter_map",
        "put",
        "TagVLiteralOrFilter",
        "TagVILiteralOrFilter",
        "FILTER_NAME",
        "getDeclaredConstructor",
        "tagv_filter_map",
        "put",
        "TagVNotLiteralOrFilter",
        "FILTER_NAME",
        "getDeclaredConstructor",
        "tagv_filter_map",
        "put",
        "TagVNotLiteralOrFilter",
        "TagVNotILiteralOrFilter",
        "FILTER_NAME",
        "getDeclaredConstructor",
        "tagv_filter_map",
        "put",
        "TagVRegexFilter",
        "FILTER_NAME",
        "getDeclaredConstructor",
        "tagv_filter_map",
        "put",
        "TagVWildcardFilter",
        "FILTER_NAME",
        "getDeclaredConstructor",
        "tagv_filter_map",
        "put",
        "TagVWildcardFilter",
        "TagVIWildcardFilter",
        "FILTER_NAME",
        "getDeclaredConstructor",
        "tagv_filter_map",
        "put",
        "TagVNotKeyFilter",
        "FILTER_NAME",
        "getDeclaredConstructor",
        "e",
        "e",
        "e",
        "e",
        "tagk",
        "tagk_bytes",
        "tagv_uids",
        "JsonProperty",
        "group_by",
        "not_key",
        "post_scan",
        "tagk",
        "tagk",
        "tagk",
        "tagk",
        "tagk",
        "tagk",
        "isEmpty",
        "tags",
        "JsonIgnore",
        "Override",
        "buf",
        "buf",
        "append",
        "append",
        "getType",
        "append",
        "append",
        "tagk",
        "append",
        "append",
        "group_by",
        "append",
        "append",
        "Bytes",
        "pretty",
        "tagk_bytes",
        "append",
        "append",
        "debugInfo",
        "buf",
        "toString",
        "tagk",
        "tagk",
        "tagk",
        "isEmpty",
        "isEmpty",
        "length",
        "charAt",
        "paren",
        "indexOf",
        "paren",
        "prefix",
        "substring",
        "paren",
        "toLowerCase",
        "withTagk",
        "tagk",
        "withFilter",
        "stripParentheses",
        "withType",
        "prefix",
        "build",
        "contains",
        "tagk",
        "isEmpty",
        "charAt",
        "length",
        "start_pos",
        "indexOf",
        "start_pos",
        "substring",
        "start_pos",
        "length",
        "filter_plugins",
        "PluginLoader",
        "loadPlugins",
        "filter_plugins",
        "filter_plugins",
        "getClass",
        "getDeclaredMethod",
        "getClass",
        "getDeclaredMethod",
        "getClass",
        "getDeclaredField",
        "ctor",
        "getClass",
        "getDeclaredConstructor",
        "existing",
        "tagv_filter_map",
        "get",
        "getType",
        "getValue",
        "existing",
        "LOG",
        "warn",
        "existing",
        "getClass",
        "getCanonicalName",
        "getClass",
        "getCanonicalName",
        "tagv_filter_map",
        "put",
        "getType",
        "toLowerCase",
        "getClass",
        "ctor",
        "LOG",
        "info",
        "tagv_filter_map",
        "size",
        "tags",
        "filters",
        "tags",
        "tags",
        "isEmpty",
        "entry",
        "tags",
        "entrySet",
        "getFilter",
        "entry",
        "getKey",
        "entry",
        "getValue",
        "entry",
        "getValue",
        "equals",
        "entry",
        "getKey",
        "entry",
        "getKey",
        "entry",
        "getValue",
        "setGroupBy",
        "duplicate",
        "existing",
        "filters",
        "equals",
        "existing",
        "LOG",
        "debug",
        "existing",
        "existing",
        "setGroupBy",
        "duplicate",
        "duplicate",
        "filters",
        "add",
        "filters",
        "tagv_filter_map",
        "size",
        "pair",
        "tagv_filter_map",
        "values",
        "filter_meta",
        "method",
        "pair",
        "getKey",
        "getDeclaredMethod",
        "filter_meta",
        "put",
        "method",
        "invoke",
        "method",
        "pair",
        "getKey",
        "getDeclaredMethod",
        "filter_meta",
        "put",
        "method",
        "invoke",
        "filter_name",
        "pair",
        "getKey",
        "getDeclaredField",
        "filters",
        "put",
        "filter_name",
        "get",
        "filter_meta",
        "e",
        "e",
        "e",
        "LOG",
        "error",
        "pair",
        "getClass",
        "getCanonicalName",
        "e",
        "LOG",
        "error",
        "pair",
        "getClass",
        "getCanonicalName",
        "e",
        "e",
        "e",
        "e",
        "e",
        "e",
        "filters",
        "tsdb",
        "Override",
        "uid",
        "tagk_bytes",
        "uid",
        "uid",
        "tsdb",
        "getUIDAsync",
        "UniqueIdType",
        "TAGK",
        "tagk",
        "addCallback",
        "tsdb",
        "literals",
        "config",
        "tsdb",
        "getConfig",
        "Override",
        "e",
        "config",
        "getBoolean",
        "LOG",
        "warn",
        "e",
        "getMessage",
        "e",
        "Override",
        "results",
        "tagv_uids",
        "results",
        "size",
        "tagv",
        "results",
        "tagv",
        "tagv_uids",
        "add",
        "tagv",
        "Collections",
        "sort",
        "tagv_uids",
        "Bytes",
        "MEMCMP",
        "tagk_bytes",
        "Override",
        "uid",
        "tagk_bytes",
        "uid",
        "tagvs",
        "literals",
        "size",
        "tagv",
        "literals",
        "tagvs",
        "add",
        "tsdb",
        "getUIDAsync",
        "UniqueIdType",
        "TAGV",
        "tagv",
        "addErrback",
        "tagvs",
        "add",
        "tsdb",
        "getUIDAsync",
        "UniqueIdType",
        "TAGK",
        "tagk",
        "addCallback",
        "Deferred",
        "group",
        "tagvs",
        "addCallback",
        "tagk",
        "JsonIgnore",
        "tagk_bytes",
        "JsonIgnore",
        "tagv_uids",
        "Collections",
        "emptyList",
        "tagv_uids",
        "JsonIgnore",
        "group_by",
        "group_by",
        "group_by",
        "group_by",
        "JsonIgnore",
        "getClass",
        "getSimpleName",
        "not_key",
        "post_scan",
        "post_scan",
        "post_scan",
        "post_scan",
        "JsonIgnore",
        "not_key",
        "Override",
        "Bytes",
        "memcmpMaybeNull",
        "tagk_bytes",
        "tagk_bytes",
        "JsonPOJOBuilder",
        "tagk",
        "JsonProperty",
        "group_by",
        "tagk",
        "tagk",
        "tagk",
        "group_by",
        "group_by",
        "group_by",
        "isEmpty",
        "tagk",
        "tagk",
        "isEmpty",
        "filter_meta",
        "tagv_filter_map",
        "get",
        "filter_meta",
        "ctor",
        "filter_meta",
        "getValue",
        "tagv_filter",
        "tagv_filter",
        "ctor",
        "newInstance",
        "tagk",
        "e",
        "e",
        "e",
        "e",
        "e",
        "e",
        "e",
        "e",
        "getCause",
        "e",
        "getCause",
        "e",
        "tagv_filter",
        "setGroupBy",
        "group_by",
        "tagv_filter"
    ],
    "literals": [
        "\"Failed to load a tag value filter\"",
        "\"Failed to load a tag value filter\"",
        "\"Filter must have a tagk\"",
        "\"filter_name=\"",
        "\", tagk=\"",
        "\", group_by=\"",
        "\", tagk_bytes=\"",
        "\", config=\"",
        "\"Tagk cannot be null or empty\"",
        "\"Filter cannot be null or empty\"",
        "\"*\"",
        "\"Filter string cannot be null or empty\"",
        "\"Filter must end with a ')': \"",
        "\"Filter must include a '(': \"",
        "\"description\"",
        "\"examples\"",
        "\"FILTER_NAME\"",
        "\"Overloading existing filter \"",
        "\" with new filter \"",
        "\"Loaded \"",
        "\" filters\"",
        "\"*\"",
        "\"*\"",
        "\"Skipping duplicate filter: \"",
        "\"description\"",
        "\"description\"",
        "\"examples\"",
        "\"examples\"",
        "\"FILTER_NAME\"",
        "\"Unexpected security exception\"",
        "\"Filter plugin \"",
        "\" did not implement one of the \\\"description\\\" or \\\"examples\\\" methods\"",
        "\"Filter plugin \"",
        "\" did not have the \\\"FILTER_NAME\\\" field\"",
        "\"Unexpected exception\"",
        "\"Unexpected security exception\"",
        "\"Unexpected security exception\"",
        "\"tsd.query.skip_unresolved_tagvs\"",
        "\"Query tag value not found: \"",
        "\"The filter type cannot be null or empty\"",
        "\"The tagk cannot be null or empty\"",
        "\"Could not find a tag value filter of the type: \"",
        "\"Failed to instantiate filter: \"",
        "\"Failed to instantiate filter: \"",
        "\"Failed to instantiate filter: \""
    ],
    "variables": [
        "tagk",
        "filter",
        "tagk_bytes",
        "tagv_uids",
        "group_by",
        "not_key",
        "type",
        "tagk",
        "filter",
        "group_by",
        "tagv_filter"
    ],
    "comments": [
        "This file is part of OpenTSDB.",
        "Copyright (C) 2015  The OpenTSDB Authors.",
        "",
        "This program is free software: you can redistribute it and/or modify it",
        "under the terms of the GNU Lesser General Public License as published by",
        "the Free Software Foundation, either version 2.1 of the License, or (at your",
        "option) any later version.  This program is distributed in the hope that it",
        "will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty",
        "of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser",
        "General Public License for more details.  You should have received a copy",
        "of the GNU Lesser General Public License along with this program.  If not,",
        "see <http://www.gnu.org/licenses/>.",
        "group by filter",
        "a shortcut for wildcards since we don't allow asterisks to be stored",
        "in strings at this time.",
        "likely a literal or unknown",
        "validate required fields and methods",
        "ugly hack to resolve the tagk UID. The callback will return null and we'll",
        "remove it from the UID list."
    ],
    "docstrings": [
        "* A base class for tag value filters that may execute against rows that\n * come out of a scanner to determine if we should include them in the results\n * or not. The filters should be prefixed with something to differentiate them\n * from literal values.\n * \n * Every filter must be associated with a tag key. During scanning, each time\n * a new TSUID is encountered, the map will be passed to {@link match} for\n * matching.\n * \n * Plugins implementing the filter must include the following:\n * \n * - {@code public static final String FILTER_NAME;} \n *   A short, unique name without spaces or odd characters that is used to \n *   invoke the filter.\n * - {@code public static String description();} \n *   A method that returns a description of what the filter does.\n * - {@code public static String examples();}\n *   A method that returns a string with some examples of how to use the filter.\n * \n * This class also contains the list of configured filters as well as a method\n * to load filters from plugin Jars.\n * @since 2.2",
        "A map of configured filters for use in querying",
        "The tag key this filter is associated with",
        "The raw, unparsed filter",
        "The tag key converted into a UID",
        "An optional list of tag value UIDs if the filter matches on literals.",
        "Whether or not to also group by this filter",
        "Flag the implementation can set to tell the scanner to pick up rows that \n   * DON'T have the given tagk (regardless of value)",
        "A flag to indicate whether or not we need to execute a post-scan lookup",
        "* Default Ctor needed for the service loader. Implementations must override\n   * and set the filterName().",
        "* The ctor that validates we have a good tag key to work with\n   * @param tagk The tag key to associate with this filter\n   * @param filter The unparsed filter\n   * @throws IlleglArgumentException if the tag was empty or null.",
        "* Looks up the tag key in the given map and determines if the filter matches\n   * or not. If the tag key doesn't exist in the tag map, then the match fails.\n   * @param tags The tag map to use for looking up the value for the tagk \n   * @return True if the tag value matches, false if it doesn't.",
        "* The name of this filter as used in queries. When used in URL queries the\n   * value will be in parentheses, e.g. filter(<exp>)\n   * The name will also be lowercased before storing it in the lookup map.\n   * @return The name of the filter.",
        "* A simple string of the filter settings for printing in toString() calls.\n   * @return A string with the format \"{settings=<val>, ...}\"",
        "* Parses the tag value and determines if it's a group by, a literal or a filter.\n   * @param tagk The tag key associated with this value\n   * @param filter The tag value, possibly a filter\n   * @return Null if the value was a group by or a literal, a valid filter object\n   * if it looked to be a filter.\n   * @throws IllegalArgumentException if the tag key or filter was null, empty\n   * or if the filter was malformed, e.g. a bad regular expression.",
        "* Helper to strip parentheses from a filter name passed in over a URL\n   * or JSON. E.g. \"regexp(foo.*)\" returns \"foo.*\".\n   * @param filter The filter string to parse\n   * @return The filter value minus the surrounding name and parens.",
        "* Loads plugins from the plugin directory and \n   * @throws ClassNotFoundException If we found a class that we didn't... find?\n   * @throws NoSuchMethodException If the discovered plugin didn't have the\n   *         proper (tagk, filter) ctor",
        "* Converts the tag map to a filter list. If a filter already exists for a\n   * tag group by, then the duplicate is skipped. \n   * @param tags A set of tag keys and values. May be null or empty.\n   * @param filters A set of filters to add the converted filters to. This may\n   * not be null.",
        "* Runs through the loaded plugin map and dumps the names, description and\n   * examples into a map to serialize via the API.\n   * @return A map of filter meta data.",
        "* Asynchronously resolves the tagk name to it's UID. On a successful lookup\n   * the {@link tagk_bytes} will be set.\n   * @param tsdb The TSDB to use for the lookup\n   * @return A deferred to let the caller know that the lookup was completed.\n   * The value will be the tag UID (unless it's an exception of course)",
        "* Resolves both the tagk to it's UID and a list of literal tag values to\n   * their UIDs. A filter may match a literal set (e.g. the pipe filter) in which\n   * case we can build the row key scanner with these values.\n   * Note that if \"tsd.query.skip_unresolved_tagvs\" is set in the config then\n   * any tag value UIDs that couldn't be found will be excluded.\n   * @param tsdb The TSDB to use for the lookup\n   * @param literals The list of unique strings to lookup\n   * @return A deferred to let the caller know that the lookup was completed.\n   * The value will be the tag UID (unless it's an exception of course)",
        "* Allows the filter to avoid killing the entire query when we can't resolve\n     * a tag value to a UID.",
        "* Stores the non-null UIDs in the local list and then sorts them in\n     * prep for use in the regex filter",
        "* Super simple callback to set the local tagk and returns null so it won't\n     * be included in the tag value UID lookups.",
        "@return the tag key associated with this filter",
        "@return the tag key UID associated with this filter. \n   * Call {@link resolveName} first",
        "@return whether or not to group by the results of this filter",
        "@param group_by Wether or not to group by the results of this filter",
        "@return the simple class name of this filter",
        "@return Whether or not this filter should be executed against scan results",
        "@param post_scan Whether or not this filter should be executed against \n   * scan results",
        "* Builder class used for deserializing filters from JSON queries via Jackson\n   * since we don't want the user to worry about the class name. The type,\n   * tagk and filter must be configured or the build will fail.",
        "@param type The type of filter matching a valid filter name",
        "@param tagk The tag key to match on for this filter",
        "@param filter The filter expression to use for matching",
        "@param group_by Whether or not the filter should group results",
        "* Searches the filter map for the given type and returns an instantiated\n     * filter if found. The caller must set the type, tagk and filter values.\n     * @return A filter if instantiation was successful\n     * @throws IllegalArgumentException if one of the required parameters was\n     * not set or the filter couldn't be found.\n     * @throws RuntimeException if the filter couldn't be instantiated. Check\n     * the implementation if it's a plugin."
    ],
    "functions": [
        "TagVFilter",
        "TagVFilter",
        "match",
        "getType",
        "debugInfo",
        "toString",
        "TagVFilter",
        "getFilter",
        "stripParentheses",
        "initializeFilterMap",
        "tagsToFilters",
        "loadedFilters",
        "resolveTagkName",
        "call",
        "resolveTags",
        "call",
        "call",
        "call",
        "getTagk",
        "getTagkBytes",
        "getTagVUids",
        "isGroupBy",
        "setGroupBy",
        "getFilter",
        "getName",
        "postScan",
        "setPostScan",
        "isNotKeyFilter",
        "compareTo",
        "Builder",
        "withType",
        "Builder",
        "withTagk",
        "Builder",
        "withFilter",
        "Builder",
        "withGroupBy",
        "TagVFilter",
        "build"
    ],
    "classes": [
        "TagVFilter",
        "ResolvedCB",
        "TagVErrback",
        "ResolvedTagVCB",
        "ResolvedTagKCB",
        "Builder"
    ]
}