{
    "identifiers": [
        "ChangeDetector",
        "cd",
        "cd",
        "throwOnChange",
        "cd",
        "cd",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "value",
        "obj",
        "callback",
        "callback",
        "newList",
        "parent",
        "distanceToParent",
        "protoElementInjector",
        "componentDirective",
        "eventBindings",
        "boundElementIndex",
        "directiveIndex",
        "elementIndex",
        "actionExpression",
        "action",
        "elementIndex",
        "eventName",
        "locals",
        "directive",
        "directive",
        "changeDetector",
        "elementInjectors",
        "rootElementInjectors",
        "preBuiltObjects",
        "componentChildViews",
        "b",
        "currentValue",
        "contextName",
        "value",
        "eventName",
        "eventObj",
        "binderIndex",
        "DependencyAnnotation",
        "viewContainerLocation",
        "atIndex",
        "viewRef",
        "hostLocation",
        "componentProtoViewRef",
        "componentBinding",
        "injector",
        "location",
        "protoViewRef",
        "injector",
        "parentComponentLocation",
        "hostProtoViewRef",
        "injector",
        "hostProtoViewRef",
        "overrideSelector",
        "injector",
        "viewContainerLocation",
        "atIndex",
        "protoViewRef",
        "context",
        "injector",
        "location",
        "viewRef",
        "parentComponentLocation",
        "hostViewRef",
        "hostViewRef",
        "viewContainerLocation",
        "atIndex",
        "viewContainerLocation",
        "atIndex",
        "hostLocation",
        "hostLocation",
        "location",
        "generator",
        "Observable",
        "value",
        "generator",
        "value",
        "error",
        "Rx",
        "Renderer",
        "hostViewRef",
        "elementIndex",
        "componentViewRef",
        "parentViewRef",
        "boundElementIndex",
        "atIndex",
        "viewRef",
        "viewRef",
        "elementIndex",
        "actionExpression",
        "actionArgs",
        "hostProtoViewRef",
        "hostElementSelector",
        "protoViewRef",
        "viewRef",
        "view",
        "hostViewRef",
        "boundElementIndex",
        "componentViewRef",
        "viewRef",
        "parentViewRef",
        "boundElementIndex",
        "atIndex",
        "viewRef",
        "viewRef",
        "viewRef",
        "componentViewRef",
        "rootNodes",
        "viewRef",
        "elementIndex",
        "propertyName",
        "propertyValue",
        "viewRef",
        "dispatcher",
        "viewRef",
        "textNodeIndex",
        "text",
        "AST",
        "context",
        "locals",
        "value",
        "context",
        "locals",
        "visitor",
        "context",
        "locals",
        "value",
        "context",
        "locals",
        "visitor",
        "ast",
        "asts",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "AST",
        "context",
        "locals",
        "value",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "text",
        "bindingAst",
        "pipes",
        "input",
        "location",
        "input",
        "location",
        "input",
        "location",
        "input",
        "location",
        "input",
        "location",
        "name",
        "name",
        "name",
        "value",
        "dispatcher",
        "bindingRecord",
        "value",
        "cd",
        "cd",
        "context",
        "locals",
        "directives",
        "cd",
        "cd",
        "definition",
        "ProtoChangeDetector",
        "dispatcher",
        "ProtoChangeDetector",
        "dispatcher",
        "AbstractChangeDetector",
        "throwOnChange",
        "context",
        "locals",
        "directives",
        "obj",
        "cdRef",
        "obj",
        "value",
        "cdRef",
        "obs",
        "Pipe",
        "obj",
        "value",
        "PipeFactory",
        "cdRef",
        "obj",
        "ChangeDetection",
        "definition",
        "ChangeDetection",
        "definition",
        "ChangeDetection",
        "definition",
        "contextName",
        "value",
        "protoViewRef",
        "atIndex",
        "context",
        "injector",
        "atIndex",
        "index",
        "viewRef",
        "viewRef",
        "atIndex",
        "atIndex",
        "name",
        "arg",
        "fn",
        "fn",
        "Visibility",
        "Visibility",
        "Visibility",
        "Visibility",
        "View",
        "arg",
        "target",
        "bootstrap",
        "appComponentType",
        "componentInjectableBindings",
        "errorReporter",
        "DependencyAnnotation",
        "DependencyAnnotation",
        "component",
        "component",
        "protoView",
        "component",
        "componentTypeOrBinding",
        "changes",
        "BaseQueryList",
        "callback",
        "callback",
        "typeOrBinding",
        "overrideSelector",
        "injector",
        "typeOrBinding",
        "location",
        "injector",
        "typeOrBinding",
        "parentComponentLocation",
        "injector",
        "typeOrBinding",
        "location",
        "injector",
        "Component",
        "arg",
        "target",
        "DirectiveAnnotation",
        "Directive",
        "arg",
        "target",
        "Injectable",
        "view",
        "record",
        "isControl",
        "c",
        "arg",
        "parent",
        "arg",
        "arg",
        "AbstractControl",
        "fn",
        "value",
        "arg",
        "AbstractControl",
        "name",
        "c",
        "controlName",
        "controlName",
        "path",
        "controlName",
        "name",
        "AbstractControl",
        "index",
        "index",
        "control",
        "control",
        "index",
        "ControlDirective",
        "c",
        "newValue",
        "ControlDirective",
        "c",
        "newValue",
        "ControlDirective",
        "c",
        "newValue",
        "newValue",
        "ControlContainerDirective",
        "ControlContainerDirective",
        "dir",
        "dir",
        "dir",
        "_",
        "dir",
        "dir",
        "dir",
        "value",
        "ControlContainerDirective",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "value",
        "fn",
        "fn",
        "obj",
        "fn",
        "fn",
        "value",
        "fn",
        "fn",
        "value",
        "fn",
        "fn",
        "value",
        "controlsConfig",
        "validator",
        "value",
        "validator",
        "controlsConfig",
        "extra",
        "resolveBindings",
        "bindings",
        "token",
        "bindings",
        "token",
        "token",
        "bindings",
        "aliasToken",
        "factoryFunction",
        "dependencies",
        "factoryFunction",
        "dependencies",
        "value",
        "bind",
        "token",
        "token",
        "AbstractBindingError",
        "key",
        "AbstractBindingError",
        "AbstractBindingError",
        "AbstractBindingError",
        "forwardRef",
        "forwardRefFn",
        "resolveForwardRef",
        "template",
        "directiveMetadata",
        "hostViewRef",
        "elementIndex",
        "componentViewRef",
        "parentViewRef",
        "boundElementIndex",
        "atIndex",
        "viewRef",
        "viewRef",
        "elementIndex",
        "actionExpression",
        "actionArgs",
        "hostProtoViewRef",
        "hostElementSelector",
        "protoViewRef",
        "viewRef",
        "viewRef",
        "hostViewRef",
        "boundElementIndex",
        "componentViewRef",
        "view",
        "parentViewRef",
        "boundElementIndex",
        "atIndex",
        "viewRef",
        "viewRef",
        "viewRef",
        "elementIndex",
        "propertyName",
        "propertyValue",
        "viewRef",
        "dispatcher",
        "viewRef",
        "textNodeIndex",
        "text",
        "elementIndex",
        "eventName",
        "locals",
        "child",
        "child",
        "prevSibling",
        "Dependency",
        "DependencyWithVisibility",
        "ResolvedBinding",
        "view",
        "boundElementIndex",
        "directive",
        "view",
        "boundElementIndex",
        "directive",
        "index",
        "parent",
        "TreeNode",
        "componentDirective",
        "parentInjector",
        "token",
        "index",
        "injector",
        "host",
        "preBuiltObjects",
        "parent",
        "parent",
        "prevSibling",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "value",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "AST",
        "context",
        "locals",
        "visitor",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast",
        "ast"
    ],
    "literals": [
        "\"angular2/angular2\"",
        "string",
        "\"angular2/angular2\"",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string"
    ],
    "variables": [
        "DOCUMENT_TOKEN",
        "CHECK_ONCE",
        "CHECK_ALWAYS",
        "DETACHED",
        "CHECKED",
        "ON_PUSH",
        "DEFAULT",
        "uninitialized",
        "defaultPipes",
        "preGeneratedProtoDetectors",
        "defaultPipeRegistry",
        "appComponentRefToken",
        "appComponentTypeToken",
        "onDestroy",
        "onChange",
        "onCheck",
        "onInit",
        "onAllChangesDone",
        "Self",
        "Parent",
        "Ancestor",
        "Unbounded",
        "Attribute",
        "Query",
        "coreDirectives",
        "VALID",
        "INVALID",
        "formDirectives",
        "Inject",
        "InjectPromise",
        "InjectLazy",
        "Optional",
        "FORWARD_REF"
    ],
    "comments": [
        "Type definitions for Angular v2.0.0-alpha.26",
        "Project: http://angular.io/",
        "Definitions by: angular team <https://github.com/angular/>",
        "Definitions: https://github.com/borisyankov/DefinitelyTyped",
        "This file is generated by the Angular build process.",
        "Please do not create manual edits or send pull requests",
        "modifying this file.",
        "Angular depends transitively on these libraries.",
        "If you don't have them installed you can run",
        "$ tsd query es6-promise rx rx-lite --action install --save",
        "<reference path=\"../es6-promise/es6-promise.d.ts\"/>",
        "<reference path=\"../rx/rx.d.ts\"/>",
        "See https://github.com/Microsoft/TypeScript/issues/1168",
        "extends Error",
        "node",
        "node",
        "() => void",
        "() => void",
        "(error, stack) => void",
        "TODO(tbosch): use Type | Binding | List<any> when Dart supports union types,",
        "as otherwise we would need to import Binding type and Dart would warn",
        "for an unused import."
    ],
    "docstrings": [
        "***********************************************************",
        "***********************************************************",
        "* A directive that contains a group of [ControlDirective].\n   * \n   * @exportedAs angular2/forms",
        "* A marker annotation that marks a class as available to `Injector` for creation. Used by tooling\n   * for generating constructor stubs.\n   * \n   * ```\n   * class NeedsService {\n   *   constructor(svc:UsefulService) {}\n   * }\n   * \n   * @Injectable\n   * class UsefulService {}\n   * ```\n   * @exportedAs angular2/di_annotations",
        "* Injectable Objects that contains a live list of child directives in the light Dom of a directive.\n   * The directives are kept in depth-first pre-order traversal of the DOM.\n   * \n   * In the future this class will implement an Observable interface.\n   * For now it uses a plain list of observable callbacks.\n   * \n   * @exportedAs angular2/view",
        "* Adds an event binding for the last created ElementBinder via bindElement.\n     * \n     * If the directive index is a positive integer, the event is evaluated in the context of\n     * the given directive.\n     * \n     * If the directive index is -1, the event is evaluated in the context of the enclosing view.\n     * \n     * @param {string} eventName\n     * @param {AST} expression\n     * @param {int} directiveIndex The directive index in the binder or -1 when the event is not bound\n     *                             to a directive",
        "* Const of making objects: http://jsperf.com/instantiate-size-of-object",
        "* The context against which data-binding expressions in this view are evaluated against.\n     * This is always a component instance.",
        "* Variables, local to this view, that can be used in binding expressions (in addition to the\n     * context). This is used for thing like `<video #player>` or\n     * `<li template=\"for #item of items\">`, where \"player\" and \"item\" are locals, respectively.",
        "* Triggers the event handlers for the element and the directives.\n     * \n     * This method is intended to be called from directive EventEmitters.\n     * \n     * @param {string} eventName\n     * @param {*} eventObj\n     * @param {int} binderIndex",
        "* Entry point for creating, moving views in the view hierarchy and destroying views.\n   * This manager contains all recursion and delegates to helper methods\n   * in AppViewManagerUtils and the Renderer, so unit tests get simpler.",
        "* Use Rx.Observable but provides an adapter to make it work as specified here:\n   * https://github.com/jhusain/observable-spec\n   * \n   * Once a reference implementation of the spec is available, switch to it.",
        "* Interface used by Angular to control the change detection strategy for an application.\n   * \n   * Angular implements the following change detection strategies by default:\n   * \n   * - <a href='DynamicChangeDetection'>DynamicChangeDetection</a>: slower, but does not require `eval()`.\n   * - <a href='JitChangeDetection'>JitChangeDetection</a>: faster, but requires `eval()`.\n   * \n   * In JavaScript, you should always use `JitChangeDetection`, unless you are in an environment that\n   * has\n   * [CSP](https://developer.mozilla.org/en-US/docs/Web/Security/CSP), such as a Chrome Extension.\n   * \n   * In Dart, use `DynamicChangeDetection` during development. The Angular transformer generates an\n   * analog to the\n   * `JitChangeDetection` strategy at compile time.\n   * \n   * \n   * See: <a href='DynamicChangeDetection'>DynamicChangeDetection</a>, <a href='JitChangeDetection'>JitChangeDetection</a>\n   * \n   * # Example\n   * ```javascript\n   * bootstrap(MyApp, [bind(ChangeDetection).toClass(DynamicChangeDetection)]);\n   * ```\n   * @exportedAs angular2/change_detection",
        "* CHECK_ONCE means that after calling detectChanges the mode of the change detector\n   * will become CHECKED.",
        "* CHECK_ALWAYS means that after calling detectChanges the mode of the change detector\n   * will remain CHECK_ALWAYS.",
        "* DETACHED means that the change detector sub tree is not a part of the main tree and\n   * should be skipped.",
        "* CHECKED means that the change detector should be skipped until its mode changes to\n   * CHECK_ONCE or CHECK_ALWAYS.",
        "* ON_PUSH means that the change detector's mode will be set to CHECK_ONCE during hydration.",
        "* DEFAULT means that the change detector's mode will be set to CHECK_ALWAYS during hydration.",
        "* Controls change detection.\n   * \n   * <a href='/angular2/angular2/ChangeDetectorRef'><code>ChangeDetectorRef</code></a> allows requesting checks for detectors that rely on observables. It\n   * also allows detaching and\n   * attaching change detector subtrees.\n   * \n   * @exportedAs angular2/change_detection",
        "* Detaches the change detector from the change detector tree.\n     * \n     * The detached change detector will not be checked until it is reattached.",
        "* Reattach the change detector to the change detector tree.\n     * \n     * This also requests a check of this change detector. This reattached change detector will be\n     * checked during the\n     * next change detection run.",
        "* Request to check all ON_PUSH ancestors.",
        "* Indicates that the result of a <a href='/angular2/angular2/Pipe'><code>Pipe</code></a> transformation has changed even though the reference\n   * has not changed.\n   * \n   * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.\n   * \n   * @exportedAs angular2/pipes",
        "* An interface for extending the list of pipes known to Angular.\n   * \n   * If you are writing a custom <a href='/angular2/angular2/Pipe'><code>Pipe</code></a>, you must extend this interface.\n   * \n   * #Example\n   * \n   * ```\n   * class DoublePipe extends Pipe {\n   *  supports(obj) {\n   *    return true;\n   *  }\n   * \n   *  transform(value) {\n   *    return `${value}${value}`;\n   *  }\n   * }\n   * ```\n   * \n   * @exportedAs angular2/pipes",
        "* @exportedAs angular2/pipes",
        "* @exportedAs angular2/pipes",
        "* Implements change detection that does not require `eval()`.\n   * \n   * This is slower than <a href='JitChangeDetection'>JitChangeDetection</a>.\n   * \n   * @exportedAs angular2/change_detection",
        "* Implements faster change detection, by generating source code.\n   * \n   * This requires `eval()`. For change detection that does not require `eval()`, see\n   * <a href='DynamicChangeDetection'>DynamicChangeDetection</a>.\n   * \n   * @exportedAs angular2/change_detection",
        "* Implements change detection using a map of pregenerated proto detectors.\n   * \n   * @exportedAs angular2/change_detection",
        "* @exportedAs angular2/view",
        "* @exportedAs angular2/view",
        "* @exportedAs angular2/core",
        "* The method can be used together with insert to implement a view move, i.e.\n     * moving the dom nodes while the directives in the view stay intact.",
        "* @exportedAs angular2/view",
        "* Exposes the underlying DOM element.\n     * (DEPRECATED way of accessing the DOM, replacement coming)",
        "* Gets an attribute from the underlying DOM element.\n     * (DEPRECATED way of accessing the DOM, replacement coming)",
        "* called before code executes in the inner zone for each VM turn",
        "* called at the end of a VM turn if code has executed in the inner\n     * zone",
        "* called when an exception is thrown by a macro or\n     * micro task",
        "* A wrapper around zones that lets you schedule tasks after it has executed a task.\n   * \n   * The wrapper maintains an \"inner\" and an \"mount\" `Zone`. The application code will executes\n   * in the \"inner\" zone unless `runOutsideAngular` is explicitely called.\n   * \n   * A typical application will create a singleton `NgZone`. The outer `Zone` is a fork of the root\n   * `Zone`. The default `onTurnDone` runs the Angular change detection.\n   * \n   * @exportedAs angular2/core",
        "* Initializes the zone hooks.",
        "* Runs `fn` in the inner zone and returns whatever it returns.\n     * \n     * In a typical app where the inner zone is the Angular zone, this allows one to make use of the\n     * Angular's auto digest mechanism.\n     * \n     * ```\n     * var zone: NgZone = [ref to the application zone];\n     * \n     * zone.run(() => {\n     *   // the change detection will run after this function and the microtasks it enqueues have\n     * executed.\n     * });\n     * ```",
        "* Runs `fn` in the outer zone and returns whatever it returns.\n     * \n     * In a typical app where the inner zone is the Angular zone, this allows one to escape Angular's\n     * auto-digest mechanism.\n     * \n     * ```\n     * var zone: NgZone = [ref to the application zone];\n     * \n     * zone.runOusideAngular(() => {\n     *   element.onClick(() => {\n     *     // Clicking on the element would not trigger the change detection\n     *   });\n     * });\n     * ```",
        "* Specifies that an injector should retrieve a dependency from its element.\n   * \n   * ## Example\n   * \n   * Here is a simple directive that retrieves a dependency from its element.\n   * \n   * ```\n   * @Directive({\n   *   selector: '[dependency]',\n   *   properties: [\n   *     'id: dependency'\n   *   ]\n   * })\n   * class Dependency {\n   *   id:string;\n   * }\n   * \n   * \n   * @Directive({\n   *   selector: '[my-directive]'\n   * })\n   * class Dependency {\n   *   constructor(@Self() dependency:Dependency) {\n   *     expect(dependency.id).toEqual(1);\n   *   };\n   * }\n   * ```\n   * \n   * We use this with the following HTML template:\n   * \n   * ```\n   * <div dependency=\"1\" my-directive></div>\n   * ```\n   * \n   * @exportedAs angular2/annotations",
        "* Specifies that an injector should retrieve a dependency from any ancestor element within the same\n   * shadow boundary.\n   * \n   * An ancestor is any element between the parent element and shadow root.\n   * \n   * \n   * ## Example\n   * \n   * Here is a simple directive that retrieves a dependency from an ancestor element.\n   * \n   * ```\n   * @Directive({\n   *   selector: '[dependency]',\n   *   properties: [\n   *     'id: dependency'\n   *   ]\n   * })\n   * class Dependency {\n   *   id:string;\n   * }\n   * \n   * \n   * @Directive({\n   *   selector: '[my-directive]'\n   * })\n   * class Dependency {\n   *   constructor(@Ancestor() dependency:Dependency) {\n   *     expect(dependency.id).toEqual(2);\n   *   };\n   * }\n   * ```\n   * \n   *  We use this with the following HTML template:\n   * \n   * ```\n   * <div dependency=\"1\">\n   *   <div dependency=\"2\">\n   *     <div>\n   *       <div dependency=\"3\" my-directive></div>\n   *     </div>\n   *   </div>\n   * </div>\n   * ```\n   * \n   * The `@Ancestor()` annotation in our constructor forces the injector to retrieve the dependency\n   * from the\n   * nearest ancestor element:\n   * - The current element `dependency=\"3\"` is skipped because it is not an ancestor.\n   * - Next parent has no directives `<div>`\n   * - Next parent has the `Dependency` directive and so the dependency is satisfied.\n   * \n   * Angular injects `dependency=2`.\n   * \n   * @exportedAs angular2/annotations",
        "* Specifies that an injector should retrieve a dependency from the direct parent.\n   * \n   * ## Example\n   * \n   * Here is a simple directive that retrieves a dependency from its parent element.\n   * \n   * ```\n   * @Directive({\n   *   selector: '[dependency]',\n   *   properties: [\n   *     'id: dependency'\n   *   ]\n   * })\n   * class Dependency {\n   *   id:string;\n   * }\n   * \n   * \n   * @Directive({\n   *   selector: '[my-directive]'\n   * })\n   * class Dependency {\n   *   constructor(@Parent() dependency:Dependency) {\n   *     expect(dependency.id).toEqual(1);\n   *   };\n   * }\n   * ```\n   * \n   * We use this with the following HTML template:\n   * \n   * ```\n   * <div dependency=\"1\">\n   *   <div dependency=\"2\" my-directive></div>\n   * </div>\n   * ```\n   * The `@Parent()` annotation in our constructor forces the injector to retrieve the dependency from\n   * the\n   * parent element (even thought the current element could resolve it): Angular injects\n   * `dependency=1`.\n   * \n   * @exportedAs angular2/annotations",
        "* Specifies that an injector should retrieve a dependency from any ancestor element.\n   * \n   * An ancestor is any element between the parent element and shadow root.\n   * \n   * \n   * ## Example\n   * \n   * Here is a simple directive that retrieves a dependency from an ancestor element.\n   * \n   * ```\n   * @Directive({\n   *   selector: '[dependency]',\n   *   properties: [\n   *     'id: dependency'\n   *   ]\n   * })\n   * class Dependency {\n   *   id:string;\n   * }\n   * \n   * \n   * @Directive({\n   *   selector: '[my-directive]'\n   * })\n   * class Dependency {\n   *   constructor(@Unbounded() dependency:Dependency) {\n   *     expect(dependency.id).toEqual(2);\n   *   };\n   * }\n   * ```\n   * \n   * @exportedAs angular2/annotations",
        "* Declares the available HTML templates for an application.\n   *\n   * Each angular component requires a single `@Component` and at least one `@View` annotation. The\n   * `@View` annotation specifies the HTML template to use, and lists the directives that are active\n   * within the template.\n   *\n   * When a component is instantiated, the template is loaded into the component's shadow root, and\n   * the expressions and statements in the template are evaluated against the component.\n   *\n   * For details on the `@Component` annotation, see {@link Component}.\n   *\n   * ## Example\n   *\n   * ```\n   * @Component({\n   *   selector: 'greet'\n   * })\n   * @View({\n   *   template: 'Hello {{name}}!',\n   *   directives: [GreetUser, Bold]\n   * })\n   * class Greet {\n   *   name: string;\n   *\n   *   constructor() {\n   *     this.name = 'World';\n   *   }\n   * }\n   * ```",
        "* Specifies a template URL for an angular component.\n     *\n     * NOTE: either `templateUrl` or `template` should be used, but not both.",
        "* Specifies an inline template for an angular component.\n     *\n     * NOTE: either `templateUrl` or `template` should be used, but not both.",
        "* Specifies a list of directives that can be used within a template.\n     *\n     * Directives must be listed explicitly to provide proper component encapsulation.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * @Component({\n     *     selector: 'my-component'\n     *   })\n     * @View({\n     *   directives: [For]\n     *   template: '\n     *   <ul>\n     *     <li *ng-for=\"#item of items\">{{item}}</li>\n     *   </ul>'\n     * })\n     * class MyComponent {\n     * }\n     * ```",
        "* Specify a custom renderer for this View.\n     * If this is set, neither `template`, `templateURL` nor `directives` are used.",
        "* Bootstrapping for Angular applications.\n   * \n   * You instantiate an Angular application by explicitly specifying a component to use as the root\n   * component for your\n   * application via the `bootstrap()` method.\n   * \n   * ## Simple Example\n   * \n   * Assuming this `index.html`:\n   * \n   * ```html\n   * <html>\n   *   <!-- load Angular script tags here. -->\n   *   <body>\n   *     <my-app>loading...</my-app>\n   *   </body>\n   * </html>\n   * ```\n   * \n   * An application is bootstrapped inside an existing browser DOM, typically `index.html`. Unlike\n   * Angular 1, Angular 2\n   * does not compile/process bindings in `index.html`. This is mainly for security reasons, as well\n   * as architectural\n   * changes in Angular 2. This means that `index.html` can safely be processed using server-side\n   * technologies such as\n   * bindings. Bindings can thus use double-curly `{{ syntax }}` without collision from Angular 2\n   * component double-curly\n   * `{{ syntax }}`.\n   * \n   * We can use this script code:\n   * \n   * ```\n   * @Component({\n   *    selector: 'my-app'\n   * })\n   * @View({\n   *    template: 'Hello {{ name }}!'\n   * })\n   * class MyApp {\n   *   name:string;\n   * \n   *   constructor() {\n   *     this.name = 'World';\n   *   }\n   * }\n   * \n   * main() {\n   *   return bootstrap(MyApp);\n   * }\n   * ```\n   * \n   * When the app developer invokes `bootstrap()` with the root component `MyApp` as its argument,\n   * Angular performs the\n   * following tasks:\n   * \n   *  1. It uses the component's `selector` property to locate the DOM element which needs to be\n   * upgraded into\n   *     the angular component.\n   *  2. It creates a new child injector (from the platform injector) and configures the injector with\n   * the component's\n   *     `appInjector`. Optionally, you can also override the injector configuration for an app by\n   * invoking\n   *     `bootstrap` with the `componentInjectableBindings` argument.\n   *  3. It creates a new `Zone` and connects it to the angular application's change detection domain\n   * instance.\n   *  4. It creates a shadow DOM on the selected component's host element and loads the template into\n   * it.\n   *  5. It instantiates the specified component.\n   *  6. Finally, Angular performs change detection to apply the initial data bindings for the\n   * application.\n   * \n   * \n   * ## Instantiating Multiple Applications on a Single Page\n   * \n   * There are two ways to do this.\n   * \n   * \n   * ### Isolated Applications\n   * \n   * Angular creates a new application each time that the `bootstrap()` method is invoked. When\n   * multiple applications\n   * are created for a page, Angular treats each application as independent within an isolated change\n   * detection and\n   * `Zone` domain. If you need to share data between applications, use the strategy described in the\n   * next\n   * section, \"Applications That Share Change Detection.\"\n   * \n   * \n   * ### Applications That Share Change Detection\n   * \n   * If you need to bootstrap multiple applications that share common data, the applications must\n   * share a common\n   * change detection and zone. To do that, create a meta-component that lists the application\n   * components in its template.\n   * By only invoking the `bootstrap()` method once, with the meta-component as its argument, you\n   * ensure that only a\n   * single change detection zone is created and therefore data can be shared across the applications.\n   * \n   * \n   * ## Platform Injector\n   * \n   * When working within a browser window, there are many singleton resources: cookies, title,\n   * location, and others.\n   * Angular services that represent these resources must likewise be shared across all Angular\n   * applications that\n   * occupy the same browser window.  For this reason, Angular creates exactly one global platform\n   * injector which stores\n   * all shared services, and each angular application injector has the platform injector as its\n   * parent.\n   * \n   * Each application has its own private injector as well. When there are multiple applications on a\n   * page, Angular treats\n   * each application injector's services as private to that application.\n   * \n   * \n   * # API\n   * - `appComponentType`: The root component which should act as the application. This is a reference\n   * to a `Type`\n   *   which is annotated with `@Component(...)`.\n   * - `componentInjectableBindings`: An additional set of bindings that can be added to `appInjector`\n   * for the\n   * <a href='/angular2/angular2/Component'><code>Component</code></a> to override default injection behavior.\n   * - `errorReporter`: `function(exception:any, stackTrace:string)` a default error reporter for\n   * unhandled exceptions.\n   * \n   * Returns a `Promise` with the application`s private <a href='/angular2/angular2/Injector'><code>Injector</code></a>.\n   * \n   * @exportedAs angular2/core",
        "* Specifies that a <a href='QueryList'>QueryList</a> should be injected.\n   * \n   * See <a href='QueryList'>QueryList</a> for usage and example.\n   * \n   * @exportedAs angular2/annotations",
        "* Specifies that a constant attribute value should be injected.\n   * \n   * The directive can inject constant string literals of host element attributes.\n   * \n   * ## Example\n   * \n   * Suppose we have an `<input>` element and want to know its `type`.\n   * \n   * ```html\n   * <input type=\"text\">\n   * ```\n   * \n   * A decorator can inject string literal `text` like so:\n   * \n   * ```javascript\n   * @Directive({\n   *   selector: `input'\n   * })\n   * class InputDirective {\n   *   constructor(@Attribute('type') type) {\n   *     // type would be `text` in this example\n   *   }\n   * }\n   * ```\n   * \n   * @exportedAs angular2/annotations",
        "* Cache that stores the AppProtoView of the template of a component.\n   * Used to prevent duplicate work and resolve cyclic dependencies.",
        "* @exportedAs angular2/view",
        "* Defines lifecycle method [onChange] called after all of component's bound\n   * properties are updated.",
        "* Defines lifecycle method [onDestroy] called when a directive is being destroyed.",
        "* Defines lifecycle method [onCheck] called when a directive is being checked.",
        "* Defines lifecycle method [onInit] called when a directive is being checked the first time.",
        "* Defines lifecycle method [onAllChangesDone ] called when the bindings of all its children have\n   * been changed.",
        "* An iterable live list of components in the Light DOM.\n   * \n   * Injectable Objects that contains a live list of child directives in the light DOM of a directive.\n   * The directives are kept in depth-first pre-order traversal of the DOM.\n   * \n   * The `QueryList` is iterable, therefore it can be used in both javascript code with `for..of` loop\n   * as well as in\n   * template with `*ng-for=\"of\"` directive.\n   * \n   * NOTE: In the future this class will implement an `Observable` interface. For now it uses a plain\n   * list of observable\n   * callbacks.\n   * \n   * # Example:\n   * \n   * Assume that `<tabs>` component would like to get a list its children which are `<pane>`\n   * components as shown in this\n   * example:\n   * \n   * ```html\n   * <tabs>\n   *   <pane title=\"Overview\">...</pane>\n   *   <pane *ng-for=\"#o of objects\" [title]=\"o.title\">{{o.text}}</pane>\n   * </tabs>\n   * ```\n   * \n   * In the above example the list of `<tabs>` elements needs to get a list of `<pane>` elements so\n   * that it could render\n   * tabs with the correct titles and in the correct order.\n   * \n   * A possible solution would be for a `<pane>` to inject `<tabs>` component and then register itself\n   * with `<tabs>`\n   * component's on `hydrate` and deregister on `dehydrate` event. While a reasonable approach, this\n   * would only work\n   * partialy since `*ng-for` could rearange the list of `<pane>` components which would not be\n   * reported to `<tabs>`\n   * component and thus the list of `<pane>` componets would be out of sync with respect to the list\n   * of `<pane>` elements.\n   * \n   * A preferred solution is to inject a `QueryList` which is a live list of directives in the\n   * component`s light DOM.\n   * \n   * ```javascript\n   * @Component({\n   *   selector: 'tabs'\n   * })\n   * @View({\n   *  template: `\n   *    <ul>\n   *      <li *ng-for=\"#pane of panes\">{{pane.title}}</li>\n   *    </ul>\n   *    <content></content>\n   *  `\n   * })\n   * class Tabs {\n   *   panes: QueryList<Pane>\n   * \n   *   constructor(@Query(Pane) panes:QueryList<Pane>) {\n   *     this.panes = panes;\n   *   }\n   * }\n   * \n   * @Component({\n   *   selector: 'pane',\n   *   properties: ['title']\n   * })\n   * @View(...)\n   * class Pane {\n   *   title:string;\n   * }\n   * ```\n   * \n   * @exportedAs angular2/view",
        "* @exportedAs angular2/view",
        "* Service for dynamically loading a Component into an arbitrary position in the internal Angular\n   * application tree.\n   * \n   * @exportedAs angular2/view",
        "* Loads a root component that is placed at the first element that matches the\n     * component's selector.\n     * The loaded component receives injection normally as a hosted view.",
        "* Loads a component into the location given by the provided ElementRef. The loaded component\n     * receives injection as if it in the place of the provided ElementRef.",
        "* Loads a component into a free host view that is not yet attached to\n     * a parent on the render side, although it is attached to a parent in the injector hierarchy.\n     * The loaded component receives injection normally as a hosted view.",
        "* Loads a component next to the provided ElementRef. The loaded component receives\n     * injection normally as a hosted view.",
        "* Declare reusable UI building blocks for an application.\n   *\n   * Each Angular component requires a single `@Component` and at least one `@View` annotation. The\n   * `@Component`\n   * annotation specifies when a component is instantiated, and which properties and hostListeners it\n   * binds to.\n   *\n   * When a component is instantiated, Angular\n   * - creates a shadow DOM for the component.\n   * - loads the selected template into the shadow DOM.\n   * - creates a child {@link Injector} which is configured with the `appInjector` for the\n   * {@link Component}.\n   *\n   * All template expressions and statements are then evaluated against the component instance.\n   *\n   * For details on the `@View` annotation, see {@link View}.\n   *\n   * ## Example\n   *\n   * ```\n   * @Component({\n   *   selector: 'greet'\n   * })\n   * @View({\n   *   template: 'Hello {{name}}!'\n   * })\n   * class Greet {\n   *   name: string;\n   *\n   *   constructor() {\n   *     this.name = 'World';\n   *   }\n   * }\n   * ```\n   *\n   *\n   * Dynamically loading a component at runtime:\n   *\n   * Regular Angular components are statically resolved. Dynamic components allows to resolve a\n   * component at runtime\n   * instead by providing a placeholder into which a regular Angular component can be dynamically\n   * loaded. Once loaded,\n   * the dynamically-loaded component becomes permanent and cannot be changed.\n   * Dynamic components are declared just like components, but without a `@View` annotation.\n   *\n   *\n   * ## Example\n   *\n   * Here we have `DynamicComp` which acts as the placeholder for `HelloCmp`. At runtime, the dynamic\n   * component\n   * `DynamicComp` requests loading of the `HelloCmp` component.\n   *\n   * There is nothing special about `HelloCmp`, which is a regular Angular component. It can also be\n   * used in other static\n   * locations.\n   *\n   * ```\n   * @Component({\n   *   selector: 'dynamic-comp'\n   * })\n   * class DynamicComp {\n   *   helloCmp:HelloCmp;\n   *   constructor(loader:DynamicComponentLoader, location:ElementRef) {\n   *     loader.load(HelloCmp, location).then((helloCmp) => {\n   *       this.helloCmp = helloCmp;\n   *     });\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'hello-cmp'\n   * })\n   * @View({\n   *   template: \"{{greeting}}\"\n   * })\n   * class HelloCmp {\n   *   greeting:string;\n   *   constructor() {\n   *     this.greeting = \"hello\";\n   *   }\n   * }\n   * ```",
        "* Defines the used change detection strategy.\n     *\n     * When a component is instantiated, Angular creates a change detector, which is responsible for\n     * propagating\n     * the component's bindings.\n     *\n     * The `changeDetection` property defines, whether the change detection will be checked every time\n     * or only when the component\n     * tells it to do so.",
        "* Defines the set of injectable objects that are visible to a Component and its children.\n     *\n     * The `appInjector` defined in the Component annotation allow you to configure a set of bindings\n     * for the component's\n     * injector.\n     *\n     * When a component is instantiated, Angular creates a new child Injector, which is configured\n     * with the bindings in\n     * the Component `appInjector` annotation. The injectable objects then become available for\n     * injection to the component\n     * itself and any of the directives in the component's template, i.e. they are not available to\n     * the directives which\n     * are children in the component's light DOM.\n     *\n     *\n     * The syntax for configuring the `appInjector` injectable is identical to {@link Injector}\n     * injectable configuration.\n     * See {@link Injector} for additional detail.\n     *\n     *\n     * ## Simple Example\n     *\n     * Here is an example of a class that can be injected:\n     *\n     * ```\n     * class Greeter {\n     *    greet(name:string) {\n     *      return 'Hello ' + name + '!';\n     *    }\n     * }\n     *\n     * @Component({\n     *   selector: 'greet',\n     *   appInjector: [\n     *     Greeter\n     *   ]\n     * })\n     * @View({\n     *   template: `{{greeter.greet('world')}}!`,\n     *   directives: [Child]\n     * })\n     * class HelloWorld {\n     *   greeter:Greeter;\n     *\n     *   constructor(greeter:Greeter) {\n     *     this.greeter = greeter;\n     *   }\n     * }\n     * ```",
        "* Defines the set of injectable objects that are visible to its view dom children.\n     *\n     * ## Simple Example\n     *\n     * Here is an example of a class that can be injected:\n     *\n     * ```\n     * class Greeter {\n     *    greet(name:string) {\n     *      return 'Hello ' + name + '!';\n     *    }\n     * }\n     *\n     * @Directive({\n     *   selector: 'needs-greeter'\n     * })\n     * class NeedsGreeter {\n     *   greeter:Greeter;\n     *\n     *   constructor(greeter:Greeter) {\n     *     this.greeter = greeter;\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'greet',\n     *   viewInjector: [\n     *     Greeter\n     *   ]\n     * })\n     * @View({\n     *   template: `<needs-greeter></needs-greeter>`,\n     *   directives: [NeedsGreeter]\n     * })\n     * class HelloWorld {\n     * }\n     *\n     * ```",
        "* Directives allow you to attach behavior to elements in the DOM.\n   * \n   * <a href='/angular2/angular2/Directive'><code>Directive</code></a>s with an embedded view are called <a href='/angular2/angular2/Component'><code>Component</code></a>s.\n   * \n   * A directive consists of a single directive annotation and a controller class. When the\n   * directive's `selector` matches\n   * elements in the DOM, the following steps occur:\n   * \n   * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor\n   * arguments.\n   * 2. Angular instantiates directives for each matched element using `ElementInjector` in a\n   * depth-first order,\n   *    as declared in the HTML.\n   * \n   * ## Understanding How Injection Works\n   * \n   * There are three stages of injection resolution.\n   * - *Pre-existing Injectors*:\n   *   - The terminal <a href='/angular2/angular2/Injector'><code>Injector</code></a> cannot resolve dependencies. It either throws an error or, if\n   * the dependency was\n   *     specified as `@Optional`, returns `null`.\n   *   - The platform injector resolves browser singleton resources, such as: cookies, title,\n   * location, and others.\n   * - *Component Injectors*: Each component instance has its own <a href='/angular2/angular2/Injector'><code>Injector</code></a>, and they follow\n   * the same parent-child hierarchy\n   *     as the component instances in the DOM.\n   * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each\n   * element has an `ElementInjector`\n   *     which follow the same parent-child hierarchy as the DOM elements themselves.\n   * \n   * When a template is instantiated, it also must instantiate the corresponding directives in a\n   * depth-first order. The\n   * current `ElementInjector` resolves the constructor dependencies for each directive.\n   * \n   * Angular then resolves dependencies as follows, according to the order in which they appear in the\n   * <a href='/angular2/angular2/View'><code>View</code></a>:\n   * \n   * 1. Dependencies on the current element\n   * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary\n   * 3. Dependencies on component injectors and their parents until it encounters the root component\n   * 4. Dependencies on pre-existing injectors\n   * \n   * \n   * The `ElementInjector` can inject other directives, element-specific special objects, or it can\n   * delegate to the parent\n   * injector.\n   * \n   * To inject other directives, declare the constructor parameter as:\n   * - `directive:DirectiveType`: a directive on the current element only\n   * - `@Ancestor() directive:DirectiveType`: any directive that matches the type between the current\n   * element and the\n   *    Shadow DOM root. Current element is not included in the resolution, therefore even if it could\n   * resolve it, it will\n   *    be ignored.\n   * - `@Parent() directive:DirectiveType`: any directive that matches the type on a direct parent\n   * element only.\n   * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child\n   * directives.\n   * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any\n   * child directives.\n   * \n   * To inject element-specific special objects, declare the constructor parameter as:\n   * - `element: ElementRef` to obtain a reference to logical element in the view.\n   * - `viewContainer: ViewContainerRef` to control child template instantiation, for\n   * <a href='/angular2/angular2/Directive'><code>Directive</code></a> directives only\n   * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.\n   * \n   * ## Example\n   * \n   * The following example demonstrates how dependency injection resolves constructor arguments in\n   * practice.\n   * \n   * \n   * Assume this HTML template:\n   * \n   * ```\n   * <div dependency=\"1\">\n   *   <div dependency=\"2\">\n   *     <div dependency=\"3\" my-directive>\n   *       <div dependency=\"4\">\n   *         <div dependency=\"5\"></div>\n   *       </div>\n   *       <div dependency=\"6\"></div>\n   *     </div>\n   *   </div>\n   * </div>\n   * ```\n   * \n   * With the following `dependency` decorator and `SomeService` injectable class.\n   * \n   * ```\n   * @Injectable()\n   * class SomeService {\n   * }\n   * \n   * @Directive({\n   *   selector: '[dependency]',\n   *   properties: [\n   *     'id: dependency'\n   *   ]\n   * })\n   * class Dependency {\n   *   id:string;\n   * }\n   * ```\n   * \n   * Let's step through the different ways in which `MyDirective` could be declared...\n   * \n   * \n   * ### No injection\n   * \n   * Here the constructor is declared with no arguments, therefore nothing is injected into\n   * `MyDirective`.\n   * \n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor() {\n   *   }\n   * }\n   * ```\n   * \n   * This directive would be instantiated with no dependencies.\n   * \n   * \n   * ### Component-level injection\n   * \n   * Directives can inject any injectable instance from the closest component injector or any of its\n   * parents.\n   * \n   * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type\n   * from the parent\n   * component's injector.\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(someService: SomeService) {\n   *   }\n   * }\n   * ```\n   * \n   * This directive would be instantiated with a dependency on `SomeService`.\n   * \n   * \n   * ### Injecting a directive from the current element\n   * \n   * Directives can inject other directives declared on the current element.\n   * \n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(dependency: Dependency) {\n   *     expect(dependency.id).toEqual(3);\n   *   }\n   * }\n   * ```\n   * This directive would be instantiated with `Dependency` declared at the same element, in this case\n   * `dependency=\"3\"`.\n   * \n   * \n   * ### Injecting a directive from a direct parent element\n   * \n   * Directives can inject other directives declared on a direct parent element. By definition, a\n   * directive with a\n   * `@Parent` annotation does not attempt to resolve dependencies for the current element, even if\n   * this would satisfy\n   * the dependency.\n   * \n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@Parent() dependency: Dependency) {\n   *     expect(dependency.id).toEqual(2);\n   *   }\n   * }\n   * ```\n   * This directive would be instantiated with `Dependency` declared at the parent element, in this\n   * case `dependency=\"2\"`.\n   * \n   * \n   * ### Injecting a directive from any ancestor elements\n   * \n   * Directives can inject other directives declared on any ancestor element (in the current Shadow\n   * DOM), i.e. on the\n   * parent element and its parents. By definition, a directive with an `@Ancestor` annotation does\n   * not attempt to\n   * resolve dependencies for the current element, even if this would satisfy the dependency.\n   * \n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@Ancestor() dependency: Dependency) {\n   *     expect(dependency.id).toEqual(2);\n   *   }\n   * }\n   * ```\n   * \n   * Unlike the `@Parent` which only checks the parent, `@Ancestor` checks the parent, as well as its\n   * parents recursively. If `dependency=\"2\"` didn't exist on the direct parent, this injection would\n   * have returned\n   * `dependency=\"1\"`.\n   * \n   * \n   * ### Injecting a live collection of direct child directives\n   * \n   * \n   * A directive can also query for other child directives. Since parent directives are instantiated\n   * before child directives, a directive can't simply inject the list of child directives. Instead,\n   * the directive injects a <a href='QueryList'>QueryList</a>, which updates its contents as children are added,\n   * removed, or moved by a directive that uses a <a href='/angular2/angular2/ViewContainerRef'><code>ViewContainerRef</code></a> such as a `ng-for`, an\n   * `ng-if`, or an `ng-switch`.\n   * \n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {\n   *   }\n   * }\n   * ```\n   * \n   * This directive would be instantiated with a <a href='QueryList'>QueryList</a> which contains `Dependency` 4 and\n   * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.\n   * \n   * ### Injecting a live collection of descendant directives\n   * \n   * Note: This is will be implemented in later release. ()\n   * \n   * Similar to `@Query` above, but also includes the children of the child elements.\n   * \n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@QueryDescendents(Dependency) dependencies:QueryList<Dependency>) {\n   *   }\n   * }\n   * ```\n   * \n   * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.\n   * \n   * ### Optional injection\n   * \n   * The normal behavior of directives is to return an error when a specified dependency cannot be\n   * resolved. If you\n   * would like to inject `null` on unresolved dependency instead, you can annotate that dependency\n   * with `@Optional()`.\n   * This explicitly permits the author of a template to treat some of the surrounding directives as\n   * optional.\n   * \n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@Optional() dependency:Dependency) {\n   *   }\n   * }\n   * ```\n   * \n   * This directive would be instantiated with a `Dependency` directive found on the current element.\n   * If none can be\n   * found, the injector supplies `null` instead of throwing an error.\n   * \n   * ## Example\n   * \n   * Here we use a decorator directive to simply define basic tool-tip behavior.\n   * \n   * ```\n   * @Directive({\n   *   selector: '[tooltip]',\n   *   properties: [\n   *     'text: tooltip'\n   *   ],\n   *   hostListeners: {\n   *     'onmouseenter': 'onMouseEnter()',\n   *     'onmouseleave': 'onMouseLeave()'\n   *   }\n   * })\n   * class Tooltip{\n   *   text:string;\n   *   overlay:Overlay; // NOT YET IMPLEMENTED\n   *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED\n   * \n   *   constructor(overlayManager:OverlayManager) {\n   *     this.overlay = overlay;\n   *   }\n   * \n   *   onMouseEnter() {\n   *     // exact signature to be determined\n   *     this.overlay = this.overlayManager.open(text, ...);\n   *   }\n   * \n   *   onMouseLeave() {\n   *     this.overlay.close();\n   *     this.overlay = null;\n   *   }\n   * }\n   * ```\n   * In our HTML template, we can then add this behavior to a `<div>` or any other element with the\n   * `tooltip` selector,\n   * like so:\n   * \n   * ```\n   * <div tooltip=\"some text here\"></div>\n   * ```\n   * \n   * Directives can also control the instantiation, destruction, and positioning of inline template\n   * elements:\n   * \n   * A directive uses a <a href='/angular2/angular2/ViewContainerRef'><code>ViewContainerRef</code></a> to instantiate, insert, move, and destroy views at\n   * runtime.\n   * The <a href='/angular2/angular2/ViewContainerRef'><code>ViewContainerRef</code></a> is created as a result of `<template>` element, and represents a\n   * location in the current view\n   * where these actions are performed.\n   * \n   * Views are always created as children of the current <a href='/angular2/angular2/View'><code>View</code></a>, and as siblings of the\n   * `<template>` element. Thus a\n   * directive in a child view cannot inject the directive that created it.\n   * \n   * Since directives that create views via ViewContainers are common in Angular, and using the full\n   * `<template>` element syntax is wordy, Angular\n   * also supports a shorthand notation: `<li *foo=\"bar\">` and `<li template=\"foo: bar\">` are\n   * equivalent.\n   * \n   * Thus,\n   * \n   * ```\n   * <ul>\n   *   <li *foo=\"bar\" title=\"text\"></li>\n   * </ul>\n   * ```\n   * \n   * Expands in use to:\n   * \n   * ```\n   * <ul>\n   *   <template [foo]=\"bar\">\n   *     <li title=\"text\"></li>\n   *   </template>\n   * </ul>\n   * ```\n   * \n   * Notice that although the shorthand places `*foo=\"bar\"` within the `<li>` element, the binding for\n   * the directive\n   * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.\n   * \n   * \n   * ## Example\n   * \n   * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.\n   * \n   * Here is a simple directive that triggers on an `unless` selector:\n   * \n   * ```\n   * @Directive({\n   *   selector: '[unless]',\n   *   properties: ['unless']\n   * })\n   * export class Unless {\n   *   viewContainer: ViewContainerRef;\n   *   protoViewRef: ProtoViewRef;\n   *   prevCondition: boolean;\n   * \n   *   constructor(viewContainer: ViewContainerRef, protoViewRef: ProtoViewRef) {\n   *     this.viewContainer = viewContainer;\n   *     this.protoViewRef = protoViewRef;\n   *     this.prevCondition = null;\n   *   }\n   * \n   *   set unless(newCondition) {\n   *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {\n   *       this.prevCondition = true;\n   *       this.viewContainer.clear();\n   *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {\n   *       this.prevCondition = false;\n   *       this.viewContainer.create(this.protoViewRef);\n   *     }\n   *   }\n   * }\n   * ```\n   * \n   * We can then use this `unless` selector in a template:\n   * ```\n   * <ul>\n   *   <li *unless=\"expr\"></li>\n   * </ul>\n   * ```\n   * \n   * Once the directive instantiates the child view, the shorthand notation for the template expands\n   * and the result is:\n   * \n   * ```\n   * <ul>\n   *   <template [unless]=\"exp\">\n   *     <li></li>\n   *   </template>\n   *   <li></li>\n   * </ul>\n   * ```\n   * \n   * Note also that although the `<li></li>` template still exists inside the `<template></template>`,\n   * the instantiated\n   * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.\n   * \n   * @exportedAs angular2/annotations",
        "* If set to true the compiler does not compile the children of this directive.",
        "* Enumerates the set of emitted events.\n     * \n     * ## Syntax\n     * \n     * ```\n     * @Component({\n     *   events: ['statusChange']\n     * })\n     * class TaskComponent {\n     *   statusChange:EventEmitter;\n     * \n     *   constructor() {\n     *     this.statusChange = new EventEmitter();\n     *   }\n     * \n     *   onComplete() {\n     *     this.statusChange.next('completed');\n     *   }\n     * }\n     * ```",
        "* Specifies which DOM methods a directive can invoke.\n     * \n     * ## Syntax\n     * \n     * ```\n     * @Directive({\n     *   selector: 'input',\n     *   hostActions: {\n     *     'emitFocus': 'focus()'\n     *   }\n     * })\n     * class InputDirective {\n     *   constructor() {\n     *     this.emitFocus = new EventEmitter();\n     *   }\n     * \n     *   focus() {\n     *     this.emitFocus.next();\n     *   }\n     * }\n     * \n     * In this example calling focus on InputDirective will result in calling focus on the DOM\n     * element.\n     * ```",
        "* Specifies static attributes that should be propagated to a host element. Attributes specified\n     * in `hostAttributes`\n     * are propagated only if a given attribute is not present on a host element.\n     * \n     * ## Syntax\n     * \n     * ```\n     * @Directive({\n     *   selector: '[my-button]',\n     *   hostAttributes: {\n     *     'role': 'button'\n     *   }\n     * })\n     * class MyButton {\n     * }\n     * \n     * In this example using `my-button` directive (ex.: `<div my-button></div>`) on a host element\n     * (here: `<div>` )\n     * will ensure that this element will get the \"button\" role.\n     * ```",
        "* Defines the set of injectable objects that are visible to a Directive and its light dom\n     * children.\n     * \n     * ## Simple Example\n     * \n     * Here is an example of a class that can be injected:\n     * \n     * ```\n     * class Greeter {\n     *    greet(name:string) {\n     *      return 'Hello ' + name + '!';\n     *    }\n     * }\n     * \n     * @Directive({\n     *   selector: 'greet',\n     *   hostInjector: [\n     *     Greeter\n     *   ]\n     * })\n     * class HelloWorld {\n     *   greeter:Greeter;\n     * \n     *   constructor(greeter:Greeter) {\n     *     this.greeter = greeter;\n     *   }\n     * }\n     * ```",
        "* Specifies which DOM hostListeners a directive listens to.\n     * \n     * The `hostListeners` property defines a set of `event` to `method` key-value pairs:\n     * \n     * - `event1`: the DOM event that the directive listens to.\n     * - `statement`: the statement to execute when the event occurs.\n     * If the evalutation of the statement returns `false`, then `preventDefault`is applied on the DOM\n     * event.\n     * \n     * To listen to global events, a target must be added to the event name.\n     * The target can be `window`, `document` or `body`.\n     * \n     * When writing a directive event binding, you can also refer to the following local variables:\n     * - `$event`: Current event object which triggered the event.\n     * - `$target`: The source of the event. This will be either a DOM element or an Angular\n     * directive.\n     *   (will be implemented in later release)\n     * \n     * \n     * ## Syntax\n     * \n     * ```\n     * @Directive({\n     *   hostListeners: {\n     *     'event1': 'onMethod1(arguments)',\n     *     'target:event2': 'onMethod2(arguments)',\n     *     ...\n     *   }\n     * }\n     * ```\n     * \n     * ## Basic Event Binding:\n     * \n     * Suppose you want to write a directive that triggers on `change` events in the DOM and on\n     * `resize` events in window.\n     * You would define the event binding as follows:\n     * \n     * ```\n     * @Directive({\n     *   selector: 'input',\n     *   hostListeners: {\n     *     'change': 'onChange($event)',\n     *     'window:resize': 'onResize($event)'\n     *   }\n     * })\n     * class InputDirective {\n     *   onChange(event:Event) {\n     *   }\n     *   onResize(event:Event) {\n     *   }\n     * }\n     * ```\n     * \n     * Here the `onChange` method of `InputDirective` is invoked whenever the DOM element fires the\n     * 'change' event.",
        "* Specifies which DOM properties a directives updates.\n     * \n     * ## Syntax\n     * \n     * ```\n     * @Directive({\n     *   selector: 'input',\n     *   hostProperties: {\n     *     'value': 'value'\n     *   }\n     * })\n     * class InputDirective {\n     *   value:string;\n     * }\n     * \n     * In this example every time the value property of the decorator changes, Angular will update the\n     * value property of\n     * the host element.\n     * ```",
        "* Specifies a set of lifecycle hostListeners in which the directive participates.\n     * \n     * See <a href='annotations/onChange'>onChange</a>, <a href='annotations/onDestroy'>onDestroy</a>,\n     * <a href='annotations/onAllChangesDone'>onAllChangesDone</a> for details.",
        "* Enumerates the set of properties that accept data binding for a directive.\n     * \n     * The `properties` property defines a set of `directiveProperty` to `bindingProperty`\n     * configuration:\n     * \n     * - `directiveProperty` specifies the component property where the value is written.\n     * - `bindingProperty` specifies the DOM property where the value is read from.\n     * \n     * You can include a <a href='/angular2/angular2/Pipe'><code>Pipe</code></a> when specifying a `bindingProperty` to allow for data\n     * transformation and structural change detection of the value. These pipes will be evaluated in\n     * the context of this component.\n     * \n     * ## Syntax\n     * \n     * There is no need to specify both `directiveProperty` and `bindingProperty` when they both have\n     * the same value.\n     * \n     * ```\n     * @Directive({\n     *   properties: [\n     *     'propertyName', // shorthand notation for 'propertyName: propertyName'\n     *     'directiveProperty1: bindingProperty1',\n     *     'directiveProperty2: bindingProperty2 | pipe1 | ...',\n     *     ...\n     *   ]\n     * }\n     * ```\n     * \n     * \n     * ## Basic Property Binding\n     * \n     * We can easily build a simple `Tooltip` directive that exposes a `tooltip` property, which can\n     * be used in templates with standard Angular syntax. For example:\n     * \n     * ```\n     * @Directive({\n     *   selector: '[tooltip]',\n     *   properties: [\n     *     'text: tooltip'\n     *   ]\n     * })\n     * class Tooltip {\n     *   set text(value: string) {\n     *     // This will get called every time with the new value when the 'tooltip' property changes\n     *   }\n     * }\n     * ```\n     * \n     * We can then bind to the `tooltip' property as either an expression (`someExpression`) or as a\n     * string literal, as shown in the HTML template below:\n     * \n     * ```html\n     * <div [tooltip]=\"someExpression\">...</div>\n     * <div tooltip=\"Some Text\">...</div>\n     * ```\n     * \n     * Whenever the `someExpression` expression changes, the `properties` declaration instructs\n     * Angular to update the `Tooltip`'s `text` property.\n     * \n     * ## Bindings With Pipes\n     * \n     * You can also use pipes when writing binding definitions for a directive.\n     * \n     * For example, we could write a binding that updates the directive on structural changes, rather\n     * than on reference changes, as normally occurs in change detection.\n     * \n     * See <a href='/angular2/angular2/Pipe'><code>Pipe</code></a> and <a href='pipes/keyValDiff'>keyValDiff</a> documentation for more details.\n     * \n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   properties: [\n     *     'classChanges: classSet | keyValDiff'\n     *   ]\n     * })\n     * class ClassSet {\n     *   set classChanges(changes: KeyValueChanges) {\n     *     // This will get called every time the `class-set` expressions changes its structure.\n     *   }\n     * }\n     * ```\n     * \n     * The template that this directive is used in may also contain its own pipes. For example:\n     * \n     * ```html\n     * <div [class-set]=\"someExpression | somePipe\">\n     * ```\n     * \n     * In this case, the two pipes compose as if they were inlined: `someExpression | somePipe |\n     * keyValDiff`.",
        "* The CSS selector that triggers the instantiation of a directive.\n     * \n     * Angular only allows directives to trigger on CSS selectors that do not cross element\n     * boundaries.\n     * \n     * `selector` may be declared as one of the following:\n     * \n     * - `element-name`: select by element name.\n     * - `.class`: select by class name.\n     * - `[attribute]`: select by attribute name.\n     * - `[attribute=value]`: select by attribute name and value.\n     * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.\n     * - `selector1, selector2`: select if either `selector1` or `selector2` matches.\n     * \n     * \n     * ## Example\n     * \n     * Suppose we have a directive with an `input[type=text]` selector.\n     * \n     * And the following HTML:\n     * \n     * ```html\n     * <form>\n     *   <input type=\"text\">\n     *   <input type=\"radio\">\n     * <form>\n     * ```\n     * \n     * The directive would only be instantiated on the `<input type=\"text\">` element.",
        "* Notify a directive whenever a <a href='/angular2/angular2/View'><code>View</code></a> that contains it is destroyed.\n   * \n   * ## Example\n   * \n   * ```\n   * @Directive({\n   *   ...,\n   *   lifecycle: [onDestroy]\n   * })\n   * class ClassSet {\n   *   onDestroy() {\n   *     // invoked to notify directive of the containing view destruction.\n   *   }\n   * }\n   * ```\n   * @exportedAs angular2/annotations",
        "* Notify a directive when any of its bindings have changed.\n   * \n   * This method is called right after the directive's bindings have been checked,\n   * and before any of its children's bindings have been checked.\n   * \n   * It is invoked only if at least one of the directive's bindings has changed.\n   * \n   * ## Example:\n   * \n   * ```\n   * @Directive({\n   *   selector: '[class-set]',\n   *   properties: [\n   *     'propA',\n   *     'propB'\n   *   ],\n   *   lifecycle: [onChange]\n   * })\n   * class ClassSet {\n   *   propA;\n   *   propB;\n   *   onChange(changes:{[idx: string, PropertyUpdate]}) {\n   *     // This will get called after any of the properties have been updated.\n   *     if (changes['propA']) {\n   *       // if propA was updated\n   *     }\n   *     if (changes['propA']) {\n   *       // if propB was updated\n   *     }\n   *   }\n   * }\n   *  ```\n   * @exportedAs angular2/annotations",
        "* Notify a directive when it has been checked.\n   * \n   * This method is called right after the directive's bindings have been checked,\n   * and before any of its children's bindings have been checked.\n   * \n   * It is invoked every time even when none of the directive's bindings has changed.\n   * \n   * ## Example:\n   * \n   * ```\n   * @Directive({\n   *   selector: '[class-set]',\n   *   lifecycle: [onCheck]\n   * })\n   * class ClassSet {\n   *   onCheck() {\n   *   }\n   * }\n   *  ```\n   * @exportedAs angular2/annotations",
        "* Notify a directive when it has been checked the first itme.\n   * \n   * This method is called right after the directive's bindings have been checked,\n   * and before any of its children's bindings have been checked.\n   * \n   * It is invoked only once.\n   * \n   * ## Example:\n   * \n   * ```\n   * @Directive({\n   *   selector: '[class-set]',\n   *   lifecycle: [onInit]\n   * })\n   * class ClassSet {\n   *   onInit() {\n   *   }\n   * }\n   *  ```\n   * @exportedAs angular2/annotations",
        "* Notify a directive when the bindings of all its children have been changed.\n   * \n   * ## Example:\n   * \n   * ```\n   * @Directive({\n   *   selector: '[class-set]',\n   *   lifecycle: [onAllChangesDone]\n   * })\n   * class ClassSet {\n   * \n   *   onAllChangesDone() {\n   *   }\n   * \n   * }\n   *  ```\n   * @exportedAs angular2/annotations",
        "* A collection of the Angular core directives that are likely to be used in each and every Angular\n   * application.\n   * \n   * This collection can be used to quickly enumerate all the built-in directives in the `@View`\n   * annotation. For example,\n   * instead of writing:\n   * \n   * ```\n   * import {If, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/angular2';\n   * import {OtherDirective} from 'myDirectives';\n   * \n   * @Component({\n   *  selector: 'my-component'\n   * })\n   * @View({\n   *   templateUrl: 'myComponent.html',\n   *   directives: [If, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]\n   * })\n   * export class MyComponent {\n   *   ...\n   * }\n   * ```\n   * one could enumerate all the core directives at once:\n   * \n   * ```\n   * import {coreDirectives} from 'angular2/angular2';\n   * import {OtherDirective} from 'myDirectives';\n   * \n   * @Component({\n   *  selector: 'my-component'\n   * })\n   * @View({\n   *   templateUrl: 'myComponent.html',\n   *   directives: [coreDirectives, OtherDirective]\n   * })\n   * export class MyComponent {\n   *   ...\n   * }\n   * ```",
        "* The `NgFor` directive instantiates a template once per item from an iterable. The context for\n   * each instantiated template inherits from the outer context with the given loop variable set\n   * to the current item from the iterable.\n   * \n   * It is possible to alias the `index` to a local variable that will be set to the current loop\n   * iteration in the template context.\n   * \n   * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:\n   * \n   * * When an item is added, a new instance of the template is added to the DOM.\n   * * When an item is removed, its template instance is removed from the DOM.\n   * * When items are reordered, their respective templates are reordered in the DOM.\n   * \n   * # Example\n   * \n   * ```\n   * <ul>\n   *   <li *ng-for=\"#error of errors; #i = index\">\n   *     Error {{i}} of {{errors.length}}: {{error.message}}\n   *   </li>\n   * </ul>\n   * ```\n   * \n   * # Syntax\n   * \n   * - `<li *ng-for=\"#item of items; #i = index\">...</li>`\n   * - `<li template=\"ng-for #item of items; #i = index\">...</li>`\n   * - `<template [ng-for] #item [ng-for-of]=\"items\" #i=\"index\"><li>...</li></template>`\n   * \n   * @exportedAs angular2/directives",
        "* Removes or recreates a portion of the DOM tree based on an {expression}.\n   * \n   * If the expression assigned to `ng-if` evaluates to a false value then the element\n   * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.\n   * \n   * # Example:\n   * \n   * ```\n   * <div *ng-if=\"errorCount > 0\" class=\"error\">\n   *   <!-- Error message displayed when the errorCount property on the current context is greater\n   * than 0. -->\n   *   {{errorCount}} errors detected\n   * </div>\n   * ```\n   * \n   * # Syntax\n   * \n   * - `<div *ng-if=\"condition\">...</div>`\n   * - `<div template=\"ng-if condition\">...</div>`\n   * - `<template [ng-if]=\"condition\"><div>...</div></template>`\n   * \n   * @exportedAs angular2/directives",
        "* The `NgNonBindable` directive tells Angular not to compile or bind the contents of the current\n   * DOM element. This is useful if the element contains what appears to be Angular directives and\n   * bindings but which should be ignored by Angular. This could be the case if you have a site that\n   * displays snippets of code, for instance.\n   * \n   * Example:\n   * \n   * ```\n   * <div>Normal: {{1 + 2}}</div> // output \"Normal: 3\"\n   * <div non-bindable>Ignored: {{1 + 2}}</div> // output \"Ignored: {{1 + 2}}\"\n   * ```\n   * \n   * @exportedAs angular2/directives",
        "* The `NgSwitch` directive is used to conditionally swap DOM structure on your template based on a\n   * scope expression.\n   * Elements within `NgSwitch` but without `NgSwitchWhen` or `NgSwitchDefault` directives will be\n   * preserved at the location as specified in the template.\n   * \n   * `NgSwitch` simply chooses nested elements and makes them visible based on which element matches\n   * the value obtained from the evaluated expression. In other words, you define a container element\n   * (where you place the directive), place an expression on the **`[ng-switch]=\"...\"` attribute**),\n   * define any inner elements inside of the directive and place a `[ng-switch-when]` attribute per\n   * element.\n   * The when attribute is used to inform NgSwitch which element to display when the expression is\n   * evaluated. If a matching expression is not found via a when attribute then an element with the\n   * default attribute is displayed.\n   * \n   * # Example:\n   * \n   * ```\n   * <ANY [ng-switch]=\"expression\">\n   *   <template [ng-switch-when]=\"whenExpression1\">...</template>\n   *   <template [ng-switch-when]=\"whenExpression1\">...</template>\n   *   <template [ng-switch-default]>...</template>\n   * </ANY>\n   * ```\n   * \n   * @exportedAs angular2/directives",
        "* Defines a case statement as an expression.\n   * \n   * If multiple `NgSwitchWhen` match the `NgSwitch` value, all of them are displayed.\n   * \n   * Example:\n   * \n   * ```\n   * // match against a context variable\n   * <template [ng-switch-when]=\"contextVariable\">...</template>\n   * \n   * // match against a constant string\n   * <template [ng-switch-when]=\"'stringValue'\">...</template>\n   * ```\n   * \n   * @exportedAs angular2/directives",
        "* Defines a default case statement.\n   * \n   * Default case statements are displayed when no `NgSwitchWhen` match the `ng-switch` value.\n   * \n   * Example:\n   * \n   * ```\n   * <template [ng-switch-default]>...</template>\n   * ```\n   * \n   * @exportedAs angular2/directives",
        "* Indicates that a Control is valid, i.e. that no errors exist in the input value.\n   * \n   * @exportedAs angular2/forms",
        "* Indicates that a Control is invalid, i.e. that an error exists in the input value.\n   * \n   * @exportedAs angular2/forms",
        "* Omitting from external API doc as this is really an abstract internal concept.",
        "* Defines a part of a form that cannot be divided into other controls.\n   * \n   * `Control` is one of the three fundamental building blocks used to define forms in Angular, along\n   * with\n   * <a href='ControlGroup'>ControlGroup</a> and <a href='ControlArray'>ControlArray</a>.\n   * \n   * @exportedAs angular2/forms",
        "* Defines a part of a form, of fixed length, that can contain other controls.\n   * \n   * A ControlGroup aggregates the values and errors of each <a href='Control'>Control</a> in the group. Thus, if\n   * one of the controls\n   * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,\n   * the entire group\n   * changes as well.\n   * \n   * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,\n   * along with\n   * <a href='Control'>Control</a> and <a href='ControlArray'>ControlArray</a>. <a href='ControlArray'>ControlArray</a> can also contain other controls,\n   * but is of variable\n   * length.\n   * \n   * @exportedAs angular2/forms",
        "* Defines a part of a form, of variable length, that can contain other controls.\n   * \n   * A `ControlArray` aggregates the values and errors of each <a href='Control'>Control</a> in the group. Thus, if\n   * one of the controls\n   * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,\n   * the entire group\n   * changes as well.\n   * \n   * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,\n   * along with\n   * <a href='Control'>Control</a> and <a href='ControlGroup'>ControlGroup</a>. <a href='ControlGroup'>ControlGroup</a> can also contain other controls,\n   * but is of fixed\n   * length.\n   * \n   * @exportedAs angular2/forms",
        "* Binds a control with the specified name to a DOM element.\n   * \n   * # Example\n   * \n   * In this example, we bind the login control to an input element. When the value of the input\n   * element\n   * changes, the value of\n   * the control will reflect that change. Likewise, if the value of the control changes, the input\n   * element reflects that\n   * change.\n   * \n   * Here we use <a href='/angular2/angular2/formDirectives'><code>formDirectives</code></a>, rather than importing each form directive individually, e.g.\n   * `ControlDirective`, `ControlGroupDirective`. This is just a shorthand for the same end result.\n   * \n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [formDirectives],\n   *      template:\n   *              \"<form [ng-form-model]='loginForm'>\" +\n   *              \"Login <input type='text' ng-control='login'>\" +\n   *              \"<button (click)=\"onLogin()\">Login</button>\" +\n   *              \"</form>\"\n   *      })\n   * class LoginComp {\n   *  loginForm:ControlGroup;\n   * \n   *  constructor() {\n   *    this.loginForm = new ControlGroup({\n   *      login: new Control(\"\"),\n   *    });\n   *  }\n   * \n   *  onLogin() {\n   *    // this.loginForm.value\n   *  }\n   * }\n   * \n   *  ```\n   * \n   * @exportedAs angular2/forms",
        "* Binds a control to a DOM element.\n   * \n   * # Example\n   * \n   * In this example, we bind the control to an input element. When the value of the input element\n   * changes, the value of\n   * the control will reflect that change. Likewise, if the value of the control changes, the input\n   * element reflects that\n   * change.\n   * \n   * Here we use <a href='/angular2/angular2/formDirectives'><code>formDirectives</code></a>, rather than importing each form directive individually, e.g.\n   * `ControlDirective`, `ControlGroupDirective`. This is just a shorthand for the same end result.\n   * \n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [formDirectives],\n   *      template: \"<input type='text' [ng-form-control]='loginControl'>\"\n   *      })\n   * class LoginComp {\n   *  loginControl:Control;\n   * \n   *  constructor() {\n   *    this.loginControl = new Control('');\n   *  }\n   * }\n   * \n   *  ```\n   * \n   * @exportedAs angular2/forms",
        "* A directive that bind a [ng-control] object to a DOM element.\n   * \n   * @exportedAs angular2/forms",
        "* Binds a ng-control group to a DOM element.\n   * \n   * # Example\n   * \n   * In this example, we create a ng-control group, and we bind the login and\n   * password controls to the login and password elements.\n   * \n   * Here we use <a href='/angular2/angular2/formDirectives'><code>formDirectives</code></a>, rather than importing each form directive individually, e.g.\n   * `ControlDirective`, `ControlGroupDirective`. This is just a shorthand for the same end result.\n   * \n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [formDirectives],\n   *      template:\n   *              \"<form [ng-form-model]='loginForm'>\" +\n   *              \"<div ng-control-group=\"credentials\">\n   *              \"Login <input type='text' ng-control='login'>\" +\n   *              \"Password <input type='password' ng-control='password'>\" +\n   *              \"<button (click)=\"onLogin()\">Login</button>\" +\n   *              \"</div>\"\n   *              \"</form>\"\n   *      })\n   * class LoginComp {\n   *  loginForm:ControlGroup;\n   * \n   *  constructor() {\n   *    this.loginForm = new ControlGroup({\n   *      credentials: new ControlGroup({\n   *        login: new Cntrol(\"\"),\n   *        password: new Control(\"\")\n   *      })\n   *    });\n   *  }\n   * \n   *  onLogin() {\n   *    // this.loginForm.value\n   *  }\n   * }\n   * \n   *  ```\n   * \n   * @exportedAs angular2/forms",
        "* Binds a control group to a DOM element.\n   * \n   * # Example\n   * \n   * In this example, we bind the control group to the form element, and we bind the login and\n   * password controls to the\n   * login and password elements.\n   * \n   * Here we use <a href='/angular2/angular2/formDirectives'><code>formDirectives</code></a>, rather than importing each form directive individually, e.g.\n   * `ControlDirective`, `ControlGroupDirective`. This is just a shorthand for the same end result.\n   * \n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [formDirectives],\n   *      template: \"<form [ng-form-model]='loginForm'>\" +\n   *              \"Login <input type='text' ng-control='login'>\" +\n   *              \"Password <input type='password' ng-control='password'>\" +\n   *              \"<button (click)=\"onLogin()\">Login</button>\" +\n   *              \"</form>\"\n   *      })\n   * class LoginComp {\n   *  loginForm:ControlGroup;\n   * \n   *  constructor() {\n   *    this.loginForm = new ControlGroup({\n   *      login: new Control(\"\"),\n   *      password: new Control(\"\")\n   *    });\n   *  }\n   * \n   *  onLogin() {\n   *    // this.loginForm.value\n   *  }\n   * }\n   * \n   *  ```\n   * \n   * @exportedAs angular2/forms",
        "* The default accessor for writing a value and listening to changes that is used by a\n   * <a href='Control'>Control</a> directive.\n   * \n   * This is the default strategy that Angular uses when no other accessor is applied.\n   * \n   *  # Example\n   *  ```\n   *  <input type=\"text\" [ng-form-control]=\"loginControl\">\n   *  ```\n   * \n   * @exportedAs angular2/forms",
        "* The accessor for writing a value and listening to changes on a checkbox input element.\n   * \n   * \n   *  # Example\n   *  ```\n   *  <input type=\"checkbox\" [ng-control]=\"rememberLogin\">\n   *  ```\n   * \n   * @exportedAs angular2/forms",
        "* The accessor for writing a value and listening to changes that is used by a\n   * <a href='Control'>Control</a> directive.\n   * \n   * This is the default strategy that Angular uses when no other accessor is applied.\n   * \n   *  # Example\n   *  ```\n   *  <input type=\"text\" [ng-control]=\"loginControl\">\n   *  ```\n   * \n   * @exportedAs angular2/forms",
        "* A list of all the form directives used as part of a `@View` annotation.\n   * \n   *  This is a shorthand for importing them each individually.\n   * \n   * @exportedAs angular2/forms",
        "* Provides a set of validators used by form controls.\n   * \n   * # Example\n   * \n   * ```\n   * var loginControl = new Control(\"\", Validators.required)\n   * ```\n   * \n   * @exportedAs angular2/forms",
        "* Creates a form object from a user-specified configuration.\n   * \n   * # Example\n   * \n   * ```\n   * import {Component, View, bootstrap} from 'angular2/angular2';\n   * import {FormBuilder, Validators, formDirectives, ControlGroup} from 'angular2/forms';\n   * \n   * @Component({\n   *   selector: 'login-comp',\n   *   appInjector: [\n   *     FormBuilder\n   *   ]\n   * })\n   * @View({\n   *   template: `\n   *     <form [control-group]=\"loginForm\">\n   *       Login <input control=\"login\">\n   * \n   *       <div control-group=\"passwordRetry\">\n   *         Password <input type=\"password\" control=\"password\">\n   *         Confirm password <input type=\"password\" control=\"passwordConfirmation\">\n   *       </div>\n   *     </form>\n   *   `,\n   *   directives: [\n   *     formDirectives\n   *   ]\n   * })\n   * class LoginComp {\n   *   loginForm: ControlGroup;\n   * \n   *   constructor(builder: FormBuilder) {\n   *     this.loginForm = builder.group({\n   *       login: [\"\", Validators.required],\n   * \n   *       passwordRetry: builder.group({\n   *         password: [\"\", Validators.required],\n   *         passwordConfirmation: [\"\", Validators.required]\n   *       })\n   *     });\n   *   }\n   * }\n   * \n   * bootstrap(LoginComp)\n   * ```\n   * \n   * This example creates a <a href='ControlGroup'>ControlGroup</a> that consists of a `login` <a href='Control'>Control</a>, and a\n   * nested\n   * <a href='ControlGroup'>ControlGroup</a> that defines a `password` and a `passwordConfirmation` <a href='Control'>Control</a>:\n   * \n   * ```\n   *  var loginForm = builder.group({\n   *    login: [\"\", Validators.required],\n   * \n   *    passwordRetry: builder.group({\n   *      password: [\"\", Validators.required],\n   *      passwordConfirmation: [\"\", Validators.required]\n   *    })\n   *  });\n   * \n   *  ```\n   * @exportedAs angular2/forms",
        "* A dependency injection container used for resolving dependencies.\n   * \n   * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n   * constructor dependencies.\n   * In typical use, application code asks for the dependencies in the constructor and they are\n   * resolved by the `Injector`.\n   * \n   * ## Example:\n   * \n   * Suppose that we want to inject an `Engine` into class `Car`, we would define it like this:\n   * \n   * ```javascript\n   * class Engine {\n   * }\n   * \n   * class Car {\n   *   constructor(@Inject(Engine) engine) {\n   *   }\n   * }\n   * \n   * ```\n   * \n   * Next we need to write the code that creates and instantiates the `Injector`. We then ask for the\n   * `root` object, `Car`, so that the `Injector` can recursively build all of that object's\n   * dependencies.\n   * \n   * ```javascript\n   * main() {\n   *   var injector = Injector.resolveAndCreate([Car, Engine]);\n   * \n   *   // Get a reference to the `root` object, which will recursively instantiate the tree.\n   *   var car = injector.get(Car);\n   * }\n   * ```\n   * Notice that we don't use the `new` operator because we explicitly want to have the `Injector`\n   * resolve all of the object's dependencies automatically.\n   * \n   * @exportedAs angular2/di",
        "* Retrieves an instance from the injector asynchronously. Used with asynchronous bindings.\n     * \n     * @param `token`: usually a `Type`. (Same as token used while setting up a binding).\n     * @returns a `Promise` which resolves to the instance represented by the token.",
        "* Creates a child injector and loads a new set of <a href='/angular2/angular2/ResolvedBinding'><code>ResolvedBinding</code></a>s into it.\n     * \n     * @param `bindings`: A sparse list of <a href='/angular2/angular2/ResolvedBinding'><code>ResolvedBinding</code></a>s.\n     * See `resolve` for the <a href='/angular2/angular2/Injector'><code>Injector</code></a>.\n     * @returns a new child <a href='/angular2/angular2/Injector'><code>Injector</code></a>.",
        "* Retrieves an instance from the injector.\n     * \n     * @param `token`: usually the `Type` of an object. (Same as the token used while setting up a\n     * binding).\n     * @returns an instance represented by the token. Throws if not found.",
        "* Retrieves an instance from the injector.\n     * \n     * @param `token`: usually a `Type`. (Same as the token used while setting up a binding).\n     * @returns an instance represented by the token. Returns `null` if not found.",
        "* Direct parent of this injector.",
        "* Creates a child injector and loads a new set of bindings into it.\n     * \n     * A resolution is a process of flattening multiple nested lists and converting individual\n     * bindings into a list of <a href='/angular2/angular2/ResolvedBinding'><code>ResolvedBinding</code></a>s. The resolution can be cached by `resolve`\n     * for the <a href='/angular2/angular2/Injector'><code>Injector</code></a> for performance-sensitive code.\n     * \n     * @param `bindings` can be a list of `Type`, <a href='/angular2/angular2/Binding'><code>Binding</code></a>, <a href='/angular2/angular2/ResolvedBinding'><code>ResolvedBinding</code></a>, or a\n     * recursive list of more bindings.",
        "* Describes how the <a href='/angular2/angular2/Injector'><code>Injector</code></a> should instantiate a given token.\n   * \n   * See <a href='/angular2/angular2/bind'><code>bind</code></a>.\n   * \n   * ## Example\n   * \n   * ```javascript\n   * var injector = Injector.resolveAndCreate([\n   *   new Binding(String, { toValue: 'Hello' })\n   * ]);\n   * \n   * expect(injector.get(String)).toEqual('Hello');\n   * ```\n   * \n   * @exportedAs angular2/di",
        "* Used in conjunction with `toFactory` or `toAsyncFactory` and specifies a set of dependencies\n     * (as `token`s) which should be injected into the factory function.\n     * \n     * ## Example\n     * \n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   new Binding(Number, { toFactory: () => { return 1+2; }}),\n     *   new Binding(String, { toFactory: (value) => { return \"Value: \" + value; },\n     *                         dependencies: [Number] })\n     * ]);\n     * \n     * expect(injector.get(Number)).toEqual(3);\n     * expect(injector.get(String)).toEqual('Value: 3');\n     * ```",
        "* Converts the <a href='/angular2/angular2/Binding'><code>Binding</code></a> into <a href='/angular2/angular2/ResolvedBinding'><code>ResolvedBinding</code></a>.\n     * \n     * <a href='/angular2/angular2/Injector'><code>Injector</code></a> internally only uses <a href='/angular2/angular2/ResolvedBinding'><code>ResolvedBinding</code></a>, <a href='/angular2/angular2/Binding'><code>Binding</code></a> contains\n     * convenience binding syntax.",
        "* Binds a key to the alias for an existing key.\n     * \n     * An alias means that <a href='/angular2/angular2/Injector'><code>Injector</code></a> returns the same instance as if the alias token was used.\n     * This is in contrast to `toClass` where a separate instance of `toClass` is returned.\n     * \n     * ## Example\n     * \n     * Becuse `toAlias` and `toClass` are often confused the example contains both use cases for easy\n     * comparison.\n     * \n     * ```javascript\n     * \n     * class Vehicle {}\n     * \n     * class Car extends Vehicle {}\n     * \n     * var injectorAlias = Injector.resolveAndCreate([\n     *   Car,\n     *   new Binding(Vehicle, { toAlias: Car })\n     * ]);\n     * var injectorClass = Injector.resolveAndCreate([\n     *   Car,\n     *   new Binding(Vehicle, { toClass: Car })\n     * ]);\n     * \n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n     * \n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n     * ```",
        "* Binds a key to a function which computes the value asynchronously.\n     * \n     * ## Example\n     * \n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   new Binding(Number, { toAsyncFactory: () => {\n     *     return new Promise((resolve) => resolve(1 + 2));\n     *   }}),\n     *   new Binding(String, { toFactory: (value) => { return \"Value: \" + value; },\n     *                         dependencies: [Number]})\n     * ]);\n     * \n     * injector.asyncGet(Number).then((v) => expect(v).toBe(3));\n     * injector.asyncGet(String).then((v) => expect(v).toBe('Value: 3'));\n     * ```\n     * \n     * The interesting thing to note is that event though `Number` has an async factory, the `String`\n     * factory function takes the resolved value. This shows that the <a href='/angular2/angular2/Injector'><code>Injector</code></a> delays\n     * executing the\n     * `String` factory\n     * until after the `Number` is resolved. This can only be done if the `token` is retrieved using\n     * the `asyncGet` API in the <a href='/angular2/angular2/Injector'><code>Injector</code></a>.",
        "* Binds an interface to an implementation / subclass.\n     * \n     * ## Example\n     * \n     * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy\n     * comparison.\n     * \n     * ```javascript\n     * \n     * class Vehicle {}\n     * \n     * class Car extends Vehicle {}\n     * \n     * var injectorClass = Injector.resolveAndCreate([\n     *   Car,\n     *   new Binding(Vehicle, { toClass: Car })\n     * ]);\n     * var injectorAlias = Injector.resolveAndCreate([\n     *   Car,\n     *   new Binding(Vehicle, { toAlias: Car })\n     * ]);\n     * \n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n     * \n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n     * ```",
        "* Binds a key to a function which computes the value.\n     * \n     * ## Example\n     * \n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   new Binding(Number, { toFactory: () => { return 1+2; }}),\n     *   new Binding(String, { toFactory: (value) => { return \"Value: \" + value; },\n     *                         dependencies: [Number] })\n     * ]);\n     * \n     * expect(injector.get(Number)).toEqual(3);\n     * expect(injector.get(String)).toEqual('Value: 3');\n     * ```",
        "* Binds a key to a value.\n     * \n     * ## Example\n     * \n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   new Binding(String, { toValue: 'Hello' })\n     * ]);\n     * \n     * expect(injector.get(String)).toEqual('Hello');\n     * ```",
        "* Token used when retrieving this binding. Usually the `Type`.",
        "* Helper class for the <a href='/angular2/angular2/bind'><code>bind</code></a> function.\n   * \n   * @exportedAs angular2/di",
        "* Binds a key to the alias for an existing key.\n     * \n     * An alias means that we will return the same instance as if the alias token was used. (This is\n     * in contrast to `toClass` where a separet instance of `toClass` will be returned.)\n     * \n     * ## Example\n     * \n     * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy\n     * comparison.\n     * \n     * ```javascript\n     * \n     * class Vehicle {}\n     * \n     * class Car extends Vehicle {}\n     * \n     * var injectorAlias = Injector.resolveAndCreate([\n     *   Car,\n     *   bind(Vehicle).toAlias(Car)\n     * ]);\n     * var injectorClass = Injector.resolveAndCreate([\n     *   Car,\n     *   bind(Vehicle).toClass(Car)\n     * ]);\n     * \n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n     * \n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n     * ```",
        "* Binds a key to a function which computes the value asynchronously.\n     * \n     * ## Example\n     * \n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   bind(Number).toAsyncFactory(() => {\n     *     return new Promise((resolve) => resolve(1 + 2));\n     *   }),\n     *   bind(String).toFactory((v) => { return \"Value: \" + v; }, [Number])\n     * ]);\n     * \n     * injector.asyncGet(Number).then((v) => expect(v).toBe(3));\n     * injector.asyncGet(String).then((v) => expect(v).toBe('Value: 3'));\n     * ```\n     * \n     * The interesting thing to note is that event though `Number` has an async factory, the `String`\n     * factory function takes the resolved value. This shows that the <a href='/angular2/angular2/Injector'><code>Injector</code></a> delays\n     * executing of the `String` factory\n     * until after the `Number` is resolved. This can only be done if the `token` is retrieved using\n     * the `asyncGet` API in the <a href='/angular2/angular2/Injector'><code>Injector</code></a>.",
        "* Binds an interface to an implementation / subclass.\n     * \n     * ## Example\n     * \n     * Because `toAlias` and `toClass` are often confused, the example contains both use cases for\n     * easy comparison.\n     * \n     * ```javascript\n     * \n     * class Vehicle {}\n     * \n     * class Car extends Vehicle {}\n     * \n     * var injectorClass = Injector.resolveAndCreate([\n     *   Car,\n     *   bind(Vehicle).toClass(Car)\n     * ]);\n     * var injectorAlias = Injector.resolveAndCreate([\n     *   Car,\n     *   bind(Vehicle).toAlias(Car)\n     * ]);\n     * \n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n     * \n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n     * ```",
        "* Binds a key to a function which computes the value.\n     * \n     * ## Example\n     * \n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   bind(Number).toFactory(() => { return 1+2; }),\n     *   bind(String).toFactory((v) => { return \"Value: \" + v; }, [Number])\n     * ]);\n     * \n     * expect(injector.get(Number)).toEqual(3);\n     * expect(injector.get(String)).toEqual('Value: 3');\n     * ```",
        "* Binds a key to a value.\n     * \n     * ## Example\n     * \n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   bind(String).toValue('Hello')\n     * ]);\n     * \n     * expect(injector.get(String)).toEqual('Hello');\n     * ```",
        "* An internal resolved representation of a <a href='/angular2/angular2/Binding'><code>Binding</code></a> used by the <a href='/angular2/angular2/Injector'><code>Injector</code></a>.\n   * \n   * A <a href='/angular2/angular2/Binding'><code>Binding</code></a> is resolved when it has a factory function. Binding to a class, alias, or\n   * value, are just convenience methods, as <a href='/angular2/angular2/Injector'><code>Injector</code></a> only operates on calling factory\n   * functions.\n   * \n   * @exportedAs angular2/di",
        "* Arguments (dependencies) to the `factory` function.",
        "* Factory function which can return an instance of an object represented by a key.",
        "* A key, usually a `Type`.",
        "* Specifies whether the `factory` function returns a `Promise`.",
        "* @private",
        "* Provides an API for imperatively constructing <a href='/angular2/angular2/Binding'><code>Binding</code></a>s.\n   * \n   * This is only relevant for JavaScript. See <a href='/angular2/angular2/BindingBuilder'><code>BindingBuilder</code></a>.\n   * \n   * ## Example\n   * \n   * ```javascript\n   * bind(MyInterface).toClass(MyClass)\n   * \n   * ```\n   * \n   * @exportedAs angular2/di",
        "* A unique object used for retrieving items from the <a href='/angular2/angular2/Injector'><code>Injector</code></a>.\n   * \n   * Keys have:\n   * - a system-wide unique `id`.\n   * - a `token`, usually the `Type` of the instance.\n   * \n   * Keys are used internally by the <a href='/angular2/angular2/Injector'><code>Injector</code></a> because their system-wide unique `id`s allow the\n   * injector to index in arrays rather than looking up items in maps.\n   * \n   * @exportedAs angular2/di",
        "* @private",
        "* Type literals is a Dart-only feature. This is here only so we can x-compile\n   * to multiple languages.",
        "* Thrown when trying to retrieve a dependency by `Key` from <a href='/angular2/angular2/Injector'><code>Injector</code></a>, but the\n   * <a href='/angular2/angular2/Injector'><code>Injector</code></a> does not have a <a href='/angular2/angular2/Binding'><code>Binding</code></a> for <a href='/angular2/angular2/Key'><code>Key</code></a>.\n   * \n   * @exportedAs angular2/di_errors",
        "* Base class for all errors arising from misconfigured bindings.\n   * \n   * @exportedAs angular2/di_errors",
        "* Thrown when trying to retrieve an async <a href='/angular2/angular2/Binding'><code>Binding</code></a> using the sync API.\n   * \n   * ## Example\n   * \n   * ```javascript\n   * var injector = Injector.resolveAndCreate([\n   *   bind(Number).toAsyncFactory(() => {\n   *     return new Promise((resolve) => resolve(1 + 2));\n   *   }),\n   *   bind(String).toFactory((v) => { return \"Value: \" + v; }, [String])\n   * ]);\n   * \n   * injector.asyncGet(String).then((v) => expect(v).toBe('Value: 3'));\n   * expect(() => {\n   *   injector.get(String);\n   * }).toThrowError(AsycBindingError);\n   * ```\n   * \n   * The above example throws because `String` depends on `Number` which is async. If any binding in\n   * the dependency graph is async then the graph can only be retrieved using the `asyncGet` API.\n   * \n   * @exportedAs angular2/di_errors",
        "* Thrown when dependencies form a cycle.\n   * \n   * ## Example:\n   * \n   * ```javascript\n   * class A {\n   *   constructor(b:B) {}\n   * }\n   * class B {\n   *   constructor(a:A) {}\n   * }\n   * ```\n   * \n   * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n   * \n   * @exportedAs angular2/di_errors",
        "* Thrown when a constructing type returns with an Error.\n   * \n   * The `InstantiationError` class contains the original error plus the dependency graph which caused\n   * this object to be instantiated.\n   * \n   * @exportedAs angular2/di_errors",
        "* Thrown when an object other then <a href='/angular2/angular2/Binding'><code>Binding</code></a> (or `Type`) is passed to <a href='/angular2/angular2/Injector'><code>Injector</code></a>\n   * creation.\n   * \n   * @exportedAs angular2/di_errors",
        "* Thrown when the class has no annotation information.\n   * \n   * Lack of annotation information prevents the <a href='/angular2/angular2/Injector'><code>Injector</code></a> from determining which dependencies\n   * need to be injected into the constructor.\n   * \n   * @exportedAs angular2/di_errors",
        "* @exportedAs angular2/di",
        "* A parameter annotation that specifies a dependency.\n   * \n   * ```\n   * class AComponent {\n   *   constructor(@Inject(MyService) aService:MyService) {}\n   * }\n   * ```\n   * \n   * @exportedAs angular2/di_annotations",
        "* A parameter annotation that specifies a `Promise` of a dependency.\n   * \n   * ```\n   * class AComponent {\n   *   constructor(@InjectPromise(MyService) aServicePromise:Promise<MyService>) {\n   *     aServicePromise.then(aService:MyService => ...);\n   *   }\n   * }\n   * ```\n   * \n   * @exportedAs angular2/di_annotations",
        "* A parameter annotation that creates a synchronous lazy dependency.\n   * \n   * ```\n   * class AComponent {\n   *   constructor(@InjectLazy(MyService) aServiceFn:Function) {\n   *     var aService:MyService = aServiceFn();\n   *   }\n   * }\n   * ```\n   * \n   * @exportedAs angular2/di_annotations",
        "* A parameter annotation that marks a dependency as optional. <a href='/angular2/angular2/Injector'><code>Injector</code></a> provides `null` if\n   * the dependency is not found.\n   * \n   * ```\n   * class AComponent {\n   *   constructor(@Optional() aService:MyService) {\n   *     this.aService = aService;\n   *   }\n   * }\n   * ```\n   * \n   * @exportedAs angular2/di_annotations",
        "* A marker annotation that marks a class as available to `Injector` for creation. Used by tooling\n   * for generating constructor stubs.\n   * \n   * ```\n   * class NeedsService {\n   *   constructor(svc:UsefulService) {}\n   * }\n   * \n   * @Injectable\n   * class UsefulService {}\n   * ```\n   * @exportedAs angular2/di_annotations",
        "* `DependencyAnnotation` is used by the framework to extend DI.\n   * \n   * Only annotations implementing `DependencyAnnotation` are added to the list of dependency\n   * properties.\n   * \n   * For example:\n   * \n   * ```\n   * class Parent extends DependencyAnnotation {}\n   * class NotDependencyProperty {}\n   * \n   * class AComponent {\n   *   constructor(@Parent @NotDependencyProperty aService:AService) {}\n   * }\n   * ```\n   * \n   * will create the following dependency:\n   * \n   * ```\n   * new Dependency(Key.get(AService), [new Parent()])\n   * ```\n   * \n   * The framework can use `new Parent()` to handle the `aService` dependency\n   * in a specific way.\n   * \n   * @exportedAs angular2/di_annotations",
        "* Allows to refer to references which are not yet defined.\n   * \n   * This situation arises when the key which we need te refer to for the purposes of DI is declared,\n   * but not yet defined.\n   * \n   * ## Example:\n   * \n   * ```\n   * class Door {\n   *   // Incorrect way to refer to a reference which is defined later.\n   *   // This fails because `Lock` is undefined at this point.\n   *   constructor(lock:Lock) { }\n   * \n   *   // Correct way to refer to a reference which is defined later.\n   *   // The reference needs to be captured in a closure.\n   *   constructor(@Inject(forwardRef(() => Lock)) lock:Lock) { }\n   * }\n   * \n   * // Only at this point the lock is defined.\n   * class Lock {\n   * }\n   * ```\n   * \n   * @exportedAs angular2/di",
        "* Lazily retrieve the reference value.\n   * \n   * See: <a href='/angular2/angular2/forwardRef'><code>forwardRef</code></a>\n   * \n   * @exportedAs angular2/di",
        "* General notes:\n   * \n   * The methods for creating / destroying views in this API are used in the AppViewHydrator\n   * and RenderViewHydrator as well.\n   * \n   * We are already parsing expressions on the render side:\n   * - this makes the ElementBinders more compact\n   *   (e.g. no need to distinguish interpolations from regular expressions from literals)\n   * - allows to retrieve which properties should be accessed from the event\n   *   by looking at the expression\n   * - we need the parse at least for the `template` attribute to match\n   *   directives in it\n   * - render compiler is not on the critical path as\n   *   its output will be stored in precompiled templates.",
        "* Compiles a single DomProtoView. Non recursive so that\n     * we don't need to serialize all possible components over the wire,\n     * but only the needed ones based on previous calls.",
        "* Creats a ProtoViewDto that contains a single nested component with the given componentId.",
        "* Attaches a componentView into the given hostView at the given element",
        "* Attaches a view into a ViewContainer (in the given parentView at the given element) at the\n     * given index.",
        "* Calls an action.\n     * Note: This will fail if the action was not mentioned previously as a host action\n     * in the ProtoView",
        "* Creates a root host view that includes the given element.\n     * @param {RenderProtoViewRef} hostProtoViewRef a RenderProtoViewRef of type\n     * ProtoViewDto.HOST_VIEW_TYPE\n     * @param {any} hostElementSelector css selector for the host element (will be queried against the\n     * main document)\n     * @return {RenderViewRef} the created view",
        "* Creates a regular view out of the given ProtoView",
        "* Dehydrates a view after it has been attached. Hydration/dehydration is used for reusing views\n     * inside of the view pool.",
        "* Destroys the given view after it has been dehydrated and detached",
        "* Detaches a componentView into the given hostView at the given element",
        "* Detaches a free view's element from the DOM.",
        "* Detaches a view into a ViewContainer (in the given parentView at the given element) at the\n     * given index.",
        "* Hydrates a view after it has been attached. Hydration/dehydration is used for reusing views\n     * inside of the view pool.",
        "* Sets a property on an element.\n     * Note: This will fail if the property was not mentioned previously as a host property\n     * in the ProtoView",
        "* Sets the dispatcher for all events of the given view",
        "* Sets the value of a text node.",
        "* A dispatcher for all events happening in a view.",
        "* Called when an event was triggered for a on-* attribute on an element.\n     * @param {Map<string, any>} locals Locals to be used to evaluate the\n     *   event expressions",
        "* Adds a child to the parent node. The child MUST NOT be a part of a tree.",
        "* Adds a child to the parent node after a given sibling.\n     * The child MUST NOT be a part of a tree and the sibling must be present.",
        "* Detaches a node from the parent's tree.",
        "* Difference between di.Injector and ElementInjector\n   * \n   * di.Injector:\n   *  - imperative based (can create child injectors imperativly)\n   *  - Lazy loading of code\n   *  - Component/App Level services which are usually not DOM Related.\n   * \n   * \n   * ElementInjector:\n   *   - ProtoBased (Injector structure fixed at compile time)\n   *   - understands @Ancestor, @Parent, @Child, @Descendent\n   *   - Fast\n   *   - Query mechanism for children\n   *   - 1:1 to DOM structure.\n   * \n   *  PERF BENCHMARK:\n   * http://www.williambrownstreet.net/blog/2014/04/faster-angularjs-rendering-angularjs-and-reactjs/",
        "* Whether the component instance is exported as $implicit.",
        "* Whether the element is exported as $implicit.",
        "* The variable name that will be set to $implicit for the element.",
        "* Get the name to which this element's $implicit is to be assigned.",
        "* Gets whether this element is exporting a component instance as $implicit.",
        "* Gets whether this element is exporting its element as $implicit.",
        "* Multiple expressions separated by a semicolon."
    ],
    "functions": [],
    "classes": [
        "AbstractChangeDetector",
        "ProtoRecord",
        "LifecycleEvent",
        "ControlContainerDirective",
        "Injectable",
        "BaseQueryList",
        "AppProtoView",
        "AppView",
        "AppViewContainer",
        "Visibility",
        "AppViewManager",
        "Observable",
        "EventEmitter",
        "DomRenderer",
        "ASTWithSource",
        "AST",
        "AstTransformer",
        "AccessMember",
        "LiteralArray",
        "ImplicitReceiver",
        "Lexer",
        "Parser",
        "Locals",
        "ExpressionChangedAfterItHasBeenChecked",
        "ChangeDetectionError",
        "ProtoChangeDetector",
        "ChangeDispatcher",
        "ChangeDetector",
        "ChangeDetection",
        "ChangeDetectorDefinition",
        "DynamicProtoChangeDetector",
        "JitProtoChangeDetector",
        "BindingRecord",
        "DirectiveIndex",
        "DirectiveRecord",
        "DynamicChangeDetector",
        "ChangeDetectorRef",
        "PipeRegistry",
        "WrappedValue",
        "Pipe",
        "PipeFactory",
        "NullPipe",
        "NullPipeFactory",
        "DynamicChangeDetection",
        "JitChangeDetection",
        "PreGeneratedChangeDetection",
        "ViewRef",
        "ProtoViewRef",
        "ViewContainerRef",
        "ElementRef",
        "NgZone",
        "SelfAnnotation",
        "AncestorAnnotation",
        "ParentAnnotation",
        "UnboundedAnnotation",
        "ViewAnnotation",
        "ApplicationRef",
        "QueryAnnotation",
        "AttributeAnnotation",
        "CompilerCache",
        "Compiler",
        "QueryList",
        "DirectiveResolver",
        "ComponentRef",
        "DynamicComponentLoader",
        "ComponentAnnotation",
        "DirectiveAnnotation",
        "CSSClass",
        "NgFor",
        "NgIf",
        "NgNonBindable",
        "SwitchView",
        "NgSwitch",
        "NgSwitchWhen",
        "NgSwitchDefault",
        "AbstractControl",
        "Control",
        "ControlGroup",
        "ControlArray",
        "ControlNameDirective",
        "FormControlDirective",
        "NgModelDirective",
        "ControlDirective",
        "ControlGroupDirective",
        "FormModelDirective",
        "TemplateDrivenFormDirective",
        "DefaultValueAccessor",
        "CheckboxControlValueAccessor",
        "SelectControlValueAccessor",
        "Validators",
        "RequiredValidatorDirective",
        "FormBuilder",
        "Injector",
        "Binding",
        "BindingBuilder",
        "ResolvedBinding",
        "Dependency",
        "Key",
        "KeyRegistry",
        "TypeLiteral",
        "NoBindingError",
        "AbstractBindingError",
        "AsyncBindingError",
        "CyclicDependencyError",
        "InstantiationError",
        "InvalidBindingError",
        "NoAnnotationError",
        "OpaqueToken",
        "InjectAnnotation",
        "InjectPromiseAnnotation",
        "InjectLazyAnnotation",
        "OptionalAnnotation",
        "InjectableAnnotation",
        "DependencyAnnotation",
        "EventBinding",
        "ElementBinder",
        "DirectiveBinder",
        "ProtoViewDto",
        "DirectiveMetadata",
        "RenderProtoViewRef",
        "RenderViewRef",
        "ViewDefinition",
        "RenderCompiler",
        "Renderer",
        "TreeNode",
        "DependencyWithVisibility",
        "DirectiveDependency",
        "DirectiveBinding",
        "PreBuiltObjects",
        "EventEmitterAccessor",
        "HostActionAccessor",
        "BindingData",
        "ProtoElementInjector",
        "ElementInjector",
        "EmptyExpr",
        "Chain",
        "Conditional",
        "SafeAccessMember",
        "KeyedAccess",
        "LiteralPrimitive",
        "LiteralMap",
        "Interpolation",
        "Binary",
        "PrefixNot",
        "Assignment",
        "MethodCall",
        "SafeMethodCall",
        "FunctionCall",
        "TemplateBinding",
        "AstVisitor"
    ]
}