{
    "identifiers": [
        "copy",
        "time",
        "keystoneauth1",
        "loading",
        "ks_loading",
        "neutronclient",
        "common",
        "exceptions",
        "neutron_client_exc",
        "neutronclient",
        "v2_0",
        "client",
        "clientv20",
        "oslo_log",
        "log",
        "logging",
        "oslo_utils",
        "excutils",
        "oslo_utils",
        "uuidutils",
        "six",
        "nova",
        "compute",
        "utils",
        "compute_utils",
        "nova",
        "conf",
        "nova",
        "exception",
        "nova",
        "i18n",
        "_",
        "nova",
        "network",
        "base_api",
        "nova",
        "network",
        "model",
        "network_model",
        "nova",
        "network",
        "neutronv2",
        "constants",
        "nova",
        "objects",
        "nova",
        "objects",
        "fields",
        "obj_fields",
        "nova",
        "pci",
        "manager",
        "pci_manager",
        "nova",
        "pci",
        "request",
        "pci_request",
        "nova",
        "pci",
        "utils",
        "pci_utils",
        "nova",
        "pci",
        "whitelist",
        "pci_whitelist",
        "nova",
        "policies",
        "servers",
        "servers_policies",
        "nova",
        "profiler",
        "nova",
        "service_auth",
        "nova",
        "utils",
        "nova",
        "conf",
        "CONF",
        "logging",
        "getLogger",
        "_ADMIN_AUTH",
        "_SESSION",
        "conf",
        "ks_loading",
        "load_auth_from_conf_options",
        "conf",
        "nova",
        "conf",
        "neutron",
        "NEUTRON_GROUP",
        "auth_plugin",
        "auth_plugin",
        "_",
        "conf",
        "neutron",
        "auth_type",
        "neutron_client_exc",
        "Unauthorized",
        "message",
        "err_msg",
        "port",
        "port",
        "get",
        "BINDING_PROFILE",
        "profiler",
        "trace_cls",
        "clientv20",
        "Client",
        "base_client",
        "admin",
        "base_client",
        "__dict__",
        "base_client",
        "admin",
        "name",
        "__getattribute__",
        "name",
        "callable",
        "obj",
        "__getattribute__",
        "obj",
        "obj",
        "obj",
        "args",
        "kwargs",
        "obj",
        "args",
        "kwargs",
        "neutron_client_exc",
        "Unauthorized",
        "admin",
        "exception",
        "Unauthorized",
        "LOG",
        "error",
        "exception",
        "NeutronAdminCredentialConfigurationInvalid",
        "neutron_client_exc",
        "Forbidden",
        "e",
        "exception",
        "Forbidden",
        "six",
        "text_type",
        "e",
        "ret",
        "wrapper",
        "context",
        "admin",
        "_ADMIN_AUTH",
        "_SESSION",
        "_SESSION",
        "ks_loading",
        "load_session_from_conf_options",
        "CONF",
        "nova",
        "conf",
        "neutron",
        "NEUTRON_GROUP",
        "admin",
        "context",
        "is_admin",
        "context",
        "auth_token",
        "_ADMIN_AUTH",
        "_load_auth_plugin",
        "CONF",
        "_ADMIN_AUTH",
        "context",
        "auth_token",
        "service_auth",
        "get_auth_plugin",
        "context",
        "auth_plugin",
        "exception",
        "Unauthorized",
        "session",
        "_SESSION",
        "auth",
        "auth_plugin",
        "global_request_id",
        "context",
        "global_id",
        "CONF",
        "neutron",
        "url",
        "client_args",
        "endpoint_override",
        "CONF",
        "neutron",
        "url",
        "region_name",
        "CONF",
        "neutron",
        "region_name",
        "utils",
        "get_ksa_adapter",
        "ksa_auth",
        "auth_plugin",
        "ksa_session",
        "_SESSION",
        "client_args",
        "service_type",
        "adap",
        "service_type",
        "service_name",
        "adap",
        "service_name",
        "adap",
        "region_name",
        "adap",
        "region_name",
        "endpoint_override",
        "adap",
        "endpoint_override",
        "ClientWrapper",
        "clientv20",
        "Client",
        "client_args",
        "admin",
        "admin",
        "context",
        "is_admin",
        "item",
        "items",
        "items_list_name",
        "instance",
        "item",
        "items",
        "present",
        "LOG",
        "warning",
        "item",
        "items_list_name",
        "items",
        "instance",
        "instance",
        "present",
        "port",
        "port",
        "get",
        "binding_vif_type",
        "network_model",
        "VIF_TYPE_BINDING_FAILED",
        "exception",
        "PortBindingFailed",
        "port_id",
        "port",
        "instance",
        "requested_ports_dict",
        "hypervisor_macs",
        "hypervisor_macs",
        "hypervisor_macs",
        "requested_ports_dict",
        "available_macs",
        "port",
        "requested_ports_dict",
        "values",
        "port",
        "mac",
        "hypervisor_macs",
        "LOG",
        "debug",
        "port",
        "mac",
        "hypervisor_macs",
        "instance",
        "instance",
        "available_macs",
        "discard",
        "mac",
        "available_macs",
        "base_api",
        "NetworkAPI",
        "API",
        "pci_whitelist",
        "Whitelist",
        "CONF",
        "pci",
        "passthrough_whitelist",
        "instance",
        "port_id",
        "port_profile",
        "admin_client",
        "admin_client",
        "update_port",
        "port_id",
        "BINDING_PROFILE",
        "port_profile",
        "updated_port",
        "ex",
        "excutils",
        "save_and_reraise_exception",
        "LOG",
        "error",
        "port_id",
        "ex",
        "instance",
        "instance",
        "context",
        "instance",
        "admin_client",
        "ports",
        "p",
        "ports",
        "_get_binding_profile",
        "p",
        "port_profile",
        "MIGRATING_ATTR",
        "port_profile",
        "port_profile",
        "MIGRATING_ATTR",
        "LOG",
        "debug",
        "p",
        "instance",
        "instance",
        "_update_port_with_migration_profile",
        "instance",
        "p",
        "port_profile",
        "admin_client",
        "context",
        "instance",
        "host",
        "admin_client",
        "ports",
        "p",
        "ports",
        "p",
        "get",
        "BINDING_HOST_ID",
        "host_id",
        "host",
        "_get_binding_profile",
        "p",
        "host",
        "_update_port_with_migration_profile",
        "instance",
        "p",
        "port_profile",
        "admin_client",
        "LOG",
        "debug",
        "p",
        "port_profile",
        "instance",
        "instance",
        "context",
        "instance",
        "host",
        "teardown",
        "host",
        "instance",
        "host",
        "host",
        "port_migrating",
        "teardown",
        "instance",
        "uuid",
        "instance",
        "project_id",
        "BINDING_HOST_ID",
        "instance",
        "host",
        "list_ports",
        "context",
        "search_opts",
        "data",
        "get_client",
        "context",
        "admin",
        "teardown",
        "_clear_migration_port_profile",
        "context",
        "instance",
        "admin_client",
        "ports",
        "port_migrating",
        "_setup_migration_port_profile",
        "context",
        "instance",
        "host",
        "admin_client",
        "ports",
        "context",
        "project_id",
        "net_ids",
        "neutron",
        "auto_allocate",
        "neutron",
        "get_client",
        "context",
        "net_ids",
        "net_ids",
        "neutron",
        "list_networks",
        "search_opts",
        "get",
        "project_id",
        "auto_allocate",
        "neutron",
        "list_networks",
        "search_opts",
        "get",
        "nets",
        "neutron",
        "list_networks",
        "search_opts",
        "get",
        "_ensure_requested_network_ordering",
        "x",
        "x",
        "nets",
        "net_ids",
        "nets",
        "port_client",
        "instance",
        "network_id",
        "fixed_ip",
        "security_group_ids",
        "instance",
        "uuid",
        "fixed_ip",
        "port_req_body",
        "fixed_ip",
        "port_req_body",
        "network_id",
        "port_req_body",
        "port_req_body",
        "instance",
        "project_id",
        "security_group_ids",
        "port_req_body",
        "security_group_ids",
        "port_client",
        "create_port",
        "port_req_body",
        "LOG",
        "warn",
        "port_response",
        "port_response",
        "port",
        "_ensure_no_port_binding_failure",
        "port",
        "exception",
        "PortBindingFailed",
        "excutils",
        "save_and_reraise_exception",
        "port_client",
        "delete_port",
        "port_id",
        "LOG",
        "debug",
        "port_id",
        "instance",
        "instance",
        "port",
        "neutron_client_exc",
        "InvalidIpForNetworkClient",
        "LOG",
        "warning",
        "fixed_ip",
        "network_id",
        "instance",
        "instance",
        "_",
        "fixed_ip",
        "network_id",
        "exception",
        "InvalidInput",
        "reason",
        "msg",
        "neutron_client_exc",
        "IpAddressInUseClient",
        "LOG",
        "warning",
        "fixed_ip",
        "instance",
        "instance",
        "_",
        "fixed_ip",
        "exception",
        "FixedIpAlreadyInUse",
        "message",
        "msg",
        "neutron_client_exc",
        "OverQuotaClient",
        "LOG",
        "warning",
        "port_req_body",
        "instance",
        "instance",
        "exception",
        "PortLimitExceeded",
        "neutron_client_exc",
        "IpAddressGenerationFailureClient",
        "LOG",
        "warning",
        "network_id",
        "instance",
        "instance",
        "exception",
        "NoMoreFixedIps",
        "net",
        "network_id",
        "neutron_client_exc",
        "NeutronClientException",
        "excutils",
        "save_and_reraise_exception",
        "LOG",
        "exception",
        "network_id",
        "instance",
        "instance",
        "port_client",
        "instance",
        "port_id",
        "port_req_body",
        "port_client",
        "update_port",
        "port_id",
        "port_req_body",
        "LOG",
        "warning",
        "port_response",
        "port_response",
        "_ensure_no_port_binding_failure",
        "port",
        "exception",
        "PortBindingFailed",
        "LOG",
        "debug",
        "port_id",
        "instance",
        "instance",
        "port",
        "neutron_client_exc",
        "MacAddressInUseClient",
        "port_req_body",
        "get",
        "port_req_body",
        "get",
        "LOG",
        "warning",
        "mac_address",
        "network_id",
        "instance",
        "instance",
        "exception",
        "PortInUse",
        "port_id",
        "mac_address",
        "neutron_client_exc",
        "HostNotCompatibleWithFixedIpsClient",
        "port_req_body",
        "get",
        "LOG",
        "warning",
        "network_id",
        "instance",
        "instance",
        "exception",
        "FixedIpInvalidOnHost",
        "port_id",
        "port_id",
        "staticmethod",
        "instance",
        "port_req_body",
        "available_macs",
        "available_macs",
        "available_macs",
        "exception",
        "PortNotFree",
        "instance",
        "instance",
        "uuid",
        "available_macs",
        "pop",
        "port_req_body",
        "mac_address",
        "mac_address",
        "context",
        "nets",
        "context",
        "can",
        "servers_policies",
        "NETWORK_ATTACH_EXTERNAL",
        "fatal",
        "net",
        "nets",
        "net",
        "get",
        "net",
        "get",
        "exception",
        "ExternalNetworkAttachForbidden",
        "network_uuid",
        "net",
        "context",
        "ports",
        "neutron",
        "port_client",
        "port_client",
        "get_client",
        "context",
        "admin",
        "port_id",
        "ports",
        "port_id",
        "port_req_body",
        "_show_port",
        "context",
        "port_id",
        "neutron_client",
        "neutron",
        "fields",
        "BINDING_PROFILE",
        "exception",
        "PortNotFound",
        "LOG",
        "debug",
        "port_id",
        "LOG",
        "exception",
        "port_id",
        "port",
        "get",
        "BINDING_PROFILE",
        "port",
        "get",
        "net_id",
        "networks",
        "networks",
        "get",
        "net_id",
        "neutron",
        "show_network",
        "net_id",
        "fields",
        "get",
        "network",
        "profile_key",
        "profile_key",
        "port_profile",
        "port_profile",
        "profile_key",
        "port_req_body",
        "port_profile",
        "_has_dns_extension",
        "network",
        "get",
        "port_req_body",
        "port_client",
        "update_port",
        "port_id",
        "port_req_body",
        "neutron_client_exc",
        "PortNotFoundClient",
        "LOG",
        "debug",
        "port_id",
        "LOG",
        "exception",
        "port_id",
        "_reset_port_dns_name",
        "network",
        "port_id",
        "neutron",
        "context",
        "instance",
        "neutron",
        "requested_networks",
        "attach",
        "requested_networks",
        "requested_networks",
        "auto_allocate",
        "request",
        "requested_networks",
        "request",
        "port_id",
        "_show_port",
        "context",
        "request",
        "port_id",
        "neutron_client",
        "neutron",
        "port",
        "instance",
        "project_id",
        "exception",
        "PortNotUsable",
        "port_id",
        "request",
        "port_id",
        "instance",
        "instance",
        "uuid",
        "port",
        "get",
        "exception",
        "PortInUse",
        "port_id",
        "request",
        "port_id",
        "port",
        "get",
        "port",
        "instance",
        "hostname",
        "exception",
        "PortNotUsableDNS",
        "port_id",
        "request",
        "port_id",
        "instance",
        "instance",
        "uuid",
        "value",
        "port",
        "hostname",
        "instance",
        "hostname",
        "_ensure_no_port_binding_failure",
        "port",
        "attach",
        "port",
        "get",
        "network_model",
        "VNIC_TYPE_NORMAL",
        "vnic_type",
        "network_model",
        "VNIC_TYPES_SRIOV",
        "exception",
        "AttachSRIOVPortNotSupported",
        "port_id",
        "port",
        "instance_uuid",
        "instance",
        "uuid",
        "port",
        "request",
        "port_id",
        "port",
        "request",
        "network_id",
        "ordered_networks",
        "append",
        "request",
        "ports",
        "ordered_networks",
        "security_groups",
        "security_groups",
        "security_groups",
        "DEFAULT_SECGROUP",
        "security_groups",
        "instance",
        "neutron",
        "security_groups",
        "len",
        "security_groups",
        "instance",
        "project_id",
        "neutron",
        "list_security_groups",
        "search_opts",
        "get",
        "security_group",
        "security_groups",
        "user_security_group",
        "user_security_groups",
        "user_security_group",
        "security_group",
        "name_match",
        "exception",
        "NoUniqueMatch",
        "_",
        "security_group",
        "user_security_group",
        "user_security_group",
        "security_group",
        "user_security_group",
        "name_match",
        "security_group_ids",
        "append",
        "name_match",
        "uuid_match",
        "security_group_ids",
        "append",
        "uuid_match",
        "exception",
        "SecurityGroupNotFound",
        "security_group_id",
        "security_group",
        "security_group_ids",
        "context",
        "instance",
        "neutron",
        "requested_networks",
        "ordered_networks",
        "requested_networks",
        "requested_networks",
        "auto_allocate",
        "request",
        "network_id",
        "request",
        "ordered_networks",
        "_get_available_networks",
        "context",
        "instance",
        "project_id",
        "net_ids",
        "neutron",
        "neutron",
        "auto_allocate",
        "auto_allocate",
        "nets",
        "requested_networks",
        "auto_allocate",
        "_auto_allocate_network",
        "instance",
        "neutron",
        "request",
        "requested_networks",
        "request",
        "port_id",
        "request",
        "network_id",
        "exception",
        "NetworkNotFound",
        "network_id",
        "request",
        "network_id",
        "requested_networks",
        "requested_networks",
        "is_single_unspecified",
        "requested_networks",
        "auto_allocate",
        "nets",
        "exception",
        "InterfaceAttachFailedNoNetwork",
        "project_id",
        "instance",
        "project_id",
        "len",
        "nets",
        "_",
        "exception",
        "NetworkAmbiguous",
        "msg",
        "ordered_networks",
        "append",
        "objects",
        "NetworkRequest",
        "network_id",
        "nets",
        "_check_external_network_attach",
        "context",
        "nets",
        "net",
        "net",
        "net",
        "nets",
        "context",
        "instance",
        "ordered_networks",
        "nets",
        "neutron",
        "security_group_ids",
        "request",
        "ordered_networks",
        "nets",
        "get",
        "request",
        "network_id",
        "network",
        "network",
        "get",
        "port_security_enabled",
        "network",
        "get",
        "LOG",
        "debug",
        "network",
        "instance",
        "instance",
        "exception",
        "SecurityGroupCannotBeApplied",
        "security_group_ids",
        "LOG",
        "debug",
        "network",
        "instance",
        "instance",
        "exception",
        "SecurityGroupCannotBeApplied",
        "request",
        "port_id",
        "_create_port_minimal",
        "neutron",
        "instance",
        "request",
        "network_id",
        "request",
        "address",
        "security_group_ids",
        "created_port",
        "created_port_ids",
        "append",
        "created_port_id",
        "requests_and_created_ports",
        "append",
        "request",
        "created_port_id",
        "excutils",
        "save_and_reraise_exception",
        "created_port_ids",
        "_delete_ports",
        "neutron",
        "instance",
        "created_port_ids",
        "requests_and_created_ports",
        "context",
        "instance",
        "vpn",
        "requested_networks",
        "macs",
        "security_groups",
        "bind_host_id",
        "attach",
        "LOG",
        "debug",
        "instance",
        "instance",
        "instance",
        "project_id",
        "_",
        "exception",
        "InvalidInput",
        "reason",
        "msg",
        "instance",
        "uuid",
        "get_client",
        "context",
        "_validate_requested_port_ids",
        "context",
        "instance",
        "neutron",
        "requested_networks",
        "attach",
        "attach",
        "_validate_requested_network_ids",
        "context",
        "instance",
        "neutron",
        "requested_networks",
        "ordered_networks",
        "nets",
        "LOG",
        "debug",
        "instance",
        "instance",
        "network_model",
        "NetworkInfo",
        "_clean_security_groups",
        "security_groups",
        "_process_security_groups",
        "instance",
        "neutron",
        "security_groups",
        "_create_ports_for_instance",
        "context",
        "instance",
        "ordered_networks",
        "nets",
        "neutron",
        "security_group_ids",
        "_filter_hypervisor_macs",
        "instance",
        "requested_ports_dict",
        "macs",
        "get_client",
        "context",
        "admin",
        "_update_ports_for_instance",
        "context",
        "instance",
        "neutron",
        "admin_client",
        "requests_and_created_ports",
        "nets",
        "bind_host_id",
        "available_macs",
        "requested_ports_dict",
        "get_instance_nw_info",
        "context",
        "instance",
        "networks",
        "ordered_nets",
        "port_ids",
        "ordered_port_ids",
        "admin_client",
        "admin_client",
        "preexisting_port_ids",
        "preexisting_port_ids",
        "update_cells",
        "network_model",
        "NetworkInfo",
        "vif",
        "vif",
        "nw_info",
        "vif",
        "created_port_ids",
        "preexisting_port_ids",
        "context",
        "instance",
        "neutron",
        "admin_client",
        "requests_and_created_ports",
        "nets",
        "bind_host_id",
        "available_macs",
        "requested_ports_dict",
        "admin_client",
        "request",
        "created_port_id",
        "requests_and_created_ports",
        "objects",
        "VirtualInterface",
        "context",
        "instance",
        "uuid",
        "request",
        "tag",
        "request",
        "nets",
        "get",
        "request",
        "network_id",
        "network",
        "nets_in_requested_order",
        "append",
        "network",
        "instance",
        "availability_zone",
        "instance",
        "uuid",
        "zone",
        "requested_ports_dict",
        "request",
        "port_id",
        "requested_ports_dict",
        "requested_ports_dict",
        "request",
        "port_id",
        "get",
        "BINDING_PROFILE",
        "port_req_body",
        "requested_ports_dict",
        "request",
        "port_id",
        "BINDING_PROFILE",
        "_populate_neutron_extension_values",
        "context",
        "instance",
        "request",
        "pci_request_id",
        "port_req_body",
        "network",
        "network",
        "neutron",
        "neutron",
        "bind_host_id",
        "bind_host_id",
        "_populate_pci_mac_address",
        "instance",
        "request",
        "pci_request_id",
        "port_req_body",
        "_populate_mac_address",
        "instance",
        "port_req_body",
        "available_macs",
        "created_port_id",
        "created_port_id",
        "created_port_ids",
        "append",
        "port_id",
        "request",
        "port_id",
        "ports_in_requested_order",
        "append",
        "port_id",
        "_update_port",
        "port_client",
        "instance",
        "port_id",
        "port_req_body",
        "updated_port",
        "updated_port",
        "port_id",
        "vifobj",
        "create",
        "created_vifs",
        "append",
        "vifobj",
        "created_port_id",
        "preexisting_port_ids",
        "append",
        "port_id",
        "_update_port_dns_name",
        "context",
        "instance",
        "network",
        "ports_in_requested_order",
        "neutron",
        "excutils",
        "save_and_reraise_exception",
        "_unbind_ports",
        "context",
        "preexisting_port_ids",
        "neutron",
        "port_client",
        "_delete_ports",
        "neutron",
        "instance",
        "created_port_ids",
        "vif",
        "created_vifs",
        "vif",
        "destroy",
        "nets_in_requested_order",
        "ports_in_requested_order",
        "preexisting_port_ids",
        "created_port_ids",
        "context",
        "neutron",
        "last_neutron_extension_sync",
        "time",
        "time",
        "last_neutron_extension_sync",
        "CONF",
        "neutron",
        "extension_sync_interval",
        "neutron",
        "get_client",
        "context",
        "neutron",
        "list_extensions",
        "time",
        "time",
        "extensions",
        "clear",
        "ext",
        "ext",
        "ext",
        "extensions_list",
        "context",
        "neutron",
        "_refresh_neutron_extensions_cache",
        "context",
        "neutron",
        "neutron",
        "constants",
        "MULTI_NET_EXT",
        "extensions",
        "constants",
        "DNS_INTEGRATION",
        "extensions",
        "context",
        "neutron",
        "_refresh_neutron_extensions_cache",
        "context",
        "neutron",
        "neutron",
        "constants",
        "QOS_QUEUE",
        "extensions",
        "context",
        "_refresh_neutron_extensions_cache",
        "context",
        "constants",
        "SUBSTR_PORT_FILTERING",
        "extensions",
        "pci_dev",
        "pci_whitelist",
        "get_devspec",
        "pci_dev",
        "dev_spec",
        "pci_dev",
        "vendor_id",
        "pci_dev",
        "product_id",
        "pci_dev",
        "address",
        "dev_spec",
        "get_tags",
        "get",
        "exception",
        "PciDeviceNotFound",
        "node_id",
        "pci_dev",
        "compute_node_id",
        "address",
        "pci_dev",
        "address",
        "instance",
        "pci_request_id",
        "port_req_body",
        "pci_request_id",
        "pci_manager",
        "get_instance_pci_devs",
        "instance",
        "pci_request_id",
        "pci_devices",
        "LOG",
        "error",
        "instance",
        "pci_devices",
        "instance",
        "instance",
        "exception",
        "PciDeviceNotFound",
        "_",
        "pci_request_id",
        "pci_devices",
        "pop",
        "port_req_body",
        "get",
        "BINDING_PROFILE",
        "port_req_body",
        "copy",
        "deepcopy",
        "port_req_body",
        "BINDING_PROFILE",
        "profile",
        "update",
        "_get_pci_device_profile",
        "pci_dev",
        "port_req_body",
        "profile",
        "staticmethod",
        "instance",
        "pci_request_id",
        "port_req_body",
        "pci_request_id",
        "pci_manager",
        "get_instance_pci_devs",
        "instance",
        "pci_request_id",
        "len",
        "pci_devs",
        "LOG",
        "error",
        "pci_request",
        "instance",
        "instance",
        "pci_devs",
        "pci_dev",
        "dev_type",
        "obj_fields",
        "PciDeviceType",
        "SRIOV_PF",
        "pci_utils",
        "get_mac_by_pci_address",
        "pci_dev",
        "address",
        "exception",
        "PciDeviceNotFoundById",
        "e",
        "LOG",
        "error",
        "pci_dev",
        "address",
        "e",
        "instance",
        "instance",
        "port_req_body",
        "mac",
        "context",
        "instance",
        "pci_request_id",
        "port_req_body",
        "network",
        "neutron",
        "bind_host_id",
        "_has_qos_queue_extension",
        "context",
        "neutron",
        "neutron",
        "instance",
        "get_flavor",
        "flavor",
        "get",
        "port_req_body",
        "rxtx_factor",
        "port_req_body",
        "bind_host_id",
        "_populate_neutron_binding_profile",
        "instance",
        "pci_request_id",
        "port_req_body",
        "_has_dns_extension",
        "network",
        "get",
        "port_req_body",
        "instance",
        "hostname",
        "context",
        "instance",
        "network",
        "port_id",
        "neutron",
        "_has_dns_extension",
        "network",
        "get",
        "instance",
        "hostname",
        "neutron",
        "update_port",
        "port_id",
        "port_req_body",
        "neutron_client_exc",
        "BadRequest",
        "LOG",
        "warning",
        "instance",
        "hostname",
        "instance",
        "instance",
        "_",
        "instance",
        "hostname",
        "exception",
        "InvalidInput",
        "reason",
        "msg",
        "network",
        "port_id",
        "neutron_client",
        "_has_dns_extension",
        "network",
        "get",
        "neutron_client",
        "update_port",
        "port_id",
        "port_req_body",
        "neutron_client_exc",
        "NeutronClientException",
        "LOG",
        "exception",
        "port_id",
        "neutron",
        "instance",
        "ports",
        "raise_if_fail",
        "port",
        "ports",
        "neutron",
        "delete_port",
        "port",
        "neutron_client_exc",
        "NeutronClientException",
        "e",
        "e",
        "status_code",
        "LOG",
        "warning",
        "port",
        "instance",
        "instance",
        "exceptions",
        "append",
        "e",
        "LOG",
        "warning",
        "port",
        "instance",
        "instance",
        "exc_info",
        "len",
        "exceptions",
        "raise_if_fail",
        "exceptions",
        "context",
        "instance",
        "kwargs",
        "LOG",
        "debug",
        "instance",
        "instance",
        "instance",
        "uuid",
        "get_client",
        "context",
        "neutron",
        "list_ports",
        "search_opts",
        "port",
        "port",
        "data",
        "get",
        "kwargs",
        "get",
        "isinstance",
        "requested_networks",
        "objects",
        "NetworkRequestList",
        "requested_networks",
        "as_tuples",
        "port_id",
        "nets",
        "fips",
        "port_id",
        "pci_request_id",
        "requested_networks",
        "ports_to_skip",
        "_get_preexisting_port_ids",
        "instance",
        "ports",
        "ports_to_skip",
        "_unbind_ports",
        "context",
        "ports_to_skip",
        "neutron",
        "_delete_ports",
        "neutron",
        "instance",
        "ports",
        "raise_if_fail",
        "objects",
        "VirtualInterface",
        "delete_by_instance_uuid",
        "context",
        "instance",
        "uuid",
        "base_api",
        "update_instance_cache_with_nw_info",
        "context",
        "instance",
        "network_model",
        "NetworkInfo",
        "context",
        "instance",
        "port_id",
        "network_id",
        "requested_ip",
        "bind_host_id",
        "tag",
        "objects",
        "NetworkRequestList",
        "objects",
        "objects",
        "NetworkRequest",
        "network_id",
        "network_id",
        "address",
        "requested_ip",
        "port_id",
        "port_id",
        "pci_request_id",
        "tag",
        "tag",
        "allocate_for_instance",
        "context",
        "instance",
        "vpn",
        "requested_networks",
        "requested_networks",
        "bind_host_id",
        "bind_host_id",
        "attach",
        "context",
        "instance",
        "port_id",
        "get_client",
        "context",
        "_get_preexisting_port_ids",
        "instance",
        "port_id",
        "preexisting_ports",
        "_unbind_ports",
        "context",
        "port_id",
        "neutron",
        "_delete_ports",
        "neutron",
        "instance",
        "port_id",
        "raise_if_fail",
        "objects",
        "VirtualInterface",
        "get_by_uuid",
        "context",
        "port_id",
        "vif",
        "vif",
        "vif",
        "tag",
        "_delete_nic_metadata",
        "instance",
        "vif",
        "vif",
        "destroy",
        "LOG",
        "debug",
        "port_id",
        "instance",
        "instance",
        "get_instance_nw_info",
        "context",
        "instance",
        "instance",
        "vif",
        "device",
        "instance",
        "device_metadata",
        "devices",
        "isinstance",
        "device",
        "objects",
        "NetworkInterfaceMetadata",
        "device",
        "mac",
        "vif",
        "address",
        "instance",
        "device_metadata",
        "devices",
        "remove",
        "device",
        "instance",
        "save",
        "context",
        "search_opts",
        "get_client",
        "context",
        "list_ports",
        "search_opts",
        "context",
        "port_id",
        "port",
        "_show_port",
        "context",
        "port_id",
        "context",
        "port_id",
        "neutron_client",
        "fields",
        "neutron_client",
        "get_client",
        "context",
        "fields",
        "neutron_client",
        "show_port",
        "port_id",
        "fields",
        "fields",
        "neutron_client",
        "show_port",
        "port_id",
        "result",
        "get",
        "neutron_client_exc",
        "PortNotFoundClient",
        "exception",
        "PortNotFound",
        "port_id",
        "port_id",
        "neutron_client_exc",
        "Unauthorized",
        "exception",
        "Forbidden",
        "neutron_client_exc",
        "NeutronClientException",
        "exc",
        "_",
        "port_id",
        "exc",
        "exception",
        "NovaException",
        "message",
        "msg",
        "context",
        "instance",
        "networks",
        "port_ids",
        "admin_client",
        "preexisting_port_ids",
        "refresh_vif_id",
        "kwargs",
        "LOG",
        "debug",
        "instance",
        "instance",
        "compute_utils",
        "refresh_info_cache_for_instance",
        "context",
        "instance",
        "_build_network_info_model",
        "context",
        "instance",
        "networks",
        "port_ids",
        "admin_client",
        "preexisting_port_ids",
        "refresh_vif_id",
        "network_model",
        "NetworkInfo",
        "hydrate",
        "nw_info",
        "context",
        "instance",
        "networks",
        "port_ids",
        "neutron",
        "networks",
        "port_ids",
        "port_ids",
        "networks",
        "_",
        "exception",
        "NovaException",
        "message",
        "message",
        "instance",
        "get_network_info",
        "port_ids",
        "iface",
        "iface",
        "ifaces",
        "iface",
        "iface",
        "ifaces",
        "networks",
        "_get_available_networks",
        "context",
        "instance",
        "project_id",
        "net_ids",
        "neutron",
        "network",
        "network",
        "networks",
        "networks",
        "iface",
        "iface",
        "iface",
        "iface",
        "ifaces",
        "_is_not_duplicate",
        "iface",
        "networks_ids",
        "instance",
        "iface",
        "iface",
        "ifaces",
        "_is_not_duplicate",
        "iface",
        "port_ids",
        "instance",
        "port_ids",
        "networks",
        "port_ids",
        "base_api",
        "refresh_cache",
        "context",
        "instance",
        "network_id",
        "get_client",
        "context",
        "network_id",
        "neutron",
        "list_subnets",
        "search_opts",
        "data",
        "get",
        "ipam_subnets",
        "exception",
        "NetworkNotFoundForInstance",
        "instance_id",
        "instance",
        "uuid",
        "instance",
        "availability_zone",
        "instance",
        "uuid",
        "zone",
        "network_id",
        "neutron",
        "list_ports",
        "search_opts",
        "data",
        "p",
        "ports",
        "subnet",
        "ipam_subnets",
        "p",
        "fixed_ips",
        "append",
        "subnet",
        "fixed_ips",
        "neutron",
        "update_port",
        "p",
        "port_req_body",
        "_get_instance_nw_info",
        "context",
        "instance",
        "ex",
        "LOG",
        "debug",
        "msg",
        "p",
        "subnet",
        "ex",
        "instance",
        "instance",
        "exception",
        "NetworkNotFoundForInstance",
        "instance_id",
        "instance",
        "uuid",
        "base_api",
        "refresh_cache",
        "context",
        "instance",
        "address",
        "get_client",
        "context",
        "instance",
        "availability_zone",
        "instance",
        "uuid",
        "zone",
        "address",
        "neutron",
        "list_ports",
        "search_opts",
        "data",
        "p",
        "ports",
        "p",
        "fixed_ip",
        "fixed_ips",
        "fixed_ip",
        "address",
        "new_fixed_ips",
        "append",
        "fixed_ip",
        "new_fixed_ips",
        "neutron",
        "update_port",
        "p",
        "port_req_body",
        "ex",
        "LOG",
        "debug",
        "msg",
        "p",
        "ex",
        "instance",
        "instance",
        "_get_instance_nw_info",
        "context",
        "instance",
        "exception",
        "FixedIpNotFoundForSpecificInstance",
        "instance_uuid",
        "instance",
        "uuid",
        "ip",
        "address",
        "context",
        "neutron",
        "net_id",
        "_has_multi_provider_extension",
        "context",
        "neutron",
        "neutron",
        "neutron",
        "show_network",
        "net_id",
        "fields",
        "get",
        "network",
        "get",
        "net",
        "segments",
        "net",
        "get",
        "phynet_name",
        "phynet_name",
        "segments",
        "_",
        "net_id",
        "exception",
        "NovaException",
        "message",
        "msg",
        "neutron",
        "show_network",
        "net_id",
        "fields",
        "get",
        "net",
        "get",
        "phynet_name",
        "context",
        "neutron",
        "port_id",
        "_show_port",
        "context",
        "port_id",
        "neutron_client",
        "neutron",
        "fields",
        "port",
        "get",
        "network_model",
        "VNIC_TYPE_NORMAL",
        "vnic_type",
        "network_model",
        "VNIC_TYPES_SRIOV",
        "port",
        "_get_phynet_info",
        "context",
        "neutron",
        "net_id",
        "vnic_type",
        "phynet_name",
        "context",
        "pci_requests",
        "requested_networks",
        "requested_networks",
        "requested_networks",
        "no_allocate",
        "get_client",
        "context",
        "admin",
        "request_net",
        "requested_networks",
        "network_model",
        "VNIC_TYPE_NORMAL",
        "request_net",
        "port_id",
        "_get_port_vnic_info",
        "context",
        "neutron",
        "request_net",
        "port_id",
        "vnic_type",
        "network_model",
        "VNIC_TYPES_SRIOV",
        "pci_request",
        "PCI_NET_TAG",
        "phynet_name",
        "pci_request",
        "DEVICE_TYPE_FOR_VNIC_TYPE",
        "get",
        "vnic_type",
        "dev_type",
        "pci_request",
        "PCI_DEVICE_TYPE_TAG",
        "dev_type",
        "objects",
        "InstancePCIRequest",
        "count",
        "spec",
        "spec",
        "request_id",
        "uuidutils",
        "generate_uuid",
        "pci_requests",
        "requests",
        "append",
        "request",
        "request",
        "request_id",
        "pci_request_id",
        "context",
        "neutron",
        "neutron",
        "validate_auto_allocated_topology_requirements",
        "context",
        "project_id",
        "LOG",
        "debug",
        "context",
        "project_id",
        "neutron_client_exc",
        "Conflict",
        "ex",
        "LOG",
        "debug",
        "six",
        "text_type",
        "ex",
        "instance",
        "neutron",
        "instance",
        "project_id",
        "LOG",
        "debug",
        "project_id",
        "instance",
        "instance",
        "neutron",
        "get_auto_allocated_topology",
        "project_id",
        "neutron_client_exc",
        "Conflict",
        "exception",
        "UnableToAutoAllocateNetwork",
        "project_id",
        "project_id",
        "neutron",
        "show_network",
        "topology",
        "neutron_client_exc",
        "NetworkNotFoundClient",
        "LOG",
        "error",
        "topology",
        "instance",
        "instance",
        "exception",
        "UnableToAutoAllocateNetwork",
        "project_id",
        "project_id",
        "LOG",
        "debug",
        "network",
        "instance",
        "instance",
        "network",
        "context",
        "neutron",
        "requested_networks",
        "requested_networks",
        "isinstance",
        "requested_networks",
        "objects",
        "NetworkRequestList",
        "from_tuples",
        "requested_networks",
        "requested_networks",
        "len",
        "requested_networks",
        "requested_networks",
        "auto_allocate",
        "_get_available_networks",
        "context",
        "context",
        "project_id",
        "neutron",
        "neutron",
        "len",
        "nets",
        "_",
        "exception",
        "NetworkAmbiguous",
        "msg",
        "nets",
        "requested_networks",
        "requested_networks",
        "auto_allocate",
        "LOG",
        "debug",
        "context",
        "project_id",
        "_can_auto_allocate_network",
        "context",
        "neutron",
        "exception",
        "UnableToAutoAllocateNetwork",
        "project_id",
        "context",
        "project_id",
        "request",
        "requested_networks",
        "request",
        "port_id",
        "_show_port",
        "context",
        "request",
        "port_id",
        "neutron_client",
        "neutron",
        "port",
        "get",
        "exception",
        "PortInUse",
        "port_id",
        "request",
        "port_id",
        "port",
        "get",
        "deferred_ip",
        "port",
        "get",
        "exception",
        "PortRequiresFixedIP",
        "port_id",
        "request",
        "port_id",
        "port",
        "ports_needed_per_instance",
        "net_ids_requested",
        "append",
        "request",
        "network_id",
        "request",
        "address",
        "request",
        "network_id",
        "request",
        "address",
        "neutron",
        "list_ports",
        "search_opts",
        "existing_ports",
        "existing_ports",
        "exception",
        "FixedIpAlreadyInUse",
        "address",
        "request",
        "address",
        "instance_uuid",
        "i_uuid",
        "net_ids_requested",
        "_get_available_networks",
        "context",
        "context",
        "project_id",
        "net_ids_requested",
        "neutron",
        "neutron",
        "net",
        "nets",
        "net",
        "get",
        "exception",
        "NetworkRequiresSubnet",
        "network_uuid",
        "net",
        "len",
        "nets",
        "len",
        "net_ids_requested",
        "net_ids_requested",
        "net",
        "net",
        "nets",
        "requested_netid_set",
        "returned_netid_set",
        "lostid_set",
        "_id",
        "lostid_set",
        "id_str",
        "id_str",
        "_id",
        "_id",
        "exception",
        "NetworkNotFound",
        "network_id",
        "id_str",
        "ports_needed_per_instance",
        "context",
        "requested_networks",
        "num_instances",
        "LOG",
        "debug",
        "requested_networks",
        "get_client",
        "context",
        "_ports_needed_per_instance",
        "context",
        "neutron",
        "requested_networks",
        "ports_needed_per_instance",
        "neutron",
        "show_quota",
        "context",
        "project_id",
        "quotas",
        "get",
        "num_instances",
        "tenant_id",
        "context",
        "project_id",
        "fields",
        "neutron",
        "list_ports",
        "quotas",
        "get",
        "len",
        "ports",
        "free_ports",
        "_",
        "len",
        "ports",
        "quotas",
        "get",
        "exception",
        "PortLimitExceeded",
        "msg",
        "ports_needed_per_instance",
        "num_instances",
        "free_ports",
        "ports_needed",
        "num_instances",
        "free_ports",
        "ports_needed_per_instance",
        "num_instances",
        "context",
        "address",
        "address",
        "get_client",
        "context",
        "list_ports",
        "search_opts",
        "data",
        "get",
        "port",
        "port",
        "ports",
        "port",
        "client",
        "instance",
        "address",
        "instance",
        "availability_zone",
        "instance",
        "uuid",
        "zone",
        "client",
        "list_ports",
        "search_opts",
        "data",
        "p",
        "ports",
        "ip",
        "p",
        "ip",
        "address",
        "p",
        "port_id",
        "exception",
        "FixedIpNotFoundForAddress",
        "address",
        "address",
        "port_id",
        "base_api",
        "refresh_cache",
        "context",
        "instance",
        "floating_address",
        "fixed_address",
        "affect_auto_assigned",
        "get_client",
        "context",
        "_get_port_id_by_fixed_address",
        "client",
        "instance",
        "fixed_address",
        "_get_floating_ip_by_address",
        "client",
        "floating_address",
        "port_id",
        "fixed_address",
        "client",
        "update_floatingip",
        "fip",
        "param",
        "neutron_client_exc",
        "Conflict",
        "e",
        "exception",
        "FloatingIpAssociateFailed",
        "six",
        "text_type",
        "e",
        "fip",
        "_show_port",
        "context",
        "fip",
        "neutron_client",
        "client",
        "port",
        "address",
        "floating_address",
        "instance_id",
        "orig_instance_uuid",
        "LOG",
        "info",
        "msg_dict",
        "instance",
        "instance",
        "objects",
        "Instance",
        "get_by_uuid",
        "context",
        "orig_instance_uuid",
        "base_api",
        "update_instance_cache_with_nw_info",
        "context",
        "orig_instance",
        "context",
        "get_client",
        "context",
        "client",
        "list_networks",
        "get",
        "network",
        "networks",
        "network_objs",
        "append",
        "objects",
        "Network",
        "context",
        "context",
        "name",
        "network",
        "label",
        "network",
        "uuid",
        "network",
        "objects",
        "NetworkList",
        "context",
        "context",
        "objects",
        "network_objs",
        "context",
        "network_uuid",
        "get_client",
        "context",
        "client",
        "show_network",
        "network_uuid",
        "get",
        "neutron_client_exc",
        "NetworkNotFoundClient",
        "exception",
        "NetworkNotFound",
        "network_id",
        "network_uuid",
        "objects",
        "Network",
        "context",
        "context",
        "name",
        "network",
        "label",
        "network",
        "uuid",
        "network",
        "net_obj",
        "context",
        "network_uuid",
        "NotImplementedError",
        "context",
        "network_uuid",
        "NotImplementedError",
        "context",
        "network_uuid",
        "host",
        "base_api",
        "SENTINEL",
        "project",
        "base_api",
        "SENTINEL",
        "NotImplementedError",
        "context",
        "id",
        "NotImplementedError",
        "context",
        "address",
        "_get_instance_uuids_by_ip",
        "context",
        "address",
        "len",
        "uuid_maps",
        "uuid_maps",
        "uuid_maps",
        "exception",
        "FixedIpNotFoundForAddress",
        "address",
        "address",
        "exception",
        "FixedIpAssociatedWithMultipleInstances",
        "address",
        "address",
        "client",
        "network_id",
        "network_id",
        "client",
        "show_network",
        "network_id",
        "pool",
        "pool",
        "context",
        "client",
        "port_id",
        "port_id",
        "_show_port",
        "context",
        "port_id",
        "neutron_client",
        "client",
        "port",
        "port",
        "client",
        "_get_floating_ip_pools",
        "client",
        "i",
        "i",
        "i",
        "pools",
        "client",
        "project_id",
        "project_id",
        "project_id",
        "client",
        "list_ports",
        "search_opts",
        "p",
        "p",
        "p",
        "ports",
        "context",
        "id",
        "get_client",
        "context",
        "client",
        "show_floatingip",
        "id",
        "neutron_client_exc",
        "NeutronClientException",
        "e",
        "e",
        "status_code",
        "exception",
        "FloatingIpNotFound",
        "id",
        "id",
        "excutils",
        "save_and_reraise_exception",
        "LOG",
        "exception",
        "id",
        "_setup_net_dict",
        "client",
        "fip",
        "_setup_port_dict",
        "context",
        "client",
        "fip",
        "_make_floating_ip_obj",
        "context",
        "fip",
        "pool_dict",
        "port_dict",
        "client",
        "project_id",
        "constants",
        "NET_EXTERNAL",
        "project_id",
        "search_opts",
        "update",
        "project_id",
        "client",
        "list_networks",
        "search_opts",
        "data",
        "context",
        "get_client",
        "context",
        "_get_floating_ip_pools",
        "client",
        "n",
        "n",
        "n",
        "pools",
        "context",
        "fip",
        "pool_dict",
        "port_dict",
        "pool_dict",
        "fip",
        "objects",
        "floating_ip",
        "NeutronFloatingIP",
        "id",
        "fip",
        "address",
        "fip",
        "pool",
        "pool",
        "pool",
        "project_id",
        "fip",
        "fixed_ip_id",
        "fip",
        "fip",
        "objects",
        "FixedIP",
        "address",
        "fip",
        "fip",
        "port_dict",
        "fip",
        "objects",
        "Instance",
        "context",
        "context",
        "uuid",
        "instance_uuid",
        "floating",
        "fixed_ip",
        "floating",
        "fixed_ip",
        "instance_uuid",
        "floating",
        "context",
        "address",
        "get_client",
        "context",
        "_get_floating_ip_by_address",
        "client",
        "address",
        "_setup_net_dict",
        "client",
        "fip",
        "_setup_port_dict",
        "context",
        "client",
        "fip",
        "_make_floating_ip_obj",
        "context",
        "fip",
        "pool_dict",
        "port_dict",
        "context",
        "get_client",
        "context",
        "context",
        "project_id",
        "_safe_get_floating_ips",
        "client",
        "tenant_id",
        "project_id",
        "fips",
        "_setup_pools_dict",
        "client",
        "_setup_ports_dict",
        "client",
        "project_id",
        "_make_floating_ip_obj",
        "context",
        "fip",
        "pool_dict",
        "port_dict",
        "fip",
        "fips",
        "context",
        "address",
        "get_client",
        "context",
        "_get_floating_ip_by_address",
        "client",
        "address",
        "fip",
        "_show_port",
        "context",
        "fip",
        "neutron_client",
        "client",
        "exception",
        "PortNotFound",
        "LOG",
        "debug",
        "fip",
        "port",
        "context",
        "instance",
        "NotImplementedError",
        "context",
        "mac_address",
        "NotImplementedError",
        "client",
        "name_or_id",
        "constants",
        "NET_EXTERNAL",
        "uuidutils",
        "is_uuid_like",
        "name_or_id",
        "search_opts",
        "update",
        "name_or_id",
        "search_opts",
        "update",
        "name_or_id",
        "client",
        "list_networks",
        "search_opts",
        "data",
        "len",
        "nets",
        "nets",
        "len",
        "nets",
        "exception",
        "FloatingIpPoolNotFound",
        "_",
        "name_or_id",
        "exception",
        "NovaException",
        "message",
        "msg",
        "CONF",
        "default_floating_pool",
        "LOG",
        "warning",
        "CONF",
        "default_floating_pool",
        "CONF",
        "neutron",
        "default_floating_pool",
        "context",
        "pool",
        "get_client",
        "context",
        "pool",
        "_get_default_floating_ip_pool_name",
        "_get_floating_ip_pool_id_by_name_or_id",
        "client",
        "pool",
        "pool_id",
        "client",
        "create_floatingip",
        "param",
        "neutron_client_exc",
        "IpAddressGenerationFailureClient",
        "neutron_client_exc",
        "ExternalIpAddressExhaustedClient",
        "e",
        "exception",
        "NoMoreFloatingIps",
        "six",
        "text_type",
        "e",
        "neutron_client_exc",
        "OverQuotaClient",
        "e",
        "exception",
        "FloatingIpLimitExceeded",
        "six",
        "text_type",
        "e",
        "neutron_client_exc",
        "BadRequest",
        "e",
        "exception",
        "FloatingIpBadRequest",
        "six",
        "text_type",
        "e",
        "fip",
        "client",
        "kwargs",
        "client",
        "list_floatingips",
        "kwargs",
        "neutron_client_exc",
        "NotFound",
        "neutron_client_exc",
        "NeutronClientException",
        "e",
        "e",
        "status_code",
        "excutils",
        "save_and_reraise_exception",
        "LOG",
        "exception",
        "join",
        "k",
        "v",
        "k",
        "v",
        "kwargs",
        "items",
        "client",
        "address",
        "address",
        "exception",
        "FloatingIpNotFoundForAddress",
        "address",
        "address",
        "_safe_get_floating_ips",
        "client",
        "floating_ip_address",
        "address",
        "len",
        "fips",
        "exception",
        "FloatingIpNotFoundForAddress",
        "address",
        "address",
        "len",
        "fips",
        "exception",
        "FloatingIpMultipleFoundForAddress",
        "address",
        "address",
        "fips",
        "client",
        "fixed_ip",
        "port",
        "_safe_get_floating_ips",
        "client",
        "fixed_ip_address",
        "fixed_ip",
        "port_id",
        "port",
        "context",
        "address",
        "affect_auto_assigned",
        "_release_floating_ip",
        "context",
        "address",
        "context",
        "instance",
        "floating_ip",
        "base_api",
        "refresh_cache",
        "context",
        "instance",
        "floating_ip",
        "_release_floating_ip",
        "context",
        "floating_ip",
        "raise_if_associated",
        "instance",
        "_release_floating_ip_and_refresh_cache",
        "context",
        "instance",
        "floating_ip",
        "_release_floating_ip",
        "context",
        "floating_ip",
        "raise_if_associated",
        "context",
        "address",
        "raise_if_associated",
        "get_client",
        "context",
        "_get_floating_ip_by_address",
        "client",
        "address",
        "raise_if_associated",
        "fip",
        "exception",
        "FloatingIpAssociated",
        "address",
        "address",
        "client",
        "delete_floatingip",
        "fip",
        "neutron_client_exc",
        "NotFound",
        "exception",
        "FloatingIpNotFoundForAddress",
        "address",
        "address",
        "base_api",
        "refresh_cache",
        "context",
        "instance",
        "address",
        "affect_auto_assigned",
        "get_client",
        "context",
        "_get_floating_ip_by_address",
        "client",
        "address",
        "client",
        "update_floatingip",
        "fip",
        "context",
        "instance",
        "migration",
        "context",
        "instance",
        "migration",
        "_update_port_binding_for_instance",
        "context",
        "instance",
        "migration",
        "migration",
        "migration",
        "context",
        "project_id",
        "network_uuid",
        "NotImplementedError",
        "client",
        "port",
        "fixed_ip",
        "port",
        "network_model",
        "FixedIP",
        "address",
        "fixed_ip",
        "_get_floating_ips_by_fixed_and_port",
        "client",
        "fixed_ip",
        "port",
        "ip",
        "floats",
        "network_model",
        "IP",
        "address",
        "ip",
        "add_floating_ip",
        "fip",
        "network_IPs",
        "append",
        "network_IPs",
        "context",
        "port",
        "network_IPs",
        "client",
        "_get_subnets_from_port",
        "context",
        "port",
        "client",
        "subnet",
        "subnets",
        "fixed_ip",
        "fixed_ip",
        "network_IPs",
        "fixed_ip",
        "is_in_subnet",
        "subnet",
        "subnets",
        "port",
        "networks",
        "subnets",
        "net",
        "networks",
        "port",
        "net",
        "net",
        "net",
        "net",
        "get",
        "port",
        "LOG",
        "warning",
        "port",
        "tenant_id",
        "port",
        "get",
        "port",
        "get",
        "vif_type",
        "network_model",
        "VIF_TYPE_OVS",
        "network_model",
        "VIF_TYPE_AGILIO_OVS",
        "port_details",
        "get",
        "network_model",
        "VIF_DETAILS_BRIDGE_NAME",
        "CONF",
        "neutron",
        "ovs_bridge",
        "port",
        "vif_type",
        "network_model",
        "VIF_TYPE_BRIDGE",
        "port_details",
        "get",
        "network_model",
        "VIF_DETAILS_BRIDGE_NAME",
        "port",
        "vif_type",
        "network_model",
        "VIF_TYPE_DVS",
        "port",
        "vif_type",
        "network_model",
        "VIF_TYPE_VHOSTUSER",
        "port_details",
        "get",
        "network_model",
        "VIF_DETAILS_VHOSTUSER_OVS_PLUG",
        "port_details",
        "get",
        "network_model",
        "VIF_DETAILS_BRIDGE_NAME",
        "CONF",
        "neutron",
        "ovs_bridge",
        "port",
        "vif_type",
        "network_model",
        "VIF_TYPE_VHOSTUSER",
        "port_details",
        "get",
        "network_model",
        "VIF_DETAILS_VHOSTUSER_FP_PLUG",
        "port_details",
        "get",
        "network_model",
        "VIF_DETAILS_BRIDGE_NAME",
        "port",
        "bridge",
        "vif_type",
        "network_model",
        "VIF_TYPE_DVS",
        "bridge",
        "network_model",
        "NIC_NAME_LEN",
        "network_model",
        "Network",
        "id",
        "port",
        "bridge",
        "bridge",
        "injected",
        "CONF",
        "flat_injected",
        "label",
        "network_name",
        "tenant_id",
        "tenant_id",
        "mtu",
        "network_mtu",
        "subnets",
        "_get_binding_profile",
        "port",
        "port_profile",
        "port_profile",
        "get",
        "physical_network",
        "physical_network",
        "should_create_bridge",
        "should_create_bridge",
        "network",
        "ovs_interfaceid",
        "instance",
        "instance",
        "get_network_info",
        "net_info",
        "LOG",
        "debug",
        "instance",
        "instance",
        "vif",
        "vif",
        "net_info",
        "vif",
        "get",
        "context",
        "client",
        "current_neutron_port",
        "networks",
        "preexisting_port_ids",
        "current_neutron_port",
        "current_neutron_port",
        "_nw_info_get_ips",
        "client",
        "current_neutron_port",
        "_nw_info_get_subnets",
        "context",
        "current_neutron_port",
        "network_IPs",
        "client",
        "current_neutron_port",
        "devname",
        "network_model",
        "NIC_NAME_LEN",
        "_nw_info_build_network",
        "current_neutron_port",
        "networks",
        "subnets",
        "current_neutron_port",
        "preexisting_port_ids",
        "network_model",
        "VIF",
        "id",
        "current_neutron_port",
        "address",
        "current_neutron_port",
        "network",
        "network",
        "vnic_type",
        "current_neutron_port",
        "get",
        "network_model",
        "VNIC_TYPE_NORMAL",
        "current_neutron_port",
        "get",
        "profile",
        "_get_binding_profile",
        "current_neutron_port",
        "details",
        "current_neutron_port",
        "get",
        "ovs_interfaceid",
        "ovs_interfaceid",
        "devname",
        "devname",
        "active",
        "vif_active",
        "preserve_on_delete",
        "preserve_on_delete",
        "context",
        "instance",
        "networks",
        "port_ids",
        "admin_client",
        "preexisting_port_ids",
        "refresh_vif_id",
        "instance",
        "project_id",
        "instance",
        "uuid",
        "admin_client",
        "get_client",
        "context",
        "admin",
        "admin_client",
        "client",
        "list_ports",
        "search_opts",
        "data",
        "get",
        "preexisting_port_ids",
        "preexisting_port_ids",
        "_get_preexisting_port_ids",
        "instance",
        "current_neutron_port",
        "current_neutron_ports",
        "current_neutron_port",
        "current_neutron_port",
        "refresh_vif_id",
        "instance",
        "get_network_info",
        "nw_info",
        "current_neutron_port_map",
        "get",
        "refresh_vif_id",
        "current_neutron_port",
        "_get_available_networks",
        "context",
        "instance",
        "project_id",
        "current_neutron_port",
        "client",
        "_build_vif_model",
        "context",
        "client",
        "current_neutron_port",
        "networks",
        "preexisting_port_ids",
        "index",
        "vif",
        "nw_info",
        "vif",
        "refresh_vif_id",
        "refreshed_vif",
        "LOG",
        "debug",
        "refresh_vif_id",
        "instance",
        "instance",
        "nw_info",
        "append",
        "refreshed_vif",
        "LOG",
        "debug",
        "refresh_vif_id",
        "instance",
        "instance",
        "index",
        "vif",
        "nw_info",
        "vif",
        "refresh_vif_id",
        "LOG",
        "info",
        "refresh_vif_id",
        "instance",
        "instance",
        "nw_info",
        "index",
        "nw_info",
        "networks",
        "port_ids",
        "_gather_port_ids_and_networks",
        "context",
        "instance",
        "networks",
        "port_ids",
        "client",
        "network_model",
        "NetworkInfo",
        "port_id",
        "port_ids",
        "current_neutron_port_map",
        "get",
        "port_id",
        "current_neutron_port",
        "_build_vif_model",
        "context",
        "client",
        "current_neutron_port",
        "networks",
        "preexisting_port_ids",
        "nw_info",
        "append",
        "vif",
        "nw_info_refresh",
        "LOG",
        "info",
        "port_id",
        "instance",
        "instance",
        "nw_info",
        "context",
        "port",
        "client",
        "port",
        "fixed_ips",
        "client",
        "get_client",
        "context",
        "ip",
        "ip",
        "fixed_ips",
        "client",
        "list_subnets",
        "search_opts",
        "data",
        "get",
        "subnet",
        "ipam_subnets",
        "subnet",
        "network_model",
        "IP",
        "address",
        "subnet",
        "subnet",
        "get",
        "subnet",
        "subnet",
        "client",
        "list_ports",
        "search_opts",
        "data",
        "get",
        "p",
        "dhcp_ports",
        "ip_pair",
        "p",
        "ip_pair",
        "subnet",
        "ip_pair",
        "network_model",
        "Subnet",
        "subnet_dict",
        "dns",
        "subnet",
        "get",
        "subnet_object",
        "add_dns",
        "network_model",
        "IP",
        "address",
        "dns",
        "route",
        "subnet",
        "get",
        "subnet_object",
        "add_route",
        "network_model",
        "Route",
        "cidr",
        "route",
        "gateway",
        "network_model",
        "IP",
        "address",
        "route",
        "subnets",
        "append",
        "subnet_object",
        "subnets",
        "context",
        "NotImplementedError",
        "context",
        "address",
        "name",
        "dns_type",
        "domain",
        "NotImplementedError",
        "context",
        "name",
        "address",
        "domain",
        "NotImplementedError",
        "context",
        "name",
        "domain",
        "NotImplementedError",
        "context",
        "domain",
        "NotImplementedError",
        "context",
        "address",
        "domain",
        "NotImplementedError",
        "context",
        "name",
        "domain",
        "NotImplementedError",
        "context",
        "domain",
        "availability_zone",
        "NotImplementedError",
        "context",
        "domain",
        "project",
        "NotImplementedError",
        "context",
        "instance",
        "host",
        "migration",
        "_update_port_binding_for_instance",
        "context",
        "instance",
        "host",
        "migration",
        "context",
        "instance",
        "host",
        "instance",
        "migration",
        "instance",
        "migration_context",
        "migration",
        "migration",
        "get",
        "instance",
        "migration_context",
        "get_pci_mapping_for_migration",
        "revert",
        "context",
        "instance",
        "host",
        "migration",
        "get_client",
        "context",
        "admin",
        "instance",
        "uuid",
        "instance",
        "project_id",
        "neutron",
        "list_ports",
        "search_opts",
        "data",
        "p",
        "ports",
        "_get_binding_profile",
        "p",
        "p",
        "get",
        "BINDING_HOST_ID",
        "host",
        "host",
        "instance",
        "availability_zone",
        "binding_profile",
        "get",
        "MIGRATING_ATTR",
        "binding_profile",
        "MIGRATING_ATTR",
        "binding_profile",
        "p",
        "get",
        "vnic_type",
        "network_model",
        "VNIC_TYPES_SRIOV",
        "migration",
        "pci_mapping",
        "_get_pci_mapping_for_migration",
        "instance",
        "migration",
        "binding_profile",
        "get",
        "pci_mapping",
        "get",
        "pci_slot",
        "new_dev",
        "binding_profile",
        "update",
        "_get_pci_device_profile",
        "new_dev",
        "binding_profile",
        "exception",
        "PortUpdateFailed",
        "port_id",
        "p",
        "reason",
        "_",
        "pci_slot",
        "port_updates",
        "append",
        "p",
        "updates",
        "port_id",
        "updates",
        "port_updates",
        "updates",
        "LOG",
        "info",
        "port_id",
        "updates",
        "instance",
        "instance",
        "neutron",
        "update_port",
        "port_id",
        "updates",
        "excutils",
        "save_and_reraise_exception",
        "LOG",
        "exception",
        "port_id",
        "instance",
        "instance",
        "context",
        "instance",
        "vif",
        "index",
        "_refresh_neutron_extensions_cache",
        "context",
        "constants",
        "VNIC_INDEX_EXT",
        "extensions",
        "get_client",
        "context",
        "index",
        "neutron",
        "update_port",
        "vif",
        "port_req_body",
        "excutils",
        "save_and_reraise_exception",
        "LOG",
        "exception",
        "vif",
        "instance",
        "instance",
        "accessor",
        "unordered",
        "preferred",
        "preferred",
        "unordered",
        "sort",
        "key",
        "i",
        "preferred",
        "index",
        "accessor",
        "i"
    ],
    "literals": [
        "'default'",
        "'binding:profile'",
        "'binding:host_id'",
        "'migrating_to'",
        "'Unknown auth type: %s'",
        "\"neutron_api\"",
        "'proxy'",
        "\"Neutron client was not able to generate a \"",
        "\"valid admin token, please verify Neutron \"",
        "\"admin credential located in nova.conf\"",
        "'RegionOne'",
        "'network'",
        "\"%(item)s already exists in list: %(list_name)s \"",
        "\"containing: %(items)s. ignoring it\"",
        "'item'",
        "'list_name'",
        "'items'",
        "'binding:vif_type'",
        "'id'",
        "'mac_address'",
        "\"Port %(port)s mac address %(mac)s is \"",
        "\"not in the set of hypervisor macs: \"",
        "\"%(hyper_macs)s. Nova will overwrite \"",
        "\"this with a new mac address.\"",
        "'port'",
        "'id'",
        "'mac'",
        "'hyper_macs'",
        "'port'",
        "\"Unable to update binding profile \"",
        "\"for port: %(port)s due to failure: %(error)s\"",
        "'port'",
        "'error'",
        "\"Removing port %s migration profile\"",
        "'id'",
        "'id'",
        "'id'",
        "\"Port %(port_id)s updated with migration \"",
        "\"profile %(profile_data)s successfully\"",
        "'port_id'",
        "'id'",
        "'profile_data'",
        "'device_id'",
        "'tenant_id'",
        "'ports'",
        "'id'",
        "'networks'",
        "'tenant_id'",
        "'shared'",
        "'admin_state_up'",
        "'networks'",
        "'shared'",
        "'networks'",
        "'id'",
        "'port'",
        "'device_id'",
        "'port'",
        "'fixed_ips'",
        "'ip_address'",
        "'port'",
        "'network_id'",
        "'port'",
        "'admin_state_up'",
        "'port'",
        "'tenant_id'",
        "'port'",
        "'security_groups'",
        "\"### port_response = [%s]\"",
        "'port'",
        "'id'",
        "'Successfully created port: %s'",
        "'Neutron error: %(ip)s is not a valid IP address '",
        "'for network %(network_id)s.'",
        "'ip'",
        "'network_id'",
        "'Fixed IP %(ip)s is not a valid ip address for '",
        "'network %(network_id)s.'",
        "'ip'",
        "'network_id'",
        "'Neutron error: Fixed IP %s is '",
        "'already in use.'",
        "\"Fixed IP %s is already in use.\"",
        "'Neutron error: Port quota exceeded in tenant: %s'",
        "'port'",
        "'tenant_id'",
        "'Neutron error: No more fixed IPs in network: %s'",
        "'Neutron error creating port on network %s'",
        "\"### port_response = [%s]\"",
        "'port'",
        "'Successfully updated port: %s'",
        "'port'",
        "'mac_address'",
        "'port'",
        "'network_id'",
        "'Neutron error: MAC address %(mac)s is already '",
        "'in use on network %(network)s.'",
        "'mac'",
        "'network'",
        "'port'",
        "'network_id'",
        "'Neutron error: Tried to bind a port with '",
        "'fixed_ips to a host in the wrong segment on '",
        "'network %(network)s.'",
        "'network'",
        "'port'",
        "'mac_address'",
        "'router:external'",
        "'shared'",
        "'id'",
        "'port'",
        "'device_id'",
        "''",
        "'device_owner'",
        "''",
        "'port'",
        "'network_id'",
        "'Unable to show port %s as it no longer '",
        "'exists.'",
        "\"Unable to get binding:profile for port '%s'\"",
        "'network_id'",
        "'dns_domain'",
        "'network'",
        "'pci_vendor_info'",
        "'pci_slot'",
        "'port'",
        "'dns_domain'",
        "'port'",
        "'dns_name'",
        "''",
        "'Unable to unbind port %s as it no longer '",
        "'exists.'",
        "\"Unable to clear device ID for port '%s'\"",
        "'tenant_id'",
        "'device_id'",
        "'dns_name'",
        "'dns_name'",
        "'dns_name'",
        "'binding:vnic_type'",
        "'id'",
        "'network_id'",
        "'tenant_id'",
        "'security_groups'",
        "'name'",
        "\"Multiple security groups found matching\"",
        "\" '%s'. Use an ID to be more specific.\"",
        "'id'",
        "'id'",
        "'id'",
        "\"Multiple possible networks found, use a Network \"",
        "\"ID to be more specific.\"",
        "'id'",
        "'id'",
        "'port_security_enabled'",
        "'subnets'",
        "'Network with port security enabled does '",
        "'not have subnets so security groups '",
        "'cannot be applied: %s'",
        "'Network has port security disabled so '",
        "'security groups cannot be applied: %s'",
        "'id'",
        "'allocate_for_instance()'",
        "'empty project id for instance %s'",
        "\"No network configured\"",
        "'id'",
        "'tag'",
        "'compute:%s'",
        "'port'",
        "'device_id'",
        "'device_owner'",
        "'port'",
        "'%s/%s'",
        "'mac_address'",
        "'id'",
        "'extensions'",
        "'name'",
        "'pci_vendor_info'",
        "\"%s:%s\"",
        "'pci_slot'",
        "'physical_network'",
        "'physical_network'",
        "'Unable to find PCI device using PCI request ID in '",
        "'list of claimed instance PCI devices: %s. Is the '",
        "'[pci]/passthrough_whitelist configuration correct?'",
        "'PCI device not found for request ID %s.'",
        "'port'",
        "'port'",
        "'port'",
        "'port'",
        "\"PCI request %s does not have a \"",
        "\"unique device associated with it. Unable to \"",
        "\"determine MAC address\"",
        "\"Could not determine MAC address for %(addr)s, \"",
        "\"error: %(e)s\"",
        "\"addr\"",
        "\"e\"",
        "'port'",
        "'mac_address'",
        "'rxtx_factor'",
        "'port'",
        "'rxtx_factor'",
        "'port'",
        "'dns_domain'",
        "'port'",
        "'dns_name'",
        "'dns_domain'",
        "'port'",
        "'dns_name'",
        "'Neutron error: Instance hostname '",
        "'%(hostname)s is not a valid DNS name'",
        "'hostname'",
        "'Instance hostname %(hostname)s is not a valid DNS '",
        "'name'",
        "'hostname'",
        "'dns_domain'",
        "'port'",
        "'dns_name'",
        "''",
        "\"Failed to reset dns_name for port %s\"",
        "\"Port %s does not exist\"",
        "\"Failed to delete port %s for instance.\"",
        "'deallocate_for_instance()'",
        "'device_id'",
        "'id'",
        "'ports'",
        "'requested_networks'",
        "'tag'",
        "'VirtualInterface not found for port: %s'",
        "'port'",
        "\"Failed to access port %(port_id)s: %(reason)s\"",
        "'port_id'",
        "'reason'",
        "'_get_instance_nw_info()'",
        "\"This method needs to be called with either \"",
        "\"networks=None and port_ids=None or port_ids and \"",
        "\"networks as not none.\"",
        "'id'",
        "'network'",
        "'id'",
        "'id'",
        "'id'",
        "'network'",
        "'id'",
        "'name'",
        "'network'",
        "'label'",
        "'tenant_id'",
        "'network'",
        "'meta'",
        "'tenant_id'",
        "'network'",
        "'id'",
        "\"networks\"",
        "'id'",
        "'id'",
        "\"port_ids\"",
        "'network_id'",
        "'subnets'",
        "'compute:%s'",
        "'device_id'",
        "'device_owner'",
        "'network_id'",
        "'ports'",
        "'fixed_ips'",
        "'subnet_id'",
        "'id'",
        "'port'",
        "'fixed_ips'",
        "'id'",
        "\"Unable to update port %(portid)s on subnet \"",
        "\"%(subnet_id)s with failure: %(exception)s\"",
        "'portid'",
        "'id'",
        "'subnet_id'",
        "'id'",
        "'exception'",
        "'compute:%s'",
        "'device_id'",
        "'device_owner'",
        "'fixed_ips'",
        "'ip_address=%s'",
        "'ports'",
        "'fixed_ips'",
        "'ip_address'",
        "'port'",
        "'fixed_ips'",
        "'id'",
        "\"Unable to update port %(portid)s with\"",
        "\" failure: %(exception)s\"",
        "'portid'",
        "'id'",
        "'exception'",
        "'segments'",
        "'network'",
        "'segments'",
        "'provider:physical_network'",
        "\"None of the segments of network %s provides a \"",
        "\"physical_network\"",
        "'provider:physical_network'",
        "'network'",
        "'provider:physical_network'",
        "'binding:vnic_type'",
        "'network_id'",
        "'binding:vnic_type'",
        "'network_id'",
        "'Network auto-allocation is available for project '",
        "'%s'",
        "'Unable to auto-allocate networks. %s'",
        "'Automatically allocating a network for project %s.'",
        "'auto_allocated_topology'",
        "'id'",
        "'network'",
        "'Automatically allocated network %(network_id)s '",
        "'was not found.'",
        "'network_id'",
        "'id'",
        "'Automatically allocated network: %s'",
        "\"Multiple possible networks found, use a Network \"",
        "\"ID to be more specific.\"",
        "'No networks are available for project %s; checking '",
        "'to see if we can automatically allocate a network.'",
        "'device_id'",
        "'ip_allocation'",
        "'deferred'",
        "'fixed_ips'",
        "'network_id'",
        "'network_id'",
        "'fixed_ips'",
        "'ip_address=%s'",
        "'fields'",
        "'device_id'",
        "'ports'",
        "'device_id'",
        "'subnets'",
        "'id'",
        "'id'",
        "''",
        "', '",
        "'validate_networks() for %s'",
        "'quota'",
        "'port'",
        "'id'",
        "'ports'",
        "'port'",
        "\"The number of defined ports: %(ports)d \"",
        "\"is over the limit: %(quota)d\"",
        "'ports'",
        "'quota'",
        "'port'",
        "\"fixed_ips\"",
        "'ip_address=%s'",
        "'ports'",
        "'instance_uuid'",
        "'device_id'",
        "'device_id'",
        "'compute:%s'",
        "'device_id'",
        "'device_owner'",
        "'ports'",
        "'fixed_ips'",
        "'ip_address'",
        "'id'",
        "'port_id'",
        "'fixed_ip_address'",
        "'id'",
        "'floatingip'",
        "'port_id'",
        "'port_id'",
        "'device_id'",
        "'re-assign floating IP %(address)s from '",
        "'instance %(instance_id)s'",
        "'networks'",
        "'name'",
        "'name'",
        "'id'",
        "'network'",
        "'name'",
        "'name'",
        "'id'",
        "'network'",
        "'id'",
        "'id'",
        "'id'",
        "'tenant_id'",
        "'ports'",
        "'id'",
        "'floatingip'",
        "'Unable to access floating IP %s'",
        "'floating_network_id'",
        "'port_id'",
        "'tenant_id'",
        "'networks'",
        "'name'",
        "'id'",
        "'floating_network_id'",
        "'id'",
        "'floating_ip_address'",
        "'name'",
        "'id'",
        "'tenant_id'",
        "'port_id'",
        "'fixed_ip_address'",
        "'fixed_ip_address'",
        "'port_id'",
        "'port_id'",
        "'device_id'",
        "'floating_network_id'",
        "'port_id'",
        "'port_id'",
        "'port_id'",
        "'The port(%s) is not found'",
        "'port_id'",
        "'device_id'",
        "'fields'",
        "'id'",
        "'id'",
        "'name'",
        "'networks'",
        "'id'",
        "\"Multiple floating IP pools matches found for name '%s'\"",
        "'nova'",
        "\"Config option 'default_floating_pool' is set to \"",
        "\"a non-default value. Falling back to this value \"",
        "\"for now but this behavior will change in a \"",
        "\"future release. You should unset this value \"",
        "\"and set the '[neutron] default_floating_pool' \"",
        "\"option instead.\"",
        "'floatingip'",
        "'floating_network_id'",
        "'floatingip'",
        "'floating_ip_address'",
        "'floatingips'",
        "'Unable to access floating IP for %s'",
        "', '",
        "'%s %s'",
        "'address'",
        "'address'",
        "'port_id'",
        "'id'",
        "'id'",
        "'floatingip'",
        "'port_id'",
        "'dest_compute'",
        "'fixed_ips'",
        "'ip_address'",
        "'ip_address'",
        "'id'",
        "'floating_ip_address'",
        "'floating'",
        "'ips'",
        "'network_id'",
        "'id'",
        "'name'",
        "'tenant_id'",
        "'mtu'",
        "'tenant_id'",
        "\"Network %(id)s not matched with the tenants \"",
        "\"network! The ports tenant %(tenant_id)s will be \"",
        "\"used.\"",
        "'id'",
        "'network_id'",
        "'tenant_id'",
        "'binding:vif_type'",
        "'binding:vif_details'",
        "'id'",
        "\"brq\"",
        "'network_id'",
        "'network_id'",
        "'id'",
        "\"brq\"",
        "'network_id'",
        "'network_id'",
        "'subnets'",
        "'physical_network'",
        "'physical_network'",
        "'should_create_bridge'",
        "'Instance cache missing network info.'",
        "'id'",
        "'preserve_on_delete'",
        "'admin_state_up'",
        "'status'",
        "'ACTIVE'",
        "\"tap\"",
        "'id'",
        "'id'",
        "'id'",
        "'mac_address'",
        "'binding:vnic_type'",
        "'binding:vif_type'",
        "'binding:vif_details'",
        "'tenant_id'",
        "'device_id'",
        "'ports'",
        "'id'",
        "'network_id'",
        "'id'",
        "'Updated VIF entry in instance network '",
        "'info cache for port %s.'",
        "'Added VIF to instance network info cache '",
        "'for port %s.'",
        "'id'",
        "'Port %s from network info_cache is no '",
        "'longer associated with instance in '",
        "'Neutron. Removing from network '",
        "'info_cache.'",
        "'Port %s from network info_cache is no '",
        "'longer associated with instance in Neutron. '",
        "'Removing from network info_cache.'",
        "'fixed_ips'",
        "'id'",
        "'subnet_id'",
        "'subnets'",
        "'cidr'",
        "'cidr'",
        "'gateway'",
        "'gateway_ip'",
        "'gateway'",
        "'ipv6_address_mode'",
        "'ipv6_address_mode'",
        "'ipv6_address_mode'",
        "'network_id'",
        "'network_id'",
        "'device_owner'",
        "'network:dhcp'",
        "'ports'",
        "'fixed_ips'",
        "'subnet_id'",
        "'id'",
        "'dhcp_server'",
        "'ip_address'",
        "'dns_nameservers'",
        "'dns'",
        "'host_routes'",
        "'destination'",
        "'nexthop'",
        "'gateway'",
        "'status'",
        "'reverted'",
        "'device_id'",
        "'tenant_id'",
        "'ports'",
        "'device_owner'",
        "'compute:%s'",
        "'binding:vnic_type'",
        "'pci_slot'",
        "'id'",
        "\"Unable to correlate PCI slot %s\"",
        "'id'",
        "\"Updating port %(port)s with \"",
        "\"attributes %(attributes)s\"",
        "\"port\"",
        "\"attributes\"",
        "'port'",
        "\"Unable to update binding details \"",
        "\"for port %s\"",
        "'port'",
        "'vnic_index'",
        "'id'",
        "'Unable to update instance VNIC index '",
        "'for port %s.'",
        "'id'"
    ],
    "variables": [
        "CONF",
        "LOG",
        "_SESSION",
        "_ADMIN_AUTH",
        "DEFAULT_SECGROUP",
        "BINDING_PROFILE",
        "BINDING_HOST_ID",
        "MIGRATING_ATTR",
        "_ADMIN_AUTH",
        "_SESSION",
        "auth_plugin",
        "err_msg",
        "__dict__",
        "base_client",
        "admin",
        "obj",
        "obj",
        "ret",
        "auth_plugin",
        "_SESSION",
        "_ADMIN_AUTH",
        "auth_plugin",
        "auth_plugin",
        "client_args",
        "client_args",
        "adap",
        "client_args",
        "present",
        "binding_vif_type",
        "available_macs",
        "mac",
        "last_neutron_extension_sync",
        "extensions",
        "pci_whitelist",
        "updated_port",
        "port_profile",
        "host_id",
        "port_profile",
        "port_profile",
        "MIGRATING_ATTR",
        "port_migrating",
        "search_opts",
        "data",
        "ports",
        "admin_client",
        "neutron",
        "search_opts",
        "nets",
        "search_opts",
        "search_opts",
        "nets",
        "search_opts",
        "port_req_body",
        "port_response",
        "port",
        "port_id",
        "msg",
        "msg",
        "port_response",
        "port",
        "mac_address",
        "network_id",
        "network_id",
        "mac_address",
        "port_client",
        "networks",
        "port_req_body",
        "BINDING_HOST_ID",
        "port",
        "port_profile",
        "network",
        "port_profile",
        "net_id",
        "network",
        "network",
        "networks",
        "net_id",
        "BINDING_PROFILE",
        "ports",
        "ordered_networks",
        "port",
        "vnic_type",
        "request",
        "network_id",
        "ports",
        "security_groups",
        "security_groups",
        "security_group_ids",
        "search_opts",
        "user_security_groups",
        "name_match",
        "uuid_match",
        "name_match",
        "uuid_match",
        "auto_allocate",
        "net_ids",
        "nets",
        "nets",
        "msg",
        "created_port_ids",
        "requests_and_created_ports",
        "network",
        "port_security_enabled",
        "created_port_id",
        "created_port",
        "created_port_id",
        "msg",
        "neutron",
        "requested_ports_dict",
        "ordered_networks",
        "nets",
        "security_groups",
        "security_group_ids",
        "requests_and_created_ports",
        "available_macs",
        "admin_client",
        "ordered_nets",
        "ordered_port_ids",
        "preexisting_port_ids",
        "created_port_ids",
        "nw_info",
        "port_client",
        "preexisting_port_ids",
        "created_port_ids",
        "ports_in_requested_order",
        "nets_in_requested_order",
        "created_vifs",
        "vifobj",
        "vifobj",
        "instance_uuid",
        "vifobj",
        "tag",
        "network",
        "zone",
        "port_req_body",
        "BINDING_PROFILE",
        "port_id",
        "port_id",
        "updated_port",
        "vifobj",
        "address",
        "vifobj",
        "uuid",
        "neutron",
        "extensions_list",
        "last_neutron_extension_sync",
        "extensions",
        "dev_spec",
        "pci_devices",
        "pci_dev",
        "BINDING_PROFILE",
        "profile",
        "BINDING_PROFILE",
        "pci_devs",
        "pci_dev",
        "mac",
        "flavor",
        "rxtx_factor",
        "BINDING_HOST_ID",
        "port_req_body",
        "msg",
        "port_req_body",
        "exceptions",
        "search_opts",
        "neutron",
        "data",
        "ports",
        "requested_networks",
        "requested_networks",
        "ports_to_skip",
        "ports",
        "requested_networks",
        "neutron",
        "preexisting_ports",
        "vif",
        "neutron_client",
        "result",
        "result",
        "msg",
        "nw_info",
        "message",
        "ifaces",
        "port_ids",
        "net_ids",
        "networks",
        "networks_ids",
        "networks",
        "port_ids",
        "neutron",
        "search_opts",
        "data",
        "ipam_subnets",
        "zone",
        "search_opts",
        "data",
        "ports",
        "fixed_ips",
        "port_req_body",
        "msg",
        "neutron",
        "zone",
        "search_opts",
        "data",
        "ports",
        "fixed_ips",
        "new_fixed_ips",
        "port_req_body",
        "msg",
        "phynet_name",
        "network",
        "segments",
        "phynet_name",
        "msg",
        "net",
        "phynet_name",
        "phynet_name",
        "port",
        "vnic_type",
        "net_id",
        "phynet_name",
        "neutron",
        "phynet_name",
        "vnic_type",
        "vnic_type",
        "phynet_name",
        "pci_request_id",
        "spec",
        "dev_type",
        "spec",
        "request",
        "pci_request_id",
        "request_net",
        "pci_request_id",
        "project_id",
        "topology",
        "network",
        "requested_networks",
        "ports_needed_per_instance",
        "nets",
        "msg",
        "ports_needed_per_instance",
        "net_ids_requested",
        "port",
        "deferred_ip",
        "request",
        "network_id",
        "search_opts",
        "existing_ports",
        "i_uuid",
        "nets",
        "requested_netid_set",
        "returned_netid_set",
        "lostid_set",
        "id_str",
        "id_str",
        "neutron",
        "ports_needed_per_instance",
        "quotas",
        "ports",
        "free_ports",
        "msg",
        "ports_needed",
        "search_opts",
        "data",
        "ports",
        "zone",
        "search_opts",
        "data",
        "ports",
        "port_id",
        "port_id",
        "client",
        "port_id",
        "fip",
        "param",
        "port",
        "orig_instance_uuid",
        "msg_dict",
        "orig_instance",
        "client",
        "networks",
        "network_objs",
        "client",
        "network",
        "net_obj",
        "uuid_maps",
        "pool",
        "port",
        "pools",
        "search_opts",
        "ports",
        "client",
        "fip",
        "pool_dict",
        "port_dict",
        "search_opts",
        "data",
        "client",
        "pools",
        "pool",
        "floating",
        "floating",
        "fixed_ip",
        "floating",
        "fixed_ip",
        "instance_uuid",
        "floating",
        "instance",
        "instance_uuid",
        "floating",
        "instance",
        "client",
        "fip",
        "pool_dict",
        "port_dict",
        "client",
        "project_id",
        "fips",
        "pool_dict",
        "port_dict",
        "client",
        "fip",
        "port",
        "search_opts",
        "data",
        "nets",
        "msg",
        "client",
        "pool",
        "pool_id",
        "param",
        "fip",
        "fips",
        "client",
        "fip",
        "client",
        "fip",
        "network_IPs",
        "floats",
        "fip",
        "subnets",
        "subnet",
        "network_name",
        "network_mtu",
        "network_name",
        "tenant_id",
        "network_mtu",
        "tenant_id",
        "bridge",
        "ovs_interfaceid",
        "should_create_bridge",
        "vif_type",
        "port_details",
        "bridge",
        "ovs_interfaceid",
        "bridge",
        "should_create_bridge",
        "bridge",
        "bridge",
        "ovs_interfaceid",
        "bridge",
        "bridge",
        "network",
        "network",
        "port_profile",
        "physical_network",
        "network",
        "network",
        "net_info",
        "vif_active",
        "vif_active",
        "network_IPs",
        "subnets",
        "devname",
        "devname",
        "network",
        "ovs_interfaceid",
        "preserve_on_delete",
        "search_opts",
        "client",
        "client",
        "data",
        "current_neutron_ports",
        "preexisting_port_ids",
        "preexisting_port_ids",
        "current_neutron_port_map",
        "current_neutron_port_map",
        "nw_info",
        "current_neutron_port",
        "networks",
        "refreshed_vif",
        "nw_info",
        "index",
        "nw_info_refresh",
        "networks",
        "port_ids",
        "nw_info",
        "current_neutron_port",
        "vif",
        "fixed_ips",
        "client",
        "search_opts",
        "data",
        "ipam_subnets",
        "subnets",
        "subnet_dict",
        "subnet_dict",
        "search_opts",
        "data",
        "dhcp_ports",
        "subnet_dict",
        "subnet_object",
        "revert",
        "neutron",
        "search_opts",
        "data",
        "pci_mapping",
        "port_updates",
        "ports",
        "updates",
        "binding_profile",
        "updates",
        "BINDING_HOST_ID",
        "updates",
        "updates",
        "BINDING_PROFILE",
        "vnic_type",
        "pci_mapping",
        "pci_slot",
        "new_dev",
        "updates",
        "BINDING_PROFILE",
        "neutron",
        "port_req_body"
    ],
    "comments": [
        "Copyright 2012 OpenStack Foundation",
        "All Rights Reserved",
        "Copyright (c) 2012 NEC Corporation",
        "",
        "Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
        "not use this file except in compliance with the License. You may obtain",
        "a copy of the License at",
        "",
        "http://www.apache.org/licenses/LICENSE-2.0",
        "",
        "Unless required by applicable law or agreed to in writing, software",
        "distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
        "WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
        "License for the specific language governing permissions and limitations",
        "under the License.",
        "",
        "Expose all attributes from the base_client instance",
        "Token is expired so Neutron is raising a",
        "unauthorized exception, we should convert it to",
        "raise a 401 to make client to handle a retry by",
        "regenerating a valid token and trying a new",
        "attempt.",
        "In admin context if token is invalid Neutron client",
        "should be able to regenerate a valid by using the",
        "Neutron admin credential configuration located in",
        "nova.conf.",
        "NOTE(dprince): In the case where no auth_token is present we allow use of",
        "neutron admin tenant credentials if it is an admin context.  This is to",
        "support some services (metadata API) where an admin context is used",
        "without an auth token.",
        "We did not get a user token and we should not be using",
        "an admin token so log an error",
        "TODO(efried): Remove in Rocky",
        "NOTE(efried): The legacy behavior was to default",
        "region_name in the conf.",
        "The new way",
        "NOTE(efried): We build an adapter",
        "to pull conf options",
        "to pass to neutronclient",
        "which uses them to build an Adapter.",
        "This should be unwound at some point.",
        "The expectation from this function's perspective is that the",
        "item is not part of the items list so if it is part of it",
        "we should at least log it as a warning",
        "Make a copy we can mutate: records macs that have not been used",
        "to create a port on a network. If we find a mac with a",
        "pre-allocated port we also remove it from this set.",
        "Don't try to use this MAC if we need to create a",
        "port on the fly later. Identical MACs may be",
        "configured by users into multiple ports so we",
        "discard rather than popping.",
        "If the port already has a migration profile and if",
        "it is to be torn down, then we need to clean up",
        "the migration profile.",
        "Migrating to a new host",
        "If the host hasn't changed, there is nothing to do.",
        "But if the destination host is different than the",
        "current one, please update the port_profile with",
        "the 'migrating_to'(MIGRATING_ATTR) key pointing to",
        "the given 'host'.",
        "Check if the instance is migrating to a new host.",
        "If the port is migrating to a new host or if it is a",
        "teardown on the original host, then proceed.",
        "Now get the port details to process the ports",
        "binding profile info.",
        "Reset the port profile",
        "Setup the port profile",
        "If user has specified to attach instance only to specific",
        "networks then only add these to **search_opts. This search will",
        "also include 'shared' networks.",
        "(1) Retrieve non-public network list owned by the tenant.",
        "The auto-allocated-topology extension may create complex",
        "network topologies and it does so in a non-transactional",
        "fashion. Therefore API users may be exposed to resources that",
        "are transient or partially built. A client should use",
        "resources that are meant to be ready and this can be done by",
        "checking their admin_state_up flag.",
        "(2) Retrieve public network list.",
        "Set the device_id so it's clear who this port was created for,",
        "and to stop other instances trying to use it",
        "NOTE(johngarbutt) On port_update, this will cause us to override",
        "any previous mac address the port may have had.",
        "Perform this check here rather than in validate_networks to",
        "ensure the check is performed every time",
        "allocate_for_instance is invoked",
        "Requires admin creds to set port bindings",
        "A port_id is optional in the NetworkRequest object so check here",
        "in case the caller forgot to filter the list.",
        "NOTE: In case we can't retrieve the binding:profile or",
        "network info assume that they are empty",
        "NOTE: We're doing this to remove the binding information",
        "for the physical device but don't want to overwrite the other",
        "information in the binding profile.",
        "NOTE: For internal DNS integration (network does not have a",
        "dns_domain), or if we cannot retrieve network info, we use the",
        "admin client to reset dns_name.",
        "NOTE: For external DNS integration, we use the neutron client",
        "with user's context to reset the dns_name since the recordset is",
        "under user's zone.",
        "If we're asked to auto-allocate the network then there won't be any",
        "ports or real neutron networks to lookup, so just return empty",
        "results.",
        "Process a request to use a pre-existing neutron port.",
        "Make sure the port exists.",
        "Make sure the instance has access to the port.",
        "Make sure the port isn't already attached to another",
        "instance.",
        "Make sure that if the user assigned a value to the port's",
        "dns_name attribute, it is equal to the instance's",
        "hostname",
        "Make sure the port is usable",
        "Make sure the port can be attached.",
        "SR-IOV port attach is not supported.",
        "If requesting a specific port, automatically process",
        "the network for that port as if it were explicitly",
        "requested.",
        "Process a request to use a specific neutron network.",
        "TODO(arosen) Should optimize more to do direct query for security",
        "group if len(security_groups) == 1",
        "If there was a name match in a previous iteration",
        "of the loop, we have a conflict.",
        "If a user names the security group the same as",
        "another's security groups uuid, the name takes priority.",
        "Get networks from Neutron",
        "If net_ids is empty, this actually returns all available nets",
        "There are no networks available for the project to use and",
        "none specifically requested, so check to see if we're asked",
        "to auto-allocate the network.",
        "During validate_networks we checked to see if",
        "auto-allocation is available so we don't need to do that",
        "again here.",
        "NOTE(chaochin): If user specifies a network id and the",
        "network can not be found, raise NetworkNotFound error.",
        "no requested nets and user has no available nets",
        "if this function is directly called without a requested_network param",
        "or if it is indirectly called through allocate_port_for_instance()",
        "with None params=(network_id=None, requested_ip=None, port_id=None,",
        "pci_request_id=None):",
        "If no networks were requested and none are available, consider",
        "it a bad request.",
        "bug/1267723 - if no network is requested and more",
        "than one is available then raise NetworkAmbiguous Exception",
        "NOTE(melwitt): check external net attach permission after the",
        "check for ambiguity, there could be another",
        "available net which is permitted bug/1364344",
        "if network_id did not pass validate_networks() and not available",
        "here then skip it safely not continuing with a None Network",
        "Neutron can't apply security groups to a port",
        "for a network without L3 assignments.",
        "We don't want to apply security groups on port",
        "for a network defined with",
        "'port_security_enabled=False'.",
        "create minimal port, if port not already created by user",
        "We do not want to create a new neutron session for each call",
        "",
        "Validate ports and networks with neutron. The requested_ports_dict",
        "variable is a dict, keyed by port ID, of ports that were on the user",
        "request and may be empty. The ordered_networks variable is a list of",
        "NetworkRequest objects for any networks or ports specifically",
        "requested by the user, which again may be empty.",
        "",
        "Validate requested security groups",
        "Create ports from the list of ordered_networks. The returned",
        "requests_and_created_ports variable is a list of 2-item tuples of",
        "the form (NetworkRequest, created_port_id). Note that a tuple pair",
        "will have None for the created_port_id if the NetworkRequest already",
        "contains a port_id, meaning the user requested a specific",
        "pre-existing port so one wasn't created here. The ports will be",
        "updated later in _update_ports_for_instance to be bound to the",
        "instance and compute host.",
        "",
        "Update existing and newly created ports",
        "",
        "We always need admin_client to build nw_info,",
        "we sometimes need it when updating ports",
        "",
        "Perform a full update of the network_info_cache,",
        "including re-fetching lots of the required data from neutron",
        "",
        "Only return info about ports we processed in this run, which might",
        "have been pre-existing neutron ports or ones that nova created. In",
        "the initial allocation case (server create), this will be everything",
        "we processed, and in later runs will only be what was processed that",
        "time. For example, if the instance was created with port A and",
        "then port B was attached in this call, only port B would be returned.",
        "Thus, this filtering only affects the attach case.",
        "We currently require admin creds to set port bindings.",
        "this list is for cleanups if we fail",
        "if network_id did not pass validate_networks() and not available",
        "here then skip it safely not continuing with a None Network",
        "After port is created, update other bits",
        "NOTE(danms): The virtual_interfaces table enforces global",
        "uniqueness on MAC addresses, which clearly does not match",
        "with neutron's view of the world. Since address is a 255-char",
        "string we can namespace it with our port id. Using '/' should",
        "be safely excluded from MAC address notations as well as",
        "UUIDs. We could stop doing this when we remove",
        "nova-network, but we'd need to leave the read translation in",
        "for longer than that of course.",
        "only add if update worked and port create not called",
        "The pci_request_id likely won't mean much except for tracing",
        "through the logs since it is generated per request.",
        "Convert to a primitive list to stringify it.",
        "NOTE(ndipanov): We shouldn't ever get here since",
        "InstancePCIRequest instances built from network requests",
        "only ever index a single device, which needs to be",
        "successfully claimed for this to be called as part of",
        "allocate_networks method",
        "If the DNS integration extension is enabled in Neutron, most",
        "ports will get their dns_name attribute set in the port create or",
        "update requests in allocate_for_instance. So we just add the",
        "dns_name attribute to the payload of those requests. The",
        "exception is when the port binding extension is enabled in",
        "Neutron and the port is on a network that has a non-blank",
        "dns_domain attribute. This case requires to be processed by",
        "method _update_port_dns_name",
        "NOTE(danms): Temporary and transitional",
        "NOTE(boden): requested_networks only passed in when deallocating",
        "from a failed build / spawn call. Therefore we need to include",
        "preexisting ports when deallocating from a standard delete op",
        "in which case requested_networks is not provided.",
        "Reset device_id and device_owner for the ports that are skipped",
        "Delete the rest of the ports",
        "deallocate vifs (mac addresses)",
        "NOTE(arosen): This clears out the network_cache only if the instance",
        "hasn't already been deleted. This is needed when an instance fails to",
        "launch and is rescheduled onto another compute node. If the instance",
        "has already been deleted this call does nothing.",
        "Delete the VirtualInterface for the given port_id.",
        "NOTE(danms): This is an inner method intended to be called",
        "by other code that updates instance nwinfo. It *must* be",
        "called with the refresh_cache-%(instance_uuid) lock held!",
        "Ensure that we have an up to date copy of the instance info cache.",
        "Otherwise multiple requests could collide and cause cache",
        "corruption.",
        "This code path is only done when refreshing the network_cache",
        "an interface was added/removed from instance.",
        "Prepare the network ids list for validation purposes",
        "Validate that interface networks doesn't exist in networks.",
        "Though this issue can and should be solved in methods",
        "that prepare the networks list, this method should have this",
        "ignore-duplicate-networks/port-ids mechanism to reduce the",
        "probability of failing to boot the VM.",
        "Include existing interfaces so they are not removed from the db.",
        "Validate that the interface id is not in the port_ids",
        "NOTE(vladikr): In general, \"multi-segments\" network is a",
        "combination of L2 segments. The current implementation",
        "contains a vxlan and vlan(s) segments, where only a vlan",
        "network will have a physical_network specified, but may",
        "change in the future. The purpose of this method",
        "is to find a first segment that provides a physical network.",
        "TODO(vladikr): Additional work will be required to handle the",
        "case of multiple vlan segments associated with different",
        "physical networks.",
        "Raising here as at least one segment should",
        "have a physical network provided.",
        "TODO(moshele): To differentiate between the SR-IOV legacy",
        "and SR-IOV ovs hardware offload we will leverage the nic",
        "feature based scheduling in nova. This mean we will need",
        "libvirt to expose the nic feature. At the moment",
        "there is a limitation that deployers cannot use both",
        "SR-IOV modes (legacy and ovs) in the same deployment.",
        "Add pci_request_id into the requested network",
        "run the dry-run validation, which will raise a 409 if not ready",
        "This shouldn't happen since we just created the network, but",
        "handle it anyway.",
        "TODO(danms): Remove me when all callers pass an object",
        "Attaching to more than one network by default doesn't",
        "make sense, as the order will be arbitrary and the guest OS",
        "won't know which to configure",
        "If there are no networks available to this project and we",
        "were asked to auto-allocate a network, check to see that we",
        "can do that first.",
        "NOTE(carl_baldwin) A deferred IP port doesn't have an",
        "address here. If it fails to get one later when nova",
        "updates it with host info, Neutron will error which",
        "raises an exception.",
        "NOTE(jecarey) There is currently a race condition.",
        "That is, if you have more than one request for a specific",
        "fixed IP at the same time then only one will be allocated",
        "the ip. The fixed IP will be allocated to only one of the",
        "instances that will run. The second instance will fail on",
        "spawn. That instance will go into error state.",
        "TODO(jecarey) Need to address this race condition once we",
        "have the ability to update mac addresses in Neutron.",
        "TODO(jecarey) Need to look at consolidating list_port",
        "calls once able to OR filters.",
        "Now check to see if all requested networks exist",
        "Note(PhilD): Ideally Nova would create all required ports as part of",
        "network validation, but port creation requires some details",
        "from the hypervisor.  So we just check the quota and return",
        "how many of the requested number of instances can be created",
        "Unlimited Port Quota",
        "We only need the port count so only ask for ids back.",
        "Note(amotoki): 'affect_auto_assigned' is not respected",
        "since it is not used anywhere in nova code and I could",
        "find why this parameter exists.",
        "purge cached nw info for the original instance",
        "Note(salv-orlando): Return a list of names to be consistent with",
        "nova.network.api.get_floating_ip_pools",
        "NOTE(danms): Don't give these objects a context, since they're",
        "not lazy-loadable anyway",
        "In Neutron v2 API fixed_ip_address and instance uuid",
        "(= device_id) are known here, so pass it as a result.",
        "NOTE(danms): This could be .refresh()d, so give it context",
        "NOTE: Here is a potential race condition between _show_port() and",
        "_get_floating_ip_by_address(). fip['port_id'] shows a port which",
        "is the server instance's. At _get_floating_ip_by_address(),",
        "Neutron returns the list which includes the instance. Just after",
        "that, the deletion of the instance happens and Neutron returns",
        "404 on _show_port().",
        "If a neutron plugin does not implement the L3 API a 404 from",
        "list_floatingips will be raised.",
        "bug/1513879 neutron client is currently using",
        "NeutronClientException when there is no L3 API",
        "Note(amotoki): We cannot handle a case where multiple pools",
        "have overlapping IP address range. In this case we cannot use",
        "'address' as a unique key.",
        "This is a limitation of the current nova.",
        "Note(amotoki): 'affect_auto_assigned' is not respected",
        "since it is not used anywhere in nova code and I could",
        "find why this parameter exists.",
        "Note(amotoki): 'affect_auto_assigned' is not respected",
        "since it is not used anywhere in nova code and I could",
        "find why this parameter exists.",
        "NOTE(wenjianhn): just pass to make migrate instance doesn't",
        "raise for now.",
        "Network model metadata",
        "The name of the DVS port group will contain the neutron",
        "network id",
        "Prune the bridge name if necessary. For the DVS this is not done",
        "as the bridge is a '<network-name>-<network-UUID>'.",
        "Figure out what kind of operation we're processing. If we're given",
        "a single port to refresh then we try to optimize and update just the",
        "information for that VIF in the existing cache rather than try to",
        "rebuild the entire thing.",
        "TODO(mriedem): Consider pulling this out into it's own method.",
        "Get the network for the port.",
        "Build the VIF model given the latest port information.",
        "Update the existing entry.",
        "If it wasn't in the existing cache, add it.",
        "This port is no longer associated with the instance, so",
        "simply remove it from the nw_info cache.",
        "else there is no existing cache and we need to build it",
        "No fixed_ips for the port means there is no subnet associated",
        "with the network the port is created on.",
        "Since list_subnets(id=[]) returns all subnets visible for the",
        "current tenant, returned subnets may contain subnets which is not",
        "related to the port. To avoid this, the method returns here.",
        "attempt to populate DHCP server field",
        "TODO(mriedem): This should likely be implemented at least for the",
        "shelve offload operation because the instance is being removed from",
        "a compute host, VIFs are unplugged, etc, so the ports should also",
        "be unbound, albeit still logically attached to the instance (for the",
        "shelve scenario). If _unbind_ports was going to be leveraged here, it",
        "would have to be adjusted a bit since it currently clears the",
        "device_id field on the port which is not what we'd want for shelve.",
        "In case of revert, swap old and new devices to",
        "update the ports back to the original devices.",
        "If the host hasn't changed, like in the case of resizing to the",
        "same host, there is nothing to do.",
        "If the host changed, the AZ could have also changed so we",
        "need to update the device_owner.",
        "NOTE: Before updating the port binding make sure we",
        "remove the pre-migration status from the binding profile",
        "Update port with newly allocated PCI devices.  Even if the",
        "resize is happening on the same host, a new PCI device can be",
        "allocated. Note that this only needs to happen if a migration",
        "is in progress such as in a resize / migrate.  It is possible",
        "that this function is called without a migration object, such",
        "as in an unshelve operation.",
        "Avoid rolling back updates if we catch an error above.",
        "TODO(lbeliveau): Batch up the port updates in one neutron call."
    ],
    "docstrings": [
        "\"\"\"Convenience method to get the binding:profile from the port\n\n    The binding:profile in the port is undefined in the networking service\n    API and is dependent on backend configuration. This means it could be\n    an empty dict, None, or have some values.\n\n    :param port: dict port response body from the networking service API\n    :returns: The port binding:profile dict; empty if not set on the port\n    \"\"\"",
        "\"\"\"A Neutron client wrapper class.\n\n    Wraps the callable methods, catches Unauthorized,Forbidden from Neutron and\n    convert it to a 401,403 for Nova clients.\n    \"\"\"",
        "\"\"\"Removes macs from set if used by existing ports\n\n    :param instance: The server instance.\n    :type instance: nova.objects.instance.Instance\n    :param requested_ports_dict: dict, keyed by port ID, of ports requested by\n        the user\n    :type requested_ports_dict: dict\n    :param hypervisor_macs: None or a set of MAC addresses that the\n        instance should use. hypervisor_macs are supplied by the hypervisor\n        driver (contrast with requested_networks which is user supplied).\n        NB: NeutronV2 currently assigns hypervisor supplied MAC addresses\n        to arbitrary networks, which requires openflow switches to\n        function correctly if more than one network is being used with\n        the bare metal hypervisor (which is the only one known to limit\n        MAC addresses).\n    :type hypervisor_macs: set\n    :returns a set of available MAC addresses to use if\n            creating a port later; this is the set of hypervisor_macs\n            after removing any MAC addresses from explicitly\n            requested ports.\n    \"\"\"",
        "\"\"\"API for interacting with the neutron 2.x API.\"\"\"",
        "\"\"\"Setup or teardown the network structures.\"\"\"",
        "\"\"\"Return a network list available for the tenant.\n        The list contains networks owned by the tenant and public networks.\n        If net_ids specified, it searches networks with requested IDs only.\n        \"\"\"",
        "\"\"\"Attempts to create a port for the instance on the given network.\n\n        :param port_client: The client to use to create the port.\n        :param instance: Create the port for the given instance.\n        :param network_id: Create the port on the given network.\n        :param fixed_ip: Optional fixed IP to use from the given network.\n        :param security_group_ids: Optional list of security group IDs to\n            apply to the port.\n        :returns: The created port.\n        :raises PortLimitExceeded: If neutron fails with an OverQuota error.\n        :raises NoMoreFixedIps: If neutron fails with\n            IpAddressGenerationFailure error.\n        :raises: PortBindingFailed: If port binding failed.\n        \"\"\"",
        "\"\"\"Check if attaching to external network is permitted.\"\"\"",
        "\"\"\"Unbind the given ports by clearing their device_id,\n        device_owner and dns_name.\n\n        :param context: The request context.\n        :param ports: list of port IDs.\n        :param neutron: neutron client for the current context.\n        :param port_client: The client with appropriate karma for\n            updating the ports.\n        \"\"\"",
        "\"\"\"Processes and validates requested networks for allocation.\n\n        Iterates over the list of NetworkRequest objects, validating the\n        request and building sets of ports and networks to\n        use for allocating ports for the instance.\n\n        :param context: The user request context.\n        :type context: nova.context.RequestContext\n        :param instance: allocate networks on this instance\n        :type instance: nova.objects.Instance\n        :param neutron: neutron client session\n        :type neutron: neutronclient.v2_0.client.Client\n        :param requested_networks: List of user-requested networks and/or ports\n        :type requested_networks: nova.objects.NetworkRequestList\n        :param attach: Boolean indicating if a port is being attached to an\n            existing running instance. Should be False during server create.\n        :type attach: bool\n        :returns: tuple of:\n            - ports: dict mapping of port id to port dict\n            - ordered_networks: list of nova.objects.NetworkRequest objects\n                for requested networks (either via explicit network request\n                or the network for an explicit port request)\n        :raises nova.exception.PortNotFound: If a requested port is not found\n            in Neutron.\n        :raises nova.exception.PortNotUsable: If a requested port is not owned\n            by the same tenant that the instance is created under.\n        :raises nova.exception.PortInUse: If a requested port is already\n            attached to another instance.\n        :raises nova.exception.PortNotUsableDNS: If a requested port has a\n            value assigned to its dns_name attribute.\n        :raises nova.exception.AttachSRIOVPortNotSupported: If a requested port\n            is an SR-IOV port and ``attach=True``.\n        \"\"\"",
        "\"\"\"Cleans security groups requested from Nova API\n\n        Neutron already passes a 'default' security group when\n        creating ports so it's not necessary to specify it to the\n        request.\n        \"\"\"",
        "\"\"\"Processes and validates requested security groups for allocation.\n\n        Iterates over the list of requested security groups, validating the\n        request and filtering out the list of security group IDs to use for\n        port allocation.\n\n        :param instance: allocate networks on this instance\n        :type instance: nova.objects.Instance\n        :param neutron: neutron client session\n        :type neutron: neutronclient.v2_0.client.Client\n        :param security_groups: list of requested security group name or IDs\n            to use when allocating new ports for the instance\n        :return: list of security group IDs to use when allocating new ports\n        :raises nova.exception.NoUniqueMatch: If multiple security groups\n            are requested with the same name.\n        :raises nova.exception.SecurityGroupNotFound: If a requested security\n            group is not in the tenant-filtered list of available security\n            groups in Neutron.\n        \"\"\"",
        "\"\"\"Check requested networks using the Neutron API.\n\n        Check the user has access to the network they requested, and that\n        it is a suitable network to connect to. This includes getting the\n        network details for any ports that have been passed in, because the\n        request will have been updated with the network_id in\n        _validate_requested_port_ids.\n\n        If the user has not requested any ports or any networks, we get back\n        a full list of networks the user has access to, and if there is only\n        one network, we update ordered_networks so we will connect the\n        instance to that network.\n\n        :param context: The request context.\n        :param instance: nova.objects.instance.Instance object.\n        :param neutron: neutron client\n        :param requested_networks: nova.objects.NetworkRequestList, list of\n            user-requested networks and/or ports; may be empty\n        :param ordered_networks: output from _validate_requested_port_ids\n            that will be used to create and update ports\n        :returns: dict, keyed by network ID, of networks to use\n        :raises InterfaceAttachFailedNoNetwork: If no specific networks were\n            requested and none are available.\n        :raises NetworkAmbiguous: If no specific networks were requested but\n            more than one is available.\n        :raises ExternalNetworkAttachForbidden: If the policy rules forbid\n            the request context from using an external non-shared network but\n            one was requested (or available).\n        \"\"\"",
        "\"\"\"Create port for network_requests that don't have a port_id\n\n        :param context: The request context.\n        :param instance: nova.objects.instance.Instance object.\n        :param ordered_networks: objects.NetworkRequestList in requested order\n        :param nets: a dict of network_id to networks returned from neutron\n        :param neutron: neutronclient built from users request context\n        :param security_group_ids: a list of security group IDs to be applied\n            to any ports created\n        :returns a list of pairs (NetworkRequest, created_port_uuid); note that\n            created_port_uuid will be None for the pair where a pre-existing\n            port was part of the user request\n        \"\"\"",
        "\"\"\"Allocate network resources for the instance.\n\n        :param context: The request context.\n        :param instance: nova.objects.instance.Instance object.\n        :param vpn: A boolean, ignored by this driver.\n        :param requested_networks: objects.NetworkRequestList object.\n        :param macs: None or a set of MAC addresses that the instance\n            should use. macs is supplied by the hypervisor driver (contrast\n            with requested_networks which is user supplied).\n            NB: NeutronV2 currently assigns hypervisor supplied MAC addresses\n            to arbitrary networks, which requires openflow switches to\n            function correctly if more than one network is being used with\n            the bare metal hypervisor (which is the only one known to limit\n            MAC addresses).\n        :param security_groups: None or security groups to allocate for\n            instance.\n        :param bind_host_id: the host ID to attach to the ports being created.\n        :param attach: Boolean indicating if a port is being attached to an\n            existing running instance. Should be False during server create.\n        :returns: network info as from get_instance_nw_info()\n        \"\"\"",
        "\"\"\"Update ports from network_requests.\n\n        Updates the pre-existing ports and the ones created in\n        ``_create_ports_for_instance`` with ``device_id``, ``device_owner``,\n        optionally ``mac_address`` and, depending on the\n        loaded extensions, ``rxtx_factor``, ``binding:host_id``, ``dns_name``.\n\n        :param context: The request context.\n        :param instance: nova.objects.instance.Instance object.\n        :param neutron: client using user context\n        :param admin_client: client using admin context\n        :param requests_and_created_ports: [(NetworkRequest, created_port_id)];\n            Note that created_port_id will be None for any user-requested\n            pre-existing port.\n        :param nets: a dict of network_id to networks returned from neutron\n        :param bind_host_id: a string for port['binding:host_id']\n        :param available_macs: a list of available mac addresses\n        :param requested_ports_dict: dict, keyed by port ID, of ports requested\n            by the user\n        :returns: tuple with the following::\n\n            * list of network dicts in their requested order\n            * list of port IDs in their requested order - note that does not\n              mean the port was requested by the user, it could be a port\n              created on a network requested by the user\n            * list of pre-existing port IDs requested by the user\n            * list of created port IDs\n        \"\"\"",
        "\"\"\"Refresh the neutron extensions cache when necessary.\"\"\"",
        "\"\"\"Populate neutron binding:profile.\n\n        Populate it with SR-IOV related information\n\n        :raises PciDeviceNotFound: If a claimed PCI device for the given\n            pci_request_id cannot be found on the instance.\n        \"\"\"",
        "\"\"\"Add the updated MAC address value to the update_port request body.\n\n        Currently this is done only for PF passthrough.\n        \"\"\"",
        "\"\"\"Populate neutron extension values for the instance.\n\n        If the extensions loaded contain QOS_QUEUE then pass the rxtx_factor.\n        \"\"\"",
        "\"\"\"Update an instance port dns_name attribute with instance.hostname.\n\n        The dns_name attribute of a port on a network with a non-blank\n        dns_domain attribute will be sent to the external DNS service\n        (Designate) if DNS integration is enabled in Neutron. This requires the\n        assignment of the dns_name to the port to be done with a Neutron client\n        using the user's context. allocate_for_instance uses a port with admin\n        context if the port binding extensions is enabled in Neutron. In this\n        case, we assign in this method the dns_name attribute to the port with\n        an additional update request. Only a very small fraction of ports will\n        require this additional update request.\n        \"\"\"",
        "\"\"\"Reset an instance port dns_name attribute to empty when using\n        external DNS service.\n\n        _unbind_ports uses a client with admin context to reset the dns_name if\n        the DNS extension is enabled and network does not have dns_domain set.\n        When external DNS service is enabled, we use this method to make the\n        request with a Neutron client using user's context, so that the DNS\n        record can be found under user's zone and domain.\n        \"\"\"",
        "\"\"\"Deallocate all network resources related to the instance.\"\"\"",
        "\"\"\"Allocate a port for the instance.\"\"\"",
        "\"\"\"Remove a specified port from the instance.\n\n        Return network information for the instance\n        \"\"\"",
        "\"\"\"List ports for the client based on search options.\"\"\"",
        "\"\"\"Return the port for the client given the port id.\n\n        :param context: Request context.\n        :param port_id: The id of port to be queried.\n        :returns: A dict containing port data keyed by 'port', e.g.\n\n        ::\n\n            {'port': {'port_id': 'abcd',\n                      'fixed_ip_address': '1.2.3.4'}}\n        \"\"\"",
        "\"\"\"Return the port for the client given the port id.\n\n        :param context: Request context.\n        :param port_id: The id of port to be queried.\n        :param neutron_client: A neutron client.\n        :param fields: The condition fields to query port data.\n        :returns: A dict of port data.\n                  e.g. {'port_id': 'abcd', 'fixed_ip_address': '1.2.3.4'}\n        \"\"\"",
        "\"\"\"Return an instance's complete list of port_ids and networks.\"\"\"",
        "\"\"\"Add a fixed IP to the instance from specified network.\"\"\"",
        "\"\"\"Remove a fixed IP from the instance.\"\"\"",
        "\"\"\"Retrieve port vnic info\n\n        Invoked with a valid port_id.\n        Return vnic type and the attached physical network name.\n        \"\"\"",
        "\"\"\"Check requested networks for any SR-IOV port request.\n\n        Create a PCI request object for each SR-IOV port, and add it to the\n        pci_requests object that contains a list of PCI request object.\n        \"\"\"",
        "\"\"\"Helper method to determine if we can auto-allocate networks\n\n        :param context: nova request context\n        :param neutron: neutron client\n        :returns: True if it's possible to auto-allocate networks, False\n                  otherwise.\n        \"\"\"",
        "\"\"\"Automatically allocates a network for the given project.\n\n        :param instance: create the network for the project that owns this\n            instance\n        :param neutron: neutron client\n        :returns: Details of the network that was created.\n        :raises: nova.exception.UnableToAutoAllocateNetwork\n        :raises: nova.exception.NetworkNotFound\n        \"\"\"",
        "\"\"\"Validate that the tenant can use the requested networks.\n\n        Return the number of instances than can be successfully allocated\n        with the requested network configuration.\n        \"\"\"",
        "\"\"\"Retrieve instance uuids associated with the given IP address.\n\n        :returns: A list of dicts containing the uuids keyed by 'instance_uuid'\n                  e.g. [{'instance_uuid': uuid}, ...]\n        \"\"\"",
        "\"\"\"Return port_id from a fixed address.\"\"\"",
        "\"\"\"Associate a floating IP with a fixed IP.\"\"\"",
        "\"\"\"Get all networks for client.\"\"\"",
        "\"\"\"Get specific network for client.\"\"\"",
        "\"\"\"Delete a network for client.\"\"\"",
        "\"\"\"Disassociate a network for client.\"\"\"",
        "\"\"\"Associate a network for client.\"\"\"",
        "\"\"\"Get a fixed IP from the id.\"\"\"",
        "\"\"\"Return instance uuids given an address.\"\"\"",
        "\"\"\"Return floating IP object given the floating IP id.\"\"\"",
        "\"\"\"Return floating IP pool names.\"\"\"",
        "\"\"\"Return a floating IP given an address.\"\"\"",
        "\"\"\"Return the instance id a floating IP's fixed IP is allocated to.\"\"\"",
        "\"\"\"Get default pool name from config.\n\n        TODO(stephenfin): Remove this helper function in Queens, opting to\n        use the [neutron] option only.\n        \"\"\"",
        "\"\"\"Add a floating IP to a project from a pool.\"\"\"",
        "\"\"\"Get floating IP gracefully handling 404 from Neutron.\"\"\"",
        "\"\"\"Get floating IP from floating IP address.\"\"\"",
        "\"\"\"Get floating IPs from fixed IP and port.\"\"\"",
        "\"\"\"Remove a floating IP with the given address from a project.\"\"\"",
        "\"\"\"Removes (deallocates) and deletes the floating IP.\n\n        This api call was added to allow this to be done in one operation\n        if using neutron.\n        \"\"\"",
        "\"\"\"Disassociate a floating IP from the instance.\"\"\"",
        "\"\"\"Start to migrate the network of an instance.\"\"\"",
        "\"\"\"Finish migrating the network of an instance.\"\"\"",
        "\"\"\"Force add a network to the project.\"\"\"",
        "\"\"\"Retrieve the preexisting ports associated with the given instance.\n        These ports were not created by nova and hence should not be\n        deallocated upon instance deletion.\n        \"\"\"",
        "\"\"\"Builds a ``nova.network.model.VIF`` object based on the parameters\n        and current state of the port in Neutron.\n\n        :param context: Request context.\n        :param client: Neutron client.\n        :param current_neutron_port: The current state of a Neutron port\n            from which to build the VIF object model.\n        :param networks: List of dicts which represent Neutron networks\n            associated with the ports currently attached to a given server\n            instance.\n        :param preexisting_port_ids: List of IDs of ports attached to a\n            given server instance which Nova did not create and therefore\n            should not delete when the port is detached from the server.\n        :return: nova.network.model.VIF object which represents a port in the\n            instance network info cache.\n        \"\"\"",
        "\"\"\"Return list of ordered VIFs attached to instance.\n\n        :param context: Request context.\n        :param instance: Instance we are returning network info for.\n        :param networks: List of networks being attached to an instance.\n                         If value is None this value will be populated\n                         from the existing cached value.\n        :param port_ids: List of port_ids that are being attached to an\n                         instance in order of attachment. If value is None\n                         this value will be populated from the existing\n                         cached value.\n        :param admin_client: A neutron client for the admin context.\n        :param preexisting_port_ids: List of port_ids that nova didn't\n                        allocate and there shouldn't be deleted when\n                        an instance is de-allocated. Supplied list will\n                        be added to the cached list of preexisting port\n                        IDs for this instance.\n        :param refresh_vif_id: Optional port ID to refresh within the existing\n                        cache rather than the entire cache. This can be\n                        triggered via a \"network-changed\" server external event\n                        from Neutron.\n        \"\"\"",
        "\"\"\"Return the subnets for a given port.\"\"\"",
        "\"\"\"Return a list of available dns domains.\n\n        These can be used to create DNS entries for floating IPs.\n        \"\"\"",
        "\"\"\"Create specified DNS entry for address.\"\"\"",
        "\"\"\"Create specified DNS entry for address.\"\"\"",
        "\"\"\"Delete the specified dns entry.\"\"\"",
        "\"\"\"Delete the specified dns domain.\"\"\"",
        "\"\"\"Get entries for address and domain.\"\"\"",
        "\"\"\"Get entries for name and domain.\"\"\"",
        "\"\"\"Create a private DNS domain with nova availability zone.\"\"\"",
        "\"\"\"Create a private DNS domain with optional nova project.\"\"\"",
        "\"\"\"Setup network for specified instance on host.\"\"\"",
        "\"\"\"Cleanup network for specified instance on host.\"\"\"",
        "\"\"\"Update instance vnic index.\n\n        When the 'VNIC index' extension is supported this method will update\n        the vnic index of the instance on the port.\n        \"\"\"",
        "\"\"\"Sort a list with respect to the preferred network ordering.\"\"\""
    ],
    "functions": [
        "reset_state",
        "_load_auth_plugin",
        "_get_binding_profile",
        "__getattribute__",
        "proxy",
        "wrapper",
        "get_client",
        "_is_not_duplicate",
        "_ensure_no_port_binding_failure",
        "_filter_hypervisor_macs",
        "_update_port_with_migration_profile",
        "_clear_migration_port_profile",
        "_setup_migration_port_profile",
        "setup_networks_on_host",
        "_get_available_networks",
        "_create_port_minimal",
        "_update_port",
        "_populate_mac_address",
        "_check_external_network_attach",
        "_unbind_ports",
        "_validate_requested_port_ids",
        "_clean_security_groups",
        "_process_security_groups",
        "_validate_requested_network_ids",
        "_create_ports_for_instance",
        "allocate_for_instance",
        "_update_ports_for_instance",
        "_refresh_neutron_extensions_cache",
        "_has_multi_provider_extension",
        "_has_dns_extension",
        "_has_qos_queue_extension",
        "has_substr_port_filtering_extension",
        "_get_pci_device_profile",
        "_populate_neutron_binding_profile",
        "_populate_pci_mac_address",
        "_populate_neutron_extension_values",
        "_update_port_dns_name",
        "_reset_port_dns_name",
        "_delete_ports",
        "deallocate_for_instance",
        "allocate_port_for_instance",
        "deallocate_port_for_instance",
        "_delete_nic_metadata",
        "list_ports",
        "show_port",
        "_show_port",
        "_get_instance_nw_info",
        "_gather_port_ids_and_networks",
        "add_fixed_ip_to_instance",
        "remove_fixed_ip_from_instance",
        "_get_phynet_info",
        "_get_port_vnic_info",
        "create_pci_requests_for_sriov_ports",
        "_can_auto_allocate_network",
        "_auto_allocate_network",
        "_ports_needed_per_instance",
        "validate_networks",
        "_get_instance_uuids_by_ip",
        "_get_port_id_by_fixed_address",
        "associate_floating_ip",
        "get_all",
        "get",
        "disassociate",
        "associate",
        "get_fixed_ip",
        "get_fixed_ip_by_address",
        "_setup_net_dict",
        "_setup_port_dict",
        "_setup_pools_dict",
        "_setup_ports_dict",
        "get_floating_ip",
        "_get_floating_ip_pools",
        "get_floating_ip_pools",
        "_make_floating_ip_obj",
        "get_floating_ip_by_address",
        "get_floating_ips_by_project",
        "get_instance_id_by_floating_address",
        "get_vifs_by_instance",
        "get_vif_by_mac_address",
        "_get_floating_ip_pool_id_by_name_or_id",
        "_get_default_floating_ip_pool_name",
        "allocate_floating_ip",
        "_safe_get_floating_ips",
        "_get_floating_ip_by_address",
        "_get_floating_ips_by_fixed_and_port",
        "release_floating_ip",
        "disassociate_and_release_floating_ip",
        "_release_floating_ip_and_refresh_cache",
        "_release_floating_ip",
        "disassociate_floating_ip",
        "migrate_instance_start",
        "migrate_instance_finish",
        "add_network_to_project",
        "_nw_info_get_ips",
        "_nw_info_get_subnets",
        "_nw_info_build_network",
        "_get_preexisting_port_ids",
        "_build_vif_model",
        "_build_network_info_model",
        "_get_subnets_from_port",
        "get_dns_domains",
        "add_dns_entry",
        "modify_dns_entry",
        "delete_dns_entry",
        "delete_dns_domain",
        "get_dns_entries_by_address",
        "get_dns_entries_by_name",
        "create_private_dns_domain",
        "create_public_dns_domain",
        "setup_instance_network_on_host",
        "cleanup_instance_network_on_host",
        "_get_pci_mapping_for_migration",
        "_update_port_binding_for_instance",
        "update_instance_vnic_index",
        "_ensure_requested_network_ordering"
    ],
    "classes": [
        "ClientWrapper",
        "API"
    ]
}