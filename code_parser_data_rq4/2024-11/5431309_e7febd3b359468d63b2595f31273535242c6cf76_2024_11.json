{
    "identifiers": [
        "mekanism",
        "common",
        "network",
        "to_client",
        "qio",
        "it",
        "unimi",
        "dsi",
        "fastutil",
        "objects",
        "Object2ObjectOpenHashMap",
        "it",
        "unimi",
        "dsi",
        "fastutil",
        "objects",
        "ReferenceArrayList",
        "java",
        "util",
        "Collections",
        "java",
        "util",
        "java",
        "util",
        "mekanism",
        "common",
        "content",
        "qio",
        "QIOFrequency",
        "mekanism",
        "common",
        "content",
        "qio",
        "QIOFrequency",
        "QIOItemTypeData",
        "mekanism",
        "common",
        "inventory",
        "ISlotClickHandler",
        "IScrollableSlot",
        "mekanism",
        "common",
        "inventory",
        "container",
        "QIOItemViewerContainer",
        "ItemSlotData",
        "mekanism",
        "common",
        "lib",
        "inventory",
        "HashedItem",
        "mekanism",
        "common",
        "lib",
        "inventory",
        "HashedItem",
        "UUIDAwareHashedItem",
        "net",
        "minecraft",
        "network",
        "RegistryFriendlyByteBuf",
        "net",
        "minecraft",
        "world",
        "item",
        "ItemStack",
        "org",
        "jetbrains",
        "annotations",
        "BulkQIOData",
        "inventory",
        "countCapacity",
        "typeCapacity",
        "totalItems",
        "items",
        "INITIAL_SERVER",
        "Collections",
        "emptyMap",
        "Collections",
        "emptyList",
        "buffer",
        "frequency",
        "buffer",
        "writeBoolean",
        "frequency",
        "frequency",
        "itemDataMap",
        "frequency",
        "getItemDataMap",
        "buffer",
        "writeVarInt",
        "itemDataMap",
        "size",
        "data",
        "itemDataMap",
        "values",
        "ItemStack",
        "STREAM_CODEC",
        "encode",
        "buffer",
        "data",
        "getItemType",
        "getInternalStack",
        "buffer",
        "writeUUID",
        "data",
        "getItemUUID",
        "buffer",
        "writeVarLong",
        "data",
        "getCount",
        "buffer",
        "writeVarLong",
        "frequency",
        "getTotalItemCountCapacity",
        "buffer",
        "writeVarInt",
        "frequency",
        "getTotalItemTypeCapacity",
        "buffer",
        "buffer",
        "readBoolean",
        "totalItems",
        "itemMapSize",
        "buffer",
        "readVarInt",
        "itemList",
        "itemMapSize",
        "inventory",
        "itemMapSize",
        "i",
        "i",
        "itemMapSize",
        "i",
        "slotData",
        "UUIDAwareHashedItem",
        "STREAM_CODEC",
        "decode",
        "buffer",
        "buffer",
        "readVarLong",
        "totalItems",
        "slotData",
        "count",
        "itemList",
        "add",
        "slotData",
        "inventory",
        "put",
        "slotData",
        "item",
        "slotData",
        "inventory",
        "buffer",
        "readVarLong",
        "buffer",
        "readVarInt",
        "totalItems",
        "itemList"
    ],
    "literals": [],
    "variables": [],
    "comments": [
        "Manual implementation of encoding PacketUpdateItemViewer.ITEM_MAP_CODEC without having to actually create the intermediary UUIDAwareHashedItem instance",
        "The following two lines are equivalent to encoding UUIDAwareHashedItem.STREAM_CODEC",
        "End implementation of encoding ITEM_MAP_CODEC",
        "Note: We manually handle decoding the map so that we can avoid having to create an intermediary holding map",
        "Note: Use a ReferenceArrayList to",
        "If we don't have a frequency, just use empty uninitialized data that is modifiable",
        "TODO: Do we even need to be using a modifiable version, instead of say INITIAL_SERVER?",
        "Theoretically because of how things are done, if the frequency changes we get a new open container packet",
        "with the bulk data in it, and if there is no frequency we shouldn't get any update contents packets"
    ],
    "docstrings": [],
    "functions": [
        "encodeToPacket",
        "BulkQIOData",
        "fromPacket"
    ],
    "classes": []
}