{
    "identifiers": [
        "ng",
        "ngWorker",
        "ngUi",
        "ng",
        "bootstrap",
        "appComponentType",
        "componentInjectableBindings",
        "DirectiveMetadata",
        "InjectableMetadata",
        "InjectableMetadata",
        "LifecycleEvent",
        "ViewEncapsulation",
        "DependencyMetadata",
        "DependencyMetadata",
        "name",
        "name",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "selector",
        "selector",
        "obj",
        "obj",
        "changes",
        "Class",
        "clsDef",
        "obj",
        "ChangeDetectionStrategy",
        "cd",
        "cd",
        "cd",
        "cd",
        "context",
        "locals",
        "directives",
        "pipes",
        "eventName",
        "elIndex",
        "locals",
        "name",
        "name",
        "name",
        "value",
        "value",
        "value",
        "args",
        "factories",
        "parent",
        "factories",
        "iterable",
        "objects",
        "cdRef",
        "factories",
        "parent",
        "factories",
        "kv",
        "objects",
        "cdRef",
        "args",
        "baseUrl",
        "url",
        "component",
        "componentTypeOrBinding",
        "location",
        "hostViewRef",
        "hostLocation",
        "variableName",
        "hostLocation",
        "hostProtoViewRef",
        "overrideSelector",
        "injector",
        "hostViewRef",
        "viewContainerLocation",
        "atIndex",
        "templateRef",
        "viewContainerLocation",
        "atIndex",
        "protoViewRef",
        "imperativelyCreatedInjector",
        "viewContainerLocation",
        "atIndex",
        "viewContainerLocation",
        "atIndex",
        "viewRef",
        "viewContainerLocation",
        "atIndex",
        "newList",
        "obj",
        "callback",
        "callback",
        "fn",
        "item",
        "typeOrBinding",
        "overrideSelector",
        "injector",
        "typeOrBinding",
        "hostLocation",
        "anchorName",
        "bindings",
        "typeOrBinding",
        "location",
        "bindings",
        "zone",
        "changeDetector",
        "name",
        "contextName",
        "value",
        "index",
        "templateRef",
        "atIndex",
        "protoViewRef",
        "atIndex",
        "dynamicallyCreatedBindings",
        "viewRef",
        "atIndex",
        "viewRef",
        "atIndex",
        "atIndex",
        "onTurnStartFn",
        "onTurnDoneFn",
        "onEventDoneFn",
        "opt_waitForAsync",
        "errorHandlingFn",
        "fn",
        "fn",
        "generator",
        "Observable",
        "generator",
        "Rx",
        "Rx",
        "value",
        "error",
        "value",
        "forwardRef",
        "forwardRefFn",
        "resolveForwardRef",
        "bindings",
        "bindings",
        "depProvider",
        "bindings",
        "depProvider",
        "token",
        "token",
        "index",
        "bindings",
        "depProvider",
        "bindings",
        "depProvider",
        "binding",
        "binding",
        "index",
        "injector",
        "binding",
        "dependency",
        "Visibility",
        "value",
        "aliasToken",
        "factoryFunction",
        "dependencies",
        "key",
        "bind",
        "token",
        "token",
        "token",
        "AbstractBindingError",
        "injector",
        "key",
        "AbstractBindingError",
        "AbstractBindingError",
        "token",
        "token",
        "tuples",
        "viewContainer",
        "tuples",
        "viewContainer",
        "templateRef",
        "parent",
        "path",
        "errorCode",
        "path",
        "errorCode",
        "path",
        "AbstractControl",
        "value",
        "fn",
        "AbstractControl",
        "name",
        "c",
        "name",
        "controlName",
        "controlName",
        "controlName",
        "AbstractControl",
        "index",
        "control",
        "index",
        "control",
        "index",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "value",
        "AbstractControlDirective",
        "NgControl",
        "c",
        "newValue",
        "NgControl",
        "c",
        "newValue",
        "NgControl",
        "c",
        "newValue",
        "AbstractControlDirective",
        "newValue",
        "ControlContainer",
        "ControlContainer",
        "_",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "value",
        "ControlContainer",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "value",
        "obj",
        "fn",
        "fn",
        "value",
        "fn",
        "_",
        "fn",
        "value",
        "fn",
        "_",
        "fn",
        "value",
        "fn",
        "fn",
        "c",
        "c",
        "validators",
        "c",
        "c",
        "NgValidator",
        "controlsConfig",
        "extra",
        "value",
        "validator",
        "controlsConfig",
        "validator",
        "Renderer",
        "hostProtoViewRef",
        "fragmentCount",
        "hostElementSelector",
        "protoViewRef",
        "fragmentCount",
        "viewRef",
        "location",
        "fragment",
        "previousFragmentRef",
        "fragmentRef",
        "elementRef",
        "fragmentRef",
        "fragmentRef",
        "viewRef",
        "viewRef",
        "location",
        "propertyName",
        "propertyValue",
        "location",
        "attributeName",
        "attributeValue",
        "location",
        "className",
        "isAdd",
        "location",
        "styleName",
        "styleValue",
        "location",
        "methodName",
        "args",
        "viewRef",
        "textNodeIndex",
        "text",
        "viewRef",
        "dispatcher",
        "elementIndex",
        "eventName",
        "locals",
        "hostProtoViewRef",
        "fragmentCount",
        "hostElementSelector",
        "protoViewRef",
        "fragmentCount",
        "viewRef",
        "previousFragmentRef",
        "fragmentRef",
        "elementRef",
        "fragmentRef",
        "fragmentRef",
        "viewRef",
        "viewRef",
        "location",
        "location",
        "propertyName",
        "propertyValue",
        "location",
        "attributeName",
        "attributeValue",
        "location",
        "className",
        "isAdd",
        "location",
        "styleName",
        "styleValue",
        "location",
        "methodName",
        "args",
        "viewRef",
        "textNodeIndex",
        "text",
        "viewRef",
        "dispatcher",
        "scope",
        "returnValue",
        "rangeType",
        "action",
        "arg0",
        "arg1",
        "ng",
        "ngWorker",
        "DirectiveMetadata",
        "InjectableMetadata",
        "InjectableMetadata",
        "LifecycleEvent",
        "ViewEncapsulation",
        "DependencyMetadata",
        "DependencyMetadata",
        "name",
        "name",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "selector",
        "selector",
        "obj",
        "obj",
        "changes",
        "Class",
        "clsDef",
        "obj",
        "ChangeDetectionStrategy",
        "cd",
        "cd",
        "cd",
        "cd",
        "context",
        "locals",
        "directives",
        "pipes",
        "eventName",
        "elIndex",
        "locals",
        "name",
        "name",
        "name",
        "value",
        "value",
        "value",
        "args",
        "factories",
        "parent",
        "factories",
        "iterable",
        "objects",
        "cdRef",
        "factories",
        "parent",
        "factories",
        "kv",
        "objects",
        "cdRef",
        "args",
        "baseUrl",
        "url",
        "component",
        "componentTypeOrBinding",
        "location",
        "hostViewRef",
        "hostLocation",
        "variableName",
        "hostLocation",
        "hostProtoViewRef",
        "overrideSelector",
        "injector",
        "hostViewRef",
        "viewContainerLocation",
        "atIndex",
        "templateRef",
        "viewContainerLocation",
        "atIndex",
        "protoViewRef",
        "imperativelyCreatedInjector",
        "viewContainerLocation",
        "atIndex",
        "viewContainerLocation",
        "atIndex",
        "viewRef",
        "viewContainerLocation",
        "atIndex",
        "newList",
        "obj",
        "callback",
        "callback",
        "fn",
        "item",
        "typeOrBinding",
        "overrideSelector",
        "injector",
        "typeOrBinding",
        "hostLocation",
        "anchorName",
        "bindings",
        "typeOrBinding",
        "location",
        "bindings",
        "zone",
        "changeDetector",
        "name",
        "contextName",
        "value",
        "index",
        "templateRef",
        "atIndex",
        "protoViewRef",
        "atIndex",
        "dynamicallyCreatedBindings",
        "viewRef",
        "atIndex",
        "viewRef",
        "atIndex",
        "atIndex",
        "onTurnStartFn",
        "onTurnDoneFn",
        "onEventDoneFn",
        "opt_waitForAsync",
        "errorHandlingFn",
        "fn",
        "fn",
        "generator",
        "Observable",
        "generator",
        "Rx",
        "Rx",
        "value",
        "error",
        "value",
        "forwardRef",
        "forwardRefFn",
        "resolveForwardRef",
        "bindings",
        "bindings",
        "depProvider",
        "bindings",
        "depProvider",
        "token",
        "token",
        "index",
        "bindings",
        "depProvider",
        "bindings",
        "depProvider",
        "binding",
        "binding",
        "index",
        "injector",
        "binding",
        "dependency",
        "Visibility",
        "value",
        "aliasToken",
        "factoryFunction",
        "dependencies",
        "key",
        "bind",
        "token",
        "token",
        "token",
        "AbstractBindingError",
        "injector",
        "key",
        "AbstractBindingError",
        "AbstractBindingError",
        "token",
        "token",
        "tuples",
        "viewContainer",
        "tuples",
        "viewContainer",
        "templateRef",
        "parent",
        "path",
        "errorCode",
        "path",
        "errorCode",
        "path",
        "AbstractControl",
        "value",
        "fn",
        "AbstractControl",
        "name",
        "c",
        "name",
        "controlName",
        "controlName",
        "controlName",
        "AbstractControl",
        "index",
        "control",
        "index",
        "control",
        "index",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "value",
        "AbstractControlDirective",
        "NgControl",
        "c",
        "newValue",
        "NgControl",
        "c",
        "newValue",
        "NgControl",
        "c",
        "newValue",
        "AbstractControlDirective",
        "newValue",
        "ControlContainer",
        "ControlContainer",
        "_",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "value",
        "ControlContainer",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "dir",
        "value",
        "obj",
        "fn",
        "fn",
        "value",
        "fn",
        "_",
        "fn",
        "value",
        "fn",
        "_",
        "fn",
        "value",
        "fn",
        "fn",
        "c",
        "c",
        "validators",
        "c",
        "c",
        "NgValidator",
        "controlsConfig",
        "extra",
        "value",
        "validator",
        "controlsConfig",
        "validator",
        "Renderer",
        "hostProtoViewRef",
        "fragmentCount",
        "hostElementSelector",
        "protoViewRef",
        "fragmentCount",
        "viewRef",
        "location",
        "fragment",
        "previousFragmentRef",
        "fragmentRef",
        "elementRef",
        "fragmentRef",
        "fragmentRef",
        "viewRef",
        "viewRef",
        "location",
        "propertyName",
        "propertyValue",
        "location",
        "attributeName",
        "attributeValue",
        "location",
        "className",
        "isAdd",
        "location",
        "styleName",
        "styleValue",
        "location",
        "methodName",
        "args",
        "viewRef",
        "textNodeIndex",
        "text",
        "viewRef",
        "dispatcher",
        "elementIndex",
        "eventName",
        "locals",
        "hostProtoViewRef",
        "fragmentCount",
        "hostElementSelector",
        "protoViewRef",
        "fragmentCount",
        "viewRef",
        "previousFragmentRef",
        "fragmentRef",
        "elementRef",
        "fragmentRef",
        "fragmentRef",
        "viewRef",
        "viewRef",
        "location",
        "location",
        "propertyName",
        "propertyValue",
        "location",
        "attributeName",
        "attributeValue",
        "location",
        "className",
        "isAdd",
        "location",
        "styleName",
        "styleValue",
        "location",
        "methodName",
        "args",
        "viewRef",
        "textNodeIndex",
        "text",
        "viewRef",
        "dispatcher",
        "scope",
        "returnValue",
        "rangeType",
        "action",
        "arg0",
        "arg1",
        "bootstrapWebWorker",
        "appComponentType",
        "componentInjectableBindings",
        "channel",
        "channel",
        "channel",
        "channel",
        "channel",
        "args",
        "returnType",
        "channel",
        "methodName",
        "signature",
        "method",
        "returnType",
        "obj",
        "data",
        "obj",
        "data",
        "fragmentCount",
        "ngWorker",
        "ngUi",
        "channel",
        "channel",
        "bootstrap",
        "uri",
        "spawnWebWorker",
        "uri",
        "Observable",
        "generator",
        "Rx",
        "Rx",
        "value",
        "error",
        "value",
        "generator",
        "channel",
        "channel",
        "channel",
        "channel",
        "args",
        "channel",
        "args",
        "returnType",
        "channel",
        "methodName",
        "signature",
        "method",
        "returnType",
        "obj",
        "data",
        "obj",
        "data",
        "fragmentCount",
        "ngUi"
    ],
    "literals": [
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "\"angular2/angular2\"",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "\"angular2/web_worker/worker\"",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "\"angular2/web_worker/ui\""
    ],
    "variables": [
        "Attribute",
        "Component",
        "Directive",
        "View",
        "Query",
        "ViewQuery",
        "Pipe",
        "APP_COMPONENT",
        "UNDEFINED",
        "Inject",
        "Optional",
        "Injectable",
        "Self",
        "Host",
        "SkipSelf",
        "CORE_DIRECTIVES",
        "FORM_DIRECTIVES",
        "FORM_BINDINGS",
        "DOCUMENT",
        "APP_ID",
        "MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE",
        "wtfCreateScope",
        "wtfLeave",
        "wtfStartTimeRange",
        "wtfEndTimeRange",
        "ChangeDetectorRef",
        "ApplicationRef",
        "Compiler",
        "AppViewManager",
        "ViewRef",
        "ProtoViewRef",
        "ViewContainerRef",
        "ComponentRef",
        "Attribute",
        "Component",
        "Directive",
        "View",
        "Query",
        "ViewQuery",
        "Pipe",
        "APP_COMPONENT",
        "UNDEFINED",
        "Inject",
        "Optional",
        "Injectable",
        "Self",
        "Host",
        "SkipSelf",
        "CORE_DIRECTIVES",
        "FORM_DIRECTIVES",
        "FORM_BINDINGS",
        "DOCUMENT",
        "APP_ID",
        "MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE",
        "wtfCreateScope",
        "wtfLeave",
        "wtfStartTimeRange",
        "wtfEndTimeRange",
        "PRIMITIVE",
        "ChangeDetectorRef",
        "ApplicationRef",
        "Compiler",
        "AppViewManager",
        "ViewRef",
        "ProtoViewRef",
        "ViewContainerRef",
        "ComponentRef",
        "PRIMITIVE"
    ],
    "comments": [
        "Type definitions for Angular v2.0.0-alpha.37",
        "Project: http://angular.io/",
        "Definitions by: angular team <https://github.com/angular/>",
        "Definitions: https://github.com/borisyankov/DefinitelyTyped",
        "This file is generated by the Angular build process.",
        "Please do not create manual edits or send pull requests",
        "modifying this file.",
        "angular2/angular2 depends transitively on these libraries.",
        "If you don't have them installed you can install them using TSD",
        "https://github.com/DefinitelyTyped/tsd",
        "<reference path=\"../es6-promise/es6-promise.d.ts\"/>",
        "<reference path=\"../rx/rx.d.ts\"/>",
        "angular2/web_worker/worker depends transitively on these libraries.",
        "If you don't have them installed you can install them using TSD",
        "https://github.com/DefinitelyTyped/tsd",
        "<reference path=\"../es6-promise/es6-promise.d.ts\"/>",
        "<reference path=\"../rx/rx.d.ts\"/>",
        "angular2/web_worker/ui depends transitively on these libraries.",
        "If you don't have them installed you can install them using TSD",
        "https://github.com/DefinitelyTyped/tsd",
        "<reference path=\"../es6-promise/es6-promise.d.ts\"/>",
        "<reference path=\"../rx/rx.d.ts\"/>",
        "See https://github.com/Microsoft/TypeScript/issues/1168",
        "extends Error",
        "See https://github.com/Microsoft/TypeScript/issues/1168",
        "extends Error",
        "See https://github.com/Microsoft/TypeScript/issues/1168",
        "extends Error",
        "Type",
        "Type",
        "Type"
    ],
    "docstrings": [
        "***********************************************************",
        "***********************************************************",
        "* The `angular2` is the single place to import all of the individual types.",
        "* Bootstrapping for Angular applications.\n   *\n   * You instantiate an Angular application by explicitly specifying a component to use as the root\n   * component for your\n   * application via the `bootstrap()` method.\n   *\n   * ## Simple Example\n   *\n   * Assuming this `index.html`:\n   *\n   * ```html\n   * <html>\n   *   <!-- load Angular script tags here. -->\n   *   <body>\n   *     <my-app>loading...</my-app>\n   *   </body>\n   * </html>\n   * ```\n   *\n   * An application is bootstrapped inside an existing browser DOM, typically `index.html`. Unlike\n   * Angular 1, Angular 2\n   * does not compile/process bindings in `index.html`. This is mainly for security reasons, as well\n   * as architectural\n   * changes in Angular 2. This means that `index.html` can safely be processed using server-side\n   * technologies such as\n   * bindings. Bindings can thus use double-curly `{{ syntax }}` without collision from Angular 2\n   * component double-curly\n   * `{{ syntax }}`.\n   *\n   * We can use this script code:\n   *\n   * ```\n   * @Component({\n   *    selector: 'my-app'\n   * })\n   * @View({\n   *    template: 'Hello {{ name }}!'\n   * })\n   * class MyApp {\n   *   name:string;\n   *\n   *   constructor() {\n   *     this.name = 'World';\n   *   }\n   * }\n   *\n   * main() {\n   *   return bootstrap(MyApp);\n   * }\n   * ```\n   *\n   * When the app developer invokes `bootstrap()` with the root component `MyApp` as its argument,\n   * Angular performs the\n   * following tasks:\n   *\n   *  1. It uses the component's `selector` property to locate the DOM element which needs to be\n   * upgraded into\n   *     the angular component.\n   *  2. It creates a new child injector (from the platform injector). Optionally, you can also\n   * override the injector configuration for an app by\n   * invoking `bootstrap` with the `componentInjectableBindings` argument.\n   *  3. It creates a new `Zone` and connects it to the angular application's change detection domain\n   * instance.\n   *  4. It creates a shadow DOM on the selected component's host element and loads the template into\n   * it.\n   *  5. It instantiates the specified component.\n   *  6. Finally, Angular performs change detection to apply the initial data bindings for the\n   * application.\n   *\n   *\n   * ## Instantiating Multiple Applications on a Single Page\n   *\n   * There are two ways to do this.\n   *\n   *\n   * ### Isolated Applications\n   *\n   * Angular creates a new application each time that the `bootstrap()` method is invoked. When\n   * multiple applications\n   * are created for a page, Angular treats each application as independent within an isolated change\n   * detection and\n   * `Zone` domain. If you need to share data between applications, use the strategy described in the\n   * next\n   * section, \"Applications That Share Change Detection.\"\n   *\n   *\n   * ### Applications That Share Change Detection\n   *\n   * If you need to bootstrap multiple applications that share common data, the applications must\n   * share a common\n   * change detection and zone. To do that, create a meta-component that lists the application\n   * components in its template.\n   * By only invoking the `bootstrap()` method once, with the meta-component as its argument, you\n   * ensure that only a\n   * single change detection zone is created and therefore data can be shared across the applications.\n   *\n   *\n   * ## Platform Injector\n   *\n   * When working within a browser window, there are many singleton resources: cookies, title,\n   * location, and others.\n   * Angular services that represent these resources must likewise be shared across all Angular\n   * applications that\n   * occupy the same browser window.  For this reason, Angular creates exactly one global platform\n   * injector which stores\n   * all shared services, and each angular application injector has the platform injector as its\n   * parent.\n   *\n   * Each application has its own private injector as well. When there are multiple applications on a\n   * page, Angular treats\n   * each application injector's services as private to that application.\n   *\n   *\n   * # API\n   * - `appComponentType`: The root component which should act as the application. This is a reference\n   * to a `Type`\n   *   which is annotated with `@Component(...)`.\n   * - `componentInjectableBindings`: An additional set of bindings that can be added to the app\n   * injector\n   * to override default injection behavior.\n   * - `errorReporter`: `function(exception:any, stackTrace:string)` a default error reporter for\n   * unhandled exceptions.\n   *\n   * Returns a `Promise` of {@link ApplicationRef}.",
        "* Declare reusable UI building blocks for an application.\n   *\n   * Each Angular component requires a single `@Component` and at least one `@View` annotation. The\n   * `@Component`\n   * annotation specifies when a component is instantiated, and which properties and hostListeners it\n   * binds to.\n   *\n   * When a component is instantiated, Angular\n   * - creates a shadow DOM for the component.\n   * - loads the selected template into the shadow DOM.\n   * - creates all the injectable objects configured with `bindings` and `viewBindings`.\n   *\n   * All template expressions and statements are then evaluated against the component instance.\n   *\n   * For details on the `@View` annotation, see {@link ViewMetadata}.\n   *\n   * ## Example\n   *\n   * ```\n   * @Component({\n   *   selector: 'greet'\n   * })\n   * @View({\n   *   template: 'Hello {{name}}!'\n   * })\n   * class Greet {\n   *   name: string;\n   *\n   *   constructor() {\n   *     this.name = 'World';\n   *   }\n   * }\n   * ```",
        "* Defines the used change detection strategy.\n     *\n     * When a component is instantiated, Angular creates a change detector, which is responsible for\n     * propagating the component's bindings.\n     *\n     * The `changeDetection` property defines, whether the change detection will be checked every time\n     * or only when the component tells it to do so.",
        "* Defines the set of injectable objects that are visible to its view dom children.\n     *\n     * ## Simple Example\n     *\n     * Here is an example of a class that can be injected:\n     *\n     * ```\n     * class Greeter {\n     *    greet(name:string) {\n     *      return 'Hello ' + name + '!';\n     *    }\n     * }\n     *\n     * @Directive({\n     *   selector: 'needs-greeter'\n     * })\n     * class NeedsGreeter {\n     *   greeter:Greeter;\n     *\n     *   constructor(greeter:Greeter) {\n     *     this.greeter = greeter;\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'greet',\n     *   viewBindings: [\n     *     Greeter\n     *   ]\n     * })\n     * @View({\n     *   template: `<needs-greeter></needs-greeter>`,\n     *   directives: [NeedsGreeter]\n     * })\n     * class HelloWorld {\n     * }\n     *\n     * ```",
        "* Directives allow you to attach behavior to elements in the DOM.\n   *\n   * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.\n   *\n   * A directive consists of a single directive annotation and a controller class. When the\n   * directive's `selector` matches\n   * elements in the DOM, the following steps occur:\n   *\n   * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor\n   * arguments.\n   * 2. Angular instantiates directives for each matched element using `ElementInjector` in a\n   * depth-first order,\n   *    as declared in the HTML.\n   *\n   * ## Understanding How Injection Works\n   *\n   * There are three stages of injection resolution.\n   * - *Pre-existing Injectors*:\n   *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if\n   * the dependency was\n   *     specified as `@Optional`, returns `null`.\n   *   - The platform injector resolves browser singleton resources, such as: cookies, title,\n   * location, and others.\n   * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow\n   * the same parent-child hierarchy\n   *     as the component instances in the DOM.\n   * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each\n   * element has an `ElementInjector`\n   *     which follow the same parent-child hierarchy as the DOM elements themselves.\n   *\n   * When a template is instantiated, it also must instantiate the corresponding directives in a\n   * depth-first order. The\n   * current `ElementInjector` resolves the constructor dependencies for each directive.\n   *\n   * Angular then resolves dependencies as follows, according to the order in which they appear in the\n   * {@link ViewMetadata}:\n   *\n   * 1. Dependencies on the current element\n   * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary\n   * 3. Dependencies on component injectors and their parents until it encounters the root component\n   * 4. Dependencies on pre-existing injectors\n   *\n   *\n   * The `ElementInjector` can inject other directives, element-specific special objects, or it can\n   * delegate to the parent\n   * injector.\n   *\n   * To inject other directives, declare the constructor parameter as:\n   * - `directive:DirectiveType`: a directive on the current element only\n   * - `@Host() directive:DirectiveType`: any directive that matches the type between the current\n   * element and the\n   *    Shadow DOM root.\n   * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child\n   * directives.\n   * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any\n   * child directives.\n   *\n   * To inject element-specific special objects, declare the constructor parameter as:\n   * - `element: ElementRef` to obtain a reference to logical element in the view.\n   * - `viewContainer: ViewContainerRef` to control child template instantiation, for\n   * {@link DirectiveMetadata} directives only\n   * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.\n   *\n   * ## Example\n   *\n   * The following example demonstrates how dependency injection resolves constructor arguments in\n   * practice.\n   *\n   *\n   * Assume this HTML template:\n   *\n   * ```\n   * <div dependency=\"1\">\n   *   <div dependency=\"2\">\n   *     <div dependency=\"3\" my-directive>\n   *       <div dependency=\"4\">\n   *         <div dependency=\"5\"></div>\n   *       </div>\n   *       <div dependency=\"6\"></div>\n   *     </div>\n   *   </div>\n   * </div>\n   * ```\n   *\n   * With the following `dependency` decorator and `SomeService` injectable class.\n   *\n   * ```\n   * @Injectable()\n   * class SomeService {\n   * }\n   *\n   * @Directive({\n   *   selector: '[dependency]',\n   *   properties: [\n   *     'id: dependency'\n   *   ]\n   * })\n   * class Dependency {\n   *   id:string;\n   * }\n   * ```\n   *\n   * Let's step through the different ways in which `MyDirective` could be declared...\n   *\n   *\n   * ### No injection\n   *\n   * Here the constructor is declared with no arguments, therefore nothing is injected into\n   * `MyDirective`.\n   *\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor() {\n   *   }\n   * }\n   * ```\n   *\n   * This directive would be instantiated with no dependencies.\n   *\n   *\n   * ### Component-level injection\n   *\n   * Directives can inject any injectable instance from the closest component injector or any of its\n   * parents.\n   *\n   * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type\n   * from the parent\n   * component's injector.\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(someService: SomeService) {\n   *   }\n   * }\n   * ```\n   *\n   * This directive would be instantiated with a dependency on `SomeService`.\n   *\n   *\n   * ### Injecting a directive from the current element\n   *\n   * Directives can inject other directives declared on the current element.\n   *\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(dependency: Dependency) {\n   *     expect(dependency.id).toEqual(3);\n   *   }\n   * }\n   * ```\n   * This directive would be instantiated with `Dependency` declared at the same element, in this case\n   * `dependency=\"3\"`.\n   *\n   * ### Injecting a directive from any ancestor elements\n   *\n   * Directives can inject other directives declared on any ancestor element (in the current Shadow\n   * DOM), i.e. on the current element, the\n   * parent element, or its parents.\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@Host() dependency: Dependency) {\n   *     expect(dependency.id).toEqual(2);\n   *   }\n   * }\n   * ```\n   *\n   * `@Host` checks the current element, the parent, as well as its parents recursively. If\n   * `dependency=\"2\"` didn't\n   * exist on the direct parent, this injection would\n   * have returned\n   * `dependency=\"1\"`.\n   *\n   *\n   * ### Injecting a live collection of direct child directives\n   *\n   *\n   * A directive can also query for other child directives. Since parent directives are instantiated\n   * before child directives, a directive can't simply inject the list of child directives. Instead,\n   * the directive injects a {@link QueryList}, which updates its contents as children are added,\n   * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ng-for`, an\n   * `ng-if`, or an `ng-switch`.\n   *\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {\n   *   }\n   * }\n   * ```\n   *\n   * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and\n   * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.\n   *\n   * ### Injecting a live collection of descendant directives\n   *\n   * By passing the descendant flag to `@Query` above, we can include the children of the child\n   * elements.\n   *\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {\n   *   }\n   * }\n   * ```\n   *\n   * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.\n   *\n   * ### Optional injection\n   *\n   * The normal behavior of directives is to return an error when a specified dependency cannot be\n   * resolved. If you\n   * would like to inject `null` on unresolved dependency instead, you can annotate that dependency\n   * with `@Optional()`.\n   * This explicitly permits the author of a template to treat some of the surrounding directives as\n   * optional.\n   *\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@Optional() dependency:Dependency) {\n   *   }\n   * }\n   * ```\n   *\n   * This directive would be instantiated with a `Dependency` directive found on the current element.\n   * If none can be\n   * found, the injector supplies `null` instead of throwing an error.\n   *\n   * ## Example\n   *\n   * Here we use a decorator directive to simply define basic tool-tip behavior.\n   *\n   * ```\n   * @Directive({\n   *   selector: '[tooltip]',\n   *   properties: [\n   *     'text: tooltip'\n   *   ],\n   *   host: {\n   *     '(mouseenter)': 'onMouseEnter()',\n   *     '(mouseleave)': 'onMouseLeave()'\n   *   }\n   * })\n   * class Tooltip{\n   *   text:string;\n   *   overlay:Overlay; // NOT YET IMPLEMENTED\n   *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED\n   *\n   *   constructor(overlayManager:OverlayManager) {\n   *     this.overlay = overlay;\n   *   }\n   *\n   *   onMouseEnter() {\n   *     // exact signature to be determined\n   *     this.overlay = this.overlayManager.open(text, ...);\n   *   }\n   *\n   *   onMouseLeave() {\n   *     this.overlay.close();\n   *     this.overlay = null;\n   *   }\n   * }\n   * ```\n   * In our HTML template, we can then add this behavior to a `<div>` or any other element with the\n   * `tooltip` selector,\n   * like so:\n   *\n   * ```\n   * <div tooltip=\"some text here\"></div>\n   * ```\n   *\n   * Directives can also control the instantiation, destruction, and positioning of inline template\n   * elements:\n   *\n   * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at\n   * runtime.\n   * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a\n   * location in the current view\n   * where these actions are performed.\n   *\n   * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the\n   * `<template>` element. Thus a\n   * directive in a child view cannot inject the directive that created it.\n   *\n   * Since directives that create views via ViewContainers are common in Angular, and using the full\n   * `<template>` element syntax is wordy, Angular\n   * also supports a shorthand notation: `<li *foo=\"bar\">` and `<li template=\"foo: bar\">` are\n   * equivalent.\n   *\n   * Thus,\n   *\n   * ```\n   * <ul>\n   *   <li *foo=\"bar\" title=\"text\"></li>\n   * </ul>\n   * ```\n   *\n   * Expands in use to:\n   *\n   * ```\n   * <ul>\n   *   <template [foo]=\"bar\">\n   *     <li title=\"text\"></li>\n   *   </template>\n   * </ul>\n   * ```\n   *\n   * Notice that although the shorthand places `*foo=\"bar\"` within the `<li>` element, the binding for\n   * the directive\n   * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.\n   *\n   *\n   * ## Example\n   *\n   * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.\n   *\n   * Here is a simple directive that triggers on an `unless` selector:\n   *\n   * ```\n   * @Directive({\n   *   selector: '[unless]',\n   *   properties: ['unless']\n   * })\n   * export class Unless {\n   *   viewContainer: ViewContainerRef;\n   *   templateRef: TemplateRef;\n   *   prevCondition: boolean;\n   *\n   *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {\n   *     this.viewContainer = viewContainer;\n   *     this.templateRef = templateRef;\n   *     this.prevCondition = null;\n   *   }\n   *\n   *   set unless(newCondition) {\n   *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {\n   *       this.prevCondition = true;\n   *       this.viewContainer.clear();\n   *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {\n   *       this.prevCondition = false;\n   *       this.viewContainer.create(this.templateRef);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * We can then use this `unless` selector in a template:\n   * ```\n   * <ul>\n   *   <li *unless=\"expr\"></li>\n   * </ul>\n   * ```\n   *\n   * Once the directive instantiates the child view, the shorthand notation for the template expands\n   * and the result is:\n   *\n   * ```\n   * <ul>\n   *   <template [unless]=\"exp\">\n   *     <li></li>\n   *   </template>\n   *   <li></li>\n   * </ul>\n   * ```\n   *\n   * Note also that although the `<li></li>` template still exists inside the `<template></template>`,\n   * the instantiated\n   * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.",
        "* The CSS selector that triggers the instantiation of a directive.\n     *\n     * Angular only allows directives to trigger on CSS selectors that do not cross element\n     * boundaries.\n     *\n     * `selector` may be declared as one of the following:\n     *\n     * - `element-name`: select by element name.\n     * - `.class`: select by class name.\n     * - `[attribute]`: select by attribute name.\n     * - `[attribute=value]`: select by attribute name and value.\n     * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.\n     * - `selector1, selector2`: select if either `selector1` or `selector2` matches.\n     *\n     *\n     * ## Example\n     *\n     * Suppose we have a directive with an `input[type=text]` selector.\n     *\n     * And the following HTML:\n     *\n     * ```html\n     * <form>\n     *   <input type=\"text\">\n     *   <input type=\"radio\">\n     * <form>\n     * ```\n     *\n     * The directive would only be instantiated on the `<input type=\"text\">` element.",
        "* Enumerates the set of properties that accept data binding for a directive.\n     *\n     * The `properties` property defines a set of `directiveProperty` to `bindingProperty`\n     * configuration:\n     *\n     * - `directiveProperty` specifies the component property where the value is written.\n     * - `bindingProperty` specifies the DOM property where the value is read from.\n     *\n     * You can include a {@link PipeMetadata} when specifying a `bindingProperty` to allow for data\n     * transformation and structural change detection of the value. These pipes will be evaluated in\n     * the context of this component.\n     *\n     * ## Syntax\n     *\n     * There is no need to specify both `directiveProperty` and `bindingProperty` when they both have\n     * the same value.\n     *\n     * ```\n     * @Directive({\n     *   properties: [\n     *     'propertyName', // shorthand notation for 'propertyName: propertyName'\n     *     'directiveProperty1: bindingProperty1',\n     *     'directiveProperty2: bindingProperty2 | pipe1 | ...',\n     *     ...\n     *   ]\n     * }\n     * ```\n     *\n     *\n     * ## Basic Property Binding\n     *\n     * We can easily build a simple `Tooltip` directive that exposes a `tooltip` property, which can\n     * be used in templates with standard Angular syntax. For example:\n     *\n     * ```\n     * @Directive({\n     *   selector: '[tooltip]',\n     *   properties: [\n     *     'text: tooltip'\n     *   ]\n     * })\n     * class Tooltip {\n     *   set text(value: string) {\n     *     // This will get called every time with the new value when the 'tooltip' property changes\n     *   }\n     * }\n     * ```\n     *\n     * We can then bind to the `tooltip' property as either an expression (`someExpression`) or as a\n     * string literal, as shown in the HTML template below:\n     *\n     * ```html\n     * <div [tooltip]=\"someExpression\">...</div>\n     * <div tooltip=\"Some Text\">...</div>\n     * ```\n     *\n     * Whenever the `someExpression` expression changes, the `properties` declaration instructs\n     * Angular to update the `Tooltip`'s `text` property.\n     *\n     * ### Bindings With Pipes\n     *\n     * You can use pipes in bindings, as follows:\n     *\n     * ```html\n     * <div [class-set]=\"someExpression | somePipe\">\n     * ```",
        "* Enumerates the set of emitted events.\n     *\n     * ## Syntax\n     *\n     * ```\n     * @Component({\n     *   events: ['statusChange']\n     * })\n     * class TaskComponent {\n     *   statusChange: EventEmitter;\n     *\n     *   constructor() {\n     *     this.statusChange = new EventEmitter();\n     *   }\n     *\n     *   onComplete() {\n     *     this.statusChange.next('completed');\n     *   }\n     * }\n     * ```\n     *\n     * Use `propertyName: eventName` when the event emitter property name is different from the name\n     * of the emitted event:\n     *\n     * ```\n     * @Component({\n     *   events: ['status: statusChange']\n     * })\n     * class TaskComponent {\n     *   status: EventEmitter;\n     *\n     *   constructor() {\n     *     this.status = new EventEmitter();\n     *   }\n     *\n     *   onComplete() {\n     *     this.status.next('completed');\n     *   }\n     * }\n     * ```",
        "* Specifiy the events, actions, properties and attributes related to the host element.\n     *\n     * ## Events\n     *\n     * Specifies which DOM hostListeners a directive listens to via a set of `(event)` to `method`\n     * key-value pairs:\n     *\n     * - `event1`: the DOM event that the directive listens to.\n     * - `statement`: the statement to execute when the event occurs.\n     * If the evalutation of the statement returns `false`, then `preventDefault`is applied on the DOM\n     * event.\n     *\n     * To listen to global events, a target must be added to the event name.\n     * The target can be `window`, `document` or `body`.\n     *\n     * When writing a directive event binding, you can also refer to the following local variables:\n     * - `$event`: Current event object which triggered the event.\n     * - `$target`: The source of the event. This will be either a DOM element or an Angular\n     * directive. (will be implemented in later release)\n     *\n     * ## Syntax\n     *\n     * ```\n     * @Directive({\n     *   host: {\n     *     '(event1)': 'onMethod1(arguments)',\n     *     '(target:event2)': 'onMethod2(arguments)',\n     *     ...\n     *   }\n     * }\n     * ```\n     *\n     * ## Basic Event Binding:\n     *\n     * Suppose you want to write a directive that reacts to `change` events in the DOM and on\n     * `resize` events in window.\n     * You would define the event binding as follows:\n     *\n     * ```\n     * @Directive({\n     *   selector: 'input',\n     *   host: {\n     *     '(change)': 'onChange($event)',\n     *     '(window:resize)': 'onResize($event)'\n     *   }\n     * })\n     * class InputDirective {\n     *   onChange(event:Event) {\n     *     // invoked when the input element fires the 'change' event\n     *   }\n     *   onResize(event:Event) {\n     *     // invoked when the window fires the 'resize' event\n     *   }\n     * }\n     * ```\n     *\n     * ## Properties\n     *\n     * Specifies which DOM properties a directives updates.\n     *\n     * ## Syntax\n     *\n     * ```\n     * @Directive({\n     *   selector: 'input',\n     *   host: {\n     *     '[prop]': 'expression'\n     *   }\n     * })\n     * class InputDirective {\n     *   value:string;\n     * }\n     * ```\n     *\n     * In this example the prop property of the host element is updated with the expression value\n     * every time it changes.\n     *\n     * ## Attributes\n     *\n     * Specifies static attributes that should be propagated to a host element. Attributes specified\n     * in `hostAttributes` are propagated only if a given attribute is not present on a host element.\n     *\n     * ## Syntax\n     *\n     * ```\n     * @Directive({\n     *   selector: '[my-button]',\n     *   host: {\n     *     'role': 'button'\n     *   }\n     * })\n     * class MyButton {\n     * }\n     * ```\n     *\n     * In this example using `my-button` directive (ex.: `<div my-button></div>`) on a host element\n     * (here: `<div>` ) will ensure that this element will get the \"button\" role.",
        "* Specifies which lifecycle should be notified to the directive.\n     *\n     * See {@link LifecycleEvent} for details.",
        "* If set to false the compiler does not compile the children of this directive.",
        "* Defines the set of injectable objects that are visible to a Directive and its light dom\n     * children.\n     *\n     * ## Simple Example\n     *\n     * Here is an example of a class that can be injected:\n     *\n     * ```\n     * class Greeter {\n     *    greet(name:string) {\n     *      return 'Hello ' + name + '!';\n     *    }\n     * }\n     *\n     * @Directive({\n     *   selector: 'greet',\n     *   bindings: [\n     *     Greeter\n     *   ]\n     * })\n     * class HelloWorld {\n     *   greeter:Greeter;\n     *\n     *   constructor(greeter:Greeter) {\n     *     this.greeter = greeter;\n     *   }\n     * }\n     * ```",
        "* Defines the name that can be used in the template to assign this directive to a variable.\n     *\n     * ## Simple Example\n     *\n     * ```\n     * @Directive({\n     *   selector: 'child-dir',\n     *   exportAs: 'child'\n     * })\n     * class ChildDir {\n     * }\n     *\n     * @Component({\n     *   selector: 'main',\n     * })\n     * @View({\n     *   template: `<child-dir #c=\"child\"></child-dir>`,\n     *   directives: [ChildDir]\n     * })\n     * class MainComponent {\n     * }\n     *\n     * ```",
        "* Declare reusable pipe function.\n   *\n   * ## Example\n   *\n   * ```\n   * @Pipe({\n   *   name: 'lowercase'\n   * })\n   * class Lowercase {\n   *   transform(v, args) { return v.toLowerCase(); }\n   * }\n   * ```",
        "* Lifecycle events are guaranteed to be called in the following order:\n   * - `OnChanges` (if any bindings have changed),\n   * - `OnInit` (after the first check only),\n   * - `DoCheck`,\n   * - `AfterContentChecked`\n   * - `AfterContentChecked`\n   * - `OnDestroy` (at the very end before destruction)",
        "* Notify a directive when it has been checked the first time.\n     *\n     * This method is called right after the directive's bindings have been checked,\n     * and before any of its children's bindings have been checked.\n     *\n     * It is invoked only once.\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   lifecycle: [LifecycleEvent.OnInit]\n     * })\n     * class ClassSet {\n     *   onInit() {\n     *   }\n     * }\n     *  ```",
        "* Notify a directive whenever a {@link ViewMetadata} that contains it is destroyed.\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   ...,\n     *   lifecycle: [LifecycleEvent.OnDestroy]\n     * })\n     * class ClassSet {\n     *   onDestroy() {\n     *     // invoked to notify directive of the containing view destruction.\n     *   }\n     * }\n     * ```",
        "* Notify a directive when any of its bindings have changed.\n     *\n     * This method is called right after the directive's bindings have been checked,\n     * and before any of its children's bindings have been checked.\n     *\n     * It is invoked only if at least one of the directive's bindings has changed.\n     *\n     * ## Example:\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   properties: [\n     *     'propA',\n     *     'propB'\n     *   ],\n     *   lifecycle: [LifecycleEvent.OnChanges]\n     * })\n     * class ClassSet {\n     *   propA;\n     *   propB;\n     *   onChanges(changes:{[idx: string, PropertyUpdate]}) {\n     *     // This will get called after any of the properties have been updated.\n     *     if (changes['propA']) {\n     *       // if propA was updated\n     *     }\n     *     if (changes['propA']) {\n     *       // if propB was updated\n     *     }\n     *   }\n     * }\n     *  ```",
        "* Notify a directive when it has been checked.\n     *\n     * This method is called right after the directive's bindings have been checked,\n     * and before any of its children's bindings have been checked.\n     *\n     * It is invoked every time even when none of the directive's bindings has changed.\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   lifecycle: [LifecycleEvent.DoCheck]\n     * })\n     * class ClassSet {\n     *   doCheck() {\n     *   }\n     * }\n     *  ```",
        "* Notify a directive when the bindings of all its content children have been checked the first\n     * time (whether they\n     * have changed or not).\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   lifecycle: [LifecycleEvent.AfterContentInit]\n     * })\n     * class ClassSet {\n     *\n     *   afterContentInit() {\n     *   }\n     *\n     * }\n     *  ```",
        "* Notify a directive when the bindings of all its content children have been checked (whether\n     * they\n     * have changed or not).\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   lifecycle: [LifecycleEvent.AfterContentChecked]\n     * })\n     * class ClassSet {\n     *\n     *   afterContentChecked() {\n     *   }\n     *\n     * }\n     *  ```",
        "* Notify a directive when the bindings of all its view children have been checked the first time\n     * (whether they\n     * have changed or not).\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   lifecycle: [LifecycleEvent.AfterViewInit]\n     * })\n     * class ClassSet {\n     *\n     *   afterViewInit() {\n     *   }\n     *\n     * }\n     *  ```",
        "* Notify a directive when the bindings of all its view children have been checked (whether they\n     * have changed or not).\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   lifecycle: [LifecycleEvent.AfterViewChecked]\n     * })\n     * class ClassSet {\n     *\n     *   afterViewChecked() {\n     *   }\n     *\n     * }\n     *  ```",
        "* Declares the available HTML templates for an application.\n   *\n   * Each angular component requires a single `@Component` and at least one `@View` annotation. The\n   * `@View` annotation specifies the HTML template to use, and lists the directives that are active\n   * within the template.\n   *\n   * When a component is instantiated, the template is loaded into the component's shadow root, and\n   * the expressions and statements in the template are evaluated against the component.\n   *\n   * For details on the `@Component` annotation, see {@link ComponentMetadata}.\n   *\n   * ## Example\n   *\n   * ```\n   * @Component({\n   *   selector: 'greet'\n   * })\n   * @View({\n   *   template: 'Hello {{name}}!',\n   *   directives: [GreetUser, Bold]\n   * })\n   * class Greet {\n   *   name: string;\n   *\n   *   constructor() {\n   *     this.name = 'World';\n   *   }\n   * }\n   * ```",
        "* Specifies a template URL for an angular component.\n     *\n     * NOTE: either `templateUrl` or `template` should be used, but not both.",
        "* Specifies an inline template for an angular component.\n     *\n     * NOTE: either `templateUrl` or `template` should be used, but not both.",
        "* Specifies stylesheet URLs for an angular component.",
        "* Specifies an inline stylesheet for an angular component.",
        "* Specifies a list of directives that can be used within a template.\n     *\n     * Directives must be listed explicitly to provide proper component encapsulation.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * @Component({\n     *     selector: 'my-component'\n     *   })\n     * @View({\n     *   directives: [For]\n     *   template: '\n     *   <ul>\n     *     <li *ng-for=\"#item of items\">{{item}}</li>\n     *   </ul>'\n     * })\n     * class MyComponent {\n     * }\n     * ```",
        "* Specify how the template and the styles should be encapsulated.\n     * The default is {@link ViewEncapsulation#Emulated `ViewEncapsulation.Emulated`} if the view\n     * has styles,\n     * otherwise {@link ViewEncapsulation#None `ViewEncapsulation.None`}.",
        "* How the template and styles of a view should be encapsulated.",
        "* Emulate scoping of styles by preprocessing the style rules\n     * and adding additional attributes to elements. This is the default.",
        "* Uses the native mechanism of the renderer. For the DOM this means creating a ShadowRoot.",
        "* Don't scope the template nor the styles.",
        "* Specifies that a {@link QueryList} should be injected.\n   *\n   * See {@link QueryList} for usage and example.",
        "* Specifies that a constant attribute value should be injected.\n   *\n   * The directive can inject constant string literals of host element attributes.\n   *\n   * ## Example\n   *\n   * Suppose we have an `<input>` element and want to know its `type`.\n   *\n   * ```html\n   * <input type=\"text\">\n   * ```\n   *\n   * A decorator can inject string literal `text` like so:\n   *\n   * ```javascript\n   * @Directive({\n   *   selector: `input'\n   * })\n   * class InputDirective {\n   *   constructor(@Attribute('type') type) {\n   *     // type would be `text` in this example\n   *   }\n   * }\n   * ```",
        "* {@link AttributeMetadata} factory function.",
        "* {@link AttributeMetadata} factory for creating annotations, decorators or DSL.\n   *\n   * ## Example as TypeScript Decorator\n   *\n   * ```\n   * import {Attribute, Component, View} from \"angular2/angular2\";\n   *\n   * @Component({...})\n   * @View({...})\n   * class MyComponent {\n   *   constructor(@Attribute('title') title: string) {\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Example as ES5 DSL\n   *\n   * ```\n   * var MyComponent = ng\n   *   .Component({...})\n   *   .View({...})\n   *   .Class({\n   *     constructor: [new ng.Attribute('title'), function(title) {\n   *       ...\n   *     }]\n   *   })\n   * ```\n   *\n   * ## Example as ES5 annotation\n   *\n   * ```\n   * var MyComponent = function(title) {\n   *   ...\n   * };\n   *\n   * MyComponent.annotations = [\n   *   new ng.Component({...}),\n   *   new ng.View({...})\n   * ]\n   * MyComponent.parameters = [\n   *   [new ng.Attribute('title')]\n   * ]\n   * ```",
        "* {@link ComponentMetadata} factory function.",
        "* Interface for the {@link ComponentMetadata} decorator function.\n   *\n   * See {@link ComponentFactory}.",
        "* Chain {@link ViewMetadata} annotation.",
        "* {@link ComponentAnnotation} factory for creating annotations, decorators or DSL.\n   *\n   * ## Example as TypeScript Decorator\n   *\n   * ```\n   * import {Component, View} from \"angular2/angular2\";\n   *\n   * @Component({...})\n   * @View({...})\n   * class MyComponent {\n   *   constructor() {\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Example as ES5 DSL\n   *\n   * ```\n   * var MyComponent = ng\n   *   .Component({...})\n   *   .View({...})\n   *   .Class({\n   *     constructor: function() {\n   *       ...\n   *     }\n   *   })\n   * ```\n   *\n   * ## Example as ES5 annotation\n   *\n   * ```\n   * var MyComponent = function() {\n   *   ...\n   * };\n   *\n   * MyComponent.annotations = [\n   *   new ng.Component({...}),\n   *   new ng.View({...})\n   * ]\n   * ```",
        "* {@link DirectiveMetadata} factory function.",
        "* Interface for the {@link DirectiveMetadata} decorator function.\n   *\n   * See {@link DirectiveFactory}.",
        "* {@link DirectiveMetadata} factory for creating annotations, decorators or DSL.\n   *\n   * ## Example as TypeScript Decorator\n   *\n   * ```\n   * import {Directive} from \"angular2/angular2\";\n   *\n   * @Directive({...})\n   * class MyDirective {\n   *   constructor() {\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Example as ES5 DSL\n   *\n   * ```\n   * var MyDirective = ng\n   *   .Directive({...})\n   *   .Class({\n   *     constructor: function() {\n   *       ...\n   *     }\n   *   })\n   * ```\n   *\n   * ## Example as ES5 annotation\n   *\n   * ```\n   * var MyDirective = function() {\n   *   ...\n   * };\n   *\n   * MyDirective.annotations = [\n   *   new ng.Directive({...})\n   * ]\n   * ```",
        "* {@link ViewMetadata} factory function.",
        "* Interface for the {@link ViewMetadata} decorator function.\n   *\n   * See {@link ViewFactory}.",
        "* Chain {@link ViewMetadata} annotation.",
        "* {@link ViewAnnotation} factory for creating annotations, decorators or DSL.\n   *\n   * ## Example as TypeScript Decorator\n   *\n   * ```\n   * import {Component, View} from \"angular2/angular2\";\n   *\n   * @Component({...})\n   * @View({...})\n   * class MyComponent {\n   *   constructor() {\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Example as ES5 DSL\n   *\n   * ```\n   * var MyComponent = ng\n   *   .Component({...})\n   *   .View({...})\n   *   .Class({\n   *     constructor: function() {\n   *       ...\n   *     }\n   *   })\n   * ```\n   *\n   * ## Example as ES5 annotation\n   *\n   * ```\n   * var MyComponent = function() {\n   *   ...\n   * };\n   *\n   * MyComponent.annotations = [\n   *   new ng.Component({...}),\n   *   new ng.View({...})\n   * ]\n   * ```",
        "* {@link QueryMetadata} factory function.",
        "* {@link QueryMetadata} factory for creating annotations, decorators or DSL.\n   *\n   * ## Example as TypeScript Decorator\n   *\n   * ```\n   * import {Query, QueryList, Component, View} from \"angular2/angular2\";\n   *\n   * @Component({...})\n   * @View({...})\n   * class MyComponent {\n   *   constructor(@Query(SomeType) queryList: QueryList) {\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Example as ES5 DSL\n   *\n   * ```\n   * var MyComponent = ng\n   *   .Component({...})\n   *   .View({...})\n   *   .Class({\n   *     constructor: [new ng.Query(SomeType), function(queryList) {\n   *       ...\n   *     }]\n   *   })\n   * ```\n   *\n   * ## Example as ES5 annotation\n   *\n   * ```\n   * var MyComponent = function(queryList) {\n   *   ...\n   * };\n   *\n   * MyComponent.annotations = [\n   *   new ng.Component({...}),\n   *   new ng.View({...})\n   * ]\n   * MyComponent.parameters = [\n   *   [new ng.Query(SomeType)]\n   * ]\n   * ```",
        "* {@link di/ViewQueryMetadata} factory function.",
        "* {@link PipeMetadata} factory function.",
        "* {@link PipeMetadata} factory for creating decorators.\n   *\n   * ## Example as TypeScript Decorator\n   *\n   * ```\n   * import {Pipe} from \"angular2/angular2\";\n   *\n   * @Pipe({...})\n   * class MyPipe {\n   *   constructor() {\n   *     ...\n   *   }\n   *\n   *   transform(v, args) {}\n   * }\n   * ```",
        "* Defines lifecycle method\n   * {@link metadata/LifeCycleEvent#AfterContentInit `LifeCycleEvent.afterContentInit`}\n   * called when the bindings of all its content children have been checked the first time.",
        "* Defines lifecycle method\n   * {@link metadata/LifeCycleEvent#AfterContentChecked `LifeCycleEvent.afterContentChecked`}\n   * called when the bindings of all its content children have been checked.",
        "* Defines lifecycle method\n   * {@link metadata/LifeCycleEvent#AfterViewInit `LifeCycleEvent.afterViewInit`}\n   * called when the bindings of all its view children have been checked the first time.",
        "* Defines lifecycle method\n   * {@link metadata/LifeCycleEvent#AfterViewChecked `LifeCycleEvent.afterViewChecked`}\n   * called when the bindings of all its view children have been checked.",
        "* Defines lifecycle method {@link metadata/LifeCycleEvent#OnChanges `LifeCycleEvent.OnChanges`}\n   * called after all of component's bound properties are updated.",
        "* Defines lifecycle method {@link metadata/LifeCycleEvent#OnDestroy `LifeCycleEvent.OnDestroy`}\n   * called when a directive is being destroyed.",
        "* Defines lifecycle method {@link metadata/LifeCycleEvent#OnInit `LifeCycleEvent.OnInit`}\n   * called when a directive is being checked the first time.",
        "* Defines lifecycle method {@link metadata/LifeCycleEvent#DoCheck `LifeCycleEvent.DoCheck`}\n   * called when a directive is being checked.",
        "* Provides a way for expressing ES6 classes with parameter annotations in ES5.\n   *\n   * ## Basic Example\n   *\n   * ```\n   * var Greeter = ng.Class({\n   *   constructor: function(name) {\n   *     this.name = name;\n   *   },\n   *\n   *   greet: function() {\n   *     alert('Hello ' + this.name + '!');\n   *   }\n   * });\n   * ```\n   *\n   * is equivalent to ES6:\n   *\n   * ```\n   * class Greeter {\n   *   constructor(name) {\n   *     this.name = name;\n   *   }\n   *\n   *   greet() {\n   *     alert('Hello ' + this.name + '!');\n   *   }\n   * }\n   * ```\n   *\n   * or equivalent to ES5:\n   *\n   * ```\n   * var Greeter = function (name) {\n   *   this.name = name;\n   * }\n   *\n   * Greeter.prototype.greet = function () {\n   *   alert('Hello ' + this.name + '!');\n   * }\n   * ```\n   *\n   * ## Example with parameter annotations\n   *\n   * ```\n   * var MyService = neg.Class({\n   *   constructor: [String, [new Query(), QueryList], function(name, queryList) {\n   *     ...\n   *   }];\n   * });\n   * ```\n   *\n   * is equivalent to ES6:\n   *\n   * ```\n   * class MyService {\n   *   constructor(name: string, @Query() queryList: QueryList) {\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Example with inheritance\n   *\n   * ```\n   * var Shape = ng.Class({\n   *   constructor: (color) {\n   *     this.color = color;\n   *   }\n   * });\n   *\n   * var Square = ng.Class({\n   *   extends: Shape,\n   *   constructor: function(color, size) {\n   *     Shape.call(this, color);\n   *     this.size = size;\n   *   }\n   * });\n   * ```",
        "* Declares the interface to be used with {@link Class}.",
        "* Optional argument for specifying the superclass.",
        "* Required constructor function for a class.\n     *\n     * The function may be optionally wrapped in an `Array`, in which case additional parameter\n     * annotations may be specified.\n     * The number of arguments and the number of parameter annotations must match.\n     *\n     * See {@link Class} for example of usage.",
        "* An interface implemented by all Angular type decorators, which allows them to be used as ES7\n   * decorators as well as\n   * Angular DSL syntax.\n   *\n   * DSL syntax:\n   *\n   * ```\n   * var MyClass = ng\n   *   .Component({...})\n   *   .View({...})\n   *   .Class({...});\n   * ```\n   *\n   * ES7 syntax:\n   *\n   * ```\n   * @ng.Component({...})\n   * @ng.View({...})\n   * class MyClass {...}\n   * ```",
        "* Invoke as ES7 decorator.",
        "* Storage for the accumulated annotations so far used by the DSL syntax.\n     *\n     * Used by {@link Class} to annotate the generated class.",
        "* Generate a class from the definition and annotate it with {@link TypeDecorator#annotations}.",
        "* `CheckedOnce` means that after calling detectChanges the mode of the change detector\n     * will become `Checked`.",
        "* `Checked` means that the change detector should be skipped until its mode changes to\n     * `CheckOnce`.",
        "* `CheckAlways` means that after calling detectChanges the mode of the change detector\n     * will remain `CheckAlways`.",
        "* `Detached` means that the change detector sub tree is not a part of the main tree and\n     * should be skipped.",
        "* `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.",
        "* `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.",
        "* This is an experimental feature. Works only in Dart.",
        "* An error thrown if application changes model breaking the top-down data flow.\n   *\n   * Angular expects that the data flows from top (root) component to child (leaf) components.\n   * This is known as directed acyclic graph. This allows Angular to only execute change detection\n   * once and prevents loops in change detection data flow.\n   *\n   * This exception is only thrown in dev mode.",
        "* Thrown when an expression evaluation raises an exception.\n   *\n   * This error wraps the original exception, this is done to attach expression location information.",
        "* Location of the expression.",
        "* Controls change detection.\n   *\n   * {@link ChangeDetectorRef} allows requesting checks for detectors that rely on observables. It\n   * also allows detaching and attaching change detector subtrees.",
        "* Request to check all OnPush ancestors.",
        "* Detaches the change detector from the change detector tree.\n     *\n     * The detached change detector will not be checked until it is reattached.",
        "* Reattach the change detector to the change detector tree.\n     *\n     * This also requests a check of this change detector. This reattached change detector will be\n     * checked during the next change detection run.",
        "* Indicates that the result of a {@link PipeMetadata} transformation has changed even though the\n   * reference\n   * has not changed.\n   *\n   * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.\n   *\n   * Example:\n   *\n   * ```\n   * if (this._latestValue === this._latestReturnedValue) {\n   *    return this._latestReturnedValue;\n   *  } else {\n   *    this._latestReturnedValue = this._latestValue;\n   *    return WrappedValue.wrap(this._latestValue); // this will force update\n   *  }\n   * ```",
        "* An interface which all pipes must implement.\n   *\n   * #Example\n   *\n   * ```\n   * class DoublePipe implements PipeTransform {\n   *  transform(value, args = []) {\n   *    return `${value}${value}`;\n   *  }\n   * }\n   * ```",
        "* An interface that stateful pipes should implement.\n   *\n   * #Example\n   *\n   * ```\n   * class StatefulPipe implements PipeTransform, PipeOnDestroy {\n   *  connection;\n   *\n   *  onDestroy() {\n   *    this.connection.release();\n   *  }\n   *\n   *  transform(value, args = []) {\n   *    this.connection = createConnection();\n   *    // ...\n   *    return someValue;\n   *  }\n   * }\n   * ```",
        "* A repository of different iterable diffing strategies used by NgFor, NgClass, and others.",
        "* Takes an array of {@link IterableDifferFactory} and returns a binding used to extend the\n     * inherited {@link IterableDiffers} instance with the provided factories and return a new\n     * {@link IterableDiffers} instance.\n     *\n     * The following example shows how to extend an existing list of factories,\n     * which will only be applied to the injector for this component and its children.\n     * This step is all that's required to make a new {@link IterableDiffer} available.\n     *\n     * # Example\n     *\n     * ```\n     * @Component({\n     *   viewBindings: [\n     *     IterableDiffers.extend([new ImmutableListDiffer()])\n     *   ]\n     * })\n     * ```",
        "* Provides a factory for {@link IterableDiffer}.",
        "* A repository of different Map diffing strategies used by NgClass, NgStyle, and others.",
        "* Takes an array of {@link KeyValueDifferFactory} and returns a binding used to extend the\n     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\n     * {@link KeyValueDiffers} instance.\n     *\n     * The following example shows how to extend an existing list of factories,\n     * which will only be applied to the injector for this component and its children.\n     * This step is all that's required to make a new {@link KeyValueDiffer} available.\n     *\n     * # Example\n     *\n     * ```\n     * @Component({\n     *   viewBindings: [\n     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\n     *   ]\n     * })\n     * ```",
        "* Provides a factory for {@link KeyValueDiffer}.",
        "* An opaque token representing the application root type in the {@link Injector}.\n   *\n   * ```\n   * @Component(...)\n   * @View(...)\n   * class MyApp {\n   *   ...\n   * }\n   *\n   * bootstrap(MyApp).then((appRef:ApplicationRef) {\n   *   expect(appRef.injector.get(appComponentTypeToken)).toEqual(MyApp);\n   * });\n   *\n   * ```",
        "* Runtime representation of a type.\n   *\n   * In JavaScript a Type is a constructor function.",
        "* Represents a Angular's representation of an Application.\n   *\n   * `ApplicationRef` represents a running application instance. Use it to retrieve the host\n   * component, injector,\n   * or dispose of an application.",
        "* Returns the current {@link ComponentMetadata} type.",
        "* Returns the current {@link ComponentMetadata} instance.",
        "* Dispose (un-load) the application.",
        "* Returns the root application {@link Injector}.",
        "* Specifies app root url for the application.\n   *\n   * Used by the {@link Compiler} when resolving HTML and CSS template URLs.\n   *\n   * This interface can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}",
        "* Returns the base URL of the currently running application.",
        "* Used by the {@link Compiler} when resolving HTML and CSS template URLs.\n   *\n   * This interface can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}",
        "* Resolves the `url` given the `baseUrl`:\n     * - when the `url` is null, the `baseUrl` is returned,\n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n     * `baseUrl` and `url`,\n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n     * returned as is (ignoring the `baseUrl`)\n     *\n     * @param {string} baseUrl\n     * @param {string} url\n     * @returns {string} the resolved URL",
        "* Resolve a `Type` from a {@link ComponentMetadata} into a URL.\n   *\n   * This interface can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}",
        "* Returns the base URL to the component source file.\n     * The returned URL could be:\n     * - an absolute URL,\n     * - a path relative to the application",
        "* Resolve a `Type` for {@link DirectiveMetadata}.\n   *\n   * This interface can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}",
        "* Return {@link DirectiveMetadata} for a given `Type`.",
        "* ## URL Resolution\n   *\n   * ```\n   * var appRootUrl: AppRootUrl = ...;\n   * var componentUrlMapper: ComponentUrlMapper = ...;\n   * var urlResolver: UrlResolver = ...;\n   *\n   * var componentType: Type = ...;\n   * var componentAnnotation: ComponentAnnotation = ...;\n   * var viewAnnotation: ViewAnnotation = ...;\n   *\n   * // Resolving a URL\n   *\n   * var url = viewAnnotation.templateUrl;\n   * var componentUrl = componentUrlMapper.getUrl(componentType);\n   * var componentResolvedUrl = urlResolver.resolve(appRootUrl.value, componentUrl);\n   * var templateResolvedUrl = urlResolver.resolve(componetResolvedUrl, url);\n   * ```",
        "* Entry point for creating, moving views in the view hierarchy and destroying views.\n   * This manager contains all recursion and delegates to helper methods\n   * in AppViewManagerUtils and the Renderer, so unit tests get simpler.",
        "* Returns a {@link ViewContainerRef} at the {@link ElementRef} location.",
        "* Return the first child element of the host element view.",
        "* Returns an ElementRef for the element with the given variable name\n     * in the current view.\n     *\n     * - `hostLocation`: {@link ElementRef} of any element in the View which defines the scope of\n     *   search.\n     * - `variableName`: Name of the variable to locate.\n     * - Returns {@link ElementRef} of the found element or null. (Throws if not found.)",
        "* Returns the component instance for a given element.\n     *\n     * The component is the execution context as seen by an expression at that {@link ElementRef}\n     * location.",
        "* Load component view into existing element.\n     *\n     * Use this if a host element is already in the DOM and it is necessary to upgrade\n     * the element into Angular component by attaching a view but reusing the existing element.\n     *\n     * - `hostProtoViewRef`: {@link ProtoViewRef} Proto view to use in creating a view for this\n     *   component.\n     * - `overrideSelector`: (optional) selector to use in locating the existing element to load\n     *   the view into. If not specified use the selector in the component definition of the\n     *   `hostProtoView`.\n     * - injector: {@link Injector} to use as parent injector for the view.\n     *\n     * See {@link AppViewManager#destroyRootHostView}.\n     *\n     * ## Example\n     *\n     * ```\n     * @ng.Component({\n     *   selector: 'child-component'\n     * })\n     * @ng.View({\n     *   template: 'Child'\n     * })\n     * class ChildComponent {\n     *\n     * }\n     *\n     * @ng.Component({\n     *   selector: 'my-app'\n     * })\n     * @ng.View({\n     *   template: `\n     *     Parent (<some-component></some-component>)\n     *   `\n     * })\n     * class MyApp {\n     *   viewRef: ng.ViewRef;\n     *\n     *   constructor(public appViewManager: ng.AppViewManager, compiler: ng.Compiler) {\n     *     compiler.compileInHost(ChildComponent).then((protoView: ng.ProtoViewRef) => {\n     *       this.viewRef = appViewManager.createRootHostView(protoView, 'some-component', null);\n     *     })\n     *   }\n     *\n     *   onDestroy() {\n     *     this.appViewManager.destroyRootHostView(this.viewRef);\n     *     this.viewRef = null;\n     *   }\n     * }\n     *\n     * ng.bootstrap(MyApp);\n     * ```",
        "* Remove the View created with {@link AppViewManager#createRootHostView}.",
        "* See {@link AppViewManager#destroyViewInContainer}.",
        "* See {@link AppViewManager#destroyViewInContainer}.",
        "* See {@link AppViewManager#createViewInContainer}.",
        "* See {@link AppViewManager#detachViewInContainer}.",
        "* See {@link AppViewManager#attachViewInContainer}.",
        "* An iterable and observable live list of components in the DOM.\n   *\n   * A QueryList contains a live list of child directives in the DOM of a directive.\n   * The directives are kept in depth-first pre-order traversal of the DOM.\n   *\n   * The `QueryList` is iterable, therefore it can be used in both javascript code with `for..of` loop\n   * as well as in template with `*ng-for=\"of\"` directive.\n   *\n   * QueryList is updated as part of the change-detection cycle of a directive. Since change detection\n   * happens after construction of a directive, QueryList will always be empty when observed in the\n   * constructor.\n   *\n   *\n   * NOTE: In the future this class will implement an `Observable` interface. For now it uses a plain\n   * list of observable callbacks.\n   *\n   * # Example:\n   *\n   * Assume that `<tabs>` component would like to get a list its children which are `<pane>`\n   * components as shown in this example:\n   *\n   * ```html\n   * <tabs>\n   *   <pane title=\"Overview\">...</pane>\n   *   <pane *ng-for=\"#o of objects\" [title]=\"o.title\">{{o.text}}</pane>\n   * </tabs>\n   * ```\n   *\n   * In the above example the list of `<tabs>` elements needs to get a list of `<pane>` elements so\n   * that it could render tabs with the correct titles and in the correct order.\n   *\n   * A possible solution would be for a `<pane>` to inject `<tabs>` component and then register itself\n   * with `<tabs>` component's on `hydrate` and deregister on `dehydrate` event. While a reasonable\n   * approach, this would only work partialy since `*ng-for` could rearrange the list of `<pane>`\n   * components which would not be reported to `<tabs>` component and thus the list of `<pane>`\n   * components would be out of sync with respect to the list of `<pane>` elements.\n   *\n   * A preferred solution is to inject a `QueryList` which is a live list of directives in the\n   * component`s light DOM.\n   *\n   * ```javascript\n   * @Component({\n   *   selector: 'tabs'\n   * })\n   * @View({\n   *  template: `\n   *    <ul>\n   *      <li *ng-for=\"#pane of panes\">{{pane.title}}</li>\n   *    </ul>\n   *    <content></content>\n   *  `\n   * })\n   * class Tabs {\n   *   panes: QueryList<Pane>\n   *\n   *   constructor(@Query(Pane) panes:QueryList<Pane>) {\n   *     this.panes = panes;\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'pane',\n   *   properties: ['title']\n   * })\n   * @View(...)\n   * class Pane {\n   *   title:string;\n   * }\n   * ```",
        "* Service for dynamically loading a Component into an arbitrary position in the internal Angular\n   * application tree.",
        "* Loads a root component that is placed at the first element that matches the component's\n     * selector.\n     *\n     * - `typeOrBinding` `Type` \\ {@link Binding} - representing the component to load.\n     * - `overrideSelector` (optional) selector to load the component at (or use\n     *   `@Component.selector`) The selector can be anywhere (i.e. outside the current component.)\n     * - `injector` {@link Injector} - optional injector to use for the component.\n     *\n     * The loaded component receives injection normally as a hosted view.\n     *\n     *\n     * ## Example\n     *\n     * ```\n     * @ng.Component({\n     *   selector: 'child-component'\n     * })\n     * @ng.View({\n     *   template: 'Child'\n     * })\n     * class ChildComponent {\n     * }\n     *\n     *\n     *\n     * @ng.Component({\n     *   selector: 'my-app'\n     * })\n     * @ng.View({\n     *   template: `\n     *     Parent (<child id=\"child\"></child>)\n     *   `\n     * })\n     * class MyApp {\n     *   constructor(dynamicComponentLoader: ng.DynamicComponentLoader, injector: ng.Injector) {\n     *     dynamicComponentLoader.loadAsRoot(ChildComponent, '#child', injector);\n     *   }\n     * }\n     *\n     * ng.bootstrap(MyApp);\n     * ```\n     *\n     * Resulting DOM:\n     *\n     * ```\n     * <my-app>\n     *   Parent (\n     *     <child id=\"child\">\n     *        Child\n     *     </child>\n     *   )\n     * </my-app>\n     * ```",
        "* Loads a component into the component view of the provided ElementRef next to the element\n     * with the given name.\n     *\n     * The loaded component receives injection normally as a hosted view.\n     *\n     * ## Example\n     *\n     * ```\n     * @ng.Component({\n     *   selector: 'child-component'\n     * })\n     * @ng.View({\n     *   template: 'Child'\n     * })\n     * class ChildComponent {\n     * }\n     *\n     *\n     * @ng.Component({\n     *   selector: 'my-app'\n     * })\n     * @ng.View({\n     *   template: `\n     *     Parent (<div #child></div>)\n     *   `\n     * })\n     * class MyApp {\n     *   constructor(dynamicComponentLoader: ng.DynamicComponentLoader, elementRef: ng.ElementRef) {\n     *     dynamicComponentLoader.loadIntoLocation(ChildComponent, elementRef, 'child');\n     *   }\n     * }\n     *\n     * ng.bootstrap(MyApp);\n     * ```\n     *\n     * Resulting DOM:\n     *\n     * ```\n     * <my-app>\n     *    Parent (\n     *      <div #child=\"\" class=\"ng-binding\"></div>\n     *      <child-component class=\"ng-binding\">Child</child-component>\n     *    )\n     * </my-app>\n     * ```",
        "* Loads a component next to the provided ElementRef.\n     *\n     * The loaded component receives injection normally as a hosted view.\n     *\n     *\n     * ## Example\n     *\n     * ```\n     * @ng.Component({\n     *   selector: 'child-component'\n     * })\n     * @ng.View({\n     *   template: 'Child'\n     * })\n     * class ChildComponent {\n     * }\n     *\n     *\n     * @ng.Component({\n     *   selector: 'my-app'\n     * })\n     * @ng.View({\n     *   template: `Parent`\n     * })\n     * class MyApp {\n     *   constructor(dynamicComponentLoader: ng.DynamicComponentLoader, elementRef: ng.ElementRef) {\n     *     dynamicComponentLoader.loadIntoLocation(ChildComponent, elementRef, 'child');\n     *   }\n     * }\n     *\n     * ng.bootstrap(MyApp);\n     * ```\n     *\n     * Resulting DOM:\n     *\n     * ```\n     * <my-app>Parent</my-app>\n     * <child-component>Child</child-component>\n     * ```",
        "* Provides access to explicitly trigger change detection in an application.\n   *\n   * By default, `Zone` triggers change detection in Angular on each virtual machine (VM) turn. When\n   * testing, or in some\n   * limited application use cases, a developer can also trigger change detection with the\n   * `lifecycle.tick()` method.\n   *\n   * Each Angular application has a single `LifeCycle` instance.\n   *\n   * # Example\n   *\n   * This is a contrived example, since the bootstrap automatically runs inside of the `Zone`, which\n   * invokes\n   * `lifecycle.tick()` on your behalf.\n   *\n   * ```javascript\n   * bootstrap(MyApp).then((ref:ComponentRef) => {\n   *   var lifeCycle = ref.injector.get(LifeCycle);\n   *   var myApp = ref.instance;\n   *\n   *   ref.doSomething();\n   *   lifecycle.tick();\n   * });\n   * ```",
        "* @private",
        "* Invoke this method to explicitly process change detection and its side-effects.\n     *\n     *  In development mode, `tick()` also performs a second change detection cycle to ensure that no\n     * further\n     *  changes are detected. If additional changes are picked up during this second cycle, bindings\n     * in\n     * the app have\n     *  side-effects that cannot be resolved in a single change detection pass. In this case, Angular\n     * throws an error,\n     *  since an Angular application can only have one change detection pass during which all change\n     * detection must\n     *  complete.",
        "* Reference to the element.\n   *\n   * Represents an opaque reference to the underlying element. The element is a DOM ELement in\n   * a Browser, but may represent other types on other rendering platforms. In the browser the\n   * `ElementRef` can be sent to the web-worker. Web Workers can not have references to the\n   * DOM Elements.",
        "* Reference to the {@link ViewRef} where the `ElementRef` is inside of.",
        "* Index of the element inside the {@link ViewRef}.\n     *\n     * This is used internally by the Angular framework to locate elements.",
        "* Index of the element inside the `RenderViewRef`.\n     *\n     * This is used internally by the Angular framework to locate elements.",
        "* Returns the native Element implementation.\n     *\n     * In the browser this represents the DOM Element.\n     *\n     * The `nativeElement` can be used as an escape hatch when direct DOM manipulation is needed. Use\n     * this with caution, as it creates tight coupling between your application and the Browser, which\n     * will not work in WebWorkers.\n     *\n     * NOTE: This method will return null in the webworker scenario!",
        "* Reference to a template within a component.\n   *\n   * Represents an opaque reference to the underlying template that can\n   * be instantiated using the {@link ViewContainerRef}.",
        "* The location of the template",
        "* Whether this template has a local variable with the given name",
        "* A reference to an Angular View.\n   *\n   * A View is a fundamental building block of Application UI. A View is the smallest set of\n   * elements which are created and destroyed together. A View can change properties on the elements\n   * within the view, but it can not change the structure of those elements.\n   *\n   * To change structure of the elements, the Views can contain zero or more {@link ViewContainerRef}s\n   * which allow the views to be nested.\n   *\n   * ## Example\n   *\n   * Given this template\n   *\n   * ```\n   * Count: {{items.length}}\n   * <ul>\n   *   <li *ng-for=\"var item of items\">{{item}}</li>\n   * </ul>\n   * ```\n   *\n   * The above example we have two {@link ProtoViewRef}s:\n   *\n   * Outter {@link ProtoViewRef}:\n   * ```\n   * Count: {{items.length}}\n   * <ul>\n   *   <template ng-for var-item [ng-for-of]=\"items\"></template>\n   * </ul>\n   * ```\n   *\n   * Inner {@link ProtoViewRef}:\n   * ```\n   *   <li>{{item}}</li>\n   * ```\n   *\n   * Notice that the original template is broken down into two separate {@link ProtoViewRef}s.\n   *\n   * The outter/inner {@link ProtoViewRef}s are then assembled into views like so:\n   *\n   * ```\n   * <!-- ViewRef: outer-0 -->\n   * Count: 2\n   * <ul>\n   *   <template view-container-ref></template>\n   *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->\n   *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->\n   * </ul>\n   * <!-- /ViewRef: outer-0 -->\n   * ```",
        "* Return `RenderViewRef`",
        "* Return `RenderFragmentRef`",
        "* Set local variable in a view.\n     *\n     * - `contextName` - Name of the local variable in a view.\n     * - `value` - Value for the local variable in a view.",
        "* A reference to an Angular ProtoView.\n   *\n   * A ProtoView is a reference to a template for easy creation of views.\n   * (See {@link AppViewManager#createViewInContainer `AppViewManager#createViewInContainer`} and\n   * {@link AppViewManager#createRootHostView `AppViewManager#createRootHostView`}).\n   *\n   * A `ProtoView` is a factory for creating `View`s.\n   *\n   * ## Example\n   *\n   * Given this template\n   *\n   * ```\n   * Count: {{items.length}}\n   * <ul>\n   *   <li *ng-for=\"var item of items\">{{item}}</li>\n   * </ul>\n   * ```\n   *\n   * The above example we have two {@link ProtoViewRef}s:\n   *\n   * Outter {@link ProtoViewRef}:\n   * ```\n   * Count: {{items.length}}\n   * <ul>\n   *   <template ng-for var-item [ng-for-of]=\"items\"></template>\n   * </ul>\n   * ```\n   *\n   * Inner {@link ProtoViewRef}:\n   * ```\n   *   <li>{{item}}</li>\n   * ```\n   *\n   * Notice that the original template is broken down into two separate {@link ProtoViewRef}s.",
        "* A location where {@link ViewRef}s can be attached.\n   *\n   * A `ViewContainerRef` represents a location in a {@link ViewRef} where other child\n   * {@link ViewRef}s can be inserted. Adding and removing views is the only way of structurally\n   * changing the rendered DOM of the application.",
        "* Remove all {@link ViewRef}s at current location.",
        "* Return a {@link ViewRef} at specific index.",
        "* Returns number of {@link ViewRef}s currently attached at this location.",
        "* Create and insert a {@link ViewRef} into the view-container.\n     *\n     * - `protoViewRef` (optional) {@link ProtoViewRef} - The `ProtoView` to use for creating\n     *   `View` to be inserted at this location. If `ViewContainer` is created at a location\n     *   of inline template, then `protoViewRef` is the `ProtoView` of the template.\n     * - `atIndex` (optional) `number` - location of insertion point. (Or at the end if unspecified.)\n     * - `context` (optional) {@link ElementRef} - Context (for expression evaluation) from the\n     *   {@link ElementRef} location. (Or current context if unspecified.)\n     * - `bindings` (optional) Array of {@link ResolvedBinding} - Used for configuring\n     *   `ElementInjector`.\n     *\n     * Returns newly created {@link ViewRef}.",
        "* Insert a {@link ViewRef} at specefic index.\n     *\n     * The index is location at which the {@link ViewRef} should be attached. If omitted it is\n     * inserted at the end.\n     *\n     * Returns the inserted {@link ViewRef}.",
        "* Return the index of already inserted {@link ViewRef}.",
        "* Remove a {@link ViewRef} at specific index.\n     *\n     * If the index is omitted last {@link ViewRef} is removed.",
        "* The method can be used together with insert to implement a view move, i.e.\n     * moving the dom nodes while the directives in the view stay intact.",
        "* Angular's reference to a component instance.\n   *\n   * `ComponentRef` represents a component instance lifecycle and meta information.",
        "* Location of the component host element.",
        "* Instance of component.",
        "* Returns the host {@link ViewRef}.",
        "* Dispose of the component instance.",
        "* A wrapper around zones that lets you schedule tasks after it has executed a task.\n   *\n   * The wrapper maintains an \"inner\" and an \"mount\" `Zone`. The application code will executes\n   * in the \"inner\" zone unless `runOutsideAngular` is explicitely called.\n   *\n   * A typical application will create a singleton `NgZone`. The outer `Zone` is a fork of the root\n   * `Zone`. The default `onTurnDone` runs the Angular change detection.",
        "* Sets the zone hook that is called just before Angular event turn starts.\n     * It is called once per browser event.",
        "* Sets the zone hook that is called immediately after Angular processes\n     * all pending microtasks.",
        "* Sets the zone hook that is called immediately after the last turn in\n     * an event completes. At this point Angular will no longer attempt to\n     * sync the UI. Any changes to the data model will not be reflected in the\n     * DOM. `onEventDoneFn` is executed outside Angular zone.\n     *\n     * This hook is useful for validating application state (e.g. in a test).",
        "* Sets the zone hook that is called when an error is uncaught in the\n     * Angular zone. The first argument is the error. The second argument is\n     * the stack trace.",
        "* Runs `fn` in the inner zone and returns whatever it returns.\n     *\n     * In a typical app where the inner zone is the Angular zone, this allows one to make use of the\n     * Angular's auto digest mechanism.\n     *\n     * ```\n     * var zone: NgZone = [ref to the application zone];\n     *\n     * zone.run(() => {\n     *   // the change detection will run after this function and the microtasks it enqueues have\n     * executed.\n     * });\n     * ```",
        "* Runs `fn` in the outer zone and returns whatever it returns.\n     *\n     * In a typical app where the inner zone is the Angular zone, this allows one to escape Angular's\n     * auto-digest mechanism.\n     *\n     * ```\n     * var zone: NgZone = [ref to the application zone];\n     *\n     * zone.runOutsideAngular(() => {\n     *   element.onClick(() => {\n     *     // Clicking on the element would not trigger the change detection\n     *   });\n     * });\n     * ```",
        "* Use Rx.Observable but provides an adapter to make it work as specified here:\n   * https://github.com/jhusain/observable-spec\n   *\n   * Once a reference implementation of the spec is available, switch to it.",
        "* A parameter metadata that specifies a dependency.\n   *\n   * ```\n   * class AComponent {\n   *   constructor(@Inject(MyService) aService:MyService) {}\n   * }\n   * ```",
        "* A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if\n   * the dependency is not found.\n   *\n   * ```\n   * class AComponent {\n   *   constructor(@Optional() aService:MyService) {\n   *     this.aService = aService;\n   *   }\n   * }\n   * ```",
        "* A marker metadata that marks a class as available to `Injector` for creation. Used by tooling\n   * for generating constructor stubs.\n   *\n   * ```\n   * class NeedsService {\n   *   constructor(svc:UsefulService) {}\n   * }\n   *\n   * @Injectable\n   * class UsefulService {}\n   * ```",
        "* Specifies that an injector should retrieve a dependency from itself.\n   *\n   * ## Example\n   *\n   * ```\n   * class Dependency {\n   * }\n   *\n   * class NeedsDependency {\n   *   constructor(public @Self() dependency:Dependency) {}\n   * }\n   *\n   * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);\n   * var nd = inj.get(NeedsDependency);\n   * expect(nd.dependency).toBeAnInstanceOf(Dependency);\n   * ```",
        "* Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * closest host.\n   *\n   * ## Example\n   *\n   * ```\n   * class Dependency {\n   * }\n   *\n   * class NeedsDependency {\n   *   constructor(public @Host() dependency:Dependency) {}\n   * }\n   *\n   * var parent = Injector.resolveAndCreate([\n   *   bind(Dependency).toClass(HostDependency)\n   * ]);\n   * var child = parent.resolveAndCreateChild([]);\n   * var grandChild = child.resolveAndCreateChild([NeedsDependency, Depedency]);\n   * var nd = grandChild.get(NeedsDependency);\n   * expect(nd.dependency).toBeAnInstanceOf(HostDependency);\n   * ```",
        "* Specifies that the dependency resolution should start from the parent injector.\n   *\n   * ## Example\n   *\n   *\n   * ```\n   * class Service {}\n   *\n   * class ParentService implements Service {\n   * }\n   *\n   * class ChildService implements Service {\n   *   constructor(public @SkipSelf() parentService:Service) {}\n   * }\n   *\n   * var parent = Injector.resolveAndCreate([\n   *   bind(Service).toClass(ParentService)\n   * ]);\n   * var child = parent.resolveAndCreateChild([\n   *   bind(Service).toClass(ChildSerice)\n   * ]);\n   * var s = child.get(Service);\n   * expect(s).toBeAnInstanceOf(ChildService);\n   * expect(s.parentService).toBeAnInstanceOf(ParentService);\n   * ```",
        "* `DependencyMetadata is used by the framework to extend DI.\n   *\n   * Only metadata implementing `DependencyMetadata` are added to the list of dependency\n   * properties.\n   *\n   * For example:\n   *\n   * ```\n   * class Exclude extends DependencyMetadata {}\n   * class NotDependencyProperty {}\n   *\n   * class AComponent {\n   *   constructor(@Exclude @NotDependencyProperty aService:AService) {}\n   * }\n   * ```\n   *\n   * will create the following dependency:\n   *\n   * ```\n   * new Dependency(Key.get(AService), [new Exclude()])\n   * ```\n   *\n   * The framework can use `new Exclude()` to handle the `aService` dependency\n   * in a specific way.",
        "* Allows to refer to references which are not yet defined.\n   *\n   * This situation arises when the key which we need te refer to for the purposes of DI is declared,\n   * but not yet defined.\n   *\n   * ## Example:\n   *\n   * ```\n   * class Door {\n   *   // Incorrect way to refer to a reference which is defined later.\n   *   // This fails because `Lock` is undefined at this point.\n   *   constructor(lock:Lock) { }\n   *\n   *   // Correct way to refer to a reference which is defined later.\n   *   // The reference needs to be captured in a closure.\n   *   constructor(@Inject(forwardRef(() => Lock)) lock:Lock) { }\n   * }\n   *\n   * // Only at this point the lock is defined.\n   * class Lock {\n   * }\n   * ```",
        "* Lazily retrieve the reference value.\n   *\n   * See: {@link forwardRef}",
        "* A dependency injection container used for resolving dependencies.\n   *\n   * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n   * constructor dependencies.\n   * In typical use, application code asks for the dependencies in the constructor and they are\n   * resolved by the `Injector`.\n   *\n   * ## Example:\n   *\n   * Suppose that we want to inject an `Engine` into class `Car`, we would define it like this:\n   *\n   * ```javascript\n   * class Engine {\n   * }\n   *\n   * class Car {\n   *   constructor(@Inject(Engine) engine) {\n   *   }\n   * }\n   *\n   * ```\n   *\n   * Next we need to write the code that creates and instantiates the `Injector`. We then ask for the\n   * `root` object, `Car`, so that the `Injector` can recursively build all of that object's\n   * dependencies.\n   *\n   * ```javascript\n   * main() {\n   *   var injector = Injector.resolveAndCreate([Car, Engine]);\n   *\n   *   // Get a reference to the `root` object, which will recursively instantiate the tree.\n   *   var car = injector.get(Car);\n   * }\n   * ```\n   * Notice that we don't use the `new` operator because we explicitly want to have the `Injector`\n   * resolve all of the object's dependencies automatically.",
        "* Turns a list of binding definitions into an internal resolved list of resolved bindings.\n     *\n     * A resolution is a process of flattening multiple nested lists and converting individual\n     * bindings into a list of {@link ResolvedBinding}s. The resolution can be cached by `resolve`\n     * for the {@link Injector} for performance-sensitive code.\n     *\n     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a\n     * recursive list of more bindings.\n     *\n     * The returned list is sparse, indexed by `id` for the {@link Key}. It is generally not useful to\n     * application code\n     * other than for passing it to {@link Injector} functions that require resolved binding lists,\n     * such as\n     * `fromResolvedBindings` and `createChildFromResolved`.",
        "* Resolves bindings and creates an injector based on those bindings. This function is slower than\n     * the corresponding `fromResolvedBindings` because it needs to resolve bindings first. See\n     * `resolve`\n     * for the {@link Injector}.\n     *\n     * Prefer `fromResolvedBindings` in performance-critical code that creates lots of injectors.\n     *\n     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a\n     * recursive list of more\n     * bindings.\n     * @param `depProvider`",
        "* Creates an injector from previously resolved bindings. This bypasses resolution and flattening.\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\n     *\n     * @param `bindings` A sparse list of {@link ResolvedBinding}s. See `resolve` for the\n     * {@link Injector}.\n     * @param `depProvider`",
        "* Returns debug information about the injector.\n     *\n     * This information is included into exceptions thrown by the injector.",
        "* Retrieves an instance from the injector.\n     *\n     * @param `token`: usually the `Type` of an object. (Same as the token used while setting up a\n     * binding).\n     * @returns an instance represented by the token. Throws if not found.",
        "* Retrieves an instance from the injector.\n     *\n     * @param `token`: usually a `Type`. (Same as the token used while setting up a binding).\n     * @returns an instance represented by the token. Returns `null` if not found.",
        "* Retrieves an instance from the injector.\n     *\n     * @param `index`: index of an instance.\n     * @returns an instance represented by the index. Throws if not found.",
        "* Direct parent of this injector.",
        "* Internal. Do not use.\n     *\n     * We return `any` not to export the InjectorStrategy type.",
        "* Creates a child injector and loads a new set of bindings into it.\n     *\n     * A resolution is a process of flattening multiple nested lists and converting individual\n     * bindings into a list of {@link ResolvedBinding}s. The resolution can be cached by `resolve`\n     * for the {@link Injector} for performance-sensitive code.\n     *\n     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a\n     * recursive list of more bindings.\n     * @param `depProvider`",
        "* Creates a child injector and loads a new set of {@link ResolvedBinding}s into it.\n     *\n     * @param `bindings`: A sparse list of {@link ResolvedBinding}s.\n     * See `resolve` for the {@link Injector}.\n     * @param `depProvider`\n     * @returns a new child {@link Injector}.",
        "* Resolves a binding and instantiates an object in the context of the injector.\n     *\n     * @param `binding`: either a type or a binding.\n     * @returns an object created using binding.",
        "* Instantiates an object using a resolved bindin in the context of the injector.\n     *\n     * @param `binding`: a resolved binding\n     * @returns an object created using binding.",
        "* Used to provide dependencies that cannot be easily expressed as bindings.",
        "* Describes how_ the {@link Injector} should instantiate a given token.\n   *\n   * See {@link bind}.\n   *\n   * ## Example\n   *\n   * ```javascript\n   * var injector = Injector.resolveAndCreate([\n   *   new Binding(String, { toValue: 'Hello' })\n   * ]);\n   *\n   * expect(injector.get(String)).toEqual('Hello');\n   * ```",
        "* Token used when retrieving this binding. Usually the `Type`.",
        "* Binds an interface to an implementation / subclass.\n     *\n     * ## Example\n     *\n     * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy\n     * comparison.\n     *\n     * ```javascript\n     *\n     * class Vehicle {}\n     *\n     * class Car extends Vehicle {}\n     *\n     * var injectorClass = Injector.resolveAndCreate([\n     *   Car,\n     *   new Binding(Vehicle, { toClass: Car })\n     * ]);\n     * var injectorAlias = Injector.resolveAndCreate([\n     *   Car,\n     *   new Binding(Vehicle, { toAlias: Car })\n     * ]);\n     *\n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n     *\n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n     * ```",
        "* Binds a key to a value.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   new Binding(String, { toValue: 'Hello' })\n     * ]);\n     *\n     * expect(injector.get(String)).toEqual('Hello');\n     * ```",
        "* Binds a key to the alias for an existing key.\n     *\n     * An alias means that {@link Injector} returns the same instance as if the alias token was used.\n     * This is in contrast to `toClass` where a separate instance of `toClass` is returned.\n     *\n     * ## Example\n     *\n     * Becuse `toAlias` and `toClass` are often confused the example contains both use cases for easy\n     * comparison.\n     *\n     * ```javascript\n     *\n     * class Vehicle {}\n     *\n     * class Car extends Vehicle {}\n     *\n     * var injectorAlias = Injector.resolveAndCreate([\n     *   Car,\n     *   new Binding(Vehicle, { toAlias: Car })\n     * ]);\n     * var injectorClass = Injector.resolveAndCreate([\n     *   Car,\n     *   new Binding(Vehicle, { toClass: Car })\n     * ]);\n     *\n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n     *\n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n     * ```",
        "* Binds a key to a function which computes the value.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   new Binding(Number, { toFactory: () => { return 1+2; }}),\n     *   new Binding(String, { toFactory: (value) => { return \"Value: \" + value; },\n     *                         dependencies: [Number] })\n     * ]);\n     *\n     * expect(injector.get(Number)).toEqual(3);\n     * expect(injector.get(String)).toEqual('Value: 3');\n     * ```",
        "* Used in conjunction with `toFactory` and specifies a set of dependencies\n     * (as `token`s) which should be injected into the factory function.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   new Binding(Number, { toFactory: () => { return 1+2; }}),\n     *   new Binding(String, { toFactory: (value) => { return \"Value: \" + value; },\n     *                         dependencies: [Number] })\n     * ]);\n     *\n     * expect(injector.get(Number)).toEqual(3);\n     * expect(injector.get(String)).toEqual('Value: 3');\n     * ```",
        "* Converts the {@link Binding} into {@link ResolvedBinding}.\n     *\n     * {@link Injector} internally only uses {@link ResolvedBinding}, {@link Binding} contains\n     * convenience binding syntax.",
        "* Helper class for the {@link bind} function.",
        "* Binds an interface to an implementation / subclass.\n     *\n     * ## Example\n     *\n     * Because `toAlias` and `toClass` are often confused, the example contains both use cases for\n     * easy comparison.\n     *\n     * ```javascript\n     *\n     * class Vehicle {}\n     *\n     * class Car extends Vehicle {}\n     *\n     * var injectorClass = Injector.resolveAndCreate([\n     *   Car,\n     *   bind(Vehicle).toClass(Car)\n     * ]);\n     * var injectorAlias = Injector.resolveAndCreate([\n     *   Car,\n     *   bind(Vehicle).toAlias(Car)\n     * ]);\n     *\n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n     *\n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n     * ```",
        "* Binds a key to a value.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   bind(String).toValue('Hello')\n     * ]);\n     *\n     * expect(injector.get(String)).toEqual('Hello');\n     * ```",
        "* Binds a key to the alias for an existing key.\n     *\n     * An alias means that we will return the same instance as if the alias token was used. (This is\n     * in contrast to `toClass` where a separate instance of `toClass` will be returned.)\n     *\n     * ## Example\n     *\n     * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy\n     * comparison.\n     *\n     * ```javascript\n     *\n     * class Vehicle {}\n     *\n     * class Car extends Vehicle {}\n     *\n     * var injectorAlias = Injector.resolveAndCreate([\n     *   Car,\n     *   bind(Vehicle).toAlias(Car)\n     * ]);\n     * var injectorClass = Injector.resolveAndCreate([\n     *   Car,\n     *   bind(Vehicle).toClass(Car)\n     * ]);\n     *\n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n     *\n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n     * ```",
        "* Binds a key to a function which computes the value.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   bind(Number).toFactory(() => { return 1+2; }),\n     *   bind(String).toFactory((v) => { return \"Value: \" + v; }, [Number])\n     * ]);\n     *\n     * expect(injector.get(Number)).toEqual(3);\n     * expect(injector.get(String)).toEqual('Value: 3');\n     * ```",
        "* An internal resolved representation of a {@link Binding} used by the {@link Injector}.\n   *\n   * A {@link Binding} is resolved when it has a factory function. Binding to a class, alias, or\n   * value, are just convenience methods, as {@link Injector} only operates on calling factory\n   * functions.",
        "* A key, usually a `Type`.",
        "* Factory function which can return an instance of an object represented by a key.",
        "* Arguments (dependencies) to the `factory` function.",
        "* @private",
        "* Provides an API for imperatively constructing {@link Binding}s.\n   *\n   * This is only relevant for JavaScript. See {@link BindingBuilder}.\n   *\n   * ## Example\n   *\n   * ```javascript\n   * bind(MyInterface).toClass(MyClass)\n   *\n   * ```",
        "* A unique object used for retrieving items from the {@link Injector}.\n   *\n   * Keys have:\n   * - a system-wide unique `id`.\n   * - a `token`, usually the `Type` of the instance.\n   *\n   * Keys are used internally by the {@link Injector} because their system-wide unique `id`s allow the\n   * injector to index in arrays rather than looking up items in maps.",
        "* Retrieves a `Key` for a token.",
        "* @returns the number of keys registered in the system.",
        "* @private",
        "* Type literals is a Dart-only feature. This is here only so we can x-compile\n   * to multiple languages.",
        "* Thrown when trying to retrieve a dependency by `Key` from {@link Injector}, but the\n   * {@link Injector} does not have a {@link Binding} for {@link Key}.",
        "* Base class for all errors arising from misconfigured bindings.",
        "* Thrown when dependencies form a cycle.\n   *\n   * ## Example:\n   *\n   * ```javascript\n   * class A {\n   *   constructor(b:B) {}\n   * }\n   * class B {\n   *   constructor(a:A) {}\n   * }\n   * ```\n   *\n   * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.",
        "* Thrown when a constructing type returns with an Error.\n   *\n   * The `InstantiationError` class contains the original error plus the dependency graph which caused\n   * this object to be instantiated.",
        "* Thrown when an object other then {@link Binding} (or `Type`) is passed to {@link Injector}\n   * creation.",
        "* Thrown when the class has no annotation information.\n   *\n   * Lack of annotation information prevents the {@link Injector} from determining which dependencies\n   * need to be injected into the constructor.",
        "* Thrown when getting an object by index.",
        "* Factory for creating {@link InjectMetadata}.",
        "* Factory for creating {@link OptionalMetadata}.",
        "* Factory for creating {@link InjectableMetadata}.",
        "* Factory for creating {@link SelfMetadata}.",
        "* Factory for creating {@link HostMetadata}.",
        "* Factory for creating {@link SkipSelfMetadata}.",
        "* Factory for creating {@link InjectMetadata}.",
        "* Factory for creating {@link OptionalMetadata}.",
        "* Factory for creating {@link InjectableMetadata}.",
        "* Factory for creating {@link SelfMetadata}.",
        "* Factory for creating {@link HostMetadata}.",
        "* Factory for creating {@link SkipSelfMetadata}.",
        "* A collection of the Angular core directives that are likely to be used in each and every Angular\n   * application.\n   *\n   * This collection can be used to quickly enumerate all the built-in directives in the `@View`\n   * annotation. For example,\n   * instead of writing:\n   *\n   * ```\n   * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/angular2';\n   * import {OtherDirective} from 'myDirectives';\n   *\n   * @Component({\n   *  selector: 'my-component'\n   * })\n   * @View({\n   *   templateUrl: 'myComponent.html',\n   *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]\n   * })\n   * export class MyComponent {\n   *   ...\n   * }\n   * ```\n   * one could import all the core directives at once:\n   *\n   * ```\n   * import {CORE_DIRECTIVES} from 'angular2/angular2';\n   * import {OtherDirective} from 'myDirectives';\n   *\n   * @Component({\n   *  selector: 'my-component'\n   * })\n   * @View({\n   *   templateUrl: 'myComponent.html',\n   *   directives: [CORE_DIRECTIVES, OtherDirective]\n   * })\n   * export class MyComponent {\n   *   ...\n   * }\n   * ```",
        "* Adds and removes CSS classes based on an {expression} value.\n   *\n   * The result of expression is used to add and remove CSS classes using the following logic,\n   * based on expression's value type:\n   * - {string} - all the CSS classes (space - separated) are added\n   * - {Array} - all the CSS classes (Array elements) are added\n   * - {Object} - each key corresponds to a CSS class name while values\n   * are interpreted as {boolean} expression. If a given expression\n   * evaluates to {true} a corresponding CSS class is added - otherwise\n   * it is removed.\n   *\n   * # Example:\n   *\n   * ```\n   * <div class=\"message\" [ng-class]=\"{error: errorCount > 0}\">\n   *     Please check errors.\n   * </div>\n   * ```",
        "* The `NgFor` directive instantiates a template once per item from an iterable. The context for\n   * each instantiated template inherits from the outer context with the given loop variable set\n   * to the current item from the iterable.\n   *\n   * It is possible to alias the `index` to a local variable that will be set to the current loop\n   * iteration in the template context.\n   *\n   * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:\n   *\n   * * When an item is added, a new instance of the template is added to the DOM.\n   * * When an item is removed, its template instance is removed from the DOM.\n   * * When items are reordered, their respective templates are reordered in the DOM.\n   *\n   * # Example\n   *\n   * ```\n   * <ul>\n   *   <li *ng-for=\"#error of errors; #i = index\">\n   *     Error {{i}} of {{errors.length}}: {{error.message}}\n   *   </li>\n   * </ul>\n   * ```\n   *\n   * # Syntax\n   *\n   * - `<li *ng-for=\"#item of items; #i = index\">...</li>`\n   * - `<li template=\"ng-for #item of items; #i = index\">...</li>`\n   * - `<template ng-for #item [ng-for-of]=\"items\" #i=\"index\"><li>...</li></template>`",
        "* Removes or recreates a portion of the DOM tree based on an {expression}.\n   *\n   * If the expression assigned to `ng-if` evaluates to a false value then the element\n   * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.\n   *\n   * # Example:\n   *\n   * ```\n   * <div *ng-if=\"errorCount > 0\" class=\"error\">\n   *   <!-- Error message displayed when the errorCount property on the current context is greater\n   * than 0. -->\n   *   {{errorCount}} errors detected\n   * </div>\n   * ```\n   *\n   * # Syntax\n   *\n   * - `<div *ng-if=\"condition\">...</div>`\n   * - `<div template=\"ng-if condition\">...</div>`\n   * - `<template [ng-if]=\"condition\"><div>...</div></template>`",
        "* The `NgNonBindable` directive tells Angular not to compile or bind the contents of the current\n   * DOM element. This is useful if the element contains what appears to be Angular directives and\n   * bindings but which should be ignored by Angular. This could be the case if you have a site that\n   * displays snippets of code, for instance.\n   *\n   * Example:\n   *\n   * ```\n   * <div>Normal: {{1 + 2}}</div> // output \"Normal: 3\"\n   * <div ng-non-bindable>Ignored: {{1 + 2}}</div> // output \"Ignored: {{1 + 2}}\"\n   * ```",
        "* Adds or removes styles based on an {expression}.\n   *\n   * When the expression assigned to `ng-style` evaluates to an object, the corresponding element\n   * styles are updated. Style names to update are taken from the object keys and values - from the\n   * corresponding object values.\n   *\n   * # Example:\n   *\n   * ```\n   * <div [ng-style]=\"{'text-align': alignExp}\"></div>\n   * ```\n   *\n   * In the above example the `text-align` style will be updated based on the `alignExp` value\n   * changes.\n   *\n   * # Syntax\n   *\n   * - `<div [ng-style]=\"{'text-align': alignExp}\"></div>`\n   * - `<div [ng-style]=\"styleExp\"></div>`",
        "* The `NgSwitch` directive is used to conditionally swap DOM structure on your template based on a\n   * scope expression.\n   * Elements within `NgSwitch` but without `NgSwitchWhen` or `NgSwitchDefault` directives will be\n   * preserved at the location as specified in the template.\n   *\n   * `NgSwitch` simply chooses nested elements and makes them visible based on which element matches\n   * the value obtained from the evaluated expression. In other words, you define a container element\n   * (where you place the directive), place an expression on the **`[ng-switch]=\"...\"` attribute**),\n   * define any inner elements inside of the directive and place a `[ng-switch-when]` attribute per\n   * element.\n   * The when attribute is used to inform NgSwitch which element to display when the expression is\n   * evaluated. If a matching expression is not found via a when attribute then an element with the\n   * default attribute is displayed.\n   *\n   * # Example:\n   *\n   * ```\n   * <ANY [ng-switch]=\"expression\">\n   *   <template [ng-switch-when]=\"whenExpression1\">...</template>\n   *   <template [ng-switch-when]=\"whenExpression1\">...</template>\n   *   <template ng-switch-default>...</template>\n   * </ANY>\n   * ```",
        "* Defines a case statement as an expression.\n   *\n   * If multiple `NgSwitchWhen` match the `NgSwitch` value, all of them are displayed.\n   *\n   * Example:\n   *\n   * ```\n   * // match against a context variable\n   * <template [ng-switch-when]=\"contextVariable\">...</template>\n   *\n   * // match against a constant string\n   * <template ng-switch-when=\"stringValue\">...</template>\n   * ```",
        "* Defines a default case statement.\n   *\n   * Default case statements are displayed when no `NgSwitchWhen` match the `ng-switch` value.\n   *\n   * Example:\n   *\n   * ```\n   * <template ng-switch-default>...</template>\n   * ```",
        "* Omitting from external API doc as this is really an abstract internal concept.",
        "* Defines a part of a form that cannot be divided into other controls.\n   *\n   * `Control` is one of the three fundamental building blocks used to define forms in Angular, along\n   * with\n   * {@link ControlGroup} and {@link ControlArray}.",
        "* Defines a part of a form, of fixed length, that can contain other controls.\n   *\n   * A ControlGroup aggregates the values and errors of each {@link Control} in the group. Thus, if\n   * one of the controls\n   * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,\n   * the entire group\n   * changes as well.\n   *\n   * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,\n   * along with\n   * {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other controls,\n   * but is of variable\n   * length.",
        "* Defines a part of a form, of variable length, that can contain other controls.\n   *\n   * A `ControlArray` aggregates the values and errors of each {@link Control} in the group. Thus, if\n   * one of the controls\n   * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,\n   * the entire group\n   * changes as well.\n   *\n   * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,\n   * along with {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain\n   * other controls, but is of fixed length.",
        "* An interface that {@link NgFormModel} and {@link NgForm} implement.\n   *\n   * Only used by the forms module.",
        "* A directive that contains a group of [NgControl].\n   *\n   * Only used by the forms module.",
        "* Creates and binds a control with a specified name to a DOM element.\n   *\n   * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.\n   *\n   * # Example\n   *\n   * In this example, we create the login and password controls.\n   * We can work with each control separately: check its validity, get its value, listen to its\n   *  changes.\n   *\n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: `\n   *              <form #f=\"form\" (submit)='onLogIn(f.value)'>\n   *                Login <input type='text' ng-control='login' #l=\"form\">\n   *                <div *ng-if=\"!l.valid\">Login is invalid</div>\n   *\n   *                Password <input type='password' ng-control='password'>\n   *\n   *                <button type='submit'>Log in!</button>\n   *              </form>\n   *      `})\n   * class LoginComp {\n   *  onLogIn(value) {\n   *    // value === {login: 'some login', password: 'some password'}\n   *  }\n   * }\n   *  ```\n   *\n   * We can also use ng-model to bind a domain model to the form.\n   *\n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: `\n   *              <form (submit)='onLogIn()'>\n   *                Login <input type='text' ng-control='login' [(ng-model)]=\"credentials.login\">\n   *                Password <input type='password' ng-control='password'\n   *  [(ng-model)]=\"credentials.password\">\n   *                <button type='submit'>Log in!</button>\n   *              </form>\n   *      `})\n   * class LoginComp {\n   *  credentials: {login:string, password:string};\n   *\n   *  onLogIn() {\n   *    // this.credentials.login === \"some login\"\n   *    // this.credentials.password === \"some password\"\n   *  }\n   * }\n   *  ```",
        "* Binds an existing control to a DOM element.\n   *\n   * # Example\n   *\n   * In this example, we bind the control to an input element. When the value of the input element\n   * changes, the value of\n   * the control will reflect that change. Likewise, if the value of the control changes, the input\n   * element reflects that\n   * change.\n   *\n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: \"<input type='text' [ng-form-control]='loginControl'>\"\n   *      })\n   * class LoginComp {\n   *  loginControl:Control;\n   *\n   *  constructor() {\n   *    this.loginControl = new Control('');\n   *  }\n   * }\n   *\n   *  ```\n   *\n   * We can also use ng-model to bind a domain model to the form.\n   *\n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: \"<input type='text' [ng-form-control]='loginControl' [(ng-model)]='login'>\"\n   *      })\n   * class LoginComp {\n   *  loginControl:Control;\n   *  login:string;\n   *\n   *  constructor() {\n   *    this.loginControl = new Control('');\n   *  }\n   * }\n   *  ```",
        "* Binds a domain model to the form.\n   *\n   * # Example\n   *  ```\n   * @Component({selector: \"search-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: `\n   *               <input type='text' [(ng-model)]=\"searchQuery\">\n   *      `})\n   * class SearchComp {\n   *  searchQuery: string;\n   * }\n   *  ```",
        "* An abstract class that all control directive extend.\n   *\n   * It binds a {@link Control} object to a DOM element.",
        "* Creates and binds a control group to a DOM element.\n   *\n   * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.\n   *\n   * # Example\n   *\n   * In this example, we create the credentials and personal control groups.\n   * We can work with each group separately: check its validity, get its value, listen to its changes.\n   *\n   *  ```\n   * @Component({selector: \"signup-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: `\n   *              <form #f=\"form\" (submit)='onSignUp(f.value)'>\n   *                <div ng-control-group='credentials' #credentials=\"form\">\n   *                  Login <input type='text' ng-control='login'>\n   *                  Password <input type='password' ng-control='password'>\n   *                </div>\n   *                <div *ng-if=\"!credentials.valid\">Credentials are invalid</div>\n   *\n   *                <div ng-control-group='personal'>\n   *                  Name <input type='text' ng-control='name'>\n   *                </div>\n   *                <button type='submit'>Sign Up!</button>\n   *              </form>\n   *      `})\n   * class SignupComp {\n   *  onSignUp(value) {\n   *    // value === {personal: {name: 'some name'},\n   *    //  credentials: {login: 'some login', password: 'some password'}}\n   *  }\n   * }\n   *\n   *  ```",
        "* Binds an existing control group to a DOM element.\n   *\n   * # Example\n   *\n   * In this example, we bind the control group to the form element, and we bind the login and\n   * password controls to the\n   * login and password elements.\n   *\n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: \"<form [ng-form-model]='loginForm'>\" +\n   *              \"Login <input type='text' ng-control='login'>\" +\n   *              \"Password <input type='password' ng-control='password'>\" +\n   *              \"<button (click)=\"onLogin()\">Login</button>\" +\n   *              \"</form>\"\n   *      })\n   * class LoginComp {\n   *  loginForm:ControlGroup;\n   *\n   *  constructor() {\n   *    this.loginForm = new ControlGroup({\n   *      login: new Control(\"\"),\n   *      password: new Control(\"\")\n   *    });\n   *  }\n   *\n   *  onLogin() {\n   *    // this.loginForm.value\n   *  }\n   * }\n   *\n   *  ```\n   *\n   * We can also use ng-model to bind a domain model to the form.\n   *\n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: \"<form [ng-form-model]='loginForm'>\" +\n   *              \"Login <input type='text' ng-control='login' [(ng-model)]='login'>\" +\n   *              \"Password <input type='password' ng-control='password' [(ng-model)]='password'>\" +\n   *              \"<button (click)=\"onLogin()\">Login</button>\" +\n   *              \"</form>\"\n   *      })\n   * class LoginComp {\n   *  credentials:{login:string, password:string}\n   *  loginForm:ControlGroup;\n   *\n   *  constructor() {\n   *    this.loginForm = new ControlGroup({\n   *      login: new Control(\"\"),\n   *      password: new Control(\"\")\n   *    });\n   *  }\n   *\n   *  onLogin() {\n   *    // this.credentials.login === 'some login'\n   *    // this.credentials.password === 'some password'\n   *  }\n   * }\n   *  ```",
        "* Creates and binds a form object to a DOM element.\n   *\n   * # Example\n   *\n   *  ```\n   * @Component({selector: \"signup-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: `\n   *              <form #f=\"form\" (submit)='onSignUp(f.value)'>\n   *                <div ng-control-group='credentials' #credentials=\"form\">\n   *                  Login <input type='text' ng-control='login'>\n   *                  Password <input type='password' ng-control='password'>\n   *                </div>\n   *                <div *ng-if=\"!credentials.valid\">Credentials are invalid</div>\n   *\n   *                <div ng-control-group='personal'>\n   *                  Name <input type='text' ng-control='name'>\n   *                </div>\n   *                <button type='submit'>Sign Up!</button>\n   *              </form>\n   *      `})\n   * class SignupComp {\n   *  onSignUp(value) {\n   *    // value === {personal: {name: 'some name'},\n   *    //  credentials: {login: 'some login', password: 'some password'}}\n   *  }\n   * }\n   *\n   *  ```",
        "* A bridge between a control and a native element.\n   *\n   * Please see {@link DefaultValueAccessor} for more information.",
        "* The default accessor for writing a value and listening to changes that is used by the\n   * {@link NgModel}, {@link NgFormControl}, and {@link NgControlName} directives.\n   *\n   *  # Example\n   *  ```\n   *  <input type=\"text\" [(ng-model)]=\"searchQuery\">\n   *  ```",
        "* The accessor for writing a value and listening to changes on a checkbox input element.\n   *\n   *  # Example\n   *  ```\n   *  <input type=\"checkbox\" [ng-control]=\"rememberLogin\">\n   *  ```",
        "* Marks <option> as dynamic, so Angular can be notified when options change.\n   *\n   * #Example:\n   *\n   * ```\n   * <select ng-control=\"city\">\n   *   <option *ng-for=\"#c of cities\" [value]=\"c\"></option>\n   * </select>\n   * ```",
        "* The accessor for writing a value and listening to changes on a select element.",
        "* A list of all the form directives used as part of a `@View` annotation.\n   *\n   *  This is a shorthand for importing them each individually.",
        "* Provides a set of validators used by form controls.\n   *\n   * # Example\n   *\n   * ```\n   * var loginControl = new Control(\"\", Validators.required)\n   * ```",
        "* Creates a form object from a user-specified configuration.\n   *\n   * # Example\n   *\n   * ```\n   * import {Component, View, bootstrap} from 'angular2/angular2';\n   * import {FormBuilder, Validators, FORM_DIRECTIVES, ControlGroup} from 'angular2/forms';\n   *\n   * @Component({\n   *   selector: 'login-comp',\n   *   viewBindings: [\n   *     FormBuilder\n   *   ]\n   * })\n   * @View({\n   *   template: `\n   *     <form [control-group]=\"loginForm\">\n   *       Login <input control=\"login\">\n   *\n   *       <div control-group=\"passwordRetry\">\n   *         Password <input type=\"password\" control=\"password\">\n   *         Confirm password <input type=\"password\" control=\"passwordConfirmation\">\n   *       </div>\n   *     </form>\n   *   `,\n   *   directives: [\n   *     FORM_DIRECTIVES\n   *   ]\n   * })\n   * class LoginComp {\n   *   loginForm: ControlGroup;\n   *\n   *   constructor(builder: FormBuilder) {\n   *     this.loginForm = builder.group({\n   *       login: [\"\", Validators.required],\n   *\n   *       passwordRetry: builder.group({\n   *         password: [\"\", Validators.required],\n   *         passwordConfirmation: [\"\", Validators.required]\n   *       })\n   *     });\n   *   }\n   * }\n   *\n   * bootstrap(LoginComp)\n   * ```\n   *\n   * This example creates a {@link ControlGroup} that consists of a `login` {@link Control}, and a\n   * nested\n   * {@link ControlGroup} that defines a `password` and a `passwordConfirmation` {@link Control}:\n   *\n   * ```\n   *  var loginForm = builder.group({\n   *    login: [\"\", Validators.required],\n   *\n   *    passwordRetry: builder.group({\n   *      password: [\"\", Validators.required],\n   *      passwordConfirmation: [\"\", Validators.required]\n   *    })\n   *  });\n   *\n   *  ```",
        "* A dispatcher for all events happening in a view.",
        "* Called when an event was triggered for a on-* attribute on an element.\n     * @param {Map<string, any>} locals Locals to be used to evaluate the\n     *   event expressions\n     * @return {boolean} False if `preventDefault` should be called on the DOM event.",
        "* Creates a root host view that includes the given element.\n     * Note that the fragmentCount needs to be passed in so that we can create a result\n     * synchronously even when dealing with webworkers!\n     *\n     * @param {RenderProtoViewRef} hostProtoViewRef a RenderProtoViewRef of type\n     * ProtoViewDto.HOST_VIEW_TYPE\n     * @param {any} hostElementSelector css selector for the host element (will be queried against the\n     * main document)\n     * @return {RenderViewWithFragments} the created view including fragments",
        "* Creates a regular view out of the given ProtoView.\n     * Note that the fragmentCount needs to be passed in so that we can create a result\n     * synchronously even when dealing with webworkers!",
        "* Destroys the given view after it has been dehydrated and detached",
        "* Attaches a fragment after another fragment.",
        "* Attaches a fragment after an element.",
        "* Detaches a fragment.",
        "* Hydrates a view after it has been attached. Hydration/dehydration is used for reusing views\n     * inside of the view pool.",
        "* Dehydrates a view after it has been attached. Hydration/dehydration is used for reusing views\n     * inside of the view pool.",
        "* Returns the native element at the given location.\n     * Attention: In a WebWorker scenario, this should always return null!",
        "* Sets a property on an element.",
        "* Sets an attribute on an element.",
        "* Sets a class on an element.",
        "* Sets a style on an element.",
        "* Calls a method on an element.",
        "* Sets the value of a text node.",
        "* Sets the dispatcher for all events of the given view",
        "* Abstract reference to the element which can be marshaled across web-worker boundary.\n   *\n   * This interface is used by the Renderer API.",
        "* Reference to the `RenderViewRef` where the `RenderElementRef` is inside of.",
        "* Index of the element inside the `RenderViewRef`.\n     *\n     * This is used internally by the Angular framework to locate elements.",
        "* A unique id (string) for an angular application.",
        "* Defines when a compiled template should be stored as a string\n   * rather than keeping its Nodes to preserve memory.",
        "* Create trace scope.\n   *\n   * Scopes must be strictly nested and are analogous to stack frames, but\n   * do not have to follow the stack frames. Instead it is recommended that they follow logical\n   * nesting. You may want to use\n   * [Event\n   * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\n   * as they are defined in WTF.\n   *\n   * Used to mark scope entry. The return value is used to leave the scope.\n   *\n   *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\n   *\n   *     someMethod() {\n   *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\n   *        // DO SOME WORK HERE\n   *        return wtfLeave(s, 123); // Return value 123\n   *     }\n   *\n   * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\n   * negatively impact the performance of your application. For this reason we recommend that\n   * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\n   * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\n   * exception, will produce incorrect trace, but presence of exception signifies logic error which\n   * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\n   * an exception is expected during normal execution while profiling.",
        "* Used to mark end of Scope.\n   *\n   * - `scope` to end.\n   * - `returnValue` (optional) to be passed to the WTF.\n   *\n   * Returns the `returnValue for easy chaining.",
        "* Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\n   * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\n   * enabled.\n   *\n   *     someMethod() {\n   *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\n   *        var future = new Future.delay(5).then((_) {\n   *          wtfEndTimeRange(s);\n   *        });\n   *     }",
        "* Ends a async time range operation.\n   * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\n   * enabled.",
        "* Declare reusable UI building blocks for an application.\n   *\n   * Each Angular component requires a single `@Component` and at least one `@View` annotation. The\n   * `@Component`\n   * annotation specifies when a component is instantiated, and which properties and hostListeners it\n   * binds to.\n   *\n   * When a component is instantiated, Angular\n   * - creates a shadow DOM for the component.\n   * - loads the selected template into the shadow DOM.\n   * - creates all the injectable objects configured with `bindings` and `viewBindings`.\n   *\n   * All template expressions and statements are then evaluated against the component instance.\n   *\n   * For details on the `@View` annotation, see {@link ViewMetadata}.\n   *\n   * ## Example\n   *\n   * ```\n   * @Component({\n   *   selector: 'greet'\n   * })\n   * @View({\n   *   template: 'Hello {{name}}!'\n   * })\n   * class Greet {\n   *   name: string;\n   *\n   *   constructor() {\n   *     this.name = 'World';\n   *   }\n   * }\n   * ```",
        "* Defines the used change detection strategy.\n     *\n     * When a component is instantiated, Angular creates a change detector, which is responsible for\n     * propagating the component's bindings.\n     *\n     * The `changeDetection` property defines, whether the change detection will be checked every time\n     * or only when the component tells it to do so.",
        "* Defines the set of injectable objects that are visible to its view dom children.\n     *\n     * ## Simple Example\n     *\n     * Here is an example of a class that can be injected:\n     *\n     * ```\n     * class Greeter {\n     *    greet(name:string) {\n     *      return 'Hello ' + name + '!';\n     *    }\n     * }\n     *\n     * @Directive({\n     *   selector: 'needs-greeter'\n     * })\n     * class NeedsGreeter {\n     *   greeter:Greeter;\n     *\n     *   constructor(greeter:Greeter) {\n     *     this.greeter = greeter;\n     *   }\n     * }\n     *\n     * @Component({\n     *   selector: 'greet',\n     *   viewBindings: [\n     *     Greeter\n     *   ]\n     * })\n     * @View({\n     *   template: `<needs-greeter></needs-greeter>`,\n     *   directives: [NeedsGreeter]\n     * })\n     * class HelloWorld {\n     * }\n     *\n     * ```",
        "* Directives allow you to attach behavior to elements in the DOM.\n   *\n   * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.\n   *\n   * A directive consists of a single directive annotation and a controller class. When the\n   * directive's `selector` matches\n   * elements in the DOM, the following steps occur:\n   *\n   * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor\n   * arguments.\n   * 2. Angular instantiates directives for each matched element using `ElementInjector` in a\n   * depth-first order,\n   *    as declared in the HTML.\n   *\n   * ## Understanding How Injection Works\n   *\n   * There are three stages of injection resolution.\n   * - *Pre-existing Injectors*:\n   *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if\n   * the dependency was\n   *     specified as `@Optional`, returns `null`.\n   *   - The platform injector resolves browser singleton resources, such as: cookies, title,\n   * location, and others.\n   * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow\n   * the same parent-child hierarchy\n   *     as the component instances in the DOM.\n   * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each\n   * element has an `ElementInjector`\n   *     which follow the same parent-child hierarchy as the DOM elements themselves.\n   *\n   * When a template is instantiated, it also must instantiate the corresponding directives in a\n   * depth-first order. The\n   * current `ElementInjector` resolves the constructor dependencies for each directive.\n   *\n   * Angular then resolves dependencies as follows, according to the order in which they appear in the\n   * {@link ViewMetadata}:\n   *\n   * 1. Dependencies on the current element\n   * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary\n   * 3. Dependencies on component injectors and their parents until it encounters the root component\n   * 4. Dependencies on pre-existing injectors\n   *\n   *\n   * The `ElementInjector` can inject other directives, element-specific special objects, or it can\n   * delegate to the parent\n   * injector.\n   *\n   * To inject other directives, declare the constructor parameter as:\n   * - `directive:DirectiveType`: a directive on the current element only\n   * - `@Host() directive:DirectiveType`: any directive that matches the type between the current\n   * element and the\n   *    Shadow DOM root.\n   * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child\n   * directives.\n   * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any\n   * child directives.\n   *\n   * To inject element-specific special objects, declare the constructor parameter as:\n   * - `element: ElementRef` to obtain a reference to logical element in the view.\n   * - `viewContainer: ViewContainerRef` to control child template instantiation, for\n   * {@link DirectiveMetadata} directives only\n   * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.\n   *\n   * ## Example\n   *\n   * The following example demonstrates how dependency injection resolves constructor arguments in\n   * practice.\n   *\n   *\n   * Assume this HTML template:\n   *\n   * ```\n   * <div dependency=\"1\">\n   *   <div dependency=\"2\">\n   *     <div dependency=\"3\" my-directive>\n   *       <div dependency=\"4\">\n   *         <div dependency=\"5\"></div>\n   *       </div>\n   *       <div dependency=\"6\"></div>\n   *     </div>\n   *   </div>\n   * </div>\n   * ```\n   *\n   * With the following `dependency` decorator and `SomeService` injectable class.\n   *\n   * ```\n   * @Injectable()\n   * class SomeService {\n   * }\n   *\n   * @Directive({\n   *   selector: '[dependency]',\n   *   properties: [\n   *     'id: dependency'\n   *   ]\n   * })\n   * class Dependency {\n   *   id:string;\n   * }\n   * ```\n   *\n   * Let's step through the different ways in which `MyDirective` could be declared...\n   *\n   *\n   * ### No injection\n   *\n   * Here the constructor is declared with no arguments, therefore nothing is injected into\n   * `MyDirective`.\n   *\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor() {\n   *   }\n   * }\n   * ```\n   *\n   * This directive would be instantiated with no dependencies.\n   *\n   *\n   * ### Component-level injection\n   *\n   * Directives can inject any injectable instance from the closest component injector or any of its\n   * parents.\n   *\n   * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type\n   * from the parent\n   * component's injector.\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(someService: SomeService) {\n   *   }\n   * }\n   * ```\n   *\n   * This directive would be instantiated with a dependency on `SomeService`.\n   *\n   *\n   * ### Injecting a directive from the current element\n   *\n   * Directives can inject other directives declared on the current element.\n   *\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(dependency: Dependency) {\n   *     expect(dependency.id).toEqual(3);\n   *   }\n   * }\n   * ```\n   * This directive would be instantiated with `Dependency` declared at the same element, in this case\n   * `dependency=\"3\"`.\n   *\n   * ### Injecting a directive from any ancestor elements\n   *\n   * Directives can inject other directives declared on any ancestor element (in the current Shadow\n   * DOM), i.e. on the current element, the\n   * parent element, or its parents.\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@Host() dependency: Dependency) {\n   *     expect(dependency.id).toEqual(2);\n   *   }\n   * }\n   * ```\n   *\n   * `@Host` checks the current element, the parent, as well as its parents recursively. If\n   * `dependency=\"2\"` didn't\n   * exist on the direct parent, this injection would\n   * have returned\n   * `dependency=\"1\"`.\n   *\n   *\n   * ### Injecting a live collection of direct child directives\n   *\n   *\n   * A directive can also query for other child directives. Since parent directives are instantiated\n   * before child directives, a directive can't simply inject the list of child directives. Instead,\n   * the directive injects a {@link QueryList}, which updates its contents as children are added,\n   * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ng-for`, an\n   * `ng-if`, or an `ng-switch`.\n   *\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {\n   *   }\n   * }\n   * ```\n   *\n   * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and\n   * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.\n   *\n   * ### Injecting a live collection of descendant directives\n   *\n   * By passing the descendant flag to `@Query` above, we can include the children of the child\n   * elements.\n   *\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {\n   *   }\n   * }\n   * ```\n   *\n   * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.\n   *\n   * ### Optional injection\n   *\n   * The normal behavior of directives is to return an error when a specified dependency cannot be\n   * resolved. If you\n   * would like to inject `null` on unresolved dependency instead, you can annotate that dependency\n   * with `@Optional()`.\n   * This explicitly permits the author of a template to treat some of the surrounding directives as\n   * optional.\n   *\n   * ```\n   * @Directive({ selector: '[my-directive]' })\n   * class MyDirective {\n   *   constructor(@Optional() dependency:Dependency) {\n   *   }\n   * }\n   * ```\n   *\n   * This directive would be instantiated with a `Dependency` directive found on the current element.\n   * If none can be\n   * found, the injector supplies `null` instead of throwing an error.\n   *\n   * ## Example\n   *\n   * Here we use a decorator directive to simply define basic tool-tip behavior.\n   *\n   * ```\n   * @Directive({\n   *   selector: '[tooltip]',\n   *   properties: [\n   *     'text: tooltip'\n   *   ],\n   *   host: {\n   *     '(mouseenter)': 'onMouseEnter()',\n   *     '(mouseleave)': 'onMouseLeave()'\n   *   }\n   * })\n   * class Tooltip{\n   *   text:string;\n   *   overlay:Overlay; // NOT YET IMPLEMENTED\n   *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED\n   *\n   *   constructor(overlayManager:OverlayManager) {\n   *     this.overlay = overlay;\n   *   }\n   *\n   *   onMouseEnter() {\n   *     // exact signature to be determined\n   *     this.overlay = this.overlayManager.open(text, ...);\n   *   }\n   *\n   *   onMouseLeave() {\n   *     this.overlay.close();\n   *     this.overlay = null;\n   *   }\n   * }\n   * ```\n   * In our HTML template, we can then add this behavior to a `<div>` or any other element with the\n   * `tooltip` selector,\n   * like so:\n   *\n   * ```\n   * <div tooltip=\"some text here\"></div>\n   * ```\n   *\n   * Directives can also control the instantiation, destruction, and positioning of inline template\n   * elements:\n   *\n   * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at\n   * runtime.\n   * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a\n   * location in the current view\n   * where these actions are performed.\n   *\n   * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the\n   * `<template>` element. Thus a\n   * directive in a child view cannot inject the directive that created it.\n   *\n   * Since directives that create views via ViewContainers are common in Angular, and using the full\n   * `<template>` element syntax is wordy, Angular\n   * also supports a shorthand notation: `<li *foo=\"bar\">` and `<li template=\"foo: bar\">` are\n   * equivalent.\n   *\n   * Thus,\n   *\n   * ```\n   * <ul>\n   *   <li *foo=\"bar\" title=\"text\"></li>\n   * </ul>\n   * ```\n   *\n   * Expands in use to:\n   *\n   * ```\n   * <ul>\n   *   <template [foo]=\"bar\">\n   *     <li title=\"text\"></li>\n   *   </template>\n   * </ul>\n   * ```\n   *\n   * Notice that although the shorthand places `*foo=\"bar\"` within the `<li>` element, the binding for\n   * the directive\n   * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.\n   *\n   *\n   * ## Example\n   *\n   * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.\n   *\n   * Here is a simple directive that triggers on an `unless` selector:\n   *\n   * ```\n   * @Directive({\n   *   selector: '[unless]',\n   *   properties: ['unless']\n   * })\n   * export class Unless {\n   *   viewContainer: ViewContainerRef;\n   *   templateRef: TemplateRef;\n   *   prevCondition: boolean;\n   *\n   *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {\n   *     this.viewContainer = viewContainer;\n   *     this.templateRef = templateRef;\n   *     this.prevCondition = null;\n   *   }\n   *\n   *   set unless(newCondition) {\n   *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {\n   *       this.prevCondition = true;\n   *       this.viewContainer.clear();\n   *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {\n   *       this.prevCondition = false;\n   *       this.viewContainer.create(this.templateRef);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * We can then use this `unless` selector in a template:\n   * ```\n   * <ul>\n   *   <li *unless=\"expr\"></li>\n   * </ul>\n   * ```\n   *\n   * Once the directive instantiates the child view, the shorthand notation for the template expands\n   * and the result is:\n   *\n   * ```\n   * <ul>\n   *   <template [unless]=\"exp\">\n   *     <li></li>\n   *   </template>\n   *   <li></li>\n   * </ul>\n   * ```\n   *\n   * Note also that although the `<li></li>` template still exists inside the `<template></template>`,\n   * the instantiated\n   * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.",
        "* The CSS selector that triggers the instantiation of a directive.\n     *\n     * Angular only allows directives to trigger on CSS selectors that do not cross element\n     * boundaries.\n     *\n     * `selector` may be declared as one of the following:\n     *\n     * - `element-name`: select by element name.\n     * - `.class`: select by class name.\n     * - `[attribute]`: select by attribute name.\n     * - `[attribute=value]`: select by attribute name and value.\n     * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.\n     * - `selector1, selector2`: select if either `selector1` or `selector2` matches.\n     *\n     *\n     * ## Example\n     *\n     * Suppose we have a directive with an `input[type=text]` selector.\n     *\n     * And the following HTML:\n     *\n     * ```html\n     * <form>\n     *   <input type=\"text\">\n     *   <input type=\"radio\">\n     * <form>\n     * ```\n     *\n     * The directive would only be instantiated on the `<input type=\"text\">` element.",
        "* Enumerates the set of properties that accept data binding for a directive.\n     *\n     * The `properties` property defines a set of `directiveProperty` to `bindingProperty`\n     * configuration:\n     *\n     * - `directiveProperty` specifies the component property where the value is written.\n     * - `bindingProperty` specifies the DOM property where the value is read from.\n     *\n     * You can include a {@link PipeMetadata} when specifying a `bindingProperty` to allow for data\n     * transformation and structural change detection of the value. These pipes will be evaluated in\n     * the context of this component.\n     *\n     * ## Syntax\n     *\n     * There is no need to specify both `directiveProperty` and `bindingProperty` when they both have\n     * the same value.\n     *\n     * ```\n     * @Directive({\n     *   properties: [\n     *     'propertyName', // shorthand notation for 'propertyName: propertyName'\n     *     'directiveProperty1: bindingProperty1',\n     *     'directiveProperty2: bindingProperty2 | pipe1 | ...',\n     *     ...\n     *   ]\n     * }\n     * ```\n     *\n     *\n     * ## Basic Property Binding\n     *\n     * We can easily build a simple `Tooltip` directive that exposes a `tooltip` property, which can\n     * be used in templates with standard Angular syntax. For example:\n     *\n     * ```\n     * @Directive({\n     *   selector: '[tooltip]',\n     *   properties: [\n     *     'text: tooltip'\n     *   ]\n     * })\n     * class Tooltip {\n     *   set text(value: string) {\n     *     // This will get called every time with the new value when the 'tooltip' property changes\n     *   }\n     * }\n     * ```\n     *\n     * We can then bind to the `tooltip' property as either an expression (`someExpression`) or as a\n     * string literal, as shown in the HTML template below:\n     *\n     * ```html\n     * <div [tooltip]=\"someExpression\">...</div>\n     * <div tooltip=\"Some Text\">...</div>\n     * ```\n     *\n     * Whenever the `someExpression` expression changes, the `properties` declaration instructs\n     * Angular to update the `Tooltip`'s `text` property.\n     *\n     * ### Bindings With Pipes\n     *\n     * You can use pipes in bindings, as follows:\n     *\n     * ```html\n     * <div [class-set]=\"someExpression | somePipe\">\n     * ```",
        "* Enumerates the set of emitted events.\n     *\n     * ## Syntax\n     *\n     * ```\n     * @Component({\n     *   events: ['statusChange']\n     * })\n     * class TaskComponent {\n     *   statusChange: EventEmitter;\n     *\n     *   constructor() {\n     *     this.statusChange = new EventEmitter();\n     *   }\n     *\n     *   onComplete() {\n     *     this.statusChange.next('completed');\n     *   }\n     * }\n     * ```\n     *\n     * Use `propertyName: eventName` when the event emitter property name is different from the name\n     * of the emitted event:\n     *\n     * ```\n     * @Component({\n     *   events: ['status: statusChange']\n     * })\n     * class TaskComponent {\n     *   status: EventEmitter;\n     *\n     *   constructor() {\n     *     this.status = new EventEmitter();\n     *   }\n     *\n     *   onComplete() {\n     *     this.status.next('completed');\n     *   }\n     * }\n     * ```",
        "* Specifiy the events, actions, properties and attributes related to the host element.\n     *\n     * ## Events\n     *\n     * Specifies which DOM hostListeners a directive listens to via a set of `(event)` to `method`\n     * key-value pairs:\n     *\n     * - `event1`: the DOM event that the directive listens to.\n     * - `statement`: the statement to execute when the event occurs.\n     * If the evalutation of the statement returns `false`, then `preventDefault`is applied on the DOM\n     * event.\n     *\n     * To listen to global events, a target must be added to the event name.\n     * The target can be `window`, `document` or `body`.\n     *\n     * When writing a directive event binding, you can also refer to the following local variables:\n     * - `$event`: Current event object which triggered the event.\n     * - `$target`: The source of the event. This will be either a DOM element or an Angular\n     * directive. (will be implemented in later release)\n     *\n     * ## Syntax\n     *\n     * ```\n     * @Directive({\n     *   host: {\n     *     '(event1)': 'onMethod1(arguments)',\n     *     '(target:event2)': 'onMethod2(arguments)',\n     *     ...\n     *   }\n     * }\n     * ```\n     *\n     * ## Basic Event Binding:\n     *\n     * Suppose you want to write a directive that reacts to `change` events in the DOM and on\n     * `resize` events in window.\n     * You would define the event binding as follows:\n     *\n     * ```\n     * @Directive({\n     *   selector: 'input',\n     *   host: {\n     *     '(change)': 'onChange($event)',\n     *     '(window:resize)': 'onResize($event)'\n     *   }\n     * })\n     * class InputDirective {\n     *   onChange(event:Event) {\n     *     // invoked when the input element fires the 'change' event\n     *   }\n     *   onResize(event:Event) {\n     *     // invoked when the window fires the 'resize' event\n     *   }\n     * }\n     * ```\n     *\n     * ## Properties\n     *\n     * Specifies which DOM properties a directives updates.\n     *\n     * ## Syntax\n     *\n     * ```\n     * @Directive({\n     *   selector: 'input',\n     *   host: {\n     *     '[prop]': 'expression'\n     *   }\n     * })\n     * class InputDirective {\n     *   value:string;\n     * }\n     * ```\n     *\n     * In this example the prop property of the host element is updated with the expression value\n     * every time it changes.\n     *\n     * ## Attributes\n     *\n     * Specifies static attributes that should be propagated to a host element. Attributes specified\n     * in `hostAttributes` are propagated only if a given attribute is not present on a host element.\n     *\n     * ## Syntax\n     *\n     * ```\n     * @Directive({\n     *   selector: '[my-button]',\n     *   host: {\n     *     'role': 'button'\n     *   }\n     * })\n     * class MyButton {\n     * }\n     * ```\n     *\n     * In this example using `my-button` directive (ex.: `<div my-button></div>`) on a host element\n     * (here: `<div>` ) will ensure that this element will get the \"button\" role.",
        "* Specifies which lifecycle should be notified to the directive.\n     *\n     * See {@link LifecycleEvent} for details.",
        "* If set to false the compiler does not compile the children of this directive.",
        "* Defines the set of injectable objects that are visible to a Directive and its light dom\n     * children.\n     *\n     * ## Simple Example\n     *\n     * Here is an example of a class that can be injected:\n     *\n     * ```\n     * class Greeter {\n     *    greet(name:string) {\n     *      return 'Hello ' + name + '!';\n     *    }\n     * }\n     *\n     * @Directive({\n     *   selector: 'greet',\n     *   bindings: [\n     *     Greeter\n     *   ]\n     * })\n     * class HelloWorld {\n     *   greeter:Greeter;\n     *\n     *   constructor(greeter:Greeter) {\n     *     this.greeter = greeter;\n     *   }\n     * }\n     * ```",
        "* Defines the name that can be used in the template to assign this directive to a variable.\n     *\n     * ## Simple Example\n     *\n     * ```\n     * @Directive({\n     *   selector: 'child-dir',\n     *   exportAs: 'child'\n     * })\n     * class ChildDir {\n     * }\n     *\n     * @Component({\n     *   selector: 'main',\n     * })\n     * @View({\n     *   template: `<child-dir #c=\"child\"></child-dir>`,\n     *   directives: [ChildDir]\n     * })\n     * class MainComponent {\n     * }\n     *\n     * ```",
        "* Declare reusable pipe function.\n   *\n   * ## Example\n   *\n   * ```\n   * @Pipe({\n   *   name: 'lowercase'\n   * })\n   * class Lowercase {\n   *   transform(v, args) { return v.toLowerCase(); }\n   * }\n   * ```",
        "* Lifecycle events are guaranteed to be called in the following order:\n   * - `OnChanges` (if any bindings have changed),\n   * - `OnInit` (after the first check only),\n   * - `DoCheck`,\n   * - `AfterContentChecked`\n   * - `AfterContentChecked`\n   * - `OnDestroy` (at the very end before destruction)",
        "* Notify a directive when it has been checked the first time.\n     *\n     * This method is called right after the directive's bindings have been checked,\n     * and before any of its children's bindings have been checked.\n     *\n     * It is invoked only once.\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   lifecycle: [LifecycleEvent.OnInit]\n     * })\n     * class ClassSet {\n     *   onInit() {\n     *   }\n     * }\n     *  ```",
        "* Notify a directive whenever a {@link ViewMetadata} that contains it is destroyed.\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   ...,\n     *   lifecycle: [LifecycleEvent.OnDestroy]\n     * })\n     * class ClassSet {\n     *   onDestroy() {\n     *     // invoked to notify directive of the containing view destruction.\n     *   }\n     * }\n     * ```",
        "* Notify a directive when any of its bindings have changed.\n     *\n     * This method is called right after the directive's bindings have been checked,\n     * and before any of its children's bindings have been checked.\n     *\n     * It is invoked only if at least one of the directive's bindings has changed.\n     *\n     * ## Example:\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   properties: [\n     *     'propA',\n     *     'propB'\n     *   ],\n     *   lifecycle: [LifecycleEvent.OnChanges]\n     * })\n     * class ClassSet {\n     *   propA;\n     *   propB;\n     *   onChanges(changes:{[idx: string, PropertyUpdate]}) {\n     *     // This will get called after any of the properties have been updated.\n     *     if (changes['propA']) {\n     *       // if propA was updated\n     *     }\n     *     if (changes['propA']) {\n     *       // if propB was updated\n     *     }\n     *   }\n     * }\n     *  ```",
        "* Notify a directive when it has been checked.\n     *\n     * This method is called right after the directive's bindings have been checked,\n     * and before any of its children's bindings have been checked.\n     *\n     * It is invoked every time even when none of the directive's bindings has changed.\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   lifecycle: [LifecycleEvent.DoCheck]\n     * })\n     * class ClassSet {\n     *   doCheck() {\n     *   }\n     * }\n     *  ```",
        "* Notify a directive when the bindings of all its content children have been checked the first\n     * time (whether they\n     * have changed or not).\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   lifecycle: [LifecycleEvent.AfterContentInit]\n     * })\n     * class ClassSet {\n     *\n     *   afterContentInit() {\n     *   }\n     *\n     * }\n     *  ```",
        "* Notify a directive when the bindings of all its content children have been checked (whether\n     * they\n     * have changed or not).\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   lifecycle: [LifecycleEvent.AfterContentChecked]\n     * })\n     * class ClassSet {\n     *\n     *   afterContentChecked() {\n     *   }\n     *\n     * }\n     *  ```",
        "* Notify a directive when the bindings of all its view children have been checked the first time\n     * (whether they\n     * have changed or not).\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   lifecycle: [LifecycleEvent.AfterViewInit]\n     * })\n     * class ClassSet {\n     *\n     *   afterViewInit() {\n     *   }\n     *\n     * }\n     *  ```",
        "* Notify a directive when the bindings of all its view children have been checked (whether they\n     * have changed or not).\n     *\n     * ## Example\n     *\n     * ```\n     * @Directive({\n     *   selector: '[class-set]',\n     *   lifecycle: [LifecycleEvent.AfterViewChecked]\n     * })\n     * class ClassSet {\n     *\n     *   afterViewChecked() {\n     *   }\n     *\n     * }\n     *  ```",
        "* Declares the available HTML templates for an application.\n   *\n   * Each angular component requires a single `@Component` and at least one `@View` annotation. The\n   * `@View` annotation specifies the HTML template to use, and lists the directives that are active\n   * within the template.\n   *\n   * When a component is instantiated, the template is loaded into the component's shadow root, and\n   * the expressions and statements in the template are evaluated against the component.\n   *\n   * For details on the `@Component` annotation, see {@link ComponentMetadata}.\n   *\n   * ## Example\n   *\n   * ```\n   * @Component({\n   *   selector: 'greet'\n   * })\n   * @View({\n   *   template: 'Hello {{name}}!',\n   *   directives: [GreetUser, Bold]\n   * })\n   * class Greet {\n   *   name: string;\n   *\n   *   constructor() {\n   *     this.name = 'World';\n   *   }\n   * }\n   * ```",
        "* Specifies a template URL for an angular component.\n     *\n     * NOTE: either `templateUrl` or `template` should be used, but not both.",
        "* Specifies an inline template for an angular component.\n     *\n     * NOTE: either `templateUrl` or `template` should be used, but not both.",
        "* Specifies stylesheet URLs for an angular component.",
        "* Specifies an inline stylesheet for an angular component.",
        "* Specifies a list of directives that can be used within a template.\n     *\n     * Directives must be listed explicitly to provide proper component encapsulation.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * @Component({\n     *     selector: 'my-component'\n     *   })\n     * @View({\n     *   directives: [For]\n     *   template: '\n     *   <ul>\n     *     <li *ng-for=\"#item of items\">{{item}}</li>\n     *   </ul>'\n     * })\n     * class MyComponent {\n     * }\n     * ```",
        "* Specify how the template and the styles should be encapsulated.\n     * The default is {@link ViewEncapsulation#Emulated `ViewEncapsulation.Emulated`} if the view\n     * has styles,\n     * otherwise {@link ViewEncapsulation#None `ViewEncapsulation.None`}.",
        "* How the template and styles of a view should be encapsulated.",
        "* Emulate scoping of styles by preprocessing the style rules\n     * and adding additional attributes to elements. This is the default.",
        "* Uses the native mechanism of the renderer. For the DOM this means creating a ShadowRoot.",
        "* Don't scope the template nor the styles.",
        "* Specifies that a {@link QueryList} should be injected.\n   *\n   * See {@link QueryList} for usage and example.",
        "* Specifies that a constant attribute value should be injected.\n   *\n   * The directive can inject constant string literals of host element attributes.\n   *\n   * ## Example\n   *\n   * Suppose we have an `<input>` element and want to know its `type`.\n   *\n   * ```html\n   * <input type=\"text\">\n   * ```\n   *\n   * A decorator can inject string literal `text` like so:\n   *\n   * ```javascript\n   * @Directive({\n   *   selector: `input'\n   * })\n   * class InputDirective {\n   *   constructor(@Attribute('type') type) {\n   *     // type would be `text` in this example\n   *   }\n   * }\n   * ```",
        "* {@link AttributeMetadata} factory function.",
        "* {@link AttributeMetadata} factory for creating annotations, decorators or DSL.\n   *\n   * ## Example as TypeScript Decorator\n   *\n   * ```\n   * import {Attribute, Component, View} from \"angular2/angular2\";\n   *\n   * @Component({...})\n   * @View({...})\n   * class MyComponent {\n   *   constructor(@Attribute('title') title: string) {\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Example as ES5 DSL\n   *\n   * ```\n   * var MyComponent = ng\n   *   .Component({...})\n   *   .View({...})\n   *   .Class({\n   *     constructor: [new ng.Attribute('title'), function(title) {\n   *       ...\n   *     }]\n   *   })\n   * ```\n   *\n   * ## Example as ES5 annotation\n   *\n   * ```\n   * var MyComponent = function(title) {\n   *   ...\n   * };\n   *\n   * MyComponent.annotations = [\n   *   new ng.Component({...}),\n   *   new ng.View({...})\n   * ]\n   * MyComponent.parameters = [\n   *   [new ng.Attribute('title')]\n   * ]\n   * ```",
        "* {@link ComponentMetadata} factory function.",
        "* Interface for the {@link ComponentMetadata} decorator function.\n   *\n   * See {@link ComponentFactory}.",
        "* Chain {@link ViewMetadata} annotation.",
        "* {@link ComponentAnnotation} factory for creating annotations, decorators or DSL.\n   *\n   * ## Example as TypeScript Decorator\n   *\n   * ```\n   * import {Component, View} from \"angular2/angular2\";\n   *\n   * @Component({...})\n   * @View({...})\n   * class MyComponent {\n   *   constructor() {\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Example as ES5 DSL\n   *\n   * ```\n   * var MyComponent = ng\n   *   .Component({...})\n   *   .View({...})\n   *   .Class({\n   *     constructor: function() {\n   *       ...\n   *     }\n   *   })\n   * ```\n   *\n   * ## Example as ES5 annotation\n   *\n   * ```\n   * var MyComponent = function() {\n   *   ...\n   * };\n   *\n   * MyComponent.annotations = [\n   *   new ng.Component({...}),\n   *   new ng.View({...})\n   * ]\n   * ```",
        "* {@link DirectiveMetadata} factory function.",
        "* Interface for the {@link DirectiveMetadata} decorator function.\n   *\n   * See {@link DirectiveFactory}.",
        "* {@link DirectiveMetadata} factory for creating annotations, decorators or DSL.\n   *\n   * ## Example as TypeScript Decorator\n   *\n   * ```\n   * import {Directive} from \"angular2/angular2\";\n   *\n   * @Directive({...})\n   * class MyDirective {\n   *   constructor() {\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Example as ES5 DSL\n   *\n   * ```\n   * var MyDirective = ng\n   *   .Directive({...})\n   *   .Class({\n   *     constructor: function() {\n   *       ...\n   *     }\n   *   })\n   * ```\n   *\n   * ## Example as ES5 annotation\n   *\n   * ```\n   * var MyDirective = function() {\n   *   ...\n   * };\n   *\n   * MyDirective.annotations = [\n   *   new ng.Directive({...})\n   * ]\n   * ```",
        "* {@link ViewMetadata} factory function.",
        "* Interface for the {@link ViewMetadata} decorator function.\n   *\n   * See {@link ViewFactory}.",
        "* Chain {@link ViewMetadata} annotation.",
        "* {@link ViewAnnotation} factory for creating annotations, decorators or DSL.\n   *\n   * ## Example as TypeScript Decorator\n   *\n   * ```\n   * import {Component, View} from \"angular2/angular2\";\n   *\n   * @Component({...})\n   * @View({...})\n   * class MyComponent {\n   *   constructor() {\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Example as ES5 DSL\n   *\n   * ```\n   * var MyComponent = ng\n   *   .Component({...})\n   *   .View({...})\n   *   .Class({\n   *     constructor: function() {\n   *       ...\n   *     }\n   *   })\n   * ```\n   *\n   * ## Example as ES5 annotation\n   *\n   * ```\n   * var MyComponent = function() {\n   *   ...\n   * };\n   *\n   * MyComponent.annotations = [\n   *   new ng.Component({...}),\n   *   new ng.View({...})\n   * ]\n   * ```",
        "* {@link QueryMetadata} factory function.",
        "* {@link QueryMetadata} factory for creating annotations, decorators or DSL.\n   *\n   * ## Example as TypeScript Decorator\n   *\n   * ```\n   * import {Query, QueryList, Component, View} from \"angular2/angular2\";\n   *\n   * @Component({...})\n   * @View({...})\n   * class MyComponent {\n   *   constructor(@Query(SomeType) queryList: QueryList) {\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Example as ES5 DSL\n   *\n   * ```\n   * var MyComponent = ng\n   *   .Component({...})\n   *   .View({...})\n   *   .Class({\n   *     constructor: [new ng.Query(SomeType), function(queryList) {\n   *       ...\n   *     }]\n   *   })\n   * ```\n   *\n   * ## Example as ES5 annotation\n   *\n   * ```\n   * var MyComponent = function(queryList) {\n   *   ...\n   * };\n   *\n   * MyComponent.annotations = [\n   *   new ng.Component({...}),\n   *   new ng.View({...})\n   * ]\n   * MyComponent.parameters = [\n   *   [new ng.Query(SomeType)]\n   * ]\n   * ```",
        "* {@link di/ViewQueryMetadata} factory function.",
        "* {@link PipeMetadata} factory function.",
        "* {@link PipeMetadata} factory for creating decorators.\n   *\n   * ## Example as TypeScript Decorator\n   *\n   * ```\n   * import {Pipe} from \"angular2/angular2\";\n   *\n   * @Pipe({...})\n   * class MyPipe {\n   *   constructor() {\n   *     ...\n   *   }\n   *\n   *   transform(v, args) {}\n   * }\n   * ```",
        "* Defines lifecycle method\n   * {@link metadata/LifeCycleEvent#AfterContentInit `LifeCycleEvent.afterContentInit`}\n   * called when the bindings of all its content children have been checked the first time.",
        "* Defines lifecycle method\n   * {@link metadata/LifeCycleEvent#AfterContentChecked `LifeCycleEvent.afterContentChecked`}\n   * called when the bindings of all its content children have been checked.",
        "* Defines lifecycle method\n   * {@link metadata/LifeCycleEvent#AfterViewInit `LifeCycleEvent.afterViewInit`}\n   * called when the bindings of all its view children have been checked the first time.",
        "* Defines lifecycle method\n   * {@link metadata/LifeCycleEvent#AfterViewChecked `LifeCycleEvent.afterViewChecked`}\n   * called when the bindings of all its view children have been checked.",
        "* Defines lifecycle method {@link metadata/LifeCycleEvent#OnChanges `LifeCycleEvent.OnChanges`}\n   * called after all of component's bound properties are updated.",
        "* Defines lifecycle method {@link metadata/LifeCycleEvent#OnDestroy `LifeCycleEvent.OnDestroy`}\n   * called when a directive is being destroyed.",
        "* Defines lifecycle method {@link metadata/LifeCycleEvent#OnInit `LifeCycleEvent.OnInit`}\n   * called when a directive is being checked the first time.",
        "* Defines lifecycle method {@link metadata/LifeCycleEvent#DoCheck `LifeCycleEvent.DoCheck`}\n   * called when a directive is being checked.",
        "* Provides a way for expressing ES6 classes with parameter annotations in ES5.\n   *\n   * ## Basic Example\n   *\n   * ```\n   * var Greeter = ng.Class({\n   *   constructor: function(name) {\n   *     this.name = name;\n   *   },\n   *\n   *   greet: function() {\n   *     alert('Hello ' + this.name + '!');\n   *   }\n   * });\n   * ```\n   *\n   * is equivalent to ES6:\n   *\n   * ```\n   * class Greeter {\n   *   constructor(name) {\n   *     this.name = name;\n   *   }\n   *\n   *   greet() {\n   *     alert('Hello ' + this.name + '!');\n   *   }\n   * }\n   * ```\n   *\n   * or equivalent to ES5:\n   *\n   * ```\n   * var Greeter = function (name) {\n   *   this.name = name;\n   * }\n   *\n   * Greeter.prototype.greet = function () {\n   *   alert('Hello ' + this.name + '!');\n   * }\n   * ```\n   *\n   * ## Example with parameter annotations\n   *\n   * ```\n   * var MyService = neg.Class({\n   *   constructor: [String, [new Query(), QueryList], function(name, queryList) {\n   *     ...\n   *   }];\n   * });\n   * ```\n   *\n   * is equivalent to ES6:\n   *\n   * ```\n   * class MyService {\n   *   constructor(name: string, @Query() queryList: QueryList) {\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Example with inheritance\n   *\n   * ```\n   * var Shape = ng.Class({\n   *   constructor: (color) {\n   *     this.color = color;\n   *   }\n   * });\n   *\n   * var Square = ng.Class({\n   *   extends: Shape,\n   *   constructor: function(color, size) {\n   *     Shape.call(this, color);\n   *     this.size = size;\n   *   }\n   * });\n   * ```",
        "* Declares the interface to be used with {@link Class}.",
        "* Optional argument for specifying the superclass.",
        "* Required constructor function for a class.\n     *\n     * The function may be optionally wrapped in an `Array`, in which case additional parameter\n     * annotations may be specified.\n     * The number of arguments and the number of parameter annotations must match.\n     *\n     * See {@link Class} for example of usage.",
        "* An interface implemented by all Angular type decorators, which allows them to be used as ES7\n   * decorators as well as\n   * Angular DSL syntax.\n   *\n   * DSL syntax:\n   *\n   * ```\n   * var MyClass = ng\n   *   .Component({...})\n   *   .View({...})\n   *   .Class({...});\n   * ```\n   *\n   * ES7 syntax:\n   *\n   * ```\n   * @ng.Component({...})\n   * @ng.View({...})\n   * class MyClass {...}\n   * ```",
        "* Invoke as ES7 decorator.",
        "* Storage for the accumulated annotations so far used by the DSL syntax.\n     *\n     * Used by {@link Class} to annotate the generated class.",
        "* Generate a class from the definition and annotate it with {@link TypeDecorator#annotations}.",
        "* `CheckedOnce` means that after calling detectChanges the mode of the change detector\n     * will become `Checked`.",
        "* `Checked` means that the change detector should be skipped until its mode changes to\n     * `CheckOnce`.",
        "* `CheckAlways` means that after calling detectChanges the mode of the change detector\n     * will remain `CheckAlways`.",
        "* `Detached` means that the change detector sub tree is not a part of the main tree and\n     * should be skipped.",
        "* `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.",
        "* `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.",
        "* This is an experimental feature. Works only in Dart.",
        "* An error thrown if application changes model breaking the top-down data flow.\n   *\n   * Angular expects that the data flows from top (root) component to child (leaf) components.\n   * This is known as directed acyclic graph. This allows Angular to only execute change detection\n   * once and prevents loops in change detection data flow.\n   *\n   * This exception is only thrown in dev mode.",
        "* Thrown when an expression evaluation raises an exception.\n   *\n   * This error wraps the original exception, this is done to attach expression location information.",
        "* Location of the expression.",
        "* Controls change detection.\n   *\n   * {@link ChangeDetectorRef} allows requesting checks for detectors that rely on observables. It\n   * also allows detaching and attaching change detector subtrees.",
        "* Request to check all OnPush ancestors.",
        "* Detaches the change detector from the change detector tree.\n     *\n     * The detached change detector will not be checked until it is reattached.",
        "* Reattach the change detector to the change detector tree.\n     *\n     * This also requests a check of this change detector. This reattached change detector will be\n     * checked during the next change detection run.",
        "* Indicates that the result of a {@link PipeMetadata} transformation has changed even though the\n   * reference\n   * has not changed.\n   *\n   * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.\n   *\n   * Example:\n   *\n   * ```\n   * if (this._latestValue === this._latestReturnedValue) {\n   *    return this._latestReturnedValue;\n   *  } else {\n   *    this._latestReturnedValue = this._latestValue;\n   *    return WrappedValue.wrap(this._latestValue); // this will force update\n   *  }\n   * ```",
        "* An interface which all pipes must implement.\n   *\n   * #Example\n   *\n   * ```\n   * class DoublePipe implements PipeTransform {\n   *  transform(value, args = []) {\n   *    return `${value}${value}`;\n   *  }\n   * }\n   * ```",
        "* An interface that stateful pipes should implement.\n   *\n   * #Example\n   *\n   * ```\n   * class StatefulPipe implements PipeTransform, PipeOnDestroy {\n   *  connection;\n   *\n   *  onDestroy() {\n   *    this.connection.release();\n   *  }\n   *\n   *  transform(value, args = []) {\n   *    this.connection = createConnection();\n   *    // ...\n   *    return someValue;\n   *  }\n   * }\n   * ```",
        "* A repository of different iterable diffing strategies used by NgFor, NgClass, and others.",
        "* Takes an array of {@link IterableDifferFactory} and returns a binding used to extend the\n     * inherited {@link IterableDiffers} instance with the provided factories and return a new\n     * {@link IterableDiffers} instance.\n     *\n     * The following example shows how to extend an existing list of factories,\n     * which will only be applied to the injector for this component and its children.\n     * This step is all that's required to make a new {@link IterableDiffer} available.\n     *\n     * # Example\n     *\n     * ```\n     * @Component({\n     *   viewBindings: [\n     *     IterableDiffers.extend([new ImmutableListDiffer()])\n     *   ]\n     * })\n     * ```",
        "* Provides a factory for {@link IterableDiffer}.",
        "* A repository of different Map diffing strategies used by NgClass, NgStyle, and others.",
        "* Takes an array of {@link KeyValueDifferFactory} and returns a binding used to extend the\n     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\n     * {@link KeyValueDiffers} instance.\n     *\n     * The following example shows how to extend an existing list of factories,\n     * which will only be applied to the injector for this component and its children.\n     * This step is all that's required to make a new {@link KeyValueDiffer} available.\n     *\n     * # Example\n     *\n     * ```\n     * @Component({\n     *   viewBindings: [\n     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\n     *   ]\n     * })\n     * ```",
        "* Provides a factory for {@link KeyValueDiffer}.",
        "* An opaque token representing the application root type in the {@link Injector}.\n   *\n   * ```\n   * @Component(...)\n   * @View(...)\n   * class MyApp {\n   *   ...\n   * }\n   *\n   * bootstrap(MyApp).then((appRef:ApplicationRef) {\n   *   expect(appRef.injector.get(appComponentTypeToken)).toEqual(MyApp);\n   * });\n   *\n   * ```",
        "* Runtime representation of a type.\n   *\n   * In JavaScript a Type is a constructor function.",
        "* Represents a Angular's representation of an Application.\n   *\n   * `ApplicationRef` represents a running application instance. Use it to retrieve the host\n   * component, injector,\n   * or dispose of an application.",
        "* Returns the current {@link ComponentMetadata} type.",
        "* Returns the current {@link ComponentMetadata} instance.",
        "* Dispose (un-load) the application.",
        "* Returns the root application {@link Injector}.",
        "* Specifies app root url for the application.\n   *\n   * Used by the {@link Compiler} when resolving HTML and CSS template URLs.\n   *\n   * This interface can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}",
        "* Returns the base URL of the currently running application.",
        "* Used by the {@link Compiler} when resolving HTML and CSS template URLs.\n   *\n   * This interface can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}",
        "* Resolves the `url` given the `baseUrl`:\n     * - when the `url` is null, the `baseUrl` is returned,\n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n     * `baseUrl` and `url`,\n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n     * returned as is (ignoring the `baseUrl`)\n     *\n     * @param {string} baseUrl\n     * @param {string} url\n     * @returns {string} the resolved URL",
        "* Resolve a `Type` from a {@link ComponentMetadata} into a URL.\n   *\n   * This interface can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}",
        "* Returns the base URL to the component source file.\n     * The returned URL could be:\n     * - an absolute URL,\n     * - a path relative to the application",
        "* Resolve a `Type` for {@link DirectiveMetadata}.\n   *\n   * This interface can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}",
        "* Return {@link DirectiveMetadata} for a given `Type`.",
        "* ## URL Resolution\n   *\n   * ```\n   * var appRootUrl: AppRootUrl = ...;\n   * var componentUrlMapper: ComponentUrlMapper = ...;\n   * var urlResolver: UrlResolver = ...;\n   *\n   * var componentType: Type = ...;\n   * var componentAnnotation: ComponentAnnotation = ...;\n   * var viewAnnotation: ViewAnnotation = ...;\n   *\n   * // Resolving a URL\n   *\n   * var url = viewAnnotation.templateUrl;\n   * var componentUrl = componentUrlMapper.getUrl(componentType);\n   * var componentResolvedUrl = urlResolver.resolve(appRootUrl.value, componentUrl);\n   * var templateResolvedUrl = urlResolver.resolve(componetResolvedUrl, url);\n   * ```",
        "* Entry point for creating, moving views in the view hierarchy and destroying views.\n   * This manager contains all recursion and delegates to helper methods\n   * in AppViewManagerUtils and the Renderer, so unit tests get simpler.",
        "* Returns a {@link ViewContainerRef} at the {@link ElementRef} location.",
        "* Return the first child element of the host element view.",
        "* Returns an ElementRef for the element with the given variable name\n     * in the current view.\n     *\n     * - `hostLocation`: {@link ElementRef} of any element in the View which defines the scope of\n     *   search.\n     * - `variableName`: Name of the variable to locate.\n     * - Returns {@link ElementRef} of the found element or null. (Throws if not found.)",
        "* Returns the component instance for a given element.\n     *\n     * The component is the execution context as seen by an expression at that {@link ElementRef}\n     * location.",
        "* Load component view into existing element.\n     *\n     * Use this if a host element is already in the DOM and it is necessary to upgrade\n     * the element into Angular component by attaching a view but reusing the existing element.\n     *\n     * - `hostProtoViewRef`: {@link ProtoViewRef} Proto view to use in creating a view for this\n     *   component.\n     * - `overrideSelector`: (optional) selector to use in locating the existing element to load\n     *   the view into. If not specified use the selector in the component definition of the\n     *   `hostProtoView`.\n     * - injector: {@link Injector} to use as parent injector for the view.\n     *\n     * See {@link AppViewManager#destroyRootHostView}.\n     *\n     * ## Example\n     *\n     * ```\n     * @ng.Component({\n     *   selector: 'child-component'\n     * })\n     * @ng.View({\n     *   template: 'Child'\n     * })\n     * class ChildComponent {\n     *\n     * }\n     *\n     * @ng.Component({\n     *   selector: 'my-app'\n     * })\n     * @ng.View({\n     *   template: `\n     *     Parent (<some-component></some-component>)\n     *   `\n     * })\n     * class MyApp {\n     *   viewRef: ng.ViewRef;\n     *\n     *   constructor(public appViewManager: ng.AppViewManager, compiler: ng.Compiler) {\n     *     compiler.compileInHost(ChildComponent).then((protoView: ng.ProtoViewRef) => {\n     *       this.viewRef = appViewManager.createRootHostView(protoView, 'some-component', null);\n     *     })\n     *   }\n     *\n     *   onDestroy() {\n     *     this.appViewManager.destroyRootHostView(this.viewRef);\n     *     this.viewRef = null;\n     *   }\n     * }\n     *\n     * ng.bootstrap(MyApp);\n     * ```",
        "* Remove the View created with {@link AppViewManager#createRootHostView}.",
        "* See {@link AppViewManager#destroyViewInContainer}.",
        "* See {@link AppViewManager#destroyViewInContainer}.",
        "* See {@link AppViewManager#createViewInContainer}.",
        "* See {@link AppViewManager#detachViewInContainer}.",
        "* See {@link AppViewManager#attachViewInContainer}.",
        "* An iterable and observable live list of components in the DOM.\n   *\n   * A QueryList contains a live list of child directives in the DOM of a directive.\n   * The directives are kept in depth-first pre-order traversal of the DOM.\n   *\n   * The `QueryList` is iterable, therefore it can be used in both javascript code with `for..of` loop\n   * as well as in template with `*ng-for=\"of\"` directive.\n   *\n   * QueryList is updated as part of the change-detection cycle of a directive. Since change detection\n   * happens after construction of a directive, QueryList will always be empty when observed in the\n   * constructor.\n   *\n   *\n   * NOTE: In the future this class will implement an `Observable` interface. For now it uses a plain\n   * list of observable callbacks.\n   *\n   * # Example:\n   *\n   * Assume that `<tabs>` component would like to get a list its children which are `<pane>`\n   * components as shown in this example:\n   *\n   * ```html\n   * <tabs>\n   *   <pane title=\"Overview\">...</pane>\n   *   <pane *ng-for=\"#o of objects\" [title]=\"o.title\">{{o.text}}</pane>\n   * </tabs>\n   * ```\n   *\n   * In the above example the list of `<tabs>` elements needs to get a list of `<pane>` elements so\n   * that it could render tabs with the correct titles and in the correct order.\n   *\n   * A possible solution would be for a `<pane>` to inject `<tabs>` component and then register itself\n   * with `<tabs>` component's on `hydrate` and deregister on `dehydrate` event. While a reasonable\n   * approach, this would only work partialy since `*ng-for` could rearrange the list of `<pane>`\n   * components which would not be reported to `<tabs>` component and thus the list of `<pane>`\n   * components would be out of sync with respect to the list of `<pane>` elements.\n   *\n   * A preferred solution is to inject a `QueryList` which is a live list of directives in the\n   * component`s light DOM.\n   *\n   * ```javascript\n   * @Component({\n   *   selector: 'tabs'\n   * })\n   * @View({\n   *  template: `\n   *    <ul>\n   *      <li *ng-for=\"#pane of panes\">{{pane.title}}</li>\n   *    </ul>\n   *    <content></content>\n   *  `\n   * })\n   * class Tabs {\n   *   panes: QueryList<Pane>\n   *\n   *   constructor(@Query(Pane) panes:QueryList<Pane>) {\n   *     this.panes = panes;\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'pane',\n   *   properties: ['title']\n   * })\n   * @View(...)\n   * class Pane {\n   *   title:string;\n   * }\n   * ```",
        "* Service for dynamically loading a Component into an arbitrary position in the internal Angular\n   * application tree.",
        "* Loads a root component that is placed at the first element that matches the component's\n     * selector.\n     *\n     * - `typeOrBinding` `Type` \\ {@link Binding} - representing the component to load.\n     * - `overrideSelector` (optional) selector to load the component at (or use\n     *   `@Component.selector`) The selector can be anywhere (i.e. outside the current component.)\n     * - `injector` {@link Injector} - optional injector to use for the component.\n     *\n     * The loaded component receives injection normally as a hosted view.\n     *\n     *\n     * ## Example\n     *\n     * ```\n     * @ng.Component({\n     *   selector: 'child-component'\n     * })\n     * @ng.View({\n     *   template: 'Child'\n     * })\n     * class ChildComponent {\n     * }\n     *\n     *\n     *\n     * @ng.Component({\n     *   selector: 'my-app'\n     * })\n     * @ng.View({\n     *   template: `\n     *     Parent (<child id=\"child\"></child>)\n     *   `\n     * })\n     * class MyApp {\n     *   constructor(dynamicComponentLoader: ng.DynamicComponentLoader, injector: ng.Injector) {\n     *     dynamicComponentLoader.loadAsRoot(ChildComponent, '#child', injector);\n     *   }\n     * }\n     *\n     * ng.bootstrap(MyApp);\n     * ```\n     *\n     * Resulting DOM:\n     *\n     * ```\n     * <my-app>\n     *   Parent (\n     *     <child id=\"child\">\n     *        Child\n     *     </child>\n     *   )\n     * </my-app>\n     * ```",
        "* Loads a component into the component view of the provided ElementRef next to the element\n     * with the given name.\n     *\n     * The loaded component receives injection normally as a hosted view.\n     *\n     * ## Example\n     *\n     * ```\n     * @ng.Component({\n     *   selector: 'child-component'\n     * })\n     * @ng.View({\n     *   template: 'Child'\n     * })\n     * class ChildComponent {\n     * }\n     *\n     *\n     * @ng.Component({\n     *   selector: 'my-app'\n     * })\n     * @ng.View({\n     *   template: `\n     *     Parent (<div #child></div>)\n     *   `\n     * })\n     * class MyApp {\n     *   constructor(dynamicComponentLoader: ng.DynamicComponentLoader, elementRef: ng.ElementRef) {\n     *     dynamicComponentLoader.loadIntoLocation(ChildComponent, elementRef, 'child');\n     *   }\n     * }\n     *\n     * ng.bootstrap(MyApp);\n     * ```\n     *\n     * Resulting DOM:\n     *\n     * ```\n     * <my-app>\n     *    Parent (\n     *      <div #child=\"\" class=\"ng-binding\"></div>\n     *      <child-component class=\"ng-binding\">Child</child-component>\n     *    )\n     * </my-app>\n     * ```",
        "* Loads a component next to the provided ElementRef.\n     *\n     * The loaded component receives injection normally as a hosted view.\n     *\n     *\n     * ## Example\n     *\n     * ```\n     * @ng.Component({\n     *   selector: 'child-component'\n     * })\n     * @ng.View({\n     *   template: 'Child'\n     * })\n     * class ChildComponent {\n     * }\n     *\n     *\n     * @ng.Component({\n     *   selector: 'my-app'\n     * })\n     * @ng.View({\n     *   template: `Parent`\n     * })\n     * class MyApp {\n     *   constructor(dynamicComponentLoader: ng.DynamicComponentLoader, elementRef: ng.ElementRef) {\n     *     dynamicComponentLoader.loadIntoLocation(ChildComponent, elementRef, 'child');\n     *   }\n     * }\n     *\n     * ng.bootstrap(MyApp);\n     * ```\n     *\n     * Resulting DOM:\n     *\n     * ```\n     * <my-app>Parent</my-app>\n     * <child-component>Child</child-component>\n     * ```",
        "* Provides access to explicitly trigger change detection in an application.\n   *\n   * By default, `Zone` triggers change detection in Angular on each virtual machine (VM) turn. When\n   * testing, or in some\n   * limited application use cases, a developer can also trigger change detection with the\n   * `lifecycle.tick()` method.\n   *\n   * Each Angular application has a single `LifeCycle` instance.\n   *\n   * # Example\n   *\n   * This is a contrived example, since the bootstrap automatically runs inside of the `Zone`, which\n   * invokes\n   * `lifecycle.tick()` on your behalf.\n   *\n   * ```javascript\n   * bootstrap(MyApp).then((ref:ComponentRef) => {\n   *   var lifeCycle = ref.injector.get(LifeCycle);\n   *   var myApp = ref.instance;\n   *\n   *   ref.doSomething();\n   *   lifecycle.tick();\n   * });\n   * ```",
        "* @private",
        "* Invoke this method to explicitly process change detection and its side-effects.\n     *\n     *  In development mode, `tick()` also performs a second change detection cycle to ensure that no\n     * further\n     *  changes are detected. If additional changes are picked up during this second cycle, bindings\n     * in\n     * the app have\n     *  side-effects that cannot be resolved in a single change detection pass. In this case, Angular\n     * throws an error,\n     *  since an Angular application can only have one change detection pass during which all change\n     * detection must\n     *  complete.",
        "* Reference to the element.\n   *\n   * Represents an opaque reference to the underlying element. The element is a DOM ELement in\n   * a Browser, but may represent other types on other rendering platforms. In the browser the\n   * `ElementRef` can be sent to the web-worker. Web Workers can not have references to the\n   * DOM Elements.",
        "* Reference to the {@link ViewRef} where the `ElementRef` is inside of.",
        "* Index of the element inside the {@link ViewRef}.\n     *\n     * This is used internally by the Angular framework to locate elements.",
        "* Index of the element inside the `RenderViewRef`.\n     *\n     * This is used internally by the Angular framework to locate elements.",
        "* Returns the native Element implementation.\n     *\n     * In the browser this represents the DOM Element.\n     *\n     * The `nativeElement` can be used as an escape hatch when direct DOM manipulation is needed. Use\n     * this with caution, as it creates tight coupling between your application and the Browser, which\n     * will not work in WebWorkers.\n     *\n     * NOTE: This method will return null in the webworker scenario!",
        "* Reference to a template within a component.\n   *\n   * Represents an opaque reference to the underlying template that can\n   * be instantiated using the {@link ViewContainerRef}.",
        "* The location of the template",
        "* Whether this template has a local variable with the given name",
        "* A reference to an Angular View.\n   *\n   * A View is a fundamental building block of Application UI. A View is the smallest set of\n   * elements which are created and destroyed together. A View can change properties on the elements\n   * within the view, but it can not change the structure of those elements.\n   *\n   * To change structure of the elements, the Views can contain zero or more {@link ViewContainerRef}s\n   * which allow the views to be nested.\n   *\n   * ## Example\n   *\n   * Given this template\n   *\n   * ```\n   * Count: {{items.length}}\n   * <ul>\n   *   <li *ng-for=\"var item of items\">{{item}}</li>\n   * </ul>\n   * ```\n   *\n   * The above example we have two {@link ProtoViewRef}s:\n   *\n   * Outter {@link ProtoViewRef}:\n   * ```\n   * Count: {{items.length}}\n   * <ul>\n   *   <template ng-for var-item [ng-for-of]=\"items\"></template>\n   * </ul>\n   * ```\n   *\n   * Inner {@link ProtoViewRef}:\n   * ```\n   *   <li>{{item}}</li>\n   * ```\n   *\n   * Notice that the original template is broken down into two separate {@link ProtoViewRef}s.\n   *\n   * The outter/inner {@link ProtoViewRef}s are then assembled into views like so:\n   *\n   * ```\n   * <!-- ViewRef: outer-0 -->\n   * Count: 2\n   * <ul>\n   *   <template view-container-ref></template>\n   *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->\n   *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->\n   * </ul>\n   * <!-- /ViewRef: outer-0 -->\n   * ```",
        "* Return `RenderViewRef`",
        "* Return `RenderFragmentRef`",
        "* Set local variable in a view.\n     *\n     * - `contextName` - Name of the local variable in a view.\n     * - `value` - Value for the local variable in a view.",
        "* A reference to an Angular ProtoView.\n   *\n   * A ProtoView is a reference to a template for easy creation of views.\n   * (See {@link AppViewManager#createViewInContainer `AppViewManager#createViewInContainer`} and\n   * {@link AppViewManager#createRootHostView `AppViewManager#createRootHostView`}).\n   *\n   * A `ProtoView` is a factory for creating `View`s.\n   *\n   * ## Example\n   *\n   * Given this template\n   *\n   * ```\n   * Count: {{items.length}}\n   * <ul>\n   *   <li *ng-for=\"var item of items\">{{item}}</li>\n   * </ul>\n   * ```\n   *\n   * The above example we have two {@link ProtoViewRef}s:\n   *\n   * Outter {@link ProtoViewRef}:\n   * ```\n   * Count: {{items.length}}\n   * <ul>\n   *   <template ng-for var-item [ng-for-of]=\"items\"></template>\n   * </ul>\n   * ```\n   *\n   * Inner {@link ProtoViewRef}:\n   * ```\n   *   <li>{{item}}</li>\n   * ```\n   *\n   * Notice that the original template is broken down into two separate {@link ProtoViewRef}s.",
        "* A location where {@link ViewRef}s can be attached.\n   *\n   * A `ViewContainerRef` represents a location in a {@link ViewRef} where other child\n   * {@link ViewRef}s can be inserted. Adding and removing views is the only way of structurally\n   * changing the rendered DOM of the application.",
        "* Remove all {@link ViewRef}s at current location.",
        "* Return a {@link ViewRef} at specific index.",
        "* Returns number of {@link ViewRef}s currently attached at this location.",
        "* Create and insert a {@link ViewRef} into the view-container.\n     *\n     * - `protoViewRef` (optional) {@link ProtoViewRef} - The `ProtoView` to use for creating\n     *   `View` to be inserted at this location. If `ViewContainer` is created at a location\n     *   of inline template, then `protoViewRef` is the `ProtoView` of the template.\n     * - `atIndex` (optional) `number` - location of insertion point. (Or at the end if unspecified.)\n     * - `context` (optional) {@link ElementRef} - Context (for expression evaluation) from the\n     *   {@link ElementRef} location. (Or current context if unspecified.)\n     * - `bindings` (optional) Array of {@link ResolvedBinding} - Used for configuring\n     *   `ElementInjector`.\n     *\n     * Returns newly created {@link ViewRef}.",
        "* Insert a {@link ViewRef} at specefic index.\n     *\n     * The index is location at which the {@link ViewRef} should be attached. If omitted it is\n     * inserted at the end.\n     *\n     * Returns the inserted {@link ViewRef}.",
        "* Return the index of already inserted {@link ViewRef}.",
        "* Remove a {@link ViewRef} at specific index.\n     *\n     * If the index is omitted last {@link ViewRef} is removed.",
        "* The method can be used together with insert to implement a view move, i.e.\n     * moving the dom nodes while the directives in the view stay intact.",
        "* Angular's reference to a component instance.\n   *\n   * `ComponentRef` represents a component instance lifecycle and meta information.",
        "* Location of the component host element.",
        "* Instance of component.",
        "* Returns the host {@link ViewRef}.",
        "* Dispose of the component instance.",
        "* A wrapper around zones that lets you schedule tasks after it has executed a task.\n   *\n   * The wrapper maintains an \"inner\" and an \"mount\" `Zone`. The application code will executes\n   * in the \"inner\" zone unless `runOutsideAngular` is explicitely called.\n   *\n   * A typical application will create a singleton `NgZone`. The outer `Zone` is a fork of the root\n   * `Zone`. The default `onTurnDone` runs the Angular change detection.",
        "* Sets the zone hook that is called just before Angular event turn starts.\n     * It is called once per browser event.",
        "* Sets the zone hook that is called immediately after Angular processes\n     * all pending microtasks.",
        "* Sets the zone hook that is called immediately after the last turn in\n     * an event completes. At this point Angular will no longer attempt to\n     * sync the UI. Any changes to the data model will not be reflected in the\n     * DOM. `onEventDoneFn` is executed outside Angular zone.\n     *\n     * This hook is useful for validating application state (e.g. in a test).",
        "* Sets the zone hook that is called when an error is uncaught in the\n     * Angular zone. The first argument is the error. The second argument is\n     * the stack trace.",
        "* Runs `fn` in the inner zone and returns whatever it returns.\n     *\n     * In a typical app where the inner zone is the Angular zone, this allows one to make use of the\n     * Angular's auto digest mechanism.\n     *\n     * ```\n     * var zone: NgZone = [ref to the application zone];\n     *\n     * zone.run(() => {\n     *   // the change detection will run after this function and the microtasks it enqueues have\n     * executed.\n     * });\n     * ```",
        "* Runs `fn` in the outer zone and returns whatever it returns.\n     *\n     * In a typical app where the inner zone is the Angular zone, this allows one to escape Angular's\n     * auto-digest mechanism.\n     *\n     * ```\n     * var zone: NgZone = [ref to the application zone];\n     *\n     * zone.runOutsideAngular(() => {\n     *   element.onClick(() => {\n     *     // Clicking on the element would not trigger the change detection\n     *   });\n     * });\n     * ```",
        "* Use Rx.Observable but provides an adapter to make it work as specified here:\n   * https://github.com/jhusain/observable-spec\n   *\n   * Once a reference implementation of the spec is available, switch to it.",
        "* A parameter metadata that specifies a dependency.\n   *\n   * ```\n   * class AComponent {\n   *   constructor(@Inject(MyService) aService:MyService) {}\n   * }\n   * ```",
        "* A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if\n   * the dependency is not found.\n   *\n   * ```\n   * class AComponent {\n   *   constructor(@Optional() aService:MyService) {\n   *     this.aService = aService;\n   *   }\n   * }\n   * ```",
        "* A marker metadata that marks a class as available to `Injector` for creation. Used by tooling\n   * for generating constructor stubs.\n   *\n   * ```\n   * class NeedsService {\n   *   constructor(svc:UsefulService) {}\n   * }\n   *\n   * @Injectable\n   * class UsefulService {}\n   * ```",
        "* Specifies that an injector should retrieve a dependency from itself.\n   *\n   * ## Example\n   *\n   * ```\n   * class Dependency {\n   * }\n   *\n   * class NeedsDependency {\n   *   constructor(public @Self() dependency:Dependency) {}\n   * }\n   *\n   * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);\n   * var nd = inj.get(NeedsDependency);\n   * expect(nd.dependency).toBeAnInstanceOf(Dependency);\n   * ```",
        "* Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * closest host.\n   *\n   * ## Example\n   *\n   * ```\n   * class Dependency {\n   * }\n   *\n   * class NeedsDependency {\n   *   constructor(public @Host() dependency:Dependency) {}\n   * }\n   *\n   * var parent = Injector.resolveAndCreate([\n   *   bind(Dependency).toClass(HostDependency)\n   * ]);\n   * var child = parent.resolveAndCreateChild([]);\n   * var grandChild = child.resolveAndCreateChild([NeedsDependency, Depedency]);\n   * var nd = grandChild.get(NeedsDependency);\n   * expect(nd.dependency).toBeAnInstanceOf(HostDependency);\n   * ```",
        "* Specifies that the dependency resolution should start from the parent injector.\n   *\n   * ## Example\n   *\n   *\n   * ```\n   * class Service {}\n   *\n   * class ParentService implements Service {\n   * }\n   *\n   * class ChildService implements Service {\n   *   constructor(public @SkipSelf() parentService:Service) {}\n   * }\n   *\n   * var parent = Injector.resolveAndCreate([\n   *   bind(Service).toClass(ParentService)\n   * ]);\n   * var child = parent.resolveAndCreateChild([\n   *   bind(Service).toClass(ChildSerice)\n   * ]);\n   * var s = child.get(Service);\n   * expect(s).toBeAnInstanceOf(ChildService);\n   * expect(s.parentService).toBeAnInstanceOf(ParentService);\n   * ```",
        "* `DependencyMetadata is used by the framework to extend DI.\n   *\n   * Only metadata implementing `DependencyMetadata` are added to the list of dependency\n   * properties.\n   *\n   * For example:\n   *\n   * ```\n   * class Exclude extends DependencyMetadata {}\n   * class NotDependencyProperty {}\n   *\n   * class AComponent {\n   *   constructor(@Exclude @NotDependencyProperty aService:AService) {}\n   * }\n   * ```\n   *\n   * will create the following dependency:\n   *\n   * ```\n   * new Dependency(Key.get(AService), [new Exclude()])\n   * ```\n   *\n   * The framework can use `new Exclude()` to handle the `aService` dependency\n   * in a specific way.",
        "* Allows to refer to references which are not yet defined.\n   *\n   * This situation arises when the key which we need te refer to for the purposes of DI is declared,\n   * but not yet defined.\n   *\n   * ## Example:\n   *\n   * ```\n   * class Door {\n   *   // Incorrect way to refer to a reference which is defined later.\n   *   // This fails because `Lock` is undefined at this point.\n   *   constructor(lock:Lock) { }\n   *\n   *   // Correct way to refer to a reference which is defined later.\n   *   // The reference needs to be captured in a closure.\n   *   constructor(@Inject(forwardRef(() => Lock)) lock:Lock) { }\n   * }\n   *\n   * // Only at this point the lock is defined.\n   * class Lock {\n   * }\n   * ```",
        "* Lazily retrieve the reference value.\n   *\n   * See: {@link forwardRef}",
        "* A dependency injection container used for resolving dependencies.\n   *\n   * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n   * constructor dependencies.\n   * In typical use, application code asks for the dependencies in the constructor and they are\n   * resolved by the `Injector`.\n   *\n   * ## Example:\n   *\n   * Suppose that we want to inject an `Engine` into class `Car`, we would define it like this:\n   *\n   * ```javascript\n   * class Engine {\n   * }\n   *\n   * class Car {\n   *   constructor(@Inject(Engine) engine) {\n   *   }\n   * }\n   *\n   * ```\n   *\n   * Next we need to write the code that creates and instantiates the `Injector`. We then ask for the\n   * `root` object, `Car`, so that the `Injector` can recursively build all of that object's\n   * dependencies.\n   *\n   * ```javascript\n   * main() {\n   *   var injector = Injector.resolveAndCreate([Car, Engine]);\n   *\n   *   // Get a reference to the `root` object, which will recursively instantiate the tree.\n   *   var car = injector.get(Car);\n   * }\n   * ```\n   * Notice that we don't use the `new` operator because we explicitly want to have the `Injector`\n   * resolve all of the object's dependencies automatically.",
        "* Turns a list of binding definitions into an internal resolved list of resolved bindings.\n     *\n     * A resolution is a process of flattening multiple nested lists and converting individual\n     * bindings into a list of {@link ResolvedBinding}s. The resolution can be cached by `resolve`\n     * for the {@link Injector} for performance-sensitive code.\n     *\n     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a\n     * recursive list of more bindings.\n     *\n     * The returned list is sparse, indexed by `id` for the {@link Key}. It is generally not useful to\n     * application code\n     * other than for passing it to {@link Injector} functions that require resolved binding lists,\n     * such as\n     * `fromResolvedBindings` and `createChildFromResolved`.",
        "* Resolves bindings and creates an injector based on those bindings. This function is slower than\n     * the corresponding `fromResolvedBindings` because it needs to resolve bindings first. See\n     * `resolve`\n     * for the {@link Injector}.\n     *\n     * Prefer `fromResolvedBindings` in performance-critical code that creates lots of injectors.\n     *\n     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a\n     * recursive list of more\n     * bindings.\n     * @param `depProvider`",
        "* Creates an injector from previously resolved bindings. This bypasses resolution and flattening.\n     * This API is the recommended way to construct injectors in performance-sensitive parts.\n     *\n     * @param `bindings` A sparse list of {@link ResolvedBinding}s. See `resolve` for the\n     * {@link Injector}.\n     * @param `depProvider`",
        "* Returns debug information about the injector.\n     *\n     * This information is included into exceptions thrown by the injector.",
        "* Retrieves an instance from the injector.\n     *\n     * @param `token`: usually the `Type` of an object. (Same as the token used while setting up a\n     * binding).\n     * @returns an instance represented by the token. Throws if not found.",
        "* Retrieves an instance from the injector.\n     *\n     * @param `token`: usually a `Type`. (Same as the token used while setting up a binding).\n     * @returns an instance represented by the token. Returns `null` if not found.",
        "* Retrieves an instance from the injector.\n     *\n     * @param `index`: index of an instance.\n     * @returns an instance represented by the index. Throws if not found.",
        "* Direct parent of this injector.",
        "* Internal. Do not use.\n     *\n     * We return `any` not to export the InjectorStrategy type.",
        "* Creates a child injector and loads a new set of bindings into it.\n     *\n     * A resolution is a process of flattening multiple nested lists and converting individual\n     * bindings into a list of {@link ResolvedBinding}s. The resolution can be cached by `resolve`\n     * for the {@link Injector} for performance-sensitive code.\n     *\n     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a\n     * recursive list of more bindings.\n     * @param `depProvider`",
        "* Creates a child injector and loads a new set of {@link ResolvedBinding}s into it.\n     *\n     * @param `bindings`: A sparse list of {@link ResolvedBinding}s.\n     * See `resolve` for the {@link Injector}.\n     * @param `depProvider`\n     * @returns a new child {@link Injector}.",
        "* Resolves a binding and instantiates an object in the context of the injector.\n     *\n     * @param `binding`: either a type or a binding.\n     * @returns an object created using binding.",
        "* Instantiates an object using a resolved bindin in the context of the injector.\n     *\n     * @param `binding`: a resolved binding\n     * @returns an object created using binding.",
        "* Used to provide dependencies that cannot be easily expressed as bindings.",
        "* Describes how_ the {@link Injector} should instantiate a given token.\n   *\n   * See {@link bind}.\n   *\n   * ## Example\n   *\n   * ```javascript\n   * var injector = Injector.resolveAndCreate([\n   *   new Binding(String, { toValue: 'Hello' })\n   * ]);\n   *\n   * expect(injector.get(String)).toEqual('Hello');\n   * ```",
        "* Token used when retrieving this binding. Usually the `Type`.",
        "* Binds an interface to an implementation / subclass.\n     *\n     * ## Example\n     *\n     * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy\n     * comparison.\n     *\n     * ```javascript\n     *\n     * class Vehicle {}\n     *\n     * class Car extends Vehicle {}\n     *\n     * var injectorClass = Injector.resolveAndCreate([\n     *   Car,\n     *   new Binding(Vehicle, { toClass: Car })\n     * ]);\n     * var injectorAlias = Injector.resolveAndCreate([\n     *   Car,\n     *   new Binding(Vehicle, { toAlias: Car })\n     * ]);\n     *\n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n     *\n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n     * ```",
        "* Binds a key to a value.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   new Binding(String, { toValue: 'Hello' })\n     * ]);\n     *\n     * expect(injector.get(String)).toEqual('Hello');\n     * ```",
        "* Binds a key to the alias for an existing key.\n     *\n     * An alias means that {@link Injector} returns the same instance as if the alias token was used.\n     * This is in contrast to `toClass` where a separate instance of `toClass` is returned.\n     *\n     * ## Example\n     *\n     * Becuse `toAlias` and `toClass` are often confused the example contains both use cases for easy\n     * comparison.\n     *\n     * ```javascript\n     *\n     * class Vehicle {}\n     *\n     * class Car extends Vehicle {}\n     *\n     * var injectorAlias = Injector.resolveAndCreate([\n     *   Car,\n     *   new Binding(Vehicle, { toAlias: Car })\n     * ]);\n     * var injectorClass = Injector.resolveAndCreate([\n     *   Car,\n     *   new Binding(Vehicle, { toClass: Car })\n     * ]);\n     *\n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n     *\n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n     * ```",
        "* Binds a key to a function which computes the value.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   new Binding(Number, { toFactory: () => { return 1+2; }}),\n     *   new Binding(String, { toFactory: (value) => { return \"Value: \" + value; },\n     *                         dependencies: [Number] })\n     * ]);\n     *\n     * expect(injector.get(Number)).toEqual(3);\n     * expect(injector.get(String)).toEqual('Value: 3');\n     * ```",
        "* Used in conjunction with `toFactory` and specifies a set of dependencies\n     * (as `token`s) which should be injected into the factory function.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   new Binding(Number, { toFactory: () => { return 1+2; }}),\n     *   new Binding(String, { toFactory: (value) => { return \"Value: \" + value; },\n     *                         dependencies: [Number] })\n     * ]);\n     *\n     * expect(injector.get(Number)).toEqual(3);\n     * expect(injector.get(String)).toEqual('Value: 3');\n     * ```",
        "* Converts the {@link Binding} into {@link ResolvedBinding}.\n     *\n     * {@link Injector} internally only uses {@link ResolvedBinding}, {@link Binding} contains\n     * convenience binding syntax.",
        "* Helper class for the {@link bind} function.",
        "* Binds an interface to an implementation / subclass.\n     *\n     * ## Example\n     *\n     * Because `toAlias` and `toClass` are often confused, the example contains both use cases for\n     * easy comparison.\n     *\n     * ```javascript\n     *\n     * class Vehicle {}\n     *\n     * class Car extends Vehicle {}\n     *\n     * var injectorClass = Injector.resolveAndCreate([\n     *   Car,\n     *   bind(Vehicle).toClass(Car)\n     * ]);\n     * var injectorAlias = Injector.resolveAndCreate([\n     *   Car,\n     *   bind(Vehicle).toAlias(Car)\n     * ]);\n     *\n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n     *\n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n     * ```",
        "* Binds a key to a value.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   bind(String).toValue('Hello')\n     * ]);\n     *\n     * expect(injector.get(String)).toEqual('Hello');\n     * ```",
        "* Binds a key to the alias for an existing key.\n     *\n     * An alias means that we will return the same instance as if the alias token was used. (This is\n     * in contrast to `toClass` where a separate instance of `toClass` will be returned.)\n     *\n     * ## Example\n     *\n     * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy\n     * comparison.\n     *\n     * ```javascript\n     *\n     * class Vehicle {}\n     *\n     * class Car extends Vehicle {}\n     *\n     * var injectorAlias = Injector.resolveAndCreate([\n     *   Car,\n     *   bind(Vehicle).toAlias(Car)\n     * ]);\n     * var injectorClass = Injector.resolveAndCreate([\n     *   Car,\n     *   bind(Vehicle).toClass(Car)\n     * ]);\n     *\n     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));\n     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);\n     *\n     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));\n     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);\n     * ```",
        "* Binds a key to a function which computes the value.\n     *\n     * ## Example\n     *\n     * ```javascript\n     * var injector = Injector.resolveAndCreate([\n     *   bind(Number).toFactory(() => { return 1+2; }),\n     *   bind(String).toFactory((v) => { return \"Value: \" + v; }, [Number])\n     * ]);\n     *\n     * expect(injector.get(Number)).toEqual(3);\n     * expect(injector.get(String)).toEqual('Value: 3');\n     * ```",
        "* An internal resolved representation of a {@link Binding} used by the {@link Injector}.\n   *\n   * A {@link Binding} is resolved when it has a factory function. Binding to a class, alias, or\n   * value, are just convenience methods, as {@link Injector} only operates on calling factory\n   * functions.",
        "* A key, usually a `Type`.",
        "* Factory function which can return an instance of an object represented by a key.",
        "* Arguments (dependencies) to the `factory` function.",
        "* @private",
        "* Provides an API for imperatively constructing {@link Binding}s.\n   *\n   * This is only relevant for JavaScript. See {@link BindingBuilder}.\n   *\n   * ## Example\n   *\n   * ```javascript\n   * bind(MyInterface).toClass(MyClass)\n   *\n   * ```",
        "* A unique object used for retrieving items from the {@link Injector}.\n   *\n   * Keys have:\n   * - a system-wide unique `id`.\n   * - a `token`, usually the `Type` of the instance.\n   *\n   * Keys are used internally by the {@link Injector} because their system-wide unique `id`s allow the\n   * injector to index in arrays rather than looking up items in maps.",
        "* Retrieves a `Key` for a token.",
        "* @returns the number of keys registered in the system.",
        "* @private",
        "* Type literals is a Dart-only feature. This is here only so we can x-compile\n   * to multiple languages.",
        "* Thrown when trying to retrieve a dependency by `Key` from {@link Injector}, but the\n   * {@link Injector} does not have a {@link Binding} for {@link Key}.",
        "* Base class for all errors arising from misconfigured bindings.",
        "* Thrown when dependencies form a cycle.\n   *\n   * ## Example:\n   *\n   * ```javascript\n   * class A {\n   *   constructor(b:B) {}\n   * }\n   * class B {\n   *   constructor(a:A) {}\n   * }\n   * ```\n   *\n   * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.",
        "* Thrown when a constructing type returns with an Error.\n   *\n   * The `InstantiationError` class contains the original error plus the dependency graph which caused\n   * this object to be instantiated.",
        "* Thrown when an object other then {@link Binding} (or `Type`) is passed to {@link Injector}\n   * creation.",
        "* Thrown when the class has no annotation information.\n   *\n   * Lack of annotation information prevents the {@link Injector} from determining which dependencies\n   * need to be injected into the constructor.",
        "* Thrown when getting an object by index.",
        "* Factory for creating {@link InjectMetadata}.",
        "* Factory for creating {@link OptionalMetadata}.",
        "* Factory for creating {@link InjectableMetadata}.",
        "* Factory for creating {@link SelfMetadata}.",
        "* Factory for creating {@link HostMetadata}.",
        "* Factory for creating {@link SkipSelfMetadata}.",
        "* Factory for creating {@link InjectMetadata}.",
        "* Factory for creating {@link OptionalMetadata}.",
        "* Factory for creating {@link InjectableMetadata}.",
        "* Factory for creating {@link SelfMetadata}.",
        "* Factory for creating {@link HostMetadata}.",
        "* Factory for creating {@link SkipSelfMetadata}.",
        "* A collection of the Angular core directives that are likely to be used in each and every Angular\n   * application.\n   *\n   * This collection can be used to quickly enumerate all the built-in directives in the `@View`\n   * annotation. For example,\n   * instead of writing:\n   *\n   * ```\n   * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/angular2';\n   * import {OtherDirective} from 'myDirectives';\n   *\n   * @Component({\n   *  selector: 'my-component'\n   * })\n   * @View({\n   *   templateUrl: 'myComponent.html',\n   *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]\n   * })\n   * export class MyComponent {\n   *   ...\n   * }\n   * ```\n   * one could import all the core directives at once:\n   *\n   * ```\n   * import {CORE_DIRECTIVES} from 'angular2/angular2';\n   * import {OtherDirective} from 'myDirectives';\n   *\n   * @Component({\n   *  selector: 'my-component'\n   * })\n   * @View({\n   *   templateUrl: 'myComponent.html',\n   *   directives: [CORE_DIRECTIVES, OtherDirective]\n   * })\n   * export class MyComponent {\n   *   ...\n   * }\n   * ```",
        "* Adds and removes CSS classes based on an {expression} value.\n   *\n   * The result of expression is used to add and remove CSS classes using the following logic,\n   * based on expression's value type:\n   * - {string} - all the CSS classes (space - separated) are added\n   * - {Array} - all the CSS classes (Array elements) are added\n   * - {Object} - each key corresponds to a CSS class name while values\n   * are interpreted as {boolean} expression. If a given expression\n   * evaluates to {true} a corresponding CSS class is added - otherwise\n   * it is removed.\n   *\n   * # Example:\n   *\n   * ```\n   * <div class=\"message\" [ng-class]=\"{error: errorCount > 0}\">\n   *     Please check errors.\n   * </div>\n   * ```",
        "* The `NgFor` directive instantiates a template once per item from an iterable. The context for\n   * each instantiated template inherits from the outer context with the given loop variable set\n   * to the current item from the iterable.\n   *\n   * It is possible to alias the `index` to a local variable that will be set to the current loop\n   * iteration in the template context.\n   *\n   * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:\n   *\n   * * When an item is added, a new instance of the template is added to the DOM.\n   * * When an item is removed, its template instance is removed from the DOM.\n   * * When items are reordered, their respective templates are reordered in the DOM.\n   *\n   * # Example\n   *\n   * ```\n   * <ul>\n   *   <li *ng-for=\"#error of errors; #i = index\">\n   *     Error {{i}} of {{errors.length}}: {{error.message}}\n   *   </li>\n   * </ul>\n   * ```\n   *\n   * # Syntax\n   *\n   * - `<li *ng-for=\"#item of items; #i = index\">...</li>`\n   * - `<li template=\"ng-for #item of items; #i = index\">...</li>`\n   * - `<template ng-for #item [ng-for-of]=\"items\" #i=\"index\"><li>...</li></template>`",
        "* Removes or recreates a portion of the DOM tree based on an {expression}.\n   *\n   * If the expression assigned to `ng-if` evaluates to a false value then the element\n   * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.\n   *\n   * # Example:\n   *\n   * ```\n   * <div *ng-if=\"errorCount > 0\" class=\"error\">\n   *   <!-- Error message displayed when the errorCount property on the current context is greater\n   * than 0. -->\n   *   {{errorCount}} errors detected\n   * </div>\n   * ```\n   *\n   * # Syntax\n   *\n   * - `<div *ng-if=\"condition\">...</div>`\n   * - `<div template=\"ng-if condition\">...</div>`\n   * - `<template [ng-if]=\"condition\"><div>...</div></template>`",
        "* The `NgNonBindable` directive tells Angular not to compile or bind the contents of the current\n   * DOM element. This is useful if the element contains what appears to be Angular directives and\n   * bindings but which should be ignored by Angular. This could be the case if you have a site that\n   * displays snippets of code, for instance.\n   *\n   * Example:\n   *\n   * ```\n   * <div>Normal: {{1 + 2}}</div> // output \"Normal: 3\"\n   * <div ng-non-bindable>Ignored: {{1 + 2}}</div> // output \"Ignored: {{1 + 2}}\"\n   * ```",
        "* Adds or removes styles based on an {expression}.\n   *\n   * When the expression assigned to `ng-style` evaluates to an object, the corresponding element\n   * styles are updated. Style names to update are taken from the object keys and values - from the\n   * corresponding object values.\n   *\n   * # Example:\n   *\n   * ```\n   * <div [ng-style]=\"{'text-align': alignExp}\"></div>\n   * ```\n   *\n   * In the above example the `text-align` style will be updated based on the `alignExp` value\n   * changes.\n   *\n   * # Syntax\n   *\n   * - `<div [ng-style]=\"{'text-align': alignExp}\"></div>`\n   * - `<div [ng-style]=\"styleExp\"></div>`",
        "* The `NgSwitch` directive is used to conditionally swap DOM structure on your template based on a\n   * scope expression.\n   * Elements within `NgSwitch` but without `NgSwitchWhen` or `NgSwitchDefault` directives will be\n   * preserved at the location as specified in the template.\n   *\n   * `NgSwitch` simply chooses nested elements and makes them visible based on which element matches\n   * the value obtained from the evaluated expression. In other words, you define a container element\n   * (where you place the directive), place an expression on the **`[ng-switch]=\"...\"` attribute**),\n   * define any inner elements inside of the directive and place a `[ng-switch-when]` attribute per\n   * element.\n   * The when attribute is used to inform NgSwitch which element to display when the expression is\n   * evaluated. If a matching expression is not found via a when attribute then an element with the\n   * default attribute is displayed.\n   *\n   * # Example:\n   *\n   * ```\n   * <ANY [ng-switch]=\"expression\">\n   *   <template [ng-switch-when]=\"whenExpression1\">...</template>\n   *   <template [ng-switch-when]=\"whenExpression1\">...</template>\n   *   <template ng-switch-default>...</template>\n   * </ANY>\n   * ```",
        "* Defines a case statement as an expression.\n   *\n   * If multiple `NgSwitchWhen` match the `NgSwitch` value, all of them are displayed.\n   *\n   * Example:\n   *\n   * ```\n   * // match against a context variable\n   * <template [ng-switch-when]=\"contextVariable\">...</template>\n   *\n   * // match against a constant string\n   * <template ng-switch-when=\"stringValue\">...</template>\n   * ```",
        "* Defines a default case statement.\n   *\n   * Default case statements are displayed when no `NgSwitchWhen` match the `ng-switch` value.\n   *\n   * Example:\n   *\n   * ```\n   * <template ng-switch-default>...</template>\n   * ```",
        "* Omitting from external API doc as this is really an abstract internal concept.",
        "* Defines a part of a form that cannot be divided into other controls.\n   *\n   * `Control` is one of the three fundamental building blocks used to define forms in Angular, along\n   * with\n   * {@link ControlGroup} and {@link ControlArray}.",
        "* Defines a part of a form, of fixed length, that can contain other controls.\n   *\n   * A ControlGroup aggregates the values and errors of each {@link Control} in the group. Thus, if\n   * one of the controls\n   * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,\n   * the entire group\n   * changes as well.\n   *\n   * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,\n   * along with\n   * {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other controls,\n   * but is of variable\n   * length.",
        "* Defines a part of a form, of variable length, that can contain other controls.\n   *\n   * A `ControlArray` aggregates the values and errors of each {@link Control} in the group. Thus, if\n   * one of the controls\n   * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,\n   * the entire group\n   * changes as well.\n   *\n   * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,\n   * along with {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain\n   * other controls, but is of fixed length.",
        "* An interface that {@link NgFormModel} and {@link NgForm} implement.\n   *\n   * Only used by the forms module.",
        "* A directive that contains a group of [NgControl].\n   *\n   * Only used by the forms module.",
        "* Creates and binds a control with a specified name to a DOM element.\n   *\n   * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.\n   *\n   * # Example\n   *\n   * In this example, we create the login and password controls.\n   * We can work with each control separately: check its validity, get its value, listen to its\n   *  changes.\n   *\n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: `\n   *              <form #f=\"form\" (submit)='onLogIn(f.value)'>\n   *                Login <input type='text' ng-control='login' #l=\"form\">\n   *                <div *ng-if=\"!l.valid\">Login is invalid</div>\n   *\n   *                Password <input type='password' ng-control='password'>\n   *\n   *                <button type='submit'>Log in!</button>\n   *              </form>\n   *      `})\n   * class LoginComp {\n   *  onLogIn(value) {\n   *    // value === {login: 'some login', password: 'some password'}\n   *  }\n   * }\n   *  ```\n   *\n   * We can also use ng-model to bind a domain model to the form.\n   *\n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: `\n   *              <form (submit)='onLogIn()'>\n   *                Login <input type='text' ng-control='login' [(ng-model)]=\"credentials.login\">\n   *                Password <input type='password' ng-control='password'\n   *  [(ng-model)]=\"credentials.password\">\n   *                <button type='submit'>Log in!</button>\n   *              </form>\n   *      `})\n   * class LoginComp {\n   *  credentials: {login:string, password:string};\n   *\n   *  onLogIn() {\n   *    // this.credentials.login === \"some login\"\n   *    // this.credentials.password === \"some password\"\n   *  }\n   * }\n   *  ```",
        "* Binds an existing control to a DOM element.\n   *\n   * # Example\n   *\n   * In this example, we bind the control to an input element. When the value of the input element\n   * changes, the value of\n   * the control will reflect that change. Likewise, if the value of the control changes, the input\n   * element reflects that\n   * change.\n   *\n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: \"<input type='text' [ng-form-control]='loginControl'>\"\n   *      })\n   * class LoginComp {\n   *  loginControl:Control;\n   *\n   *  constructor() {\n   *    this.loginControl = new Control('');\n   *  }\n   * }\n   *\n   *  ```\n   *\n   * We can also use ng-model to bind a domain model to the form.\n   *\n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: \"<input type='text' [ng-form-control]='loginControl' [(ng-model)]='login'>\"\n   *      })\n   * class LoginComp {\n   *  loginControl:Control;\n   *  login:string;\n   *\n   *  constructor() {\n   *    this.loginControl = new Control('');\n   *  }\n   * }\n   *  ```",
        "* Binds a domain model to the form.\n   *\n   * # Example\n   *  ```\n   * @Component({selector: \"search-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: `\n   *               <input type='text' [(ng-model)]=\"searchQuery\">\n   *      `})\n   * class SearchComp {\n   *  searchQuery: string;\n   * }\n   *  ```",
        "* An abstract class that all control directive extend.\n   *\n   * It binds a {@link Control} object to a DOM element.",
        "* Creates and binds a control group to a DOM element.\n   *\n   * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.\n   *\n   * # Example\n   *\n   * In this example, we create the credentials and personal control groups.\n   * We can work with each group separately: check its validity, get its value, listen to its changes.\n   *\n   *  ```\n   * @Component({selector: \"signup-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: `\n   *              <form #f=\"form\" (submit)='onSignUp(f.value)'>\n   *                <div ng-control-group='credentials' #credentials=\"form\">\n   *                  Login <input type='text' ng-control='login'>\n   *                  Password <input type='password' ng-control='password'>\n   *                </div>\n   *                <div *ng-if=\"!credentials.valid\">Credentials are invalid</div>\n   *\n   *                <div ng-control-group='personal'>\n   *                  Name <input type='text' ng-control='name'>\n   *                </div>\n   *                <button type='submit'>Sign Up!</button>\n   *              </form>\n   *      `})\n   * class SignupComp {\n   *  onSignUp(value) {\n   *    // value === {personal: {name: 'some name'},\n   *    //  credentials: {login: 'some login', password: 'some password'}}\n   *  }\n   * }\n   *\n   *  ```",
        "* Binds an existing control group to a DOM element.\n   *\n   * # Example\n   *\n   * In this example, we bind the control group to the form element, and we bind the login and\n   * password controls to the\n   * login and password elements.\n   *\n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: \"<form [ng-form-model]='loginForm'>\" +\n   *              \"Login <input type='text' ng-control='login'>\" +\n   *              \"Password <input type='password' ng-control='password'>\" +\n   *              \"<button (click)=\"onLogin()\">Login</button>\" +\n   *              \"</form>\"\n   *      })\n   * class LoginComp {\n   *  loginForm:ControlGroup;\n   *\n   *  constructor() {\n   *    this.loginForm = new ControlGroup({\n   *      login: new Control(\"\"),\n   *      password: new Control(\"\")\n   *    });\n   *  }\n   *\n   *  onLogin() {\n   *    // this.loginForm.value\n   *  }\n   * }\n   *\n   *  ```\n   *\n   * We can also use ng-model to bind a domain model to the form.\n   *\n   *  ```\n   * @Component({selector: \"login-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: \"<form [ng-form-model]='loginForm'>\" +\n   *              \"Login <input type='text' ng-control='login' [(ng-model)]='login'>\" +\n   *              \"Password <input type='password' ng-control='password' [(ng-model)]='password'>\" +\n   *              \"<button (click)=\"onLogin()\">Login</button>\" +\n   *              \"</form>\"\n   *      })\n   * class LoginComp {\n   *  credentials:{login:string, password:string}\n   *  loginForm:ControlGroup;\n   *\n   *  constructor() {\n   *    this.loginForm = new ControlGroup({\n   *      login: new Control(\"\"),\n   *      password: new Control(\"\")\n   *    });\n   *  }\n   *\n   *  onLogin() {\n   *    // this.credentials.login === 'some login'\n   *    // this.credentials.password === 'some password'\n   *  }\n   * }\n   *  ```",
        "* Creates and binds a form object to a DOM element.\n   *\n   * # Example\n   *\n   *  ```\n   * @Component({selector: \"signup-comp\"})\n   * @View({\n   *      directives: [FORM_DIRECTIVES],\n   *      template: `\n   *              <form #f=\"form\" (submit)='onSignUp(f.value)'>\n   *                <div ng-control-group='credentials' #credentials=\"form\">\n   *                  Login <input type='text' ng-control='login'>\n   *                  Password <input type='password' ng-control='password'>\n   *                </div>\n   *                <div *ng-if=\"!credentials.valid\">Credentials are invalid</div>\n   *\n   *                <div ng-control-group='personal'>\n   *                  Name <input type='text' ng-control='name'>\n   *                </div>\n   *                <button type='submit'>Sign Up!</button>\n   *              </form>\n   *      `})\n   * class SignupComp {\n   *  onSignUp(value) {\n   *    // value === {personal: {name: 'some name'},\n   *    //  credentials: {login: 'some login', password: 'some password'}}\n   *  }\n   * }\n   *\n   *  ```",
        "* A bridge between a control and a native element.\n   *\n   * Please see {@link DefaultValueAccessor} for more information.",
        "* The default accessor for writing a value and listening to changes that is used by the\n   * {@link NgModel}, {@link NgFormControl}, and {@link NgControlName} directives.\n   *\n   *  # Example\n   *  ```\n   *  <input type=\"text\" [(ng-model)]=\"searchQuery\">\n   *  ```",
        "* The accessor for writing a value and listening to changes on a checkbox input element.\n   *\n   *  # Example\n   *  ```\n   *  <input type=\"checkbox\" [ng-control]=\"rememberLogin\">\n   *  ```",
        "* Marks <option> as dynamic, so Angular can be notified when options change.\n   *\n   * #Example:\n   *\n   * ```\n   * <select ng-control=\"city\">\n   *   <option *ng-for=\"#c of cities\" [value]=\"c\"></option>\n   * </select>\n   * ```",
        "* The accessor for writing a value and listening to changes on a select element.",
        "* A list of all the form directives used as part of a `@View` annotation.\n   *\n   *  This is a shorthand for importing them each individually.",
        "* Provides a set of validators used by form controls.\n   *\n   * # Example\n   *\n   * ```\n   * var loginControl = new Control(\"\", Validators.required)\n   * ```",
        "* Creates a form object from a user-specified configuration.\n   *\n   * # Example\n   *\n   * ```\n   * import {Component, View, bootstrap} from 'angular2/angular2';\n   * import {FormBuilder, Validators, FORM_DIRECTIVES, ControlGroup} from 'angular2/forms';\n   *\n   * @Component({\n   *   selector: 'login-comp',\n   *   viewBindings: [\n   *     FormBuilder\n   *   ]\n   * })\n   * @View({\n   *   template: `\n   *     <form [control-group]=\"loginForm\">\n   *       Login <input control=\"login\">\n   *\n   *       <div control-group=\"passwordRetry\">\n   *         Password <input type=\"password\" control=\"password\">\n   *         Confirm password <input type=\"password\" control=\"passwordConfirmation\">\n   *       </div>\n   *     </form>\n   *   `,\n   *   directives: [\n   *     FORM_DIRECTIVES\n   *   ]\n   * })\n   * class LoginComp {\n   *   loginForm: ControlGroup;\n   *\n   *   constructor(builder: FormBuilder) {\n   *     this.loginForm = builder.group({\n   *       login: [\"\", Validators.required],\n   *\n   *       passwordRetry: builder.group({\n   *         password: [\"\", Validators.required],\n   *         passwordConfirmation: [\"\", Validators.required]\n   *       })\n   *     });\n   *   }\n   * }\n   *\n   * bootstrap(LoginComp)\n   * ```\n   *\n   * This example creates a {@link ControlGroup} that consists of a `login` {@link Control}, and a\n   * nested\n   * {@link ControlGroup} that defines a `password` and a `passwordConfirmation` {@link Control}:\n   *\n   * ```\n   *  var loginForm = builder.group({\n   *    login: [\"\", Validators.required],\n   *\n   *    passwordRetry: builder.group({\n   *      password: [\"\", Validators.required],\n   *      passwordConfirmation: [\"\", Validators.required]\n   *    })\n   *  });\n   *\n   *  ```",
        "* A dispatcher for all events happening in a view.",
        "* Called when an event was triggered for a on-* attribute on an element.\n     * @param {Map<string, any>} locals Locals to be used to evaluate the\n     *   event expressions\n     * @return {boolean} False if `preventDefault` should be called on the DOM event.",
        "* Creates a root host view that includes the given element.\n     * Note that the fragmentCount needs to be passed in so that we can create a result\n     * synchronously even when dealing with webworkers!\n     *\n     * @param {RenderProtoViewRef} hostProtoViewRef a RenderProtoViewRef of type\n     * ProtoViewDto.HOST_VIEW_TYPE\n     * @param {any} hostElementSelector css selector for the host element (will be queried against the\n     * main document)\n     * @return {RenderViewWithFragments} the created view including fragments",
        "* Creates a regular view out of the given ProtoView.\n     * Note that the fragmentCount needs to be passed in so that we can create a result\n     * synchronously even when dealing with webworkers!",
        "* Destroys the given view after it has been dehydrated and detached",
        "* Attaches a fragment after another fragment.",
        "* Attaches a fragment after an element.",
        "* Detaches a fragment.",
        "* Hydrates a view after it has been attached. Hydration/dehydration is used for reusing views\n     * inside of the view pool.",
        "* Dehydrates a view after it has been attached. Hydration/dehydration is used for reusing views\n     * inside of the view pool.",
        "* Returns the native element at the given location.\n     * Attention: In a WebWorker scenario, this should always return null!",
        "* Sets a property on an element.",
        "* Sets an attribute on an element.",
        "* Sets a class on an element.",
        "* Sets a style on an element.",
        "* Calls a method on an element.",
        "* Sets the value of a text node.",
        "* Sets the dispatcher for all events of the given view",
        "* Abstract reference to the element which can be marshaled across web-worker boundary.\n   *\n   * This interface is used by the Renderer API.",
        "* Reference to the `RenderViewRef` where the `RenderElementRef` is inside of.",
        "* Index of the element inside the `RenderViewRef`.\n     *\n     * This is used internally by the Angular framework to locate elements.",
        "* A unique id (string) for an angular application.",
        "* Defines when a compiled template should be stored as a string\n   * rather than keeping its Nodes to preserve memory.",
        "* Create trace scope.\n   *\n   * Scopes must be strictly nested and are analogous to stack frames, but\n   * do not have to follow the stack frames. Instead it is recommended that they follow logical\n   * nesting. You may want to use\n   * [Event\n   * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)\n   * as they are defined in WTF.\n   *\n   * Used to mark scope entry. The return value is used to leave the scope.\n   *\n   *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');\n   *\n   *     someMethod() {\n   *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI\n   *        // DO SOME WORK HERE\n   *        return wtfLeave(s, 123); // Return value 123\n   *     }\n   *\n   * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can\n   * negatively impact the performance of your application. For this reason we recommend that\n   * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and\n   * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to\n   * exception, will produce incorrect trace, but presence of exception signifies logic error which\n   * needs to be fixed before the app should be profiled. Add try-finally only when you expect that\n   * an exception is expected during normal execution while profiling.",
        "* Used to mark end of Scope.\n   *\n   * - `scope` to end.\n   * - `returnValue` (optional) to be passed to the WTF.\n   *\n   * Returns the `returnValue for easy chaining.",
        "* Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.\n   * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been\n   * enabled.\n   *\n   *     someMethod() {\n   *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');\n   *        var future = new Future.delay(5).then((_) {\n   *          wtfEndTimeRange(s);\n   *        });\n   *     }",
        "* Ends a async time range operation.\n   * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been\n   * enabled.",
        "* Bootstrapping a Webworker Application\n   *\n   * You instantiate the application side by calling bootstrapWebworker from your webworker index\n   * script.\n   * You can call bootstrapWebworker() exactly as you would call bootstrap() in a regular Angular\n   * application\n   * See the bootstrap() docs for more details.",
        "* Message Bus is a low level API used to communicate between the UI and the background.\n   * Communication is based on a channel abstraction. Messages published in a\n   * given channel to one MessageBusSink are received on the same channel\n   * by the corresponding MessageBusSource.",
        "* Returns an {@link EventEmitter} that emits every time a messsage\n     * is received on the given channel.",
        "* Returns an {@link EventEmitter} for the given channel\n     * To publish methods to that channel just call next (or add in dart) on the returned emitter",
        "* Returns an {@link EventEmitter} that emits every time a messsage\n     * is received on the given channel.",
        "* Returns an {@link EventEmitter} for the given channel\n     * To publish methods to that channel just call next (or add in dart) on the returned emitter",
        "* Helper class for UIComponents that allows components to register methods.\n   * If a registered method message is received from the broker on the worker,\n   * the UIMessageBroker desererializes its arguments and calls the registered method.\n   * If that method returns a promise, the UIMessageBroker returns the result to the worker.",
        "* Bootstrapping a WebWorker\n   *\n   * You instantiate a WebWorker application by calling bootstrap with the URI of your worker's index\n   * script\n   * Note: The WebWorker script must call bootstrapWebworker once it is set up to complete the\n   * bootstrapping process",
        "* Wrapper class that exposes the {@link WebWorkerApplication}\n   * Isolate instance and underyling {@link MessageBus} for lower level message passing.",
        "* Use Rx.Observable but provides an adapter to make it work as specified here:\n   * https://github.com/jhusain/observable-spec\n   *\n   * Once a reference implementation of the spec is available, switch to it.",
        "* Message Bus is a low level API used to communicate between the UI and the background.\n   * Communication is based on a channel abstraction. Messages published in a\n   * given channel to one MessageBusSink are received on the same channel\n   * by the corresponding MessageBusSource.",
        "* Returns an {@link EventEmitter} that emits every time a messsage\n     * is received on the given channel.",
        "* Returns an {@link EventEmitter} for the given channel\n     * To publish methods to that channel just call next (or add in dart) on the returned emitter",
        "* Returns an {@link EventEmitter} that emits every time a messsage\n     * is received on the given channel.",
        "* Returns an {@link EventEmitter} for the given channel\n     * To publish methods to that channel just call next (or add in dart) on the returned emitter",
        "* Runtime representation of a type.\n   *\n   * In JavaScript a Type is a constructor function.",
        "* Helper class for UIComponents that allows components to register methods.\n   * If a registered method message is received from the broker on the worker,\n   * the UIMessageBroker desererializes its arguments and calls the registered method.\n   * If that method returns a promise, the UIMessageBroker returns the result to the worker."
    ],
    "functions": [],
    "classes": [
        "ComponentMetadata",
        "DirectiveMetadata",
        "PipeMetadata",
        "ViewMetadata",
        "QueryMetadata",
        "AttributeMetadata",
        "ExpressionChangedAfterItHasBeenCheckedException",
        "ChangeDetectionError",
        "Locals",
        "WrappedValue",
        "IterableDiffers",
        "KeyValueDiffers",
        "AppRootUrl",
        "UrlResolver",
        "ComponentUrlMapper",
        "DirectiveResolver",
        "QueryList",
        "DynamicComponentLoader",
        "LifeCycle",
        "ElementRef",
        "TemplateRef",
        "NgZone",
        "Observable",
        "EventEmitter",
        "InjectMetadata",
        "OptionalMetadata",
        "InjectableMetadata",
        "SelfMetadata",
        "HostMetadata",
        "SkipSelfMetadata",
        "DependencyMetadata",
        "Injector",
        "ProtoInjector",
        "BindingWithVisibility",
        "Binding",
        "BindingBuilder",
        "ResolvedBinding",
        "Dependency",
        "Key",
        "KeyRegistry",
        "TypeLiteral",
        "NoBindingError",
        "AbstractBindingError",
        "CyclicDependencyError",
        "InstantiationError",
        "InvalidBindingError",
        "NoAnnotationError",
        "OutOfBoundsError",
        "OpaqueToken",
        "NgClass",
        "NgFor",
        "RecordViewTuple",
        "NgIf",
        "NgNonBindable",
        "NgStyle",
        "SwitchView",
        "NgSwitch",
        "NgSwitchWhen",
        "NgSwitchDefault",
        "AbstractControl",
        "Control",
        "ControlGroup",
        "ControlArray",
        "AbstractControlDirective",
        "ControlContainer",
        "NgControlName",
        "NgFormControl",
        "NgModel",
        "NgControl",
        "NgControlGroup",
        "NgFormModel",
        "NgForm",
        "DefaultValueAccessor",
        "CheckboxControlValueAccessor",
        "NgSelectOption",
        "SelectControlValueAccessor",
        "Validators",
        "NgValidator",
        "NgRequiredValidator",
        "FormBuilder",
        "RenderDirectiveMetadata",
        "DomRenderer",
        "Renderer",
        "RenderViewRef",
        "RenderProtoViewRef",
        "RenderFragmentRef",
        "RenderViewWithFragments",
        "ViewDefinition",
        "ComponentMetadata",
        "DirectiveMetadata",
        "PipeMetadata",
        "ViewMetadata",
        "QueryMetadata",
        "AttributeMetadata",
        "ExpressionChangedAfterItHasBeenCheckedException",
        "ChangeDetectionError",
        "Locals",
        "WrappedValue",
        "IterableDiffers",
        "KeyValueDiffers",
        "AppRootUrl",
        "UrlResolver",
        "ComponentUrlMapper",
        "DirectiveResolver",
        "QueryList",
        "DynamicComponentLoader",
        "LifeCycle",
        "ElementRef",
        "TemplateRef",
        "NgZone",
        "Observable",
        "EventEmitter",
        "InjectMetadata",
        "OptionalMetadata",
        "InjectableMetadata",
        "SelfMetadata",
        "HostMetadata",
        "SkipSelfMetadata",
        "DependencyMetadata",
        "Injector",
        "ProtoInjector",
        "BindingWithVisibility",
        "Binding",
        "BindingBuilder",
        "ResolvedBinding",
        "Dependency",
        "Key",
        "KeyRegistry",
        "TypeLiteral",
        "NoBindingError",
        "AbstractBindingError",
        "CyclicDependencyError",
        "InstantiationError",
        "InvalidBindingError",
        "NoAnnotationError",
        "OutOfBoundsError",
        "OpaqueToken",
        "NgClass",
        "NgFor",
        "RecordViewTuple",
        "NgIf",
        "NgNonBindable",
        "NgStyle",
        "SwitchView",
        "NgSwitch",
        "NgSwitchWhen",
        "NgSwitchDefault",
        "AbstractControl",
        "Control",
        "ControlGroup",
        "ControlArray",
        "AbstractControlDirective",
        "ControlContainer",
        "NgControlName",
        "NgFormControl",
        "NgModel",
        "NgControl",
        "NgControlGroup",
        "NgFormModel",
        "NgForm",
        "DefaultValueAccessor",
        "CheckboxControlValueAccessor",
        "NgSelectOption",
        "SelectControlValueAccessor",
        "Validators",
        "NgValidator",
        "NgRequiredValidator",
        "FormBuilder",
        "RenderDirectiveMetadata",
        "DomRenderer",
        "Renderer",
        "RenderViewRef",
        "RenderProtoViewRef",
        "RenderFragmentRef",
        "RenderViewWithFragments",
        "ViewDefinition",
        "MessageBus",
        "ClientMessageBrokerFactory",
        "ClientMessageBroker",
        "FnArg",
        "UiArguments",
        "ServiceMessageBrokerFactory",
        "ServiceMessageBroker",
        "ReceivedMessage",
        "Serializer",
        "WebWorkerApplication",
        "WebWorkerInstance",
        "EventEmitter",
        "Observable",
        "MessageBus",
        "ClientMessageBrokerFactory",
        "ClientMessageBroker",
        "FnArg",
        "UiArguments",
        "ServiceMessageBrokerFactory",
        "ServiceMessageBroker",
        "ReceivedMessage",
        "Serializer"
    ]
}