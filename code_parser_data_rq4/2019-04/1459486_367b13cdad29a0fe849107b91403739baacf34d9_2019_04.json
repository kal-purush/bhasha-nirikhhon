{
    "identifiers": [
        "com",
        "maddyhome",
        "idea",
        "vim",
        "helper",
        "com",
        "intellij",
        "lexer",
        "Lexer",
        "com",
        "intellij",
        "lexer",
        "LexerPosition",
        "com",
        "intellij",
        "lexer",
        "XmlLexer",
        "com",
        "intellij",
        "psi",
        "tree",
        "IElementType",
        "com",
        "intellij",
        "psi",
        "xml",
        "XmlTokenType",
        "State",
        "LOOK_OPENING_TAG",
        "LOOK_ENDING_TAG",
        "END",
        "os",
        "ie",
        "oe",
        "name",
        "os",
        "ie",
        "oe",
        "name",
        "os",
        "os",
        "ie",
        "ie",
        "oe",
        "oe",
        "name",
        "name",
        "tagBlock",
        "tagBlock",
        "result",
        "result",
        "name",
        "tagBlock",
        "name",
        "name",
        "tagBlock",
        "name",
        "result",
        "os",
        "tagBlock",
        "os",
        "os",
        "tagBlock",
        "os",
        "result",
        "tagBlock",
        "tagBlock",
        "result",
        "ie",
        "tagBlock",
        "ie",
        "ie",
        "tagBlock",
        "ie",
        "result",
        "oe",
        "tagBlock",
        "oe",
        "oe",
        "tagBlock",
        "oe",
        "result",
        "os",
        "ie",
        "oe",
        "oe",
        "os",
        "name",
        "Override",
        "os",
        "ie",
        "oe",
        "name",
        "seq",
        "pos",
        "lexer",
        "lexer",
        "start",
        "seq",
        "pos",
        "seq",
        "length",
        "lexer",
        "advance",
        "find",
        "lexer",
        "lexer",
        "result",
        "buildingTagBlock",
        "state",
        "State",
        "LOOK_OPENING_TAG",
        "lexer",
        "getTokenType",
        "state",
        "State",
        "END",
        "state",
        "LOOK_OPENING_TAG",
        "buildingTagBlock",
        "buildingTagBlock",
        "merge",
        "lookForOpeningTag",
        "lexer",
        "buildingTagBlock",
        "name",
        "state",
        "State",
        "LOOK_ENDING_TAG",
        "LOOK_ENDING_TAG",
        "buildingTagBlock",
        "buildingTagBlock",
        "merge",
        "lookForClosingTag",
        "lexer",
        "buildingTagBlock",
        "name",
        "buildingTagBlock",
        "oe",
        "state",
        "State",
        "END",
        "result",
        "buildingTagBlock",
        "lexer",
        "advance",
        "result",
        "lexer",
        "name",
        "ie",
        "oe",
        "lexer",
        "getTokenType",
        "oe",
        "tokenType",
        "lexer",
        "getTokenType",
        "XmlTokenType",
        "XML_START_TAG_START",
        "equals",
        "tokenType",
        "lexerPosition",
        "lexer",
        "getCurrentPosition",
        "nestedTagBlock",
        "find",
        "lexer",
        "nestedTagBlock",
        "lexer",
        "restore",
        "lexerPosition",
        "lexer",
        "advance",
        "XmlTokenType",
        "XML_END_TAG_START",
        "equals",
        "tokenType",
        "ie",
        "lexer",
        "getCurrentPosition",
        "getOffset",
        "lexer",
        "advance",
        "XmlTokenType",
        "XML_NAME",
        "lexer",
        "getTokenType",
        "name",
        "equals",
        "lexer",
        "getTokenText",
        "toUpperCase",
        "oe",
        "lexer",
        "getCurrentPosition",
        "getOffset",
        "lexer",
        "getTokenText",
        "length",
        "lexer",
        "advance",
        "ie",
        "oe",
        "name",
        "lexer",
        "ob",
        "ib",
        "name",
        "lexer",
        "getTokenType",
        "XmlTokenType",
        "XML_START_TAG_START",
        "ob",
        "lexer",
        "getCurrentPosition",
        "getOffset",
        "lexer",
        "advance",
        "lexer",
        "getTokenType",
        "XmlTokenType",
        "XML_NAME",
        "name",
        "lexer",
        "getTokenText",
        "toUpperCase",
        "lexer",
        "getTokenType",
        "XmlTokenType",
        "XML_TAG_END",
        "lexer",
        "getTokenType",
        "lexer",
        "advance",
        "lexer",
        "getTokenType",
        "XmlTokenType",
        "XML_TAG_END",
        "ib",
        "lexer",
        "getCurrentPosition",
        "getOffset",
        "ob",
        "ib",
        "name"
    ],
    "literals": [
        "\"TagBlock{\"",
        "\"os=\"",
        "\", is=\"",
        "\", ie=\"",
        "\", oe=\"",
        "\", name='\""
    ],
    "variables": [
        "ob",
        "ib",
        "name"
    ],
    "comments": [
        "outer start",
        "inner start",
        "inner end",
        "outer end",
        "name of the tag",
        "we can do thig since TagBlock is immutable",
        "NOOP",
        "inner end. ie: position of '</' form",
        "outer end. ie: the last closing '>' of tag block",
        "maybe a nested tag block",
        "this is not a valid nested tag",
        "we resume parsing at opening of 'not nested tag'",
        "we resume parsing at end of nested tag",
        "outer begin, ie: first '<' of the tag block",
        "inner begin, ie: closing '>' of the opening tag of tag block",
        "",
        "",
        ""
    ],
    "docstrings": [
        "* Helper class for manipulating tag blocks.\n * We try to comply as much as possible to the specs\n * of a tag block in vim: http://vimdoc.sourceforge.net/htmldoc/motion.html#tag-blocks",
        "* Represents a tag block.\n   * It has a name\n   * a inner/outer start position\n   * and an inner/outer end position\n   *\n   * Note that a TagBlock has sense only in context of a text parsed text.\n   * therefore there is no equals/hashcode semantics.\n   * Also note that a TagBlock is immutable.",
        "find the nearest tag block positioned forward in seq",
        "*********************************************\n     *\n     * state machine which:\n     * 1 look for an open tag form : <name *...*>\n     * 2 when opening tag found, look for the end tag form: </name\n     *   2.* if we find an open tag form during end tag form lookup,\n     *       recursively find tag block (step 1).\n     *       Any nested tag block is discarded, the parsing continues after\n     *       the nested tag block.\n     *       If the nested tag block is malformed (or it was not a tag block)\n     *       parsing resumes before the nested tag block.\n     *\n     * ********************************************"
    ],
    "functions": [
        "TagBlock",
        "TagBlock",
        "TagBlock",
        "merge",
        "getOuterStart",
        "getInnerStart",
        "getInnerEnd",
        "getOuterEnd",
        "length",
        "getName",
        "toString",
        "TagBlock",
        "find",
        "TagBlock",
        "find",
        "TagBlock",
        "lookForClosingTag",
        "TagBlock",
        "lookForOpeningTag"
    ],
    "classes": [
        "TagBlockHelper",
        "TagBlock"
    ]
}