{
    "identifiers": [
        "absolute_import",
        "division",
        "print_function",
        "numpy",
        "np",
        "re",
        "six",
        "moves",
        "os",
        "threading",
        "warnings",
        "multiprocessing",
        "pool",
        "keras_preprocessing",
        "get_keras_submodule",
        "get_keras_submodule",
        "Sequence",
        "ImportError",
        "PIL",
        "ImageEnhance",
        "PIL",
        "Image",
        "pil_image",
        "ImportError",
        "scipy",
        "scipy",
        "linalg",
        "scipy",
        "ndimage",
        "ImportError",
        "pil_image",
        "pil_image",
        "NEAREST",
        "pil_image",
        "BILINEAR",
        "pil_image",
        "BICUBIC",
        "hasattr",
        "pil_image",
        "pil_image",
        "HAMMING",
        "hasattr",
        "pil_image",
        "pil_image",
        "BOX",
        "hasattr",
        "pil_image",
        "pil_image",
        "LANCZOS",
        "x",
        "rg",
        "row_axis",
        "col_axis",
        "channel_axis",
        "fill_mode",
        "cval",
        "np",
        "random",
        "uniform",
        "rg",
        "rg",
        "apply_affine_transform",
        "x",
        "theta",
        "theta",
        "channel_axis",
        "channel_axis",
        "fill_mode",
        "fill_mode",
        "cval",
        "cval",
        "x",
        "x",
        "wrg",
        "hrg",
        "row_axis",
        "col_axis",
        "channel_axis",
        "fill_mode",
        "cval",
        "x",
        "shape",
        "row_axis",
        "x",
        "shape",
        "col_axis",
        "np",
        "random",
        "uniform",
        "hrg",
        "hrg",
        "h",
        "np",
        "random",
        "uniform",
        "wrg",
        "wrg",
        "w",
        "apply_affine_transform",
        "x",
        "tx",
        "tx",
        "ty",
        "ty",
        "channel_axis",
        "channel_axis",
        "fill_mode",
        "fill_mode",
        "cval",
        "cval",
        "x",
        "x",
        "intensity",
        "row_axis",
        "col_axis",
        "channel_axis",
        "fill_mode",
        "cval",
        "np",
        "random",
        "uniform",
        "intensity",
        "intensity",
        "apply_affine_transform",
        "x",
        "shear",
        "shear",
        "channel_axis",
        "channel_axis",
        "fill_mode",
        "fill_mode",
        "cval",
        "cval",
        "x",
        "x",
        "zoom_range",
        "row_axis",
        "col_axis",
        "channel_axis",
        "fill_mode",
        "cval",
        "len",
        "zoom_range",
        "ValueError",
        "zoom_range",
        "zoom_range",
        "zoom_range",
        "np",
        "random",
        "uniform",
        "zoom_range",
        "zoom_range",
        "apply_affine_transform",
        "x",
        "zx",
        "zx",
        "zy",
        "zy",
        "channel_axis",
        "channel_axis",
        "fill_mode",
        "fill_mode",
        "cval",
        "cval",
        "x",
        "x",
        "intensity",
        "channel_axis",
        "np",
        "rollaxis",
        "x",
        "channel_axis",
        "np",
        "min",
        "x",
        "np",
        "max",
        "x",
        "np",
        "clip",
        "x_channel",
        "intensity",
        "min_x",
        "max_x",
        "x_channel",
        "x",
        "np",
        "stack",
        "channel_images",
        "axis",
        "np",
        "rollaxis",
        "x",
        "channel_axis",
        "x",
        "x",
        "intensity_range",
        "channel_axis",
        "np",
        "random",
        "uniform",
        "intensity_range",
        "intensity_range",
        "apply_channel_shift",
        "x",
        "intensity",
        "channel_axis",
        "channel_axis",
        "x",
        "brightness",
        "ImageEnhance",
        "ImportError",
        "array_to_img",
        "x",
        "ImageEnhance",
        "Brightness",
        "x",
        "imgenhancer_Brightness",
        "enhance",
        "brightness",
        "img_to_array",
        "x",
        "x",
        "x",
        "brightness_range",
        "len",
        "brightness_range",
        "ValueError",
        "brightness_range",
        "np",
        "random",
        "uniform",
        "brightness_range",
        "brightness_range",
        "apply_brightness_shift",
        "x",
        "u",
        "matrix",
        "x",
        "y",
        "x",
        "y",
        "np",
        "array",
        "o_x",
        "o_y",
        "np",
        "array",
        "o_x",
        "o_y",
        "np",
        "dot",
        "np",
        "dot",
        "offset_matrix",
        "matrix",
        "reset_matrix",
        "transform_matrix",
        "x",
        "theta",
        "tx",
        "ty",
        "shear",
        "zx",
        "zy",
        "row_axis",
        "col_axis",
        "channel_axis",
        "fill_mode",
        "cval",
        "scipy",
        "ImportError",
        "theta",
        "np",
        "deg2rad",
        "theta",
        "np",
        "array",
        "np",
        "cos",
        "theta",
        "np",
        "sin",
        "theta",
        "np",
        "sin",
        "theta",
        "np",
        "cos",
        "theta",
        "rotation_matrix",
        "tx",
        "ty",
        "np",
        "array",
        "tx",
        "ty",
        "transform_matrix",
        "shift_matrix",
        "np",
        "dot",
        "transform_matrix",
        "shift_matrix",
        "shear",
        "np",
        "deg2rad",
        "shear",
        "np",
        "array",
        "np",
        "sin",
        "shear",
        "np",
        "cos",
        "shear",
        "transform_matrix",
        "shear_matrix",
        "np",
        "dot",
        "transform_matrix",
        "shear_matrix",
        "zx",
        "zy",
        "np",
        "array",
        "zx",
        "zy",
        "transform_matrix",
        "zoom_matrix",
        "np",
        "dot",
        "transform_matrix",
        "zoom_matrix",
        "transform_matrix",
        "x",
        "shape",
        "row_axis",
        "x",
        "shape",
        "col_axis",
        "transform_matrix_offset_center",
        "transform_matrix",
        "h",
        "w",
        "np",
        "rollaxis",
        "x",
        "channel_axis",
        "transform_matrix",
        "transform_matrix",
        "scipy",
        "ndimage",
        "interpolation",
        "affine_transform",
        "x_channel",
        "final_affine_matrix",
        "final_offset",
        "order",
        "mode",
        "fill_mode",
        "cval",
        "cval",
        "x_channel",
        "x",
        "np",
        "stack",
        "channel_images",
        "axis",
        "np",
        "rollaxis",
        "x",
        "channel_axis",
        "x",
        "x",
        "axis",
        "np",
        "asarray",
        "x",
        "swapaxes",
        "axis",
        "x",
        "x",
        "swapaxes",
        "axis",
        "x",
        "x",
        "data_format",
        "scale",
        "dtype",
        "pil_image",
        "ImportError",
        "np",
        "asarray",
        "x",
        "dtype",
        "dtype",
        "x",
        "ndim",
        "ValueError",
        "x",
        "shape",
        "data_format",
        "ValueError",
        "data_format",
        "data_format",
        "x",
        "transpose",
        "scale",
        "x",
        "max",
        "np",
        "min",
        "x",
        "np",
        "max",
        "x",
        "x_max",
        "x",
        "x_max",
        "x",
        "x",
        "shape",
        "pil_image",
        "fromarray",
        "x",
        "astype",
        "x",
        "shape",
        "pil_image",
        "fromarray",
        "x",
        "astype",
        "x",
        "shape",
        "pil_image",
        "fromarray",
        "x",
        "astype",
        "ValueError",
        "x",
        "shape",
        "img",
        "data_format",
        "dtype",
        "data_format",
        "ValueError",
        "data_format",
        "np",
        "asarray",
        "img",
        "dtype",
        "dtype",
        "len",
        "x",
        "shape",
        "data_format",
        "x",
        "transpose",
        "len",
        "x",
        "shape",
        "data_format",
        "x",
        "reshape",
        "x",
        "shape",
        "x",
        "shape",
        "x",
        "reshape",
        "x",
        "shape",
        "x",
        "shape",
        "ValueError",
        "x",
        "shape",
        "x",
        "path",
        "x",
        "data_format",
        "file_format",
        "scale",
        "kwargs",
        "array_to_img",
        "x",
        "data_format",
        "data_format",
        "scale",
        "scale",
        "img",
        "mode",
        "file_format",
        "file_format",
        "warnings",
        "warn",
        "img",
        "convert",
        "img",
        "save",
        "path",
        "format",
        "file_format",
        "kwargs",
        "path",
        "grayscale",
        "color_mode",
        "target_size",
        "interpolation",
        "grayscale",
        "warnings",
        "warn",
        "pil_image",
        "ImportError",
        "pil_image",
        "open",
        "path",
        "color_mode",
        "img",
        "mode",
        "img",
        "convert",
        "color_mode",
        "img",
        "mode",
        "img",
        "convert",
        "color_mode",
        "img",
        "mode",
        "img",
        "convert",
        "ValueError",
        "target_size",
        "target_size",
        "target_size",
        "img",
        "size",
        "width_height_tuple",
        "interpolation",
        "_PIL_INTERPOLATION_METHODS",
        "ValueError",
        "format",
        "interpolation",
        "join",
        "_PIL_INTERPOLATION_METHODS",
        "keys",
        "_PIL_INTERPOLATION_METHODS",
        "interpolation",
        "img",
        "resize",
        "width_height_tuple",
        "resample",
        "img",
        "directory",
        "ext",
        "os",
        "path",
        "join",
        "root",
        "f",
        "root",
        "_",
        "files",
        "os",
        "walk",
        "directory",
        "f",
        "files",
        "re",
        "match",
        "ext",
        "f",
        "lower",
        "featurewise_center",
        "samplewise_center",
        "featurewise_std_normalization",
        "samplewise_std_normalization",
        "zca_whitening",
        "zca_epsilon",
        "rotation_range",
        "width_shift_range",
        "height_shift_range",
        "brightness_range",
        "shear_range",
        "zoom_range",
        "channel_shift_range",
        "fill_mode",
        "cval",
        "horizontal_flip",
        "vertical_flip",
        "rescale",
        "preprocessing_function",
        "data_format",
        "validation_split",
        "dtype",
        "featurewise_center",
        "samplewise_center",
        "featurewise_std_normalization",
        "samplewise_std_normalization",
        "zca_whitening",
        "zca_epsilon",
        "rotation_range",
        "width_shift_range",
        "height_shift_range",
        "brightness_range",
        "shear_range",
        "zoom_range",
        "channel_shift_range",
        "fill_mode",
        "cval",
        "horizontal_flip",
        "vertical_flip",
        "rescale",
        "preprocessing_function",
        "dtype",
        "data_format",
        "ValueError",
        "data_format",
        "data_format",
        "data_format",
        "data_format",
        "validation_split",
        "validation_split",
        "ValueError",
        "validation_split",
        "validation_split",
        "np",
        "isscalar",
        "zoom_range",
        "zoom_range",
        "zoom_range",
        "len",
        "zoom_range",
        "zoom_range",
        "zoom_range",
        "ValueError",
        "zoom_range",
        "zca_whitening",
        "featurewise_center",
        "warnings",
        "warn",
        "featurewise_std_normalization",
        "warnings",
        "warn",
        "featurewise_std_normalization",
        "featurewise_center",
        "warnings",
        "warn",
        "samplewise_std_normalization",
        "samplewise_center",
        "warnings",
        "warn",
        "x",
        "y",
        "batch_size",
        "shuffle",
        "sample_weight",
        "seed",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "subset",
        "NumpyArrayIterator",
        "x",
        "y",
        "batch_size",
        "batch_size",
        "shuffle",
        "shuffle",
        "sample_weight",
        "sample_weight",
        "seed",
        "seed",
        "data_format",
        "data_format",
        "save_to_dir",
        "save_to_dir",
        "save_prefix",
        "save_prefix",
        "save_format",
        "save_format",
        "subset",
        "subset",
        "directory",
        "target_size",
        "color_mode",
        "classes",
        "class_mode",
        "batch_size",
        "shuffle",
        "seed",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "follow_links",
        "subset",
        "interpolation",
        "DirectoryIterator",
        "directory",
        "target_size",
        "target_size",
        "color_mode",
        "color_mode",
        "classes",
        "classes",
        "class_mode",
        "class_mode",
        "data_format",
        "data_format",
        "batch_size",
        "batch_size",
        "shuffle",
        "shuffle",
        "seed",
        "seed",
        "save_to_dir",
        "save_to_dir",
        "save_prefix",
        "save_prefix",
        "save_format",
        "save_format",
        "follow_links",
        "follow_links",
        "subset",
        "subset",
        "interpolation",
        "interpolation",
        "dataframe",
        "directory",
        "x_col",
        "y_col",
        "has_ext",
        "target_size",
        "color_mode",
        "classes",
        "class_mode",
        "batch_size",
        "shuffle",
        "seed",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "subset",
        "interpolation",
        "DataFrameIterator",
        "dataframe",
        "directory",
        "x_col",
        "x_col",
        "y_col",
        "y_col",
        "has_ext",
        "has_ext",
        "target_size",
        "target_size",
        "color_mode",
        "color_mode",
        "classes",
        "classes",
        "class_mode",
        "class_mode",
        "data_format",
        "data_format",
        "batch_size",
        "batch_size",
        "shuffle",
        "shuffle",
        "seed",
        "seed",
        "save_to_dir",
        "save_to_dir",
        "save_prefix",
        "save_prefix",
        "save_format",
        "save_format",
        "subset",
        "subset",
        "interpolation",
        "interpolation",
        "x",
        "preprocessing_function",
        "preprocessing_function",
        "x",
        "rescale",
        "x",
        "rescale",
        "samplewise_center",
        "x",
        "np",
        "mean",
        "x",
        "keepdims",
        "samplewise_std_normalization",
        "x",
        "np",
        "std",
        "x",
        "keepdims",
        "featurewise_center",
        "mean",
        "x",
        "mean",
        "warnings",
        "warn",
        "featurewise_std_normalization",
        "std",
        "x",
        "std",
        "warnings",
        "warn",
        "zca_whitening",
        "principal_components",
        "np",
        "reshape",
        "x",
        "np",
        "prod",
        "x",
        "shape",
        "np",
        "dot",
        "flatx",
        "principal_components",
        "np",
        "reshape",
        "whitex",
        "x",
        "shape",
        "warnings",
        "warn",
        "x",
        "img_shape",
        "seed",
        "row_axis",
        "col_axis",
        "seed",
        "np",
        "random",
        "seed",
        "seed",
        "rotation_range",
        "np",
        "random",
        "uniform",
        "rotation_range",
        "rotation_range",
        "height_shift_range",
        "np",
        "random",
        "choice",
        "height_shift_range",
        "tx",
        "np",
        "random",
        "choice",
        "ValueError",
        "np",
        "random",
        "uniform",
        "height_shift_range",
        "height_shift_range",
        "np",
        "max",
        "height_shift_range",
        "tx",
        "img_shape",
        "img_row_axis",
        "width_shift_range",
        "np",
        "random",
        "choice",
        "width_shift_range",
        "ty",
        "np",
        "random",
        "choice",
        "ValueError",
        "np",
        "random",
        "uniform",
        "width_shift_range",
        "width_shift_range",
        "np",
        "max",
        "width_shift_range",
        "ty",
        "img_shape",
        "img_col_axis",
        "shear_range",
        "np",
        "random",
        "uniform",
        "shear_range",
        "shear_range",
        "zoom_range",
        "zoom_range",
        "np",
        "random",
        "uniform",
        "zoom_range",
        "zoom_range",
        "np",
        "random",
        "random",
        "horizontal_flip",
        "np",
        "random",
        "random",
        "vertical_flip",
        "channel_shift_range",
        "np",
        "random",
        "uniform",
        "channel_shift_range",
        "channel_shift_range",
        "brightness_range",
        "len",
        "brightness_range",
        "ValueError",
        "brightness_range",
        "np",
        "random",
        "uniform",
        "brightness_range",
        "brightness_range",
        "theta",
        "tx",
        "ty",
        "shear",
        "zx",
        "zy",
        "flip_horizontal",
        "flip_vertical",
        "channel_shift_intensity",
        "brightness",
        "transform_parameters",
        "x",
        "transform_parameters",
        "row_axis",
        "col_axis",
        "channel_axis",
        "apply_affine_transform",
        "x",
        "transform_parameters",
        "get",
        "transform_parameters",
        "get",
        "transform_parameters",
        "get",
        "transform_parameters",
        "get",
        "transform_parameters",
        "get",
        "transform_parameters",
        "get",
        "row_axis",
        "img_row_axis",
        "col_axis",
        "img_col_axis",
        "channel_axis",
        "img_channel_axis",
        "fill_mode",
        "fill_mode",
        "cval",
        "cval",
        "transform_parameters",
        "get",
        "apply_channel_shift",
        "x",
        "transform_parameters",
        "img_channel_axis",
        "transform_parameters",
        "get",
        "flip_axis",
        "x",
        "img_col_axis",
        "transform_parameters",
        "get",
        "flip_axis",
        "x",
        "img_row_axis",
        "transform_parameters",
        "get",
        "apply_brightness_shift",
        "x",
        "transform_parameters",
        "x",
        "x",
        "seed",
        "get_random_transform",
        "x",
        "shape",
        "seed",
        "apply_transform",
        "x",
        "x",
        "augment",
        "rounds",
        "seed",
        "np",
        "asarray",
        "x",
        "dtype",
        "dtype",
        "x",
        "ndim",
        "ValueError",
        "x",
        "shape",
        "x",
        "shape",
        "channel_axis",
        "warnings",
        "warn",
        "data_format",
        "channel_axis",
        "channel_axis",
        "x",
        "shape",
        "x",
        "shape",
        "channel_axis",
        "seed",
        "np",
        "random",
        "seed",
        "seed",
        "np",
        "copy",
        "x",
        "augment",
        "np",
        "zeros",
        "rounds",
        "x",
        "shape",
        "x",
        "shape",
        "dtype",
        "dtype",
        "r",
        "rounds",
        "i",
        "x",
        "shape",
        "i",
        "r",
        "x",
        "shape",
        "random_transform",
        "x",
        "i",
        "ax",
        "featurewise_center",
        "np",
        "mean",
        "x",
        "axis",
        "row_axis",
        "col_axis",
        "channel_axis",
        "x",
        "shape",
        "channel_axis",
        "np",
        "reshape",
        "mean",
        "broadcast_shape",
        "x",
        "mean",
        "featurewise_std_normalization",
        "np",
        "std",
        "x",
        "axis",
        "row_axis",
        "col_axis",
        "channel_axis",
        "x",
        "shape",
        "channel_axis",
        "np",
        "reshape",
        "std",
        "broadcast_shape",
        "x",
        "std",
        "zca_whitening",
        "scipy",
        "ImportError",
        "np",
        "reshape",
        "x",
        "x",
        "shape",
        "x",
        "shape",
        "x",
        "shape",
        "x",
        "shape",
        "np",
        "dot",
        "flat_x",
        "T",
        "flat_x",
        "flat_x",
        "shape",
        "scipy",
        "linalg",
        "svd",
        "sigma",
        "np",
        "sqrt",
        "s",
        "np",
        "newaxis",
        "zca_epsilon",
        "u",
        "s_inv",
        "dot",
        "u",
        "T",
        "IteratorType",
        "n",
        "batch_size",
        "shuffle",
        "seed",
        "n",
        "batch_size",
        "seed",
        "shuffle",
        "threading",
        "Lock",
        "_flow_index",
        "np",
        "arange",
        "n",
        "shuffle",
        "np",
        "random",
        "permutation",
        "n",
        "idx",
        "idx",
        "len",
        "ValueError",
        "format",
        "idx",
        "idx",
        "length",
        "len",
        "seed",
        "np",
        "random",
        "seed",
        "seed",
        "total_batches_seen",
        "total_batches_seen",
        "index_array",
        "_set_index_array",
        "index_array",
        "batch_size",
        "idx",
        "batch_size",
        "idx",
        "_get_batches_of_transformed_samples",
        "index_array",
        "image_data_generator",
        "target_size",
        "color_mode",
        "data_format",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "subset",
        "interpolation",
        "image_data_generator",
        "target_size",
        "color_mode",
        "ValueError",
        "color_mode",
        "color_mode",
        "data_format",
        "color_mode",
        "data_format",
        "target_size",
        "target_size",
        "color_mode",
        "data_format",
        "target_size",
        "target_size",
        "data_format",
        "target_size",
        "target_size",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "interpolation",
        "subset",
        "image_data_generator",
        "_validation_split",
        "subset",
        "validation_split",
        "subset",
        "validation_split",
        "ValueError",
        "subset",
        "split",
        "subset",
        "n",
        "batch_size",
        "batch_size",
        "_set_index_array",
        "reset",
        "seed",
        "np",
        "random",
        "seed",
        "seed",
        "total_batches_seen",
        "batch_index",
        "_set_index_array",
        "batch_index",
        "batch_size",
        "n",
        "n",
        "current_index",
        "batch_size",
        "batch_index",
        "total_batches_seen",
        "index_array",
        "current_index",
        "current_index",
        "batch_size",
        "args",
        "kwargs",
        "next",
        "args",
        "kwargs",
        "index_array",
        "NotImplementedError",
        "Iterator",
        "x",
        "y",
        "image_data_generator",
        "batch_size",
        "shuffle",
        "sample_weight",
        "seed",
        "data_format",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "subset",
        "dtype",
        "dtype",
        "x",
        "x",
        "x",
        "np",
        "asarray",
        "x",
        "np",
        "asarray",
        "xx",
        "xx",
        "x",
        "x",
        "xx",
        "x_misc",
        "len",
        "x",
        "len",
        "xx",
        "ValueError",
        "len",
        "x",
        "len",
        "xx",
        "y",
        "len",
        "x",
        "len",
        "y",
        "ValueError",
        "np",
        "asarray",
        "x",
        "shape",
        "np",
        "asarray",
        "y",
        "shape",
        "sample_weight",
        "len",
        "x",
        "len",
        "sample_weight",
        "ValueError",
        "np",
        "asarray",
        "x",
        "shape",
        "np",
        "asarray",
        "sample_weight",
        "shape",
        "subset",
        "subset",
        "ValueError",
        "subset",
        "len",
        "x",
        "image_data_generator",
        "_validation_split",
        "np",
        "array_equal",
        "np",
        "unique",
        "y",
        "split_idx",
        "np",
        "unique",
        "y",
        "split_idx",
        "ValueError",
        "subset",
        "x",
        "split_idx",
        "np",
        "asarray",
        "xx",
        "split_idx",
        "xx",
        "x_misc",
        "y",
        "y",
        "split_idx",
        "x",
        "split_idx",
        "np",
        "asarray",
        "xx",
        "split_idx",
        "xx",
        "x_misc",
        "y",
        "y",
        "split_idx",
        "np",
        "asarray",
        "x",
        "dtype",
        "dtype",
        "x_misc",
        "x",
        "ndim",
        "ValueError",
        "x",
        "shape",
        "data_format",
        "x",
        "shape",
        "channels_axis",
        "warnings",
        "warn",
        "data_format",
        "channels_axis",
        "channels_axis",
        "x",
        "shape",
        "x",
        "shape",
        "channels_axis",
        "y",
        "np",
        "asarray",
        "y",
        "sample_weight",
        "np",
        "asarray",
        "sample_weight",
        "image_data_generator",
        "data_format",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "NumpyArrayIterator",
        "x",
        "shape",
        "batch_size",
        "shuffle",
        "seed",
        "index_array",
        "np",
        "zeros",
        "len",
        "index_array",
        "x",
        "shape",
        "dtype",
        "dtype",
        "i",
        "j",
        "index_array",
        "x",
        "j",
        "image_data_generator",
        "get_random_transform",
        "x",
        "shape",
        "image_data_generator",
        "apply_transform",
        "x",
        "astype",
        "dtype",
        "image_data_generator",
        "standardize",
        "x",
        "x",
        "save_to_dir",
        "i",
        "j",
        "index_array",
        "array_to_img",
        "batch_x",
        "i",
        "data_format",
        "scale",
        "format",
        "prefix",
        "save_prefix",
        "index",
        "j",
        "hash",
        "np",
        "random",
        "randint",
        "format",
        "save_format",
        "img",
        "save",
        "os",
        "path",
        "join",
        "save_to_dir",
        "fname",
        "xx",
        "index_array",
        "xx",
        "x_misc",
        "batch_x",
        "batch_x_miscs",
        "batch_x",
        "batch_x_miscs",
        "y",
        "output",
        "output",
        "y",
        "index_array",
        "sample_weight",
        "output",
        "sample_weight",
        "index_array",
        "output",
        "next",
        "index_generator",
        "_get_batches_of_transformed_samples",
        "index_array",
        "directory",
        "white_list_formats",
        "follow_links",
        "subpath",
        "sorted",
        "os",
        "walk",
        "subpath",
        "followlinks",
        "follow_links",
        "key",
        "x",
        "x",
        "root",
        "_",
        "files",
        "_recursive_list",
        "directory",
        "fname",
        "sorted",
        "files",
        "extension",
        "white_list_formats",
        "fname",
        "lower",
        "endswith",
        "warnings",
        "warn",
        "fname",
        "lower",
        "endswith",
        "extension",
        "root",
        "fname",
        "directory",
        "white_list_formats",
        "split",
        "class_indices",
        "follow_links",
        "df",
        "os",
        "path",
        "basename",
        "directory",
        "split",
        "len",
        "_iter_valid_files",
        "directory",
        "white_list_formats",
        "follow_links",
        "split",
        "num_files",
        "split",
        "num_files",
        "_iter_valid_files",
        "directory",
        "white_list_formats",
        "follow_links",
        "start",
        "stop",
        "_iter_valid_files",
        "directory",
        "white_list_formats",
        "follow_links",
        "df",
        "root",
        "fname",
        "valid_files",
        "filenames",
        "append",
        "os",
        "path",
        "basename",
        "fname",
        "filenames",
        "root",
        "fname",
        "valid_files",
        "classes",
        "append",
        "class_indices",
        "dirname",
        "os",
        "path",
        "join",
        "root",
        "fname",
        "os",
        "path",
        "join",
        "dirname",
        "os",
        "path",
        "relpath",
        "absolute_path",
        "directory",
        "filenames",
        "append",
        "relative_path",
        "classes",
        "filenames",
        "Iterator",
        "directory",
        "image_data_generator",
        "target_size",
        "color_mode",
        "classes",
        "class_mode",
        "batch_size",
        "shuffle",
        "seed",
        "data_format",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "follow_links",
        "subset",
        "interpolation",
        "dtype",
        "DirectoryIterator",
        "common_init",
        "image_data_generator",
        "target_size",
        "color_mode",
        "data_format",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "subset",
        "interpolation",
        "directory",
        "classes",
        "class_mode",
        "ValueError",
        "class_mode",
        "class_mode",
        "dtype",
        "classes",
        "subdir",
        "sorted",
        "os",
        "listdir",
        "directory",
        "os",
        "path",
        "isdir",
        "os",
        "path",
        "join",
        "directory",
        "subdir",
        "classes",
        "append",
        "subdir",
        "len",
        "classes",
        "classes",
        "len",
        "classes",
        "multiprocessing",
        "pool",
        "ThreadPool",
        "dirpath",
        "os",
        "path",
        "join",
        "directory",
        "subdir",
        "subdir",
        "classes",
        "results",
        "append",
        "pool",
        "apply_async",
        "_list_valid_filenames_in_directory",
        "dirpath",
        "white_list_formats",
        "split",
        "class_indices",
        "follow_links",
        "res",
        "results",
        "res",
        "get",
        "classes_list",
        "append",
        "classes",
        "filenames",
        "filenames",
        "len",
        "filenames",
        "np",
        "zeros",
        "samples",
        "dtype",
        "classes",
        "classes_list",
        "classes",
        "i",
        "i",
        "len",
        "classes",
        "classes",
        "i",
        "len",
        "classes",
        "samples",
        "num_classes",
        "pool",
        "close",
        "pool",
        "join",
        "DirectoryIterator",
        "samples",
        "batch_size",
        "shuffle",
        "seed",
        "index_array",
        "np",
        "zeros",
        "len",
        "index_array",
        "image_shape",
        "dtype",
        "dtype",
        "i",
        "j",
        "index_array",
        "filenames",
        "j",
        "load_img",
        "os",
        "path",
        "join",
        "directory",
        "fname",
        "color_mode",
        "color_mode",
        "target_size",
        "target_size",
        "interpolation",
        "interpolation",
        "img_to_array",
        "img",
        "data_format",
        "data_format",
        "hasattr",
        "img",
        "img",
        "close",
        "image_data_generator",
        "get_random_transform",
        "x",
        "shape",
        "image_data_generator",
        "apply_transform",
        "x",
        "image_data_generator",
        "standardize",
        "x",
        "x",
        "save_to_dir",
        "i",
        "j",
        "index_array",
        "array_to_img",
        "batch_x",
        "i",
        "data_format",
        "scale",
        "format",
        "prefix",
        "save_prefix",
        "index",
        "j",
        "hash",
        "np",
        "random",
        "randint",
        "format",
        "save_format",
        "img",
        "save",
        "os",
        "path",
        "join",
        "save_to_dir",
        "fname",
        "class_mode",
        "batch_x",
        "copy",
        "class_mode",
        "classes",
        "index_array",
        "class_mode",
        "classes",
        "index_array",
        "astype",
        "dtype",
        "class_mode",
        "np",
        "zeros",
        "len",
        "batch_x",
        "num_classes",
        "dtype",
        "dtype",
        "i",
        "label",
        "classes",
        "index_array",
        "batch_x",
        "batch_x",
        "batch_y",
        "next",
        "index_generator",
        "_get_batches_of_transformed_samples",
        "index_array",
        "Iterator",
        "dataframe",
        "directory",
        "image_data_generator",
        "x_col",
        "y_col",
        "has_ext",
        "target_size",
        "color_mode",
        "classes",
        "class_mode",
        "batch_size",
        "shuffle",
        "seed",
        "data_format",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "follow_links",
        "subset",
        "interpolation",
        "dtype",
        "DataFrameIterator",
        "common_init",
        "image_data_generator",
        "target_size",
        "color_mode",
        "data_format",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "subset",
        "interpolation",
        "pandas",
        "pd",
        "ImportError",
        "ImportError",
        "x_col",
        "ValueError",
        "has_ext",
        "ValueError",
        "dataframe",
        "drop_duplicates",
        "x_col",
        "df",
        "df",
        "x_col",
        "astype",
        "directory",
        "classes",
        "class_mode",
        "ValueError",
        "class_mode",
        "class_mode",
        "dtype",
        "classes",
        "class_mode",
        "df",
        "y_col",
        "unique",
        "class_mode",
        "ValueError",
        "len",
        "classes",
        "classes",
        "len",
        "classes",
        "np",
        "zeros",
        "samples",
        "dtype",
        "_list_valid_filenames_in_directory",
        "directory",
        "white_list_formats",
        "split",
        "class_indices",
        "class_indices",
        "follow_links",
        "follow_links",
        "df",
        "has_ext",
        "ext",
        "white_list_formats",
        "df",
        "loc",
        "x_col",
        "endswith",
        "ext",
        "ext_exist",
        "ValueError",
        "pd",
        "DataFrame",
        "x_col",
        "filenames",
        "dtype",
        "df",
        "merge",
        "temp_df",
        "how",
        "on",
        "x_col",
        "temp_df",
        "set_index",
        "x_col",
        "temp_df",
        "reindex",
        "filenames",
        "temp_df",
        "dropna",
        "temp_df",
        "index",
        "f",
        "len",
        "f",
        "split",
        "f",
        "f",
        "filenames",
        "f",
        "len",
        "f",
        "split",
        "f",
        "filenames",
        "pd",
        "DataFrame",
        "x_col",
        "filenames_without_ext",
        "dtype",
        "df",
        "merge",
        "temp_df",
        "how",
        "on",
        "x_col",
        "temp_df",
        "set_index",
        "x_col",
        "temp_df",
        "reindex",
        "filenames_without_ext",
        "temp_df",
        "dropna",
        "without_ext_with",
        "f",
        "f",
        "temp_df",
        "index",
        "temp_df",
        "copy",
        "class_mode",
        "temp_df",
        "y_col",
        "values",
        "np",
        "array",
        "class_indices",
        "cls",
        "cls",
        "classes",
        "class_mode",
        "df",
        "y_col",
        "values",
        "y_col",
        "y_col",
        "df",
        "y_col",
        "dtypes",
        "len",
        "filenames",
        "num_classes",
        "samples",
        "num_classes",
        "samples",
        "DataFrameIterator",
        "samples",
        "batch_size",
        "shuffle",
        "seed",
        "index_array",
        "np",
        "zeros",
        "len",
        "index_array",
        "image_shape",
        "dtype",
        "dtype",
        "i",
        "j",
        "index_array",
        "filenames",
        "j",
        "load_img",
        "os",
        "path",
        "join",
        "directory",
        "fname",
        "color_mode",
        "color_mode",
        "target_size",
        "target_size",
        "interpolation",
        "interpolation",
        "img_to_array",
        "img",
        "data_format",
        "data_format",
        "hasattr",
        "img",
        "img",
        "close",
        "image_data_generator",
        "get_random_transform",
        "x",
        "shape",
        "image_data_generator",
        "apply_transform",
        "x",
        "image_data_generator",
        "standardize",
        "x",
        "x",
        "save_to_dir",
        "i",
        "j",
        "index_array",
        "array_to_img",
        "batch_x",
        "i",
        "data_format",
        "scale",
        "format",
        "prefix",
        "save_prefix",
        "index",
        "j",
        "hash",
        "np",
        "random",
        "randint",
        "format",
        "save_format",
        "img",
        "save",
        "os",
        "path",
        "join",
        "save_to_dir",
        "fname",
        "class_mode",
        "batch_x",
        "copy",
        "class_mode",
        "classes",
        "index_array",
        "class_mode",
        "classes",
        "index_array",
        "astype",
        "dtype",
        "class_mode",
        "np",
        "zeros",
        "len",
        "batch_x",
        "num_classes",
        "dtype",
        "dtype",
        "i",
        "label",
        "classes",
        "index_array",
        "class_mode",
        "data",
        "index_array",
        "batch_x",
        "batch_x",
        "batch_y",
        "next",
        "index_generator",
        "_get_batches_of_transformed_samples",
        "index_array"
    ],
    "literals": [
        "'utils'",
        "'nearest'",
        "'bilinear'",
        "'bicubic'",
        "'HAMMING'",
        "'hamming'",
        "'BOX'",
        "'box'",
        "'LANCZOS'",
        "'lanczos'",
        "'nearest'",
        "'nearest'",
        "'nearest'",
        "'nearest'",
        "'`zoom_range` should be a tuple or list of two'",
        "' floats. Received: %s'",
        "'Using brightness shifts requires PIL. '",
        "'Install PIL or Pillow.'",
        "'`brightness_range should be tuple or list of two floats. '",
        "'Received: %s'",
        "'nearest'",
        "'Image transformations require SciPy. '",
        "'Install SciPy.'",
        "'channels_last'",
        "'float32'",
        "'Could not import PIL.Image. '",
        "'The use of `array_to_img` requires PIL.'",
        "'Expected image array to have rank 3 (single image). '",
        "'Got array with shape: %s'",
        "'channels_first'",
        "'channels_last'",
        "'Invalid data_format: %s'",
        "'channels_first'",
        "'uint8'",
        "'RGBA'",
        "'uint8'",
        "'RGB'",
        "'uint8'",
        "'L'",
        "'Unsupported channel number: %s'",
        "'channels_last'",
        "'float32'",
        "'channels_first'",
        "'channels_last'",
        "'Unknown data_format: %s'",
        "'channels_first'",
        "'channels_first'",
        "'Unsupported image shape: %s'",
        "'channels_last'",
        "'RGBA'",
        "'jpg'",
        "'jpeg'",
        "'The JPG format does not support '",
        "'RGBA images, converting to RGB.'",
        "'RGB'",
        "'rgb'",
        "'nearest'",
        "'grayscale is deprecated. Please use '",
        "'color_mode = \"grayscale\"'",
        "'grayscale'",
        "'Could not import PIL.Image. '",
        "'The use of `array_to_img` requires PIL.'",
        "'grayscale'",
        "'L'",
        "'L'",
        "'rgba'",
        "'RGBA'",
        "'RGBA'",
        "'rgb'",
        "'RGB'",
        "'RGB'",
        "'color_mode must be \"grayscale\", \"rbg\", or \"rgba\"'",
        "'Invalid interpolation method {} specified. Supported '",
        "'methods are {}'",
        "\", \"",
        "'jpg|jpeg|bmp|png|ppm'",
        "r'([\\w]+\\.(?:'",
        "'))'",
        "'nearest'",
        "'channels_last'",
        "'float32'",
        "'channels_last'",
        "'channels_first'",
        "'`data_format` should be `\"channels_last\"` '",
        "'(channel after row and column) or '",
        "'`\"channels_first\"` (channel before row and column). '",
        "'Received: %s'",
        "'channels_first'",
        "'channels_last'",
        "'`validation_split` must be strictly between 0 and 1. '",
        "' Received: %s'",
        "'`zoom_range` should be a float or '",
        "'a tuple or list of two floats. '",
        "'Received: %s'",
        "'This ImageDataGenerator specifies '",
        "'`zca_whitening`, which overrides '",
        "'setting of `featurewise_center`.'",
        "'This ImageDataGenerator specifies '",
        "'`zca_whitening` '",
        "'which overrides setting of'",
        "'`featurewise_std_normalization`.'",
        "'This ImageDataGenerator specifies '",
        "'`featurewise_std_normalization`, '",
        "'which overrides setting of '",
        "'`featurewise_center`.'",
        "'This ImageDataGenerator specifies '",
        "'`samplewise_std_normalization`, '",
        "'which overrides setting of '",
        "'`samplewise_center`.'",
        "''",
        "'png'",
        "'rgb'",
        "'categorical'",
        "''",
        "'png'",
        "'nearest'",
        "\"filename\"",
        "\"class\"",
        "'rgb'",
        "'categorical'",
        "''",
        "'png'",
        "'nearest'",
        "'This ImageDataGenerator specifies '",
        "'`featurewise_center`, but it hasn\\'t '",
        "'been fit on any training data. Fit it '",
        "'first by calling `.fit(numpy_data)`.'",
        "'This ImageDataGenerator specifies '",
        "'`featurewise_std_normalization`, '",
        "'but it hasn\\'t '",
        "'been fit on any training data. Fit it '",
        "'first by calling `.fit(numpy_data)`.'",
        "'This ImageDataGenerator specifies '",
        "'`zca_whitening`, but it hasn\\'t '",
        "'been fit on any training data. Fit it '",
        "'first by calling `.fit(numpy_data)`.'",
        "'`brightness_range should be tuple or list of two floats. '",
        "'Received: %s'",
        "'theta'",
        "'tx'",
        "'ty'",
        "'shear'",
        "'zx'",
        "'zy'",
        "'flip_horizontal'",
        "'flip_vertical'",
        "'channel_shift_intensity'",
        "'brightness'",
        "'theta'",
        "'tx'",
        "'ty'",
        "'shear'",
        "'zx'",
        "'zy'",
        "'channel_shift_intensity'",
        "'channel_shift_intensity'",
        "'flip_horizontal'",
        "'flip_vertical'",
        "'brightness'",
        "'brightness'",
        "'Input to `.fit()` should have rank 4. '",
        "'Got array with shape: '",
        "'Expected input to be images (as Numpy array) '",
        "'following the data format convention \"'",
        "'\" (channels on axis '",
        "'), i.e. expected '",
        "'either 1, 3 or 4 channels on axis '",
        "'. '",
        "'However, it was passed an array with shape '",
        "' ('",
        "' channels).'",
        "'Using zca_whitening requires SciPy. '",
        "'Install SciPy.'",
        "'Asked to retrieve element {idx}, '",
        "'but the Sequence '",
        "'has length {length}'",
        "'rgb'",
        "'rgba'",
        "'grayscale'",
        "'Invalid color mode:'",
        "'; expected \"rgb\", \"rgba\", or \"grayscale\".'",
        "'rgba'",
        "'channels_last'",
        "'rgb'",
        "'channels_last'",
        "'channels_last'",
        "'validation'",
        "'training'",
        "'Invalid subset name: %s;'",
        "'expected \"training\" or \"validation\"'",
        "'channels_last'",
        "''",
        "'png'",
        "'float32'",
        "'All of the arrays in `x` '",
        "'should have the same length. '",
        "'Found a pair with: len(x[0]) = %s, len(x[?]) = %s'",
        "'`x` (images tensor) and `y` (labels) '",
        "'should have the same length. '",
        "'Found: x.shape = %s, y.shape = %s'",
        "'`x` (images tensor) and `sample_weight` '",
        "'should have the same length. '",
        "'Found: x.shape = %s, sample_weight.shape = %s'",
        "'training'",
        "'validation'",
        "'Invalid subset name:'",
        "'; expected \"training\" or \"validation\".'",
        "'Training and validation subsets '",
        "'have different number of classes after '",
        "'the split. If your numpy arrays are '",
        "'sorted by the label, you might want '",
        "'to shuffle them.'",
        "'validation'",
        "'Input data in `NumpyArrayIterator` '",
        "'should have rank 4. You passed an array '",
        "'with shape'",
        "'channels_last'",
        "'NumpyArrayIterator is set to use the '",
        "'data format convention \"'",
        "'\" '",
        "'(channels on axis '",
        "'), i.e. expected either 1, 3, or 4 '",
        "'channels on axis '",
        "'. '",
        "'However, it was passed an array with shape '",
        "' ('",
        "' channels).'",
        "'{prefix}_{index}_{hash}.{format}'",
        "'.tiff'",
        "'Using \\'.tiff\\' files with multiple bands '",
        "'will cause distortion. '",
        "'Please verify your output.'",
        "'.'",
        "'rgb'",
        "'categorical'",
        "'channels_last'",
        "''",
        "'png'",
        "'nearest'",
        "'float32'",
        "'categorical'",
        "'binary'",
        "'sparse'",
        "'input'",
        "'Invalid class_mode:'",
        "'; expected one of \"categorical\", '",
        "'\"binary\", \"sparse\", \"input\"'",
        "' or None.'",
        "'png'",
        "'jpg'",
        "'jpeg'",
        "'bmp'",
        "'ppm'",
        "'tif'",
        "'tiff'",
        "'int32'",
        "'Found %d images belonging to %d classes.'",
        "'close'",
        "'{prefix}_{index}_{hash}.{format}'",
        "'input'",
        "'sparse'",
        "'binary'",
        "'categorical'",
        "\"filenames\"",
        "\"class\"",
        "'rgb'",
        "'categorical'",
        "''",
        "'png'",
        "'nearest'",
        "'float32'",
        "'Install pandas to use flow_from_dataframe.'",
        "\"x_col must be a string.\"",
        "\"has_ext must be either True if filenames in\"",
        "\" x_col has extensions,else False.\"",
        "'categorical'",
        "'binary'",
        "'sparse'",
        "'input'",
        "'other'",
        "'Invalid class_mode:'",
        "'; expected one of \"categorical\", '",
        "'\"binary\", \"sparse\", \"input\"'",
        "'\"other\" or None.'",
        "'png'",
        "'jpg'",
        "'jpeg'",
        "'bmp'",
        "'ppm'",
        "'tif'",
        "'tiff'",
        "\"other\"",
        "\"input\"",
        "\"other\"",
        "\"input\"",
        "'classes cannot be set if class_mode'",
        "' is either \"other\" or \"input\" or None.'",
        "'int32'",
        "\".\"",
        "'has_ext is set to True but'",
        "' extension not found in x_col'",
        "'right'",
        "\".\"",
        "\".\"",
        "'right'",
        "\"other\"",
        "\"input\"",
        "\"other\"",
        "\"object\"",
        "\"y_col column/s must be numeric datatypes.\"",
        "'Found %d images belonging to %d classes.'",
        "'Found %d images.'",
        "'close'",
        "'{prefix}_{index}_{hash}.{format}'",
        "'input'",
        "'sparse'",
        "'binary'",
        "'categorical'",
        "'other'"
    ],
    "variables": [
        "IteratorType",
        "IteratorType",
        "pil_image",
        "ImageEnhance",
        "scipy",
        "_PIL_INTERPOLATION_METHODS",
        "_PIL_INTERPOLATION_METHODS",
        "_PIL_INTERPOLATION_METHODS",
        "_PIL_INTERPOLATION_METHODS",
        "theta",
        "x",
        "h",
        "w",
        "tx",
        "ty",
        "x",
        "shear",
        "x",
        "zx",
        "zy",
        "zx",
        "zy",
        "x",
        "x",
        "min_x",
        "max_x",
        "channel_images",
        "x",
        "x",
        "intensity",
        "x",
        "x",
        "imgenhancer_Brightness",
        "x",
        "x",
        "u",
        "o_x",
        "o_y",
        "offset_matrix",
        "reset_matrix",
        "transform_matrix",
        "transform_matrix",
        "theta",
        "rotation_matrix",
        "transform_matrix",
        "shift_matrix",
        "transform_matrix",
        "transform_matrix",
        "shear",
        "shear_matrix",
        "transform_matrix",
        "transform_matrix",
        "zoom_matrix",
        "transform_matrix",
        "transform_matrix",
        "h",
        "w",
        "transform_matrix",
        "x",
        "final_affine_matrix",
        "final_offset",
        "channel_images",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x_max",
        "x",
        "x",
        "x",
        "x",
        "img",
        "img",
        "color_mode",
        "img",
        "img",
        "img",
        "img",
        "width_height_tuple",
        "resample",
        "img",
        "featurewise_center",
        "samplewise_center",
        "featurewise_std_normalization",
        "samplewise_std_normalization",
        "zca_whitening",
        "zca_epsilon",
        "rotation_range",
        "width_shift_range",
        "height_shift_range",
        "brightness_range",
        "shear_range",
        "zoom_range",
        "channel_shift_range",
        "fill_mode",
        "cval",
        "horizontal_flip",
        "vertical_flip",
        "rescale",
        "preprocessing_function",
        "dtype",
        "data_format",
        "channel_axis",
        "row_axis",
        "col_axis",
        "channel_axis",
        "row_axis",
        "col_axis",
        "_validation_split",
        "mean",
        "std",
        "principal_components",
        "zoom_range",
        "zoom_range",
        "featurewise_center",
        "featurewise_std_normalization",
        "featurewise_center",
        "samplewise_center",
        "x",
        "flatx",
        "whitex",
        "x",
        "img_row_axis",
        "img_col_axis",
        "theta",
        "theta",
        "tx",
        "tx",
        "tx",
        "ty",
        "ty",
        "ty",
        "shear",
        "shear",
        "zx",
        "zy",
        "zx",
        "zy",
        "flip_horizontal",
        "flip_vertical",
        "channel_shift_intensity",
        "channel_shift_intensity",
        "brightness",
        "brightness",
        "transform_parameters",
        "img_row_axis",
        "img_col_axis",
        "img_channel_axis",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "ax",
        "ax",
        "x",
        "mean",
        "broadcast_shape",
        "broadcast_shape",
        "mean",
        "std",
        "broadcast_shape",
        "broadcast_shape",
        "std",
        "flat_x",
        "sigma",
        "u",
        "s",
        "_",
        "s_inv",
        "principal_components",
        "n",
        "batch_size",
        "seed",
        "shuffle",
        "batch_index",
        "total_batches_seen",
        "index_array",
        "index_generator",
        "index_array",
        "index_array",
        "index_array",
        "image_data_generator",
        "target_size",
        "color_mode",
        "data_format",
        "image_shape",
        "image_shape",
        "image_shape",
        "image_shape",
        "image_shape",
        "image_shape",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "interpolation",
        "validation_split",
        "split",
        "split",
        "split",
        "split",
        "subset",
        "batch_index",
        "current_index",
        "batch_index",
        "dtype",
        "x_misc",
        "x_misc",
        "x",
        "x_misc",
        "split_idx",
        "x",
        "x_misc",
        "y",
        "x",
        "x_misc",
        "y",
        "x",
        "x_misc",
        "channels_axis",
        "y",
        "y",
        "sample_weight",
        "sample_weight",
        "image_data_generator",
        "data_format",
        "save_to_dir",
        "save_prefix",
        "save_format",
        "batch_x",
        "x",
        "x",
        "x",
        "batch_x",
        "i",
        "img",
        "fname",
        "batch_x_miscs",
        "output",
        "index_array",
        "dirname",
        "num_files",
        "start",
        "stop",
        "valid_files",
        "valid_files",
        "filenames",
        "classes",
        "filenames",
        "absolute_path",
        "relative_path",
        "directory",
        "classes",
        "class_mode",
        "dtype",
        "white_list_formats",
        "samples",
        "classes",
        "num_classes",
        "class_indices",
        "pool",
        "results",
        "filenames",
        "i",
        "classes_list",
        "classes",
        "filenames",
        "samples",
        "classes",
        "batch_x",
        "fname",
        "img",
        "x",
        "x",
        "x",
        "batch_x",
        "i",
        "img",
        "fname",
        "batch_y",
        "batch_y",
        "batch_y",
        "batch_y",
        "batch_y",
        "i",
        "label",
        "index_array",
        "df",
        "x_col",
        "directory",
        "classes",
        "class_mode",
        "dtype",
        "white_list_formats",
        "samples",
        "classes",
        "classes",
        "num_classes",
        "class_indices",
        "filenames",
        "classes",
        "filenames",
        "ext_exist",
        "ext_exist",
        "temp_df",
        "temp_df",
        "temp_df",
        "temp_df",
        "temp_df",
        "filenames",
        "without_ext_with",
        "filenames_without_ext",
        "temp_df",
        "temp_df",
        "temp_df",
        "temp_df",
        "temp_df",
        "filenames",
        "df",
        "classes",
        "classes",
        "data",
        "y_col",
        "samples",
        "batch_x",
        "fname",
        "img",
        "x",
        "x",
        "x",
        "batch_x",
        "i",
        "img",
        "fname",
        "batch_y",
        "batch_y",
        "batch_y",
        "batch_y",
        "batch_y",
        "i",
        "label",
        "batch_y",
        "index_array"
    ],
    "comments": [
        "scipy.linalg cannot be accessed until explicitly imported",
        "scipy.ndimage cannot be accessed until explicitly imported",
        "These methods were only introduced in version 3.4.0 (2016).",
        "This method is new in version 1.1.3 (2013).",
        "Original Numpy array x has format (height, width, channel)",
        "or (channel, height, width)",
        "but target PIL image has format (width, height, channel)",
        "RGBA",
        "RGB",
        "grayscale",
        "Numpy array x has format (height, width, channel)",
        "or (channel, height, width)",
        "but original PIL image has format (width, height, channel)",
        "1-D array-like or int",
        "floating point",
        "1-D array-like or int",
        "floating point",
        "x is a single image, so it doesn't have image number at index 0",
        "round up",
        "Ensure self.batch_index is 0.",
        "Needed if we want to do something like:",
        "for x, y in data_gen.flow(...):",
        "Keeps under lock only the mechanism which advances",
        "the indexing of each batch.",
        "The transformation of images is not under thread lock",
        "so it can be done in parallel",
        "First, count the number of samples and classes.",
        "Second, build an index of the images",
        "in the different class subfolders.",
        "build batch of image data",
        "Pillow images should be closed after `load_img`,",
        "but not PIL images.",
        "optionally save augmented images to disk for debugging purposes",
        "build batch of labels",
        "The transformation of images is not under thread lock",
        "so it can be done in parallel",
        "First, count the number of samples and classes.",
        "Second, build an index of the images.",
        "build batch of image data",
        "Pillow images should be closed after `load_img`,",
        "but not PIL images.",
        "optionally save augmented images to disk for debugging purposes",
        "build batch of labels",
        "The transformation of images is not under thread lock",
        "so it can be done in parallel"
    ],
    "docstrings": [
        "\"\"\"Utilities for real-time data augmentation on image data.\n\"\"\"",
        "\"\"\"Performs a random rotation of a Numpy image tensor.\n\n    # Arguments\n        x: Input tensor. Must be 3D.\n        rg: Rotation range, in degrees.\n        row_axis: Index of axis for rows in the input tensor.\n        col_axis: Index of axis for columns in the input tensor.\n        channel_axis: Index of axis for channels in the input tensor.\n        fill_mode: Points outside the boundaries of the input\n            are filled according to the given mode\n            (one of `{'constant', 'nearest', 'reflect', 'wrap'}`).\n        cval: Value used for points outside the boundaries\n            of the input if `mode='constant'`.\n\n    # Returns\n        Rotated Numpy image tensor.\n    \"\"\"",
        "\"\"\"Performs a random spatial shift of a Numpy image tensor.\n\n    # Arguments\n        x: Input tensor. Must be 3D.\n        wrg: Width shift range, as a float fraction of the width.\n        hrg: Height shift range, as a float fraction of the height.\n        row_axis: Index of axis for rows in the input tensor.\n        col_axis: Index of axis for columns in the input tensor.\n        channel_axis: Index of axis for channels in the input tensor.\n        fill_mode: Points outside the boundaries of the input\n            are filled according to the given mode\n            (one of `{'constant', 'nearest', 'reflect', 'wrap'}`).\n        cval: Value used for points outside the boundaries\n            of the input if `mode='constant'`.\n\n    # Returns\n        Shifted Numpy image tensor.\n    \"\"\"",
        "\"\"\"Performs a random spatial shear of a Numpy image tensor.\n\n    # Arguments\n        x: Input tensor. Must be 3D.\n        intensity: Transformation intensity in degrees.\n        row_axis: Index of axis for rows in the input tensor.\n        col_axis: Index of axis for columns in the input tensor.\n        channel_axis: Index of axis for channels in the input tensor.\n        fill_mode: Points outside the boundaries of the input\n            are filled according to the given mode\n            (one of `{'constant', 'nearest', 'reflect', 'wrap'}`).\n        cval: Value used for points outside the boundaries\n            of the input if `mode='constant'`.\n\n    # Returns\n        Sheared Numpy image tensor.\n    \"\"\"",
        "\"\"\"Performs a random spatial zoom of a Numpy image tensor.\n\n    # Arguments\n        x: Input tensor. Must be 3D.\n        zoom_range: Tuple of floats; zoom range for width and height.\n        row_axis: Index of axis for rows in the input tensor.\n        col_axis: Index of axis for columns in the input tensor.\n        channel_axis: Index of axis for channels in the input tensor.\n        fill_mode: Points outside the boundaries of the input\n            are filled according to the given mode\n            (one of `{'constant', 'nearest', 'reflect', 'wrap'}`).\n        cval: Value used for points outside the boundaries\n            of the input if `mode='constant'`.\n\n    # Returns\n        Zoomed Numpy image tensor.\n\n    # Raises\n        ValueError: if `zoom_range` isn't a tuple.\n    \"\"\"",
        "\"\"\"Performs a channel shift.\n\n    # Arguments\n        x: Input tensor. Must be 3D.\n        intensity: Transformation intensity.\n        channel_axis: Index of axis for channels in the input tensor.\n\n    # Returns\n        Numpy image tensor.\n\n    \"\"\"",
        "\"\"\"Performs a random channel shift.\n\n    # Arguments\n        x: Input tensor. Must be 3D.\n        intensity_range: Transformation intensity.\n        channel_axis: Index of axis for channels in the input tensor.\n\n    # Returns\n        Numpy image tensor.\n    \"\"\"",
        "\"\"\"Performs a brightness shift.\n\n    # Arguments\n        x: Input tensor. Must be 3D.\n        brightness: Float. The new brightness value.\n        channel_axis: Index of axis for channels in the input tensor.\n\n    # Returns\n        Numpy image tensor.\n\n    # Raises\n        ValueError if `brightness_range` isn't a tuple.\n    \"\"\"",
        "\"\"\"Performs a random brightness shift.\n\n    # Arguments\n        x: Input tensor. Must be 3D.\n        brightness_range: Tuple of floats; brightness range.\n        channel_axis: Index of axis for channels in the input tensor.\n\n    # Returns\n        Numpy image tensor.\n\n    # Raises\n        ValueError if `brightness_range` isn't a tuple.\n    \"\"\"",
        "\"\"\"Applies an affine transformation specified by the parameters given.\n\n    # Arguments\n        x: 2D numpy array, single image.\n        theta: Rotation angle in degrees.\n        tx: Width shift.\n        ty: Heigh shift.\n        shear: Shear angle in degrees.\n        zx: Zoom in x direction.\n        zy: Zoom in y direction\n        row_axis: Index of axis for rows in the input image.\n        col_axis: Index of axis for columns in the input image.\n        channel_axis: Index of axis for channels in the input image.\n        fill_mode: Points outside the boundaries of the input\n            are filled according to the given mode\n            (one of `{'constant', 'nearest', 'reflect', 'wrap'}`).\n        cval: Value used for points outside the boundaries\n            of the input if `mode='constant'`.\n\n    # Returns\n        The transformed version of the input.\n    \"\"\"",
        "\"\"\"Converts a 3D Numpy array to a PIL Image instance.\n\n    # Arguments\n        x: Input Numpy array.\n        data_format: Image data format.\n            either \"channels_first\" or \"channels_last\".\n        scale: Whether to rescale image values\n            to be within `[0, 255]`.\n        dtype: Dtype to use.\n\n    # Returns\n        A PIL Image instance.\n\n    # Raises\n        ImportError: if PIL is not available.\n        ValueError: if invalid `x` or `data_format` is passed.\n    \"\"\"",
        "\"\"\"Converts a PIL Image instance to a Numpy array.\n\n    # Arguments\n        img: PIL Image instance.\n        data_format: Image data format,\n            either \"channels_first\" or \"channels_last\".\n        dtype: Dtype to use for the returned array.\n\n    # Returns\n        A 3D Numpy array.\n\n    # Raises\n        ValueError: if invalid `img` or `data_format` is passed.\n    \"\"\"",
        "\"\"\"Saves an image stored as a Numpy array to a path or file object.\n\n    # Arguments\n        path: Path or file object.\n        x: Numpy array.\n        data_format: Image data format,\n            either \"channels_first\" or \"channels_last\".\n        file_format: Optional file format override. If omitted, the\n            format to use is determined from the filename extension.\n            If a file object was used instead of a filename, this\n            parameter should always be used.\n        scale: Whether to rescale image values to be within `[0, 255]`.\n        **kwargs: Additional keyword arguments passed to `PIL.Image.save()`.\n    \"\"\"",
        "\"\"\"Loads an image into PIL format.\n\n    # Arguments\n        path: Path to image file.\n        color_mode: One of \"grayscale\", \"rbg\", \"rgba\". Default: \"rgb\".\n            The desired image format.\n        target_size: Either `None` (default to original size)\n            or tuple of ints `(img_height, img_width)`.\n        interpolation: Interpolation method used to resample the image if the\n            target size is different from that of the loaded image.\n            Supported methods are \"nearest\", \"bilinear\", and \"bicubic\".\n            If PIL version 1.1.3 or newer is installed, \"lanczos\" is also\n            supported. If PIL version 3.4.0 or newer is installed, \"box\" and\n            \"hamming\" are also supported. By default, \"nearest\" is used.\n\n    # Returns\n        A PIL Image instance.\n\n    # Raises\n        ImportError: if PIL is not available.\n        ValueError: if interpolation method is not supported.\n    \"\"\"",
        "\"\"\"Generate batches of tensor image data with real-time data augmentation.\n     The data will be looped over (in batches).\n\n    # Arguments\n        featurewise_center: Boolean.\n            Set input mean to 0 over the dataset, feature-wise.\n        samplewise_center: Boolean. Set each sample mean to 0.\n        featurewise_std_normalization: Boolean.\n            Divide inputs by std of the dataset, feature-wise.\n        samplewise_std_normalization: Boolean. Divide each input by its std.\n        zca_epsilon: epsilon for ZCA whitening. Default is 1e-6.\n        zca_whitening: Boolean. Apply ZCA whitening.\n        rotation_range: Int. Degree range for random rotations.\n        width_shift_range: Float, 1-D array-like or int\n            - float: fraction of total width, if < 1, or pixels if >= 1.\n            - 1-D array-like: random elements from the array.\n            - int: integer number of pixels from interval\n                `(-width_shift_range, +width_shift_range)`\n            - With `width_shift_range=2` possible values\n                are integers `[-1, 0, +1]`,\n                same as with `width_shift_range=[-1, 0, +1]`,\n                while with `width_shift_range=1.0` possible values are floats\n                in the interval [-1.0, +1.0).\n        height_shift_range: Float, 1-D array-like or int\n            - float: fraction of total height, if < 1, or pixels if >= 1.\n            - 1-D array-like: random elements from the array.\n            - int: integer number of pixels from interval\n                `(-height_shift_range, +height_shift_range)`\n            - With `height_shift_range=2` possible values\n                are integers `[-1, 0, +1]`,\n                same as with `height_shift_range=[-1, 0, +1]`,\n                while with `height_shift_range=1.0` possible values are floats\n                in the interval [-1.0, +1.0).\n        brightness_range: Tuple or list of two floats. Range for picking\n            a brightness shift value from.\n        shear_range: Float. Shear Intensity\n            (Shear angle in counter-clockwise direction in degrees)\n        zoom_range: Float or [lower, upper]. Range for random zoom.\n            If a float, `[lower, upper] = [1-zoom_range, 1+zoom_range]`.\n        channel_shift_range: Float. Range for random channel shifts.\n        fill_mode: One of {\"constant\", \"nearest\", \"reflect\" or \"wrap\"}.\n            Default is 'nearest'.\n            Points outside the boundaries of the input are filled\n            according to the given mode:\n            - 'constant': kkkkkkkk|abcd|kkkkkkkk (cval=k)\n            - 'nearest':  aaaaaaaa|abcd|dddddddd\n            - 'reflect':  abcddcba|abcd|dcbaabcd\n            - 'wrap':  abcdabcd|abcd|abcdabcd\n        cval: Float or Int.\n            Value used for points outside the boundaries\n            when `fill_mode = \"constant\"`.\n        horizontal_flip: Boolean. Randomly flip inputs horizontally.\n        vertical_flip: Boolean. Randomly flip inputs vertically.\n        rescale: rescaling factor. Defaults to None.\n            If None or 0, no rescaling is applied,\n            otherwise we multiply the data by the value provided\n            (after applying all other transformations).\n        preprocessing_function: function that will be implied on each input.\n            The function will run after the image is resized and augmented.\n            The function should take one argument:\n            one image (Numpy tensor with rank 3),\n            and should output a Numpy tensor with the same shape.\n        data_format: Image data format,\n            either \"channels_first\" or \"channels_last\".\n            \"channels_last\" mode means that the images should have shape\n            `(samples, height, width, channels)`,\n            \"channels_first\" mode means that the images should have shape\n            `(samples, channels, height, width)`.\n            It defaults to the `image_data_format` value found in your\n            Keras config file at `~/.keras/keras.json`.\n            If you never set it, then it will be \"channels_last\".\n        validation_split: Float. Fraction of images reserved for validation\n            (strictly between 0 and 1).\n        dtype: Dtype to use for the generated arrays.\n\n    # Examples\n    Example of using `.flow(x, y)`:\n\n    ```python\n    (x_train, y_train), (x_test, y_test) = cifar10.load_data()\n    y_train = np_utils.to_categorical(y_train, num_classes)\n    y_test = np_utils.to_categorical(y_test, num_classes)\n\n    datagen = ImageDataGenerator(\n        featurewise_center=True,\n        featurewise_std_normalization=True,\n        rotation_range=20,\n        width_shift_range=0.2,\n        height_shift_range=0.2,\n        horizontal_flip=True)\n\n    # compute quantities required for featurewise normalization\n    # (std, mean, and principal components if ZCA whitening is applied)\n    datagen.fit(x_train)\n\n    # fits the model on batches with real-time data augmentation:\n    model.fit_generator(datagen.flow(x_train, y_train, batch_size=32),\n                        steps_per_epoch=len(x_train) / 32, epochs=epochs)\n\n    # here's a more \"manual\" example\n    for e in range(epochs):\n        print('Epoch', e)\n        batches = 0\n        for x_batch, y_batch in datagen.flow(x_train, y_train, batch_size=32):\n            model.fit(x_batch, y_batch)\n            batches += 1\n            if batches >= len(x_train) / 32:\n                # we need to break the loop by hand because\n                # the generator loops indefinitely\n                break\n    ```\n    Example of using `.flow_from_directory(directory)`:\n\n    ```python\n    train_datagen = ImageDataGenerator(\n            rescale=1./255,\n            shear_range=0.2,\n            zoom_range=0.2,\n            horizontal_flip=True)\n\n    test_datagen = ImageDataGenerator(rescale=1./255)\n\n    train_generator = train_datagen.flow_from_directory(\n            'data/train',\n            target_size=(150, 150),\n            batch_size=32,\n            class_mode='binary')\n\n    validation_generator = test_datagen.flow_from_directory(\n            'data/validation',\n            target_size=(150, 150),\n            batch_size=32,\n            class_mode='binary')\n\n    model.fit_generator(\n            train_generator,\n            steps_per_epoch=2000,\n            epochs=50,\n            validation_data=validation_generator,\n            validation_steps=800)\n    ```\n\n    Example of transforming images and masks together.\n\n    ```python\n    # we create two instances with the same arguments\n    data_gen_args = dict(featurewise_center=True,\n                         featurewise_std_normalization=True,\n                         rotation_range=90,\n                         width_shift_range=0.1,\n                         height_shift_range=0.1,\n                         zoom_range=0.2)\n    image_datagen = ImageDataGenerator(**data_gen_args)\n    mask_datagen = ImageDataGenerator(**data_gen_args)\n\n    # Provide the same seed and keyword arguments to the fit and flow methods\n    seed = 1\n    image_datagen.fit(images, augment=True, seed=seed)\n    mask_datagen.fit(masks, augment=True, seed=seed)\n\n    image_generator = image_datagen.flow_from_directory(\n        'data/images',\n        class_mode=None,\n        seed=seed)\n\n    mask_generator = mask_datagen.flow_from_directory(\n        'data/masks',\n        class_mode=None,\n        seed=seed)\n\n    # combine generators into one which yields image and masks\n    train_generator = zip(image_generator, mask_generator)\n\n    model.fit_generator(\n        train_generator,\n        steps_per_epoch=2000,\n        epochs=50)\n    ```\n\n    Example of using ```.flow_from_dataframe(dataframe, directory,\n                                            x_col, y_col,\n                                            has_ext)```:\n\n    ```python\n\n    train_df = pandas.read_csv(\"./train.csv\")\n    valid_df = pandas.read_csv(\"./valid.csv\")\n\n    train_datagen = ImageDataGenerator(\n            rescale=1./255,\n            shear_range=0.2,\n            zoom_range=0.2,\n            horizontal_flip=True)\n\n    test_datagen = ImageDataGenerator(rescale=1./255)\n\n    train_generator = train_datagen.flow_from_dataframe(\n            dataframe=train_df,\n            directory='data/train',\n            x_col=\"filename\",\n            y_col=\"class\",\n            has_ext=True,\n            target_size=(150, 150),\n            batch_size=32,\n            class_mode='binary')\n\n    validation_generator = test_datagen.flow_from_dataframe(\n            dataframe=valid_df,\n            directory='data/validation',\n            x_col=\"filename\",\n            y_col=\"class\",\n            has_ext=True,\n            target_size=(150, 150),\n            batch_size=32,\n            class_mode='binary')\n\n    model.fit_generator(\n            train_generator,\n            steps_per_epoch=2000,\n            epochs=50,\n            validation_data=validation_generator,\n            validation_steps=800)\n    ```\n    \"\"\"",
        "\"\"\"Takes data & label arrays, generates batches of augmented data.\n\n        # Arguments\n            x: Input data. Numpy array of rank 4 or a tuple.\n                If tuple, the first element\n                should contain the images and the second element\n                another numpy array or a list of numpy arrays\n                that gets passed to the output\n                without any modifications.\n                Can be used to feed the model miscellaneous data\n                along with the images.\n                In case of grayscale data, the channels axis of the image array\n                should have value 1, in case\n                of RGB data, it should have value 3, and in case\n                of RGBA data, it should have value 4.\n            y: Labels.\n            batch_size: Int (default: 32).\n            shuffle: Boolean (default: True).\n            sample_weight: Sample weights.\n            seed: Int (default: None).\n            save_to_dir: None or str (default: None).\n                This allows you to optionally specify a directory\n                to which to save the augmented pictures being generated\n                (useful for visualizing what you are doing).\n            save_prefix: Str (default: `''`).\n                Prefix to use for filenames of saved pictures\n                (only relevant if `save_to_dir` is set).\n            save_format: one of \"png\", \"jpeg\"\n                (only relevant if `save_to_dir` is set). Default: \"png\".\n            subset: Subset of data (`\"training\"` or `\"validation\"`) if\n                `validation_split` is set in `ImageDataGenerator`.\n\n        # Returns\n            An `Iterator` yielding tuples of `(x, y)`\n                where `x` is a numpy array of image data\n                (in the case of a single image input) or a list\n                of numpy arrays (in the case with\n                additional inputs) and `y` is a numpy array\n                of corresponding labels. If 'sample_weight' is not None,\n                the yielded tuples are of the form `(x, y, sample_weight)`.\n                If `y` is None, only the numpy array `x` is returned.\n        \"\"\"",
        "\"\"\"Takes the path to a directory & generates batches of augmented data.\n\n        # Arguments\n            directory: Path to the target directory.\n                It should contain one subdirectory per class.\n                Any PNG, JPG, BMP, PPM or TIF images\n                inside each of the subdirectories directory tree\n                will be included in the generator.\n                See [this script](\n                https://gist.github.com/fchollet/0830affa1f7f19fd47b06d4cf89ed44d)\n                for more details.\n            target_size: Tuple of integers `(height, width)`,\n                default: `(256, 256)`.\n                The dimensions to which all images found will be resized.\n            color_mode: One of \"grayscale\", \"rbg\", \"rgba\". Default: \"rgb\".\n                Whether the images will be converted to\n                have 1, 3, or 4 channels.\n            classes: Optional list of class subdirectories\n                (e.g. `['dogs', 'cats']`). Default: None.\n                If not provided, the list of classes will be automatically\n                inferred from the subdirectory names/structure\n                under `directory`, where each subdirectory will\n                be treated as a different class\n                (and the order of the classes, which will map to the label\n                indices, will be alphanumeric).\n                The dictionary containing the mapping from class names to class\n                indices can be obtained via the attribute `class_indices`.\n            class_mode: One of \"categorical\", \"binary\", \"sparse\",\n                \"input\", or None. Default: \"categorical\".\n                Determines the type of label arrays that are returned:\n                - \"categorical\" will be 2D one-hot encoded labels,\n                - \"binary\" will be 1D binary labels,\n                    \"sparse\" will be 1D integer labels,\n                - \"input\" will be images identical\n                    to input images (mainly used to work with autoencoders).\n                - If None, no labels are returned\n                  (the generator will only yield batches of image data,\n                  which is useful to use with `model.predict_generator()`,\n                  `model.evaluate_generator()`, etc.).\n                  Please note that in case of class_mode None,\n                  the data still needs to reside in a subdirectory\n                  of `directory` for it to work correctly.\n            batch_size: Size of the batches of data (default: 32).\n            shuffle: Whether to shuffle the data (default: True)\n            seed: Optional random seed for shuffling and transformations.\n            save_to_dir: None or str (default: None).\n                This allows you to optionally specify\n                a directory to which to save\n                the augmented pictures being generated\n                (useful for visualizing what you are doing).\n            save_prefix: Str. Prefix to use for filenames of saved pictures\n                (only relevant if `save_to_dir` is set).\n            save_format: One of \"png\", \"jpeg\"\n                (only relevant if `save_to_dir` is set). Default: \"png\".\n            follow_links: Whether to follow symlinks inside\n                class subdirectories (default: False).\n            subset: Subset of data (`\"training\"` or `\"validation\"`) if\n                `validation_split` is set in `ImageDataGenerator`.\n            interpolation: Interpolation method used to\n                resample the image if the\n                target size is different from that of the loaded image.\n                Supported methods are `\"nearest\"`, `\"bilinear\"`,\n                and `\"bicubic\"`.\n                If PIL version 1.1.3 or newer is installed, `\"lanczos\"` is also\n                supported. If PIL version 3.4.0 or newer is installed,\n                `\"box\"` and `\"hamming\"` are also supported.\n                By default, `\"nearest\"` is used.\n\n        # Returns\n            A `DirectoryIterator` yielding tuples of `(x, y)`\n                where `x` is a numpy array containing a batch\n                of images with shape `(batch_size, *target_size, channels)`\n                and `y` is a numpy array of corresponding labels.\n        \"\"\"",
        "\"\"\"Takes the dataframe and the path to a directory\n         and generates batches of augmented/normalized data.\n\n        # A simple tutorial can be found at: http://bit.ly/keras_flow_from_dataframe\n\n        # Arguments\n                dataframe: Pandas dataframe containing the filenames of the\n                           images in a column and classes in another or column/s\n                           that can be fed as raw target data.\n                directory: string, path to the target directory that contains all\n                           the images mapped in the dataframe.\n                x_col: string, column in the dataframe that contains\n                       the filenames of the target images.\n                y_col: string or list of strings,columns in\n                       the dataframe that will be the target data.\n                has_ext: bool, True if filenames in dataframe[x_col]\n                        has filename extensions,else False.\n                target_size: tuple of integers `(height, width)`,\n                             default: `(256, 256)`.\n                             The dimensions to which all images\n                             found will be resized.\n                color_mode: one of \"grayscale\", \"rbg\". Default: \"rgb\".\n                            Whether the images will be converted to have\n                            1 or 3 color channels.\n                classes: optional list of classes\n                (e.g. `['dogs', 'cats']`). Default: None.\n                 If not provided, the list of classes will be automatically\n                 inferred from the y_col,\n                 which will map to the label indices, will be alphanumeric).\n                 The dictionary containing the mapping from class names to class\n                 indices can be obtained via the attribute `class_indices`.\n                class_mode: one of \"categorical\", \"binary\", \"sparse\",\n                  \"input\", \"other\" or None. Default: \"categorical\".\n                 Determines the type of label arrays that are returned:\n                 - `\"categorical\"` will be 2D one-hot encoded labels,\n                 - `\"binary\"` will be 1D binary labels,\n                 - `\"sparse\"` will be 1D integer labels,\n                 - `\"input\"` will be images identical\n                 to input images (mainly used to work with autoencoders).\n                - `\"other\"` will be numpy array of y_col data\n                 - None, no labels are returned (the generator will only\n                         yield batches of image data, which is useful to use\n                 `model.predict_generator()`, `model.evaluate_generator()`, etc.).\n                batch_size: size of the batches of data (default: 32).\n                shuffle: whether to shuffle the data (default: True)\n                seed: optional random seed for shuffling and transformations.\n                save_to_dir: None or str (default: None).\n                             This allows you to optionally specify a directory\n                             to which to save the augmented pictures being generated\n                             (useful for visualizing what you are doing).\n                save_prefix: str. Prefix to use for filenames of saved pictures\n                (only relevant if `save_to_dir` is set).\n                save_format: one of \"png\", \"jpeg\"\n                (only relevant if `save_to_dir` is set). Default: \"png\".\n                follow_links: whether to follow symlinks inside class subdirectories\n                (default: False).\n                subset: Subset of data (`\"training\"` or `\"validation\"`) if\n                 `validation_split` is set in `ImageDataGenerator`.\n                interpolation: Interpolation method used to resample the image if the\n                 target size is different from that of the loaded image.\n                 Supported methods are `\"nearest\"`, `\"bilinear\"`, and `\"bicubic\"`.\n                 If PIL version 1.1.3 or newer is installed, `\"lanczos\"` is also\n                 supported. If PIL version 3.4.0 or newer is installed, `\"box\"` and\n                 `\"hamming\"` are also supported. By default, `\"nearest\"` is used.\n\n        # Returns\n            A DataFrameIterator yielding tuples of `(x, y)`\n            where `x` is a numpy array containing a batch\n            of images with shape `(batch_size, *target_size, channels)`\n             and `y` is a numpy array of corresponding labels.\n        \"\"\"",
        "\"\"\"Applies the normalization configuration to a batch of inputs.\n\n        # Arguments\n            x: Batch of inputs to be normalized.\n\n        # Returns\n            The inputs, normalized.\n        \"\"\"",
        "\"\"\"Generates random parameters for a transformation.\n\n        # Arguments\n            seed: Random seed.\n            img_shape: Tuple of integers.\n                Shape of the image that is transformed.\n\n        # Returns\n            A dictionary containing randomly chosen parameters describing the\n            transformation.\n        \"\"\"",
        "\"\"\"Applies a transformation to an image according to given parameters.\n\n        # Arguments\n            x: 3D tensor, single image.\n            transform_parameters: Dictionary with string - parameter pairs\n                describing the transformation.\n                Currently, the following parameters\n                from the dictionary are used:\n                - `'theta'`: Float. Rotation angle in degrees.\n                - `'tx'`: Float. Shift in the x direction.\n                - `'ty'`: Float. Shift in the y direction.\n                - `'shear'`: Float. Shear angle in degrees.\n                - `'zx'`: Float. Zoom in the x direction.\n                - `'zy'`: Float. Zoom in the y direction.\n                - `'flip_horizontal'`: Boolean. Horizontal flip.\n                - `'flip_vertical'`: Boolean. Vertical flip.\n                - `'channel_shift_intencity'`: Float. Channel shift intensity.\n                - `'brightness'`: Float. Brightness shift intensity.\n\n        # Returns\n            A transformed version of the input (same shape).\n        \"\"\"",
        "\"\"\"Applies a random transformation to an image.\n\n        # Arguments\n            x: 3D tensor, single image.\n            seed: Random seed.\n\n        # Returns\n            A randomly transformed version of the input (same shape).\n        \"\"\"",
        "\"\"\"Fits the data generator to some sample data.\n\n        This computes the internal data stats related to the\n        data-dependent transformations, based on an array of sample data.\n\n        Only required if `featurewise_center` or\n        `featurewise_std_normalization` or `zca_whitening` are set to True.\n\n        # Arguments\n            x: Sample data. Should have rank 4.\n             In case of grayscale data,\n             the channels axis should have value 1, in case\n             of RGB data, it should have value 3, and in case\n             of RGBA data, it should have value 4.\n            augment: Boolean (default: False).\n                Whether to fit on randomly augmented samples.\n            rounds: Int (default: 1).\n                If using data augmentation (`augment=True`),\n                this is how many augmentation passes over the data to use.\n            seed: Int (default: None). Random seed.\n       \"\"\"",
        "\"\"\"Base class for image data iterators.\n\n    Every `Iterator` must implement the `_get_batches_of_transformed_samples`\n    method.\n\n    # Arguments\n        n: Integer, total number of samples in the dataset to loop over.\n        batch_size: Integer, size of a batch.\n        shuffle: Boolean, whether to shuffle the data between epochs.\n        seed: Random seeding for data shuffling.\n    \"\"\"",
        "\"\"\"Gets a batch of transformed samples.\n\n        # Arguments\n            index_array: Array of sample indices to include in batch.\n\n        # Returns\n            A batch of transformed samples.\n        \"\"\"",
        "\"\"\"Iterator yielding data from a Numpy array.\n\n    # Arguments\n        x: Numpy array of input data or tuple.\n            If tuple, the second elements is either\n            another numpy array or a list of numpy arrays,\n            each of which gets passed\n            through as an output without any modifications.\n        y: Numpy array of targets data.\n        image_data_generator: Instance of `ImageDataGenerator`\n            to use for random transformations and normalization.\n        batch_size: Integer, size of a batch.\n        shuffle: Boolean, whether to shuffle the data between epochs.\n        sample_weight: Numpy array of sample weights.\n        seed: Random seed for data shuffling.\n        data_format: String, one of `channels_first`, `channels_last`.\n        save_to_dir: Optional directory where to save the pictures\n            being yielded, in a viewable format. This is useful\n            for visualizing the random transformations being\n            applied, for debugging purposes.\n        save_prefix: String prefix to use for saving sample\n            images (if `save_to_dir` is set).\n        save_format: Format to use for saving sample images\n            (if `save_to_dir` is set).\n        subset: Subset of data (`\"training\"` or `\"validation\"`) if\n            validation_split is set in ImageDataGenerator.\n        dtype: Dtype to use for the generated arrays.\n    \"\"\"",
        "\"\"\"For python 2.x.\n\n        # Returns\n            The next batch.\n        \"\"\"",
        "\"\"\"Iterates on files with extension in `white_list_formats` contained in `directory`.\n\n    # Arguments\n        directory: Absolute path to the directory\n            containing files to be counted\n        white_list_formats: Set of strings containing allowed extensions for\n            the files to be counted.\n        follow_links: Boolean.\n\n    # Yields\n        Tuple of (root, filename) with extension in `white_list_formats`.\n    \"\"\"",
        "\"\"\"Lists paths of files in `subdir` with extensions in `white_list_formats`.\n\n    # Arguments\n        directory: absolute path to a directory containing the files to list.\n            The directory name is used as class label\n            and must be a key of `class_indices`.\n        white_list_formats: set of strings containing allowed extensions for\n            the files to be counted.\n        split: tuple of floats (e.g. `(0.2, 0.6)`) to only take into\n            account a certain fraction of files in each directory.\n            E.g.: `segment=(0.6, 1.0)` would only account for last 40 percent\n            of images in each directory.\n        class_indices: dictionary mapping a class name to its index.\n        follow_links: boolean.\n        df: boolean\n\n    # Returns\n        classes: a list of class indices(returns only if `df=False`)\n        filenames: if `df=False`,returns the path of valid files in `directory`,\n            relative from `directory`'s parent (e.g., if `directory` is\n            \"dataset/class1\", the filenames will be\n            `[\"class1/file1.jpg\", \"class1/file2.jpg\", ...]`).\n            if `df=True`, returns only the filenames that are found inside the\n             provided directory (e.g., if `directory` is\n            \"dataset/\", the filenames will be\n            `[\"file1.jpg\", \"file2.jpg\", ...]`).\n    \"\"\"",
        "\"\"\"Iterator capable of reading images from a directory on disk.\n\n    # Arguments\n        directory: Path to the directory to read images from.\n            Each subdirectory in this directory will be\n            considered to contain images from one class,\n            or alternatively you could specify class subdirectories\n            via the `classes` argument.\n        image_data_generator: Instance of `ImageDataGenerator`\n            to use for random transformations and normalization.\n        target_size: tuple of integers, dimensions to resize input images to.\n        color_mode: One of `\"rgb\"`, `\"rgba\"`, `\"grayscale\"`.\n            Color mode to read images.\n        classes: Optional list of strings, names of subdirectories\n            containing images from each class (e.g. `[\"dogs\", \"cats\"]`).\n            It will be computed automatically if not set.\n        class_mode: Mode for yielding the targets:\n            `\"binary\"`: binary targets (if there are only two classes),\n            `\"categorical\"`: categorical targets,\n            `\"sparse\"`: integer targets,\n            `\"input\"`: targets are images identical to input images (mainly\n                used to work with autoencoders),\n            `None`: no targets get yielded (only input images are yielded).\n        batch_size: Integer, size of a batch.\n        shuffle: Boolean, whether to shuffle the data between epochs.\n        seed: Random seed for data shuffling.\n        data_format: String, one of `channels_first`, `channels_last`.\n        save_to_dir: Optional directory where to save the pictures\n            being yielded, in a viewable format. This is useful\n            for visualizing the random transformations being\n            applied, for debugging purposes.\n        save_prefix: String prefix to use for saving sample\n            images (if `save_to_dir` is set).\n        save_format: Format to use for saving sample images\n            (if `save_to_dir` is set).\n        subset: Subset of data (`\"training\"` or `\"validation\"`) if\n            validation_split is set in ImageDataGenerator.\n        interpolation: Interpolation method used to resample the image if the\n            target size is different from that of the loaded image.\n            Supported methods are \"nearest\", \"bilinear\", and \"bicubic\".\n            If PIL version 1.1.3 or newer is installed, \"lanczos\" is also\n            supported. If PIL version 3.4.0 or newer is installed, \"box\" and\n            \"hamming\" are also supported. By default, \"nearest\" is used.\n        dtype: Dtype to use for generated arrays.\n    \"\"\"",
        "\"\"\"For python 2.x.\n\n        # Returns\n            The next batch.\n        \"\"\"",
        "\"\"\"Iterator capable of reading images from a directory on disk\n        through a dataframe.\n\n    # Arguments\n        dataframe: Pandas dataframe containing the filenames of the\n                   images in a column and classes in another or column/s\n                   that can be fed as raw target data.\n        directory: Path to the directory to read images from.\n            Each subdirectory in this directory will be\n            considered to contain images from one class,\n            or alternatively you could specify class subdirectories\n            via the `classes` argument.\n            if used with dataframe,this will be the directory to under which\n            all the images are present.\n        image_data_generator: Instance of `ImageDataGenerator`\n            to use for random transformations and normalization.\n        x_col: Column in dataframe that contains all the filenames.\n        y_col: Column/s in dataframe that has the target data.\n        has_ext: bool, Whether the filenames in x_col has extensions or not.\n        target_size: tuple of integers, dimensions to resize input images to.\n        color_mode: One of `\"rgb\"`, `\"rgba\"`, `\"grayscale\"`.\n            Color mode to read images.\n        classes: Optional list of strings, names of\n            each class (e.g. `[\"dogs\", \"cats\"]`).\n            It will be computed automatically if not set.\n        class_mode: Mode for yielding the targets:\n            `\"binary\"`: binary targets (if there are only two classes),\n            `\"categorical\"`: categorical targets,\n            `\"sparse\"`: integer targets,\n            `\"input\"`: targets are images identical to input images (mainly\n                used to work with autoencoders),\n            `\"other\"`: targets are the data(numpy array) of y_col data\n            `None`: no targets get yielded (only input images are yielded).\n        batch_size: Integer, size of a batch.\n        shuffle: Boolean, whether to shuffle the data between epochs.\n        seed: Random seed for data shuffling.\n        data_format: String, one of `channels_first`, `channels_last`.\n        save_to_dir: Optional directory where to save the pictures\n            being yielded, in a viewable format. This is useful\n            for visualizing the random transformations being\n            applied, for debugging purposes.\n        save_prefix: String prefix to use for saving sample\n            images (if `save_to_dir` is set).\n        save_format: Format to use for saving sample images\n            (if `save_to_dir` is set).\n        subset: Subset of data (`\"training\"` or `\"validation\"`) if\n            validation_split is set in ImageDataGenerator.\n        interpolation: Interpolation method used to resample the image if the\n            target size is different from that of the loaded image.\n            Supported methods are \"nearest\", \"bilinear\", and \"bicubic\".\n            If PIL version 1.1.3 or newer is installed, \"lanczos\" is also\n            supported. If PIL version 3.4.0 or newer is installed, \"box\" and\n            \"hamming\" are also supported. By default, \"nearest\" is used.\n    \"\"\"",
        "\"\"\"For python 2.x.\n\n        # Returns\n            The next batch.\n        \"\"\""
    ],
    "functions": [
        "random_rotation",
        "random_shift",
        "random_shear",
        "random_zoom",
        "apply_channel_shift",
        "random_channel_shift",
        "apply_brightness_shift",
        "random_brightness",
        "transform_matrix_offset_center",
        "apply_affine_transform",
        "flip_axis",
        "array_to_img",
        "img_to_array",
        "save_img",
        "load_img",
        "list_pictures",
        "flow",
        "flow_from_directory",
        "flow_from_dataframe",
        "standardize",
        "get_random_transform",
        "apply_transform",
        "random_transform",
        "fit",
        "_set_index_array",
        "__getitem__",
        "common_init",
        "__len__",
        "on_epoch_end",
        "reset",
        "_flow_index",
        "__iter__",
        "__next__",
        "_get_batches_of_transformed_samples",
        "_get_batches_of_transformed_samples",
        "next",
        "_iter_valid_files",
        "_recursive_list",
        "_list_valid_filenames_in_directory",
        "_get_batches_of_transformed_samples",
        "next",
        "_get_batches_of_transformed_samples",
        "next"
    ],
    "classes": [
        "ImageDataGenerator",
        "Iterator",
        "NumpyArrayIterator",
        "DirectoryIterator",
        "DataFrameIterator"
    ]
}