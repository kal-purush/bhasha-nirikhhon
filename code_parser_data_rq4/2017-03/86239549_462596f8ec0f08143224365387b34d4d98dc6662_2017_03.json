{
    "identifiers": [
        "JSONStream",
        "chunk",
        "batchCount",
        "resolve",
        "reject",
        "resolve",
        "geoCode",
        "geocode",
        "err",
        "reject",
        "err",
        "promiseArray",
        "p",
        "data",
        "data",
        "err",
        "err",
        "p",
        "batchCount",
        "MAX_BATCH",
        "JSONStream",
        "promiseArray",
        "results",
        "results",
        "aggregate",
        "item",
        "item",
        "aggregate",
        "item",
        "aggregate",
        "item",
        "processBatch",
        "batch",
        "results",
        "batch",
        "promiseArray",
        "batchCount",
        "promiseArray",
        "JSONStream",
        "JSONStream",
        "promiseArray",
        "results",
        "results",
        "aggregate",
        "item",
        "item",
        "aggregate",
        "item",
        "aggregate",
        "item",
        "processBatch",
        "batch",
        "results",
        "batch",
        "promiseArray",
        "batch"
    ],
    "literals": [
        "data",
        "''",
        "end"
    ],
    "variables": [
        "MAX_BATCH",
        "JSONStream",
        "promiseArray",
        "batchCount",
        "p",
        "geoCode",
        "batch",
        "batch"
    ],
    "comments": [
        "Second Try, using `data` and `end` events\n * The code has not been tested, here to give the general idea\n * Need to write these things down, very important",
        "how many promises/API calls are queued at once",
        "I live in the outer closure, so I'm available to all functions in this context",
        "I hold the promises within a batch",
        "create a promise for each chunk, and add it to promiseArray",
        "Add geocode stuff here",
        "...",
        "End geocode stuff",
        "set all variables to null after the promise resolves to encourage garbage collection (explicitly break references)",
        "Add all geocodes to an object - will be aggregated by Promise.all",
        "Add all error to an object - will be aggregated by Promise.all",
        "This also guarantees that the promise chain will always resolve successfully, prevent early Promise.all resolution",
        "shout-out to pipakin for doing this in courtbot-engine",
        "null out to encourage garbage collection for large data sets",
        "Prevent further event triggering",
        "Use Promise.all to wait for everything to finish processing, for better or worse",
        "No catch statement, since all errors are processed earlier",
        "batch is now an object with an array of geoCodes and an array of errors",
        "null out to encourage garbage collection for large data sets",
        "reset batch vars",
        "resume the stream",
        "Force processing of a batch when the stream ends",
        "batch is now an object with an array of geoCodes and an array of errors",
        "null out to encourage garbage collection for large data sets",
        "I process a batch of geoCodes",
        "fill out function stub;"
    ],
    "docstrings": [],
    "functions": [
        "processBatch"
    ],
    "classes": []
}