{
    "identifiers": [
        "org",
        "openhab",
        "binding",
        "paradoxalarm",
        "communication",
        "java",
        "io",
        "DataInputStream",
        "java",
        "io",
        "DataOutputStream",
        "java",
        "io",
        "java",
        "net",
        "Socket",
        "java",
        "net",
        "UnknownHostException",
        "java",
        "util",
        "java",
        "util",
        "Arrays",
        "java",
        "util",
        "Collection",
        "java",
        "util",
        "java",
        "util",
        "concurrent",
        "ScheduledExecutorService",
        "org",
        "openhab",
        "binding",
        "paradoxalarm",
        "communication",
        "messages",
        "HeaderMessageType",
        "org",
        "openhab",
        "binding",
        "paradoxalarm",
        "communication",
        "messages",
        "IPPacketPayload",
        "org",
        "openhab",
        "binding",
        "paradoxalarm",
        "communication",
        "messages",
        "ParadoxIPPacket",
        "org",
        "openhab",
        "binding",
        "paradoxalarm",
        "exceptions",
        "ParadoxException",
        "org",
        "openhab",
        "binding",
        "paradoxalarm",
        "util",
        "ParadoxUtil",
        "org",
        "slf4j",
        "Logger",
        "org",
        "slf4j",
        "LoggerFactory",
        "SOCKET_TIMEOUT",
        "PACKET_EXPIRATION_TRESHOLD_MILLISECONDS",
        "logger",
        "LoggerFactory",
        "getLogger",
        "scheduler",
        "listeners",
        "retryCounter",
        "socket",
        "ipAddress",
        "tcpPort",
        "tx",
        "rx",
        "isOnline",
        "ipAddress",
        "tcpPort",
        "scheduler",
        "ipAddress",
        "ipAddress",
        "tcpPort",
        "tcpPort",
        "scheduler",
        "scheduler",
        "initializeSocket",
        "socket",
        "close",
        "socket",
        "ipAddress",
        "tcpPort",
        "socket",
        "setSoTimeout",
        "SOCKET_TIMEOUT",
        "tx",
        "socket",
        "getOutputStream",
        "rx",
        "socket",
        "getInputStream",
        "Override",
        "logger",
        "info",
        "tx",
        "close",
        "rx",
        "close",
        "socket",
        "close",
        "e",
        "logger",
        "warn",
        "e",
        "Override",
        "request",
        "syncQueue",
        "SyncQueue",
        "getInstance",
        "syncQueue",
        "add",
        "request",
        "communicateToParadox",
        "syncQueue",
        "SyncQueue",
        "getInstance",
        "syncQueue",
        "syncQueue",
        "hasPacketToReceive",
        "receivePacket",
        "syncQueue",
        "hasPacketsToSend",
        "sendPacket",
        "syncQueue",
        "hasPacketsToSend",
        "syncQueue",
        "hasPacketToReceive",
        "communicateToParadox",
        "syncQueue",
        "SyncQueue",
        "getInstance",
        "request",
        "syncQueue",
        "peekSendQueue",
        "logger",
        "debug",
        "request",
        "packetBytes",
        "request",
        "getRequestPayload",
        "getBytes",
        "ParadoxUtil",
        "printPacket",
        "packetBytes",
        "tx",
        "write",
        "packetBytes",
        "syncQueue",
        "moveRequest",
        "e",
        "syncQueue",
        "removeSendRequest",
        "logger",
        "debug",
        "request",
        "e",
        "syncQueue",
        "SyncQueue",
        "getInstance",
        "logger",
        "debug",
        "result",
        "readBytes",
        "rx",
        "read",
        "result",
        "readBytes",
        "result",
        "result",
        "logger",
        "debug",
        "retryCounter",
        "request",
        "syncQueue",
        "poll",
        "bytesData",
        "Arrays",
        "copyOfRange",
        "result",
        "result",
        "response",
        "request",
        "bytesData",
        "handleReceivedPacket",
        "response",
        "SyncQueue",
        "getInstance",
        "peekReceiveQueue",
        "isTimeStampExpired",
        "PACKET_EXPIRATION_TRESHOLD_MILLISECONDS",
        "logger",
        "debug",
        "retryCounter",
        "requestInQueue",
        "syncQueue",
        "poll",
        "logger",
        "debug",
        "requestInQueue",
        "retryCounter",
        "e",
        "request",
        "syncQueue",
        "poll",
        "retryCounter",
        "logger",
        "debug",
        "request",
        "e",
        "response",
        "payload",
        "response",
        "getPayload",
        "parsePacket",
        "payload",
        "command",
        "packetResponse",
        "finalCommand",
        "command",
        "ParadoxUtil",
        "getHighNibble",
        "command",
        "command",
        "responses",
        "splitResponsePackets",
        "packetResponse",
        "response",
        "responses",
        "response",
        "length",
        "ParadoxUtil",
        "getHighNibble",
        "response",
        "finalCommand",
        "Arrays",
        "copyOfRange",
        "response",
        "response",
        "length",
        "response",
        "packets",
        "responseCopy",
        "Arrays",
        "copyOf",
        "response",
        "response",
        "length",
        "totalLength",
        "responseCopy",
        "length",
        "responseCopy",
        "length",
        "responseCopy",
        "length",
        "responseCopy",
        "logger",
        "debug",
        "header",
        "Arrays",
        "copyOfRange",
        "responseCopy",
        "messageLength",
        "header",
        "responseCopy",
        "Arrays",
        "copyOfRange",
        "responseCopy",
        "totalLength",
        "responseCopy",
        "length",
        "messageLength",
        "responseCopy",
        "length",
        "messageLength",
        "i",
        "messageLength",
        "i",
        "responseCopy",
        "length",
        "i",
        "responseCopy",
        "i",
        "messageLength",
        "message",
        "Arrays",
        "copyOfRange",
        "responseCopy",
        "messageLength",
        "responseCopy",
        "Arrays",
        "copyOfRange",
        "responseCopy",
        "messageLength",
        "responseCopy",
        "length",
        "packets",
        "add",
        "ParadoxUtil",
        "mergeByteArrays",
        "header",
        "message",
        "packets",
        "Override",
        "isOnline",
        "Override",
        "flag",
        "isOnline",
        "flag",
        "rx",
        "payload",
        "readEpromIPPacket",
        "payload",
        "setMessageType",
        "HeaderMessageType",
        "SERIAL_PASSTHRU_REQUEST",
        "setUnknown0",
        "readEpromIPPacket",
        "response",
        "response",
        "response"
    ],
    "literals": [
        "\"Stopping communication to Paradox system\"",
        "\"IO exception during socket/stream close operation.\"",
        "\"Sending packet with request={}\"",
        "\"Tx Packet:\"",
        "\"Error while sending packet with request={}. IOException={}. Will discard this request.\"",
        "\"Found packet to receive in queue...\"",
        "\"Successfully read valid packet from Rx\"",
        "\"Unable to receive proper package for {} time. Rescheduling...\"",
        "\"Error receiving packet after reaching the set treshold of retries. Request: {}\"",
        "\"Unable to receive package due to IO Exception. Request {}. Exception={}\"",
        "\"No 16 byte header found\"",
        "\"Unexpected end of data\""
    ],
    "variables": [
        "scheduler",
        "listeners",
        "socket",
        "ipAddress",
        "tcpPort",
        "tx",
        "rx",
        "isOnline"
    ],
    "comments": [
        "Recursively check if there are more packets to send in TX queue until it becomes empty",
        "We might enter this too early, meaning the panel has not yet had time to",
        "respond to our command. We add a retry counter that will wait and retry.",
        "Message too short",
        "Response command (after header) is not related to reading memory",
        "Remove the header",
        "Check if there's padding bytes (0xEE)"
    ],
    "docstrings": [
        "* Copyright (c) 2010-2019 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0",
        "* The {@link AbstractCommunicator} Abstract class with common low-level communication logic. Extended by the\n * communicator classes.\n *\n * @author Konstantin Polihronov - Initial contribution",
        "* This method reads data from the IP150 module. It can return multiple\n     * responses e.g. a live event is combined with another response.\n     * The open active TCP/IP stream.\n     * A panel command, e.g. 0x5 (read memory\n     * An array of an array of the raw bytes received from the TCP/IP\n     * stream.\n     *\n     * @param command (currently it's only 0x5 but other commands can be used for different other areas)\n     * @return\n     * @throws IOException\n     * @throws InterruptedException\n     * @throws ParadoxException"
    ],
    "functions": [
        "AbstractCommunicator",
        "initializeSocket",
        "close",
        "submitRequest",
        "communicateToParadox",
        "sendPacket",
        "receivePacket",
        "parsePacket",
        "parsePacket",
        "splitResponsePackets",
        "isOnline",
        "setOnline",
        "DataInputStream",
        "getRx",
        "ParadoxIPPacket",
        "createParadoxIpPacket",
        "handleReceivedPacket",
        "receiveEpromResponse",
        "receiveRamResponse"
    ],
    "classes": [
        "AbstractCommunicator"
    ]
}