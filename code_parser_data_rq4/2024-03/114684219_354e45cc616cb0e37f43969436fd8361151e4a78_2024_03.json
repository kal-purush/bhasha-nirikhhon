{
    "identifiers": [
        "utils",
        "java",
        "util",
        "java",
        "util",
        "concurrent",
        "ConcurrentHashMap",
        "java",
        "util",
        "java",
        "util",
        "stream",
        "Collector",
        "mKeyMapper",
        "mValueMapper",
        "mMapSupplier",
        "keyMapper",
        "valueMapper",
        "mapSupplier",
        "keyMapper",
        "valueMapper",
        "mapSupplier",
        "keyMapper",
        "valueMapper",
        "mapSupplier",
        "mKeyMapper",
        "keyMapper",
        "mValueMapper",
        "valueMapper",
        "mMapSupplier",
        "mapSupplier",
        "Override",
        "mMapSupplier",
        "Override",
        "t",
        "key",
        "mKeyMapper",
        "apply",
        "t",
        "values",
        "computeIfAbsent",
        "key",
        "k",
        "values",
        "add",
        "mValueMapper",
        "apply",
        "t",
        "Override",
        "first",
        "second",
        "first",
        "putAll",
        "second",
        "first",
        "Override",
        "identity",
        "Override",
        "Collections",
        "unmodifiableSet",
        "EnumSet",
        "of",
        "Collector",
        "Characteristics",
        "IDENTITY_FINISH",
        "Collector",
        "Characteristics",
        "UNORDERED"
    ],
    "literals": [],
    "variables": [
        "mKeyMapper",
        "mValueMapper",
        "mMapSupplier"
    ],
    "comments": [
        "Return a BiConsumer that takes a Map and an element of type",
        "T.",
        "Apply the key mapping function to the element to obtain",
        "its key.",
        "Retrieve or create the collection of values",
        "corresponding to the key.",
        "Apply the value mapping function to the element and add",
        "the result to the collection.",
        "Merge the two maps together."
    ],
    "docstrings": [
        "* This generic custom collector accumulates input elements\n * of type {@code T} into a {@link Map} parameterized\n * with {@code K} and {@code Collection<V>} types and returns\n * that {@link Map}.",
        "* A {@link Function} that maps the key {@code K}.",
        "* A {@link Function} that maps the value {@code V}.",
        "* A {@link Supplier} that returns a new, empty {@link Map} into\n     * which the results will be inserted.",
        "* This static factory method creates a concurrent {@link\n     * Collector} that accumulates elements into a {@link Map} whose\n     * keys and values are the result of applying the provided mapping\n     * functions to the input elements.\n     *\n     * If the mapped keys contain duplicates (according to {@link\n     * Object#equals(Object)}), the value mapping function is applied\n     * to each equal element, and the results are merged using the\n     * provided merging function.\n     *\n     * @param <T> the type of the input elements\n     * @param <K> the output type of the key mapping function\n     * @param <V> the output type of the value mapping function\n     * @param keyMapper a mapping function to produce keys\n     * @param valueMapper a mapping function to produce values\n     * @param mapSupplier a supplier that returns a new, empty {@link\n     *                    Map} into which the results will be inserted\n     * @return a {@link Collector} that collects elements into a\n     *         {@link Map} whose keys are the result of applying a key\n     *         mapping function to the input elements and whose values\n     *         are the result of applying a value mapping function to\n     *         all input elements equal to the key",
        "* Create a {@link Collector} that accumulates elements into a\n     * {@link Map} whose keys and values are the result of applying\n     * the provided mapping functions to the input elements.\n     * \n     * @param keyMapper a mapping function to produce keys\n     * @param valueMapper a mapping function to produce values\n     * @param mapSupplier a supplier that returns a new, empty {@link\n     *                    Map} into which the results will be inserted",
        "* A factory method that creates and returns a new mutable result\n     * container of type {@link ConcurrentHashMap} that holds all the\n     * elements in the stream.\n     *\n     * @return a function which returns a new, mutable result container",
        "* A method that folds an element into the {@link\n     * ConcurrentHashMap}.\n     *\n     * @return a {@link BiConsumer} that folds a value into the\n     * mutable result container",
        "* A method that accepts two partial results and merges them.\n     *\n     * @return A {@link BinaryOperator} that merges two maps together",
        "* This method is a no-op given the {@link Characteristics} set as\n     * {@code IDENTITY_FINISH}.\n     *\n     * @return Null",
        "* Returns a {@link Set} of {@link Collector.Characteristics}\n     * indicating the characteristics of this Collector.  This set is\n     * immutable.\n     *\n     * @return An immutable set of {@link Collector} characteristics,\n     *         which in this case is {@code\n     *         [UNORDERED|IDENTITY_FINISH]}"
    ],
    "functions": [
        "toMap",
        "MultimapCollector",
        "supplier",
        "accumulator",
        "combiner",
        "finisher",
        "characteristics"
    ],
    "classes": [
        "MultimapCollector"
    ]
}