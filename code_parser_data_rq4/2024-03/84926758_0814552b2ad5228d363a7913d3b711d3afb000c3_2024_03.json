{
    "identifiers": [
        "collections",
        "abc",
        "AsyncGenerator",
        "datetime",
        "UTC",
        "datetime",
        "functools",
        "wraps",
        "aiohttp",
        "ClientResponse",
        "supervisor",
        "exceptions",
        "MalformedBinaryEntryError",
        "supervisor",
        "host",
        "LogFormatter",
        "required_fields",
        "func",
        "wraps",
        "func",
        "args",
        "kwargs",
        "func",
        "args",
        "kwargs",
        "required_fields",
        "wrapper",
        "decorator",
        "formatter",
        "entries",
        "entries",
        "formatter",
        "entries",
        "datetime",
        "fromtimestamp",
        "entries",
        "UTC",
        "isoformat",
        "sep",
        "timespec",
        "ts",
        "ts",
        "index",
        "entries",
        "get",
        "entries",
        "entries",
        "entries",
        "get",
        "ts",
        "entries",
        "get",
        "identifier",
        "entries",
        "get",
        "journal_logs",
        "ClientResponse",
        "log_formatter",
        "LogFormatter",
        "LogFormatter",
        "PLAIN",
        "AsyncGenerator",
        "log_formatter",
        "LogFormatter",
        "PLAIN",
        "journal_plain_formatter",
        "LogFormatter",
        "VERBOSE",
        "journal_verbose_formatter",
        "ValueError",
        "log_formatter",
        "journal_logs",
        "resp",
        "resp",
        "content",
        "at_eof",
        "resp",
        "content",
        "readuntil",
        "line",
        "formatter_",
        "entries",
        "line",
        "partition",
        "sep",
        "name",
        "resp",
        "content",
        "readexactly",
        "from_bytes",
        "length_raw",
        "byteorder",
        "resp",
        "content",
        "readexactly",
        "length",
        "data",
        "endswith",
        "MalformedBinaryEntryError",
        "data",
        "name",
        "decode",
        "name",
        "formatter_",
        "required_fields",
        "data",
        "decode"
    ],
    "literals": [
        "\"MESSAGE\"",
        "\"MESSAGE\"",
        "\"__REALTIME_TIMESTAMP\"",
        "\"_HOSTNAME\"",
        "\"SYSLOG_IDENTIFIER\"",
        "\"_PID\"",
        "\"MESSAGE\"",
        "\"__REALTIME_TIMESTAMP\"",
        "\" \"",
        "\"milliseconds\"",
        "\".\"",
        "f\"{entries.get(\"SYSLOG_IDENTIFIER\", \"_UNKNOWN_\")}[{entries[\"_PID\"]}]\"",
        "\"SYSLOG_IDENTIFIER\"",
        "\"_UNKNOWN_\"",
        "\"_PID\"",
        "\"_PID\"",
        "\"SYSLOG_IDENTIFIER\"",
        "\"_UNKNOWN_\"",
        "f\"{ts} {entries.get(\"_HOSTNAME\", \"\")} {identifier}: {entries.get(\"MESSAGE\", \"\")}\"",
        "\"_HOSTNAME\"",
        "\"\"",
        "\"MESSAGE\"",
        "\"\"",
        "f\"Unknown log format: {log_formatter}\"",
        "b\"\\n\"",
        "b\"\\n\"",
        "b\"=\"",
        "\"little\"",
        "b\"\\n\"",
        "f\"Failed parsing binary entry {data}\"",
        "\"utf-8\"",
        "\"utf-8\""
    ],
    "variables": [
        "wrapper",
        "required_fields",
        "ts",
        "ts",
        "identifier",
        "formatter_",
        "formatter_",
        "entries",
        "line",
        "entries",
        "name",
        "sep",
        "data",
        "name",
        "length_raw",
        "length",
        "data",
        "name",
        "entries",
        "name"
    ],
    "comments": [
        "strip TZ offset",
        "newline means end of message:",
        "Journal fields consisting only of valid non-control UTF-8 codepoints",
        "are serialized as they are (i.e. the field name, followed by '=',",
        "followed by field data), followed by a newline as separator to the next",
        "field. Note that fields containing newlines cannot be formatted like",
        "this. Non-control UTF-8 codepoints are the codepoints with value at or",
        "above 32 (' '), or equal to 9 (TAB).",
        "Other journal fields are serialized in a special binary safe way:",
        "field name, followed by newline",
        "strip \\n",
        "followed by a binary 64-bit little endian size value,",
        "followed by the binary field data,",
        "followed by a newline as separator to the next field.",
        "we must read to the end of the entry in the stream, so we can",
        "only continue the loop here",
        "strip \\n for simple fields before decoding"
    ],
    "docstrings": [
        "\"\"\"Utilities for working with systemd journal export format.\"\"\"",
        "\"\"\"Decorate journal entry formatters with list of required fields.\n\n    Helper decorator that can be used for getting list of required fields for a journal\n    formatter function using function.required_fields function attribute.\n    \"\"\"",
        "\"\"\"Format parsed journal entries as a plain message.\"\"\"",
        "\"\"\"Format parsed journal entries to a journalctl-like format.\"\"\"",
        "\"\"\"Read logs from systemd journal line by line, formatted using the given formatter.\"\"\""
    ],
    "functions": [
        "formatter",
        "decorator",
        "wrapper",
        "journal_plain_formatter",
        "journal_verbose_formatter",
        "journal_logs_reader"
    ],
    "classes": []
}