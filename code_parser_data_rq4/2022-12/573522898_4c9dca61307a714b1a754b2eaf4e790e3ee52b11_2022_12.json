{
    "identifiers": [
        "TFADisplay",
        "TFADisplay",
        "boot",
        "time",
        "machine",
        "Pin",
        "SoftSPI",
        "SoftI2C",
        "pycc1101",
        "TICC1101",
        "micropython",
        "TFADecode",
        "json",
        "gc",
        "_thread",
        "Pin",
        "Pin",
        "OUT",
        "Pin",
        "Pin",
        "IN",
        "Pin",
        "Pin",
        "IN",
        "Pin",
        "Pin",
        "OUT",
        "Pin",
        "Pin",
        "OUT",
        "Pin",
        "Pin",
        "OUT",
        "Pin",
        "Pin",
        "IN",
        "Pin",
        "Pin",
        "pPower",
        "on",
        "SoftSPI",
        "baudrate",
        "polarity",
        "phase",
        "bits",
        "firstbit",
        "SoftSPI",
        "MSB",
        "sck",
        "pSCK",
        "miso",
        "pMISO",
        "mosi",
        "pMOSI",
        "TICC1101",
        "spi",
        "pCS",
        "pCS",
        "pGDO0",
        "pGDO0",
        "pGDO2",
        "pGDO2",
        "debug",
        "CC1101",
        "reset",
        "CC1101",
        "selfTest",
        "CC1101",
        "reset",
        "CC1101",
        "setDefaultValues",
        "CC1101",
        "setCarrierFrequency",
        "CC1101",
        "setCarrierFrequencyHz",
        "CC1101",
        "setChannelBandwidth",
        "CC1101",
        "setModulation",
        "CC1101",
        "setBaud",
        "CC1101",
        "setRXAttenuation",
        "CC1101",
        "setOptimumASKGainControl",
        "CC1101",
        "setPacketMode",
        "CC1101",
        "setPktLen",
        "CC1101",
        "enCRC",
        "CC1101",
        "enFEC",
        "CC1101",
        "setSyncMode",
        "CC1101",
        "_writeSingleByte",
        "CC1101",
        "SYNC1",
        "CC1101",
        "_writeSingleByte",
        "CC1101",
        "SYNC0",
        "CC1101",
        "setGDO0Cfg",
        "CC1101",
        "setGDO2Cfg",
        "CC1101",
        "getBaud",
        "CC1101",
        "getCarrierFrequency",
        "CC1101",
        "getChannelBandwidth",
        "SoftI2C",
        "pSDA",
        "pSCL",
        "TFADisplay",
        "i2c",
        "TFADecode",
        "TFADecode",
        "time",
        "time",
        "CC1101",
        "_readSingleByte",
        "CC1101",
        "PKTLEN",
        "RXbuff",
        "SPI_buff",
        "args",
        "spi_buff_mv",
        "RXbuff_mv",
        "RXbuff_idx",
        "tmp1",
        "tmp2",
        "tmp1",
        "CC1101",
        "_readSingleByte",
        "CC1101",
        "RXBYTES",
        "cnt",
        "RuntimeError",
        "cnt",
        "tmp1",
        "bytes_available",
        "CC1101",
        "_strobe",
        "CC1101",
        "SFRX",
        "bytes_available",
        "len",
        "spi_buff_mv",
        "bytes_available",
        "len",
        "RXbuff_mv",
        "RXbuff_idx",
        "bytes_available",
        "CC1101",
        "_strobe",
        "CC1101",
        "SIDLE",
        "RXbuff_mv",
        "RXbuff_idx",
        "CC1101",
        "_pCS",
        "off",
        "CC1101",
        "_spi",
        "write_readinto",
        "spi_buff_mv",
        "bytes_available",
        "RXbuff_mv",
        "RXbuff_idx",
        "RXbuff_idx",
        "bytes_available",
        "CC1101",
        "_pCS",
        "on",
        "RXbuff_idx",
        "tmp",
        "RXbuff_idx",
        "bytes_available",
        "pGDO2",
        "value",
        "micropython",
        "schedule",
        "process",
        "RXbuff",
        "RXbuff_idx",
        "loop",
        "CC1101",
        "_setRXState",
        "irq",
        "micropython",
        "schedule",
        "readout",
        "pGDO0",
        "irq",
        "ISR_data_available",
        "Pin",
        "IRQ_RISING",
        "globals",
        "network",
        "network",
        "WLAN",
        "network",
        "STA_IF",
        "sta_if",
        "active",
        "sta_if",
        "active",
        "sta_if",
        "connect",
        "WIFI_ESSID",
        "WIFI_PASSWORD",
        "globals",
        "umqttsimple",
        "MQTTClient",
        "MQTTClient",
        "MQTT_CLIENTID",
        "MQTT_SERVER",
        "args",
        "tfa_display",
        "update",
        "args",
        "data_from_isr",
        "last_time_package_received",
        "time",
        "time",
        "join",
        "format",
        "b",
        "b",
        "data_from_isr",
        "encode",
        "TFADecode",
        "twostate_demodulate",
        "data_bytes_bin",
        "len",
        "data_bin",
        "sta_if",
        "sta_if",
        "isconnected",
        "sta_if",
        "status",
        "sta_if",
        "active",
        "sta_if",
        "active",
        "CC1101",
        "getRSSIdBm",
        "cc1101_rssi",
        "wifi_rssi",
        "client",
        "client",
        "connect",
        "len",
        "data_bin",
        "tfa",
        "update",
        "data_bin",
        "json",
        "dumps",
        "tfa",
        "data_raw",
        "tfa",
        "is_weather_data",
        "tfa",
        "is_time_data",
        "micropython",
        "schedule",
        "display_update_cb",
        "tfa",
        "data_dict",
        "tfa",
        "_rtc",
        "datetime",
        "wifi_rssi",
        "cc1101_rssi",
        "wifi_rssi",
        "client",
        "tfa",
        "is_weather_data",
        "client",
        "publish",
        "MQTT_TOPIC",
        "tfa",
        "data_json",
        "tfa",
        "is_time_data",
        "client",
        "publish",
        "MQTT_TOPIC",
        "tfa",
        "dfc_tuple",
        "json",
        "dumps",
        "data_bytes_bin",
        "len",
        "data_bin",
        "MQTT_TOPIC",
        "RESULT_json",
        "wifi_rssi",
        "client",
        "sta_if",
        "config",
        "OSError",
        "json",
        "dumps",
        "format",
        "time",
        "localtime",
        "WIFI_ESSID",
        "wifi_channel",
        "wifi_rssi",
        "CC1101_settings_dict",
        "MQTT_TOPIC",
        "STATE_json",
        "client",
        "publish",
        "MQTT_TOPIC",
        "STATE_json",
        "client",
        "publish",
        "MQTT_TOPIC",
        "RESULT_json",
        "client",
        "disconnect",
        "gc",
        "collect",
        "args",
        "RXbuff_idx",
        "loop",
        "CC1101",
        "_getMRStateMachineState",
        "state",
        "CC1101",
        "_strobe",
        "CC1101",
        "SFRX",
        "state",
        "state",
        "CC1101",
        "_setRXState",
        "time",
        "time",
        "last_time_package_received",
        "end",
        "time",
        "sleep",
        "_thread",
        "start_new_thread",
        "watchdog"
    ],
    "literals": [
        "'ASK'",
        "\"PKT_LEN_FIXED\"",
        "\"RSSI\"",
        "\"Baudrate\"",
        "\"CarrierFrequency\"",
        "\"ChannelBandwidth\"",
        "'communication error'",
        "'RX FIFO in CC1101 overflow'",
        "'receive buffer on MCU is full'",
        "'WIFI_ESSID'",
        "'MQTT_CLIENTID'",
        "''",
        "'{:08b}'",
        "f'Decoded {len(data_bin)} bits'",
        "'rssi'",
        "'RSSI'",
        "'raw_int'",
        "'isweather'",
        "'istime'",
        "f'tele/{MQTT_TOPIC}/SENSOR'",
        "f'tele/{MQTT_TOPIC}/DFC'",
        "'raw'",
        "f'{data_bytes_bin}'",
        "'maxdecode'",
        "f'stat/{MQTT_TOPIC}/RESULT'",
        "'channel'",
        "'Time'",
        "'{0}-{1:02d}-{2:02d}T{3:02d}:{4:02d}:{5:02d}'",
        "\"Wifi\"",
        "\"SSId\"",
        "\"Channel\"",
        "\"RSSI\"",
        "'CC1101'",
        "f'tele/{MQTT_TOPIC}/STATE'",
        "f'tele/{MQTT_TOPIC}/STATE'",
        "f'stat/{MQTT_TOPIC}/RESULT'",
        "f'CC1101 state: {state}->13'",
        "'.'",
        "''"
    ],
    "variables": [
        "pPower",
        "pGDO0",
        "pGDO2",
        "pCS",
        "pSCK",
        "pMOSI",
        "pMISO",
        "pSDA",
        "pSCL",
        "spi",
        "CC1101",
        "CC1101_settings_dict",
        "i2c",
        "tfa_display",
        "tfa",
        "loop",
        "last_time_package_received",
        "RXbuff",
        "RXbuff_mv",
        "RXbuff",
        "RXbuff",
        "RXbuff_idx",
        "SPI_buff",
        "SPI_buff",
        "spi_buff_mv",
        "tmp1",
        "tmp2",
        "cnt",
        "tmp2",
        "tmp1",
        "bytes_available",
        "RXbuff_idx",
        "RXbuff_idx",
        "tmp",
        "RXbuff_mv",
        "RXbuff_idx",
        "sta_if",
        "sta_if",
        "client",
        "client",
        "last_time_package_received",
        "data_bytes_bin",
        "decode_state",
        "data_bin",
        "wifi_rssi",
        "wifi_rssi",
        "cc1101_rssi",
        "CC1101_settings_dict",
        "RESULT_json",
        "RESULT_json",
        "wifi_channel",
        "wifi_channel",
        "STATE_json",
        "state",
        "RXbuff_idx",
        "watchdog_thread"
    ],
    "comments": [
        "get settings",
        "CC1101 Pins",
        "SPI Pins",
        "I2C",
        "CC1101",
        "CC1101 settings",
        "my oscillator is a bit to low",
        "my oscillator is a bit to low",
        "High Byte",
        "Low Byte",
        "asserts when data is available (fifo is filled above threshold, or end of packet), de-asserts when fifo is empty",
        "asserts when sync-word received, de-asserts when end of package or error",
        "data decoder and display",
        "loop-control",
        "if True, re-arm CC1101 after if received packet",
        "prepare receive buffer to be read to copy data from RXFIFO",
        "sync word is part of package data",
        "SYNC1",
        "SYNC0",
        "spi write buffer for burst RX mode",
        "RX FIFO size + 1",
        "read burst read of RXFIFO",
        "Get length byte in packet safely according to errata https://www.ti.com/lit/er/swrz020e/swrz020e.pdf",
        "RXBytes must be read at rate at least double the baudrate until the same value is read twice",
        "don't try forever",
        "RXOverflow, reset buffers and revert to idle",
        "buffers full, maybe something was left from a previously aborted transmission",
        "bytes available and in receive buffer is enough space",
        "end of data",
        "print('end of data')",
        "re-arm receiver",
        "attach ISR to GDO0, i.e. data available or and of packet",
        "configure wifi",
        "start WiFi",
        "deactivate in case it was already active",
        "configure MQTT client",
        "check wifi",
        "reset WiFi",
        "check CC1101 link quality",
        "prepare mqtt session",
        "decode data",
        "schedule display update (can run in background while MQTT messages are processed)",
        "TODO: if reoccuring, adjust baudrate or carrier frequency in case it drifted too much",
        "it is not on every hardware possible to read-out the channel",
        "free memory after processing",
        "RX FIFO overflow",
        "not in RX state",
        "heartbeat"
    ],
    "docstrings": [
        "\"\"\"\n    Readout of rx fifo of CC1101.\n    \"\"\"",
        "\"\"\"\n    Callback for end-of-packet\n    \"\"\"",
        "\"\"\"\n    watchdog/heartbeat-thread to clear buffers in case of buffer overflow or set to RX mode\n    \"\"\""
    ],
    "functions": [
        "readout",
        "ISR_data_available",
        "display_update_cb",
        "process",
        "watchdog"
    ],
    "classes": []
}