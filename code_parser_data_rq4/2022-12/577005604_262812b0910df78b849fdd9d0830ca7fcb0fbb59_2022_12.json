{
    "identifiers": [
        "a",
        "a",
        "b",
        "a",
        "b"
    ],
    "literals": [],
    "variables": [],
    "comments": [
        "ПРИКЛАД ССИЛОЧНИХ ЗМІННИХ",
        "let data = {\n    a: 17,\n    b: 'Word'\n}\n\nlet newData = data //НОВА ЗМІННА newData ЯКА ПОСИЛАЄТЬСЯ НА ПОПЕРЕДНЮ ЗМІННУ data\nnewData.c = false\n\nconsole.log(newData.c)",
        "ПРИКЛАД ЗМІНИ ТИПУ ЗМІННОЇ З ФУНКЦІЇ НА ЧИСЛО",
        "function a() {\n    console.log('Yo Hed')\n}\n\na = 10\na()",
        "ПРИКЛАД ПОМИЛКИ ПІД ЧАС ЗМІНИ ЗНАЧЕННЯ ЗМІННОЇ",
        "const a = () => {\n    console.log('Yo Hed')\n}\n\na() // 'Yo Hed'\na = 10 //Appear the following error: TypeError: Assignment to constant variable.\na()",
        "ВИКЛИК ВЛАСТИВОСТІ ОБ'ЄКТА myCity",
        "const myCity = {\n    city: 'Lviv',\n    popular: true,\n    country: 'Ukraine'\n}\n\nconsole.log(myCity.city)",
        "ПРИКЛАД ПРИСВОЮВАННЯ ІНШОГО ЗНАЧЕННЯ ДЛЯ ВЛАСТИВОСТІ ОБ'ЄКТА myCity",
        "const myCity = {\n    city: 'Lviv',\n    popular: true,\n    country: 'Ukraine'\n}\n\nmyCity.city = 'Kyiv'//Нове значення властивості city об'єкта myCity\n\nconsole.log(myCity.city)",
        "ДОДАВАННЯ НОВОЇ ВЛАСТИВОСТІ ДЛЯ ОБ'ЄКТА myCity",
        "const myCity = {\n    city: 'Lviv'\n}\nconsole.log(myCity)\n\nmyCity.popular = true //Додавання нової властивості popular у об'єкт myCity\nmyCity.country = 'Ukraine' //Додавання нової властивості country у об'єкт myCity\nconsole.log(myCity)",
        "ПРИКЛАД ВИДАЛЕННЯ ВЛАСТИВОСТІ У ОБ'ЄКТІ ІЗ ДОПОМОГОЮ ОПЕРАТОРА delete",
        "const myCity = {\n    city: 'Lviv',\n    popular: true,\n    country: 'Ukraine'\n}\n\nconsole.log(myCity)\n\ndelete myCity.popular //Видалення властивості popular із об'єкта myCity\nconsole.log(myCity)",
        "РОБОТА ІЗ ВЛАСТИВОСТЯМИ ОБ'ЄКТА ЗА ДОПОМОГОЮ КВАДРАТНИХ СКОБОК []",
        "const myCity = {\n    city: 'Lviv'\n}\n\nmyCity['popular'] = true //Створення нової властивості з назвою popular і присвоєння їй значення true\nconsole.log(myCity)\n\nconst countryProperName = 'country' //Створення змінної countryProperName, яка має значення country\nmyCity[countryProperName] = 'Ukraine' //Створення нової властивості, яка візьме значення із змінної countryProperName. А воно дорівнює country. І тоді присвоїть цій властивості country значення Ukraine\nconsole.log(myCity)",
        "ПРИКЛАД ВКЛАДЕНИХ ОБ'ЄКТІВ info, ЯК ВЛАСТИВІСТЬ У ІНШОМУ ОБ'ЄКТІ myCity",
        "const myCity = {\n    city: 'Lviv',\n    info: {             //Об'єкт info є вкладенним об'єктом myCity. і в свою чергу info також має свої властивості\n        isPopular: true,\n        country: 'Ukraine'\n    }\n}\n\nconsole.log(myCity.info.country) \n\ndelete myCity.info.isPopular       //Приклад видалення властивості вкладенного об'єкта за допомогою крапки\ndelete myCity.info['country']       //Приклад видалення властивості вкладенного об'єкта за допомогою квадратних скобок []\n\nconsole.log(myCity)",
        "ПРИКЛАД ВИКОРИСТАННЯ ЗАВЧАСНО СТВОРЕННИХ ЗМІННИХ ДЛЯ ВИКОРИСТАННЯ ЇХ У ОБ'ЄКТІ",
        "const userName = 'Hed'\nconst userAge = 30\n\nconst userProfile = {\n    userName: userName,\n    userAge: userAge,\n    hasSigned: false\n}\n\nconsole.log(userProfile)",
        "АНАЛОГІЧНИЙ ВАРІАНТ, АЛЕ З ВИКОРИСТАННЯМ СКОРОЧЕННОГО ЗАПИСУ ВЛАСТИВОСТЕЙ",
        "const userName = 'Hed'\nconst userAge = 30\n\nconst userProfile = {\n    userName,\n    userAge,\n    hasSigned: false\n}\n\nconsole.log(userProfile)",
        "МЕТОДИ. Метод - це властивість об'єкта, значення якого це функція",
        "const myCity = {\n    city: 'Lviv',\n    cityGreeting: function () {     //Позначення функції\n        console.log('Greeting!')\n    }\n}\n\nmyCity.cityGreeting()",
        "Виклик метода",
        "або ж:",
        "const myCity = {\n    city: 'Lviv',\n    cityGreeting() {        //Позначення функції\n        console.log('Greeting!')\n    }\n}\n\nmyCity.cityGreeting()",
        "Виклик метода",
        "СТВОРЕННЯ НОВОГО ОБ'ЄКТА НА ОСНОВІ ПОПЕРЕДНЬОГО",
        "Варіант 1:",
        "const user = {      //Створення першого об'єкта\n    userId: 12,\n    userName: 'Bob'\n}\n\nconst user2 = Object.assign({}, user)     //Створення другого об'єкта user2 на основі попереднього user\nuser2.userId = 23     //Зміна значення властивості userId у другому об'єкті user2. Але не зачепаючи першого об'єкта user\n\nconsole.log(user.userId)\nconsole.log(user2.userId)",
        "Варіант 2:",
        "const user = {      //Створення першого об'єкта\n    userId: 12,\n    userName: 'Bob'\n}\n\nconst user2 = {...user}       //Створення другого об'єкта userTwo на основі попереднього user (... - це оператор розділення об'єкта на властивості)\nuser2.userName = 'Mike'       //Зміна значення властивості userName у другому об'єкті user2. Але не зачепаючи першого об'єкта user\n\nconsole.log(user.userName)\nconsole.log(user2.userName)",
        "Варіант 3:",
        "const user = {      //Створення першого об'єкта\n    userId: 12,\n    userName: 'Bob'\n}\n\nconst user2 = JSON.parse(JSON.stringify(user))      //Створення другого об'єкта userTwo на основі попереднього user із допомогою парсування та розпарсування\nuser2.userName = 'Mike'\n\nconsole.log(user.userName)\nconsole.log(user2.userName)",
        "ФУНКЦІЇ",
        "let a = 5\nlet b = 3\n\nfunction sum(a, b) {        //Створення функції sum, яка сумує два числа і виводить результат\n    const c = a + b\n    console.log(c)\n}\n\nsum(a, b)       //Виклик функції sum\na = 12\nb = 8\nsum(a, b)",
        "Виклик функції sum",
        "СТВОРЕННЯ ФУНКЦІЇ ЯКА ПОВЕРТАЄ ЗНАЧЕННЯ РЕЗУЛЬТАТУ ОБЧИСЛЕННЯ",
        "function myFun(a, b) {      //Оголошення функції\n    let c\n    a = a - 1\n    c = a + b\n    return c        //Повертає значення с\n}\n\na = 5\nb = 2\nconsole.log(myFun(a, b))",
        "Вивід результату роботи функції",
        "ВИКЛИК ФУНКЦІЇ !!!",
        "function myFun(a, b) {      //Створення функції (a та b це змінні, яким буде присвоєне значення Аргументів (11 та 2) під час виклику функції)\n    let c\n    a = a - 1\n    c = a + b\n    return c        //Повертає значення с\n}\n//myFun(11, 2)     //Виклик функції myFun (11 та 2 це є Аргументи функції)\n//console.log(myFun(11, 2))  //Виклик функції myFun і вивід результату у консоль\nlet result = myFun(11, 2)       //Присвоєння результату функції myFun змінній result\nconsole.log(result)",
        "Вивід змінної result у консоль",
        "СТВОРЕННЯ КОПІЇ ОБ'ЄКТА І ЙОГО ВИКОРИСТАННЯ У ФУНКЦІЇ",
        "ОПИС: \nМи створюємо об'єкт personOne.\nДалі створюємо функцію increasePersonAge, у якій ми створюємо змінну(об'єкт) updatedPerson, яка буде копією об'єкту personOne для \nвикористання в середині функції.\nТобто після цього об'єкт updatedPerson буде мати тіж самі властивості як і об'єкт personOne (тобто age і userName).\nПісля цього у функції ми збільшуємо на 1 властивість age об'єкта updatedPerson. І повертаємо результат за допомогою return.\nДалі створюємо нову змінну updatedPersonOne і присвоюємо їй результат виклику функції increasePersonAge, аргументом якого буде об'єкт personOne.\nТобто по факту, ми взяли властивості об'єкта personOne, створили його копію(updatedPerson) всередині функції, збільшили значення властивості\nage на одиницю, і результат цих обчислень записали у змінну updatedPersonOne. І вивели цей результат у консоль.",
        "const personOne = {     //Створення об'єкта (це наш зовнішній об'єкт з яким ми будемо працювати, але не змінюючи його)\n    age: 20,\n    userName: 'Hed'\n}\n\nfunction increasePersonAge (person) {\n    const updatedPerson = Object.assign({}, person)     //Створення нової змінної(так званої копії) на основі person\n    updatedPerson.age += 1      //Тут ми збільшуємо значення age на 1\n    return updatedPerson        //І тут повертаємо результат після збільшення age на 1\n}\n\nconst updatedPersonOne = increasePersonAge(personOne)       //Виклик функції increasePersonAge з аргументом personOne. Цей personeOne підставляється на місце person у функції\nconsole.log(personOne.age)\nconsole.log(updatedPersonOne.age)",
        "CALLBACK ФУНКЦІЇ",
        "Приклад колбек функції:",
        "function anotherFunction(){\n    //there is some actions\n}\n\nfunction fnWithCallback(callbackFunction){\n    callbackFunction()\n}\n\nfnWithCallback(anotherFunction)",
        "function printMyName() {\n    console.log('HED')\n}\n\nsetTimeout(printMyName, 1000)",
        "Вбудована в JS функція setTimeout робить затримку на 1000мс після чого виконує функцію яку ми створили вище printMyName",
        "ОБЛАСТІ ВИДИМОСТІ - Вони визначають кордони дії змінних. Є Глобальні і Локальні області. Це можуть бути змінні і тд.",
        "Приклад:",
        "Оголошення  Глобальних змінних a та b:",
        "let a\nlet b \n\nfunction myFn() {\n    let b       //Оголошення Локальної змінної b\n    a = true\n    b = 10\n    console.log(b)      //Тут виведеться число 10, тому що буде викликана Локальна змінна b\n}\n\nmyFn()\n\nconsole.log(a)      // Тут буде вивід true\nconsole.log(b)      // Тут буде вивід undefined, тому що буде викликана Глобальна змінна b",
        "ЛАНЦЮГ ОБЛАСТІ ВИДИМОСТІ",
        "const a = 7",
        "Тут ми об'явили змінну a у Глобальній області видимості",
        "Далі ми створюємо функцію myFn і всередині неї створюємо ще одну функцію innerFn у якій ми викликаємо console.log(a)\nЩо відбувається коли console.log(a) намагається знайти змінну a: він спочатку шукає у області innerFn-не знаходить змінної a. Йде далі і шукає в області myFn-не знаходить.\nЙде далі і шукає у Глобальній області, де вже і знаходить змінну a значення якої дорівнює 7.",
        "function myFn() {       \n    function innerFn() {\n        console.log(a)      //Буде виведено число 7.\n    }\n    innerFn()\n}\n\nmyFn()\ninnerFn()",
        "Тут ми отримаємо помилку, тому що такої змінної/функції як innerFn не існує у Глобальній області видимості. Вона існує тільки всередині області видимості myFn",
        "ОПЕРАТОРИ!!!  Оператор - це по факту вбудована функція в мову програмування",
        "Арифметичні оператори: \n+ Додати \n- Відняти\n* Помножити\n/ Розділити\n\nОператори порувняння: \n=== Дорівнює\n!== Не дорівнює\n<= Більше або дорівнює\n>= Менше або дорівнює\n\nЛогічні оператори:\n! Ні\n&& і\n||  або (или)\n\nОператор присвоювання:\n= Присвоювання\n\nТекстові оператори:\ndelete видаляє властивість значення\nnew \ntypeof перевіряє тип значення\ninstanceof перевіряє принадлежність об'єкта тому чи іншому класу",
        "ОПЕРАТОР ... - завдяки цьому оператору можна створити новий об'єкт(redButton) на основі іншого(button) . Але значення об'єкту button при цьому НЕ змінюються",
        "const button = {\n    width: 200,\n    text: 'Buy'\n}\n\nconst redButton = {\n    ...button,\n    color: 'red'\n}\n\nconsole.table(redButton) //Вивід у вигляді таблиці",
        "КОНКАТЕНАЦІЯ РЯДКІВ за допомогою знака +",
        "const hello = 'Hello'\nconst world = 'World'\n\nconst greeting = hello + ' ' + world\n\nconsole.log(greeting)",
        "КОНКАТЕНАЦІЯ РЯДКІВ за допомогою ШАБЛОННИХ РЯДКІВ. Шаблонні рядки позначаю наступним чином `${значення/змінна} ${значення/змінна} ${значення/змінна}`",
        "const hello = 'Hello'\nconst world = 'World'\n\nconst greeting = `${hello} ${world}`\n\nconsole.log(greeting)",
        "ДОМАШНЄ ЗАВДАННЯ:",
        "const myNameIs = 'Мене Звати'\nconst name = 'Стас'\nconst iAmFrom = 'Я З Міста'\nconst city = 'Львів'\n\nconst result = `${myNameIs} ${name} ${iAmFrom} ${city}`\n\nconsole.log(result)",
        "ФУНКЦІОНАЛЬНІ ВИРАЗИ",
        "const myFunction = function(a, b) {     //function - це і є функціональний вираз. Тобто функція починається з function(a, b) і т.д.. А const myFunction - це змінна\n    let c\n    a = a + 1\n    c = a + b\n    return c\n}\n\nconsole.log(myFunction(5, 3))",
        "ФУНКЦІОНАЛЬНИЙ ВИРАЗ У ВИКЛИКУ ІНШОЇ ФУНКЦІЇ",
        "setTimeout(function() {\n    console.log('Відкладене повідомлення')\n}, 1000)",
        "СТРІЛОЧНА ФУНКЦІЯ ( не має імені та позначається за рахунок => ) . Також треба розуміти, що стрілочна функція є Виразом",
        "(a, b) => {\n    let c\n    a = a + 1\n    c = a + b\n    return c\n}",
        "Приклад, як дати ім'я Стрілочній функції",
        "const myFunction = (a, b) => {\n    let c\n    a = a + 1\n    c = a + b\n    return c\n}\n\nmyFunction(5, 3) // 9",
        "Стрілочна Функція у виклику іншої функції",
        "setTimeout( () => {\n    console.log('MESSAGE!')\n}, 1000)",
        "Варіанти скорочення Стрілочних функцій:",
        "#1 - Якщо функція має тільки один параметр \"a\".",
        "Тіло функції",
        "#2 - Якщо тіло функції складається тільки із одного виразу \"a + b\"",
        "У такому випадку функція автоматично вертає результат її роботи."
    ],
    "docstrings": [],
    "functions": [],
    "classes": []
}