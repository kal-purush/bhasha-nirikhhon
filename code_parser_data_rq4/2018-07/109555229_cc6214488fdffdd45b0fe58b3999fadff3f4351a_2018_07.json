{
    "identifiers": [
        "division",
        "numbers",
        "Integral",
        "numpy",
        "np",
        "BaseIndex",
        "_checks",
        "check_sequential_index",
        "BaseIndex",
        "step_size",
        "burn_in",
        "train_window",
        "test_window",
        "X",
        "raise_on_exception",
        "SequentialIndex",
        "step_size",
        "burn_in",
        "burn_in",
        "step_size",
        "train_window",
        "test_window",
        "raise_on_exception",
        "X",
        "fit",
        "X",
        "X",
        "y",
        "job",
        "X",
        "shape",
        "n",
        "check_sequential_index",
        "burn_in",
        "step_size",
        "train_window",
        "test_window",
        "n",
        "raise_on_exception",
        "burn_in",
        "stop",
        "idx",
        "burn_in",
        "train_window",
        "max",
        "idx",
        "train_window",
        "train_stop",
        "test_window",
        "n_samples",
        "min",
        "idx",
        "test_window",
        "n_samples",
        "train_start",
        "train_stop",
        "test_start",
        "test_stop",
        "train_index",
        "test_index",
        "idx",
        "step_size",
        "idx",
        "n_samples"
    ],
    "literals": [],
    "variables": [
        "step_size",
        "burn_in",
        "train_window",
        "test_window",
        "raise_on_exception",
        "n",
        "n_test_samples",
        "n_samples",
        "__fitted__",
        "idx",
        "stop",
        "burn_in",
        "train_stop",
        "train_start",
        "burn_in",
        "train_start",
        "train_start",
        "test_start",
        "test_stop",
        "test_stop",
        "train_index",
        "test_index",
        "stop"
    ],
    "comments": [],
    "docstrings": [
        "\"\"\"ML-ENSEMBLE\n\n:author: Sebastian Flennerhag\n:copyright: 2017-2018\n:licence: MIT\n\nSequential (time series) indexing.\n\"\"\"",
        "\"\"\"Indexer that generates time series fold over ``X``.\n\n    Sequential iterator that generates fold index tuples that preserve\n    time series structure of data. Consequently, test folds always contain\n    \"future\" observations (i.e. higher index values).\n\n    The generator returns a tuple of stop and start positions to be used\n    for numpy array slicing [stop:start].\n\n    .. versionadded:: 0.2.3\n\n    Parameters\n    ----------\n    step_size : int\n        number of samples to move fold window. Note that setting\n        step_size = train_window will create non-overlapping training\n        folds, while step_size < train_window will not.\n\n    burn_in : int (default=step_size)\n        number of samples to use for first training fold.\n\n    train_window : int (default=None)\n        number of samples to use in each training fold, except first which\n        is determined by ``burn_in``. If ``None``, will use all previous\n        observations.\n\n    test_window : int (default=None)\n        number of samples to use in each test fold. If ``None``,\n        will use all remaining samples in the sequence. The final window\n        size may be smaller if too few observations remain.\n\n    X : array-like of shape [n_samples,] , optional\n        the training set to partition. The training label array is also,\n        accepted, as only the first dimension is used. If ``X`` is not\n        passed at instantiating, the ``fit`` method must be called before\n        ``generate``, or ``X`` must be passed as an argument of\n        ``generate``.\n\n    raise_on_exception : bool (default = True)\n        whether to warn on suspicious slices or raise an error.\n\n    See Also\n    --------\n    :class:`FoldIndex`, :class:`BlendIndex`, :class:`SubsetIndex`\n\n    Examples\n    --------\n\n    >>> import numpy as np\n    >>> from mlens.index import TimeSeriesIndex\n    >>> X = np.arange(10)\n    >>> print(\"Data set: %r\" % X)\n    >>> print()\n    >>>\n    >>> idx = TimeSeriesIndex(2, X)\n    >>>\n    >>> for train, test in idx.generate(as_array=True):\n    ...     print('TRAIN IDX: %32r | TEST IDX: %16r' % (train, test))\n    >>>\n    >>> print()\n    >>>\n    >>> for train, test in idx.generate(as_array=True):\n    ...     print('TRAIN SET: %32r | TEST SET: %16r' % (X[train], X[test]))\n    >>>\n    >>> for train_idx, test_idx in idx.generate(as_array=True):\n    ...     assert max(train_idx) <= min(test_idx)\n    >>>\n    >>> print()\n    >>>\n    >>> print(\"No overlap between train set and test set.\")\n    Data set: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n    TRAIN IDX:     array([3, 4, 5, 6, 7, 8, 9]) | TEST IDX: array([0, 1, 2])\n    TRAIN IDX:     array([0, 1, 2, 6, 7, 8, 9]) | TEST IDX: array([3, 4, 5])\n    TRAIN IDX:  array([0, 1, 2, 3, 4, 5, 8, 9]) | TEST IDX:    array([6, 7])\n    TRAIN IDX:  array([0, 1, 2, 3, 4, 5, 6, 7]) | TEST IDX:    array([8, 9])\n    TRAIN SET:     array([3, 4, 5, 6, 7, 8, 9]) | TEST SET: array([0, 1, 2])\n    TRAIN SET:     array([0, 1, 2, 6, 7, 8, 9]) | TEST SET: array([3, 4, 5])\n    TRAIN SET:  array([0, 1, 2, 3, 4, 5, 8, 9]) | TEST SET:    array([6, 7])\n    TRAIN SET:  array([0, 1, 2, 3, 4, 5, 6, 7]) | TEST SET:    array([8, 9])\n    No overlap between train set and test set.\n    \"\"\"",
        "\"\"\"Method for storing array data.\n\n        Parameters\n        ----------\n        X : array-like of shape [n_samples, optional]\n            array to _collect dimension data from.\n        y : None\n            for compatibility\n        job : None\n            for compatibility\n\n        Returns\n        -------\n        instance :\n            indexer with stores sample size data.\n        \"\"\"",
        "\"\"\"Generate Time series folds\"\"\""
    ],
    "functions": [
        "fit",
        "_gen_indices"
    ],
    "classes": [
        "SequentialIndex"
    ]
}