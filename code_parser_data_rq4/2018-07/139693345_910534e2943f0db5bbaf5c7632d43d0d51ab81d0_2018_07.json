{
    "identifiers": [
        "expose",
        "uneval",
        "uneval",
        "uneval",
        "require",
        "util",
        "util",
        "util",
        "MarkdownHelpers",
        "block",
        "trail",
        "line",
        "arguments",
        "trail",
        "block",
        "s",
        "trail",
        "s",
        "mk_block_inspect",
        "s",
        "mk_block_toSource",
        "line",
        "s",
        "line",
        "s",
        "MarkdownHelpers",
        "obj",
        "obj",
        "MarkdownHelpers",
        "forEach",
        "arr",
        "cb",
        "thisp",
        "arr",
        "cb",
        "thisp",
        "MarkdownHelpers",
        "forEach",
        "arr",
        "cb",
        "thisp",
        "i",
        "arr",
        "i",
        "cb",
        "thisp",
        "arr",
        "arr",
        "i",
        "i",
        "arr",
        "MarkdownHelpers",
        "isEmpty",
        "obj",
        "key",
        "obj",
        "hasOwnProperty",
        "obj",
        "key",
        "MarkdownHelpers",
        "extract_attr",
        "jsonml",
        "isArray",
        "jsonml",
        "jsonml",
        "jsonml",
        "isArray",
        "jsonml",
        "jsonml",
        "dialect",
        "dialect",
        "Markdown",
        "dialect",
        "dialect",
        "Markdown",
        "Markdown",
        "dialect",
        "dialect",
        "Markdown",
        "Markdown",
        "MarkdownHelpers",
        "MarkdownHelpers",
        "Markdown",
        "source",
        "dialect",
        "Markdown",
        "dialect",
        "md",
        "source",
        "i",
        "i",
        "n",
        "n",
        "Markdown",
        "splitBlocks",
        "input",
        "input",
        "input",
        "m",
        "input",
        "line_no",
        "count_lines",
        "m",
        "re",
        "m",
        "m",
        "re",
        "input",
        "m",
        "m",
        "re",
        "blocks",
        "mk_block",
        "m",
        "m",
        "line_no",
        "line_no",
        "count_lines",
        "m",
        "blocks",
        "Markdown",
        "processBlock",
        "block",
        "next",
        "cbs",
        "cbs",
        "cbs",
        "block",
        "next",
        "i",
        "ord",
        "i",
        "cbs",
        "ord",
        "i",
        "block",
        "next",
        "res",
        "isArray",
        "res",
        "res",
        "isArray",
        "res",
        "ord",
        "i",
        "res",
        "Markdown",
        "processInline",
        "block",
        "block",
        "Markdown",
        "toTree",
        "source",
        "custom_root",
        "source",
        "source",
        "source",
        "custom_root",
        "blocks",
        "blocks",
        "blocks",
        "b",
        "b",
        "custom_root",
        "old_tree",
        "Markdown",
        "arguments",
        "args",
        "args",
        "args",
        "Markdown",
        "re",
        "block",
        "cb",
        "block",
        "b",
        "m",
        "re",
        "b",
        "b",
        "b",
        "m",
        "cb",
        "m",
        "b",
        "Markdown",
        "d",
        "i",
        "d",
        "i",
        "i",
        "ord",
        "i",
        "d",
        "ord",
        "Markdown",
        "d",
        "i",
        "d",
        "i",
        "i",
        "patterns",
        "i",
        "l",
        "l",
        "patterns",
        "patterns",
        "d",
        "patterns",
        "d",
        "d",
        "text",
        "pattern",
        "pattern",
        "fn",
        "text",
        "pattern",
        "fn",
        "text",
        "patterns",
        "MarkdownHelpers",
        "Markdown",
        "jsonml",
        "options",
        "options",
        "options",
        "options",
        "options",
        "options",
        "content",
        "render_tree",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "content",
        "render_tree",
        "jsonml",
        "content",
        "Markdown",
        "toHTMLTree",
        "input",
        "dialect",
        "options",
        "input",
        "input",
        "input",
        "dialect",
        "extract_attr",
        "input",
        "attrs",
        "attrs",
        "refs",
        "attrs",
        "convert_tree_to_html",
        "input",
        "refs",
        "options",
        "merge_text_nodes",
        "html",
        "html",
        "Markdown",
        "toHTML",
        "source",
        "dialect",
        "options",
        "source",
        "dialect",
        "options",
        "input",
        "text",
        "text",
        "jsonml",
        "jsonml",
        "escapeHTML",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "attributes",
        "jsonml",
        "jsonml",
        "content",
        "render_tree",
        "jsonml",
        "a",
        "attributes",
        "tag_attrs",
        "a",
        "escapeHTML",
        "attributes",
        "a",
        "tag",
        "tag",
        "tag",
        "tag",
        "tag_attrs",
        "tag",
        "tag_attrs",
        "content",
        "tag",
        "tree",
        "references",
        "options",
        "options",
        "options",
        "tree",
        "options",
        "jsonml",
        "options",
        "jsonml",
        "references",
        "extract_attr",
        "jsonml",
        "attrs",
        "jsonml",
        "i",
        "attrs",
        "jsonml",
        "i",
        "attrs",
        "i",
        "attrs",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "attrs",
        "attrs",
        "jsonml",
        "i",
        "attrs",
        "code",
        "code",
        "jsonml",
        "i",
        "jsonml",
        "i",
        "jsonml",
        "i",
        "code",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "jsonml",
        "references",
        "attrs",
        "attrs",
        "attrs",
        "attrs",
        "attrs",
        "attrs",
        "jsonml",
        "references",
        "attrs",
        "attrs",
        "attrs",
        "attrs",
        "attrs",
        "attrs",
        "i",
        "attrs",
        "key",
        "jsonml",
        "i",
        "i",
        "jsonml",
        "i",
        "i",
        "jsonml",
        "i",
        "jsonml",
        "i",
        "convert_tree_to_html",
        "jsonml",
        "i",
        "references",
        "options",
        "jsonml",
        "jsonml",
        "extract_attr",
        "jsonml",
        "i",
        "jsonml",
        "jsonml",
        "i",
        "i",
        "jsonml",
        "jsonml",
        "i",
        "jsonml",
        "i",
        "jsonml",
        "i",
        "i",
        "merge_text_nodes",
        "jsonml",
        "i",
        "i",
        "DialectHelpers",
        "text",
        "want",
        "text",
        "consumed",
        "want",
        "consumed",
        "consumed",
        "nodes",
        "consumed",
        "text",
        "text",
        "consumed",
        "consumed",
        "res",
        "nodes",
        "nodes",
        "res",
        "DialectHelpers",
        "d",
        "Block",
        "d",
        "Inline",
        "d",
        "Block",
        "Inline",
        "MarkdownHelpers",
        "MarkdownHelpers",
        "MarkdownHelpers",
        "MarkdownHelpers",
        "DialectHelpers",
        "atxHeader",
        "block",
        "next",
        "block",
        "m",
        "m",
        "header",
        "m",
        "m",
        "block",
        "next",
        "mk_block",
        "block",
        "m",
        "block",
        "block",
        "header",
        "setextHeader",
        "block",
        "next",
        "block",
        "m",
        "m",
        "level",
        "m",
        "m",
        "block",
        "next",
        "mk_block",
        "block",
        "m",
        "block",
        "block",
        "header",
        "code",
        "block",
        "next",
        "block",
        "re",
        "re",
        "block",
        "m",
        "ret",
        "m",
        "b",
        "next",
        "mk_block",
        "b",
        "block",
        "next",
        "next",
        "re",
        "ret",
        "block",
        "block",
        "next",
        "ret",
        "horizRule",
        "block",
        "next",
        "block",
        "m",
        "m",
        "mk_block",
        "m",
        "block",
        "jsonml",
        "jsonml",
        "contained",
        "m",
        "next",
        "mk_block",
        "m",
        "block",
        "block",
        "jsonml",
        "any_list",
        "depth",
        "indent_re",
        "depth",
        "any_list",
        "indent_re",
        "depth",
        "input",
        "input",
        "li",
        "loose",
        "inline",
        "nl",
        "loose",
        "li",
        "inline",
        "li",
        "li",
        "li",
        "li",
        "li",
        "li",
        "li",
        "nl",
        "li",
        "inline",
        "nl",
        "i",
        "inline",
        "i",
        "inline",
        "i",
        "what",
        "is_str",
        "add_to",
        "add_to",
        "add_to",
        "add_to",
        "add_to",
        "what",
        "add_to",
        "what",
        "depth",
        "blocks",
        "indent_re",
        "depth",
        "indent_re",
        "depth",
        "blocks",
        "re",
        "blocks",
        "blocks",
        "b",
        "replace",
        "ret",
        "mk_block",
        "x",
        "b",
        "b",
        "ret",
        "s",
        "i",
        "stack",
        "s",
        "last_li",
        "last_li",
        "i",
        "stack",
        "last_li",
        "last_li",
        "last_li",
        "last_li",
        "last_li",
        "last_li",
        "last_li",
        "sublist",
        "block",
        "next",
        "block",
        "is_list_re",
        "m",
        "m",
        "bullet_list",
        "m",
        "stack",
        "m",
        "make_list",
        "m",
        "stack",
        "block",
        "line_no",
        "lines",
        "line_no",
        "nl",
        "lines",
        "line_no",
        "n",
        "nl",
        "n",
        "regex_for_depth",
        "stack",
        "m",
        "l",
        "line_re",
        "m",
        "li_accumulate",
        "add",
        "last_li",
        "loose",
        "li_accumulate",
        "nl",
        "loose",
        "li_accumulate",
        "m",
        "expand_tab",
        "m",
        "m",
        "wanted_depth",
        "stack",
        "make_list",
        "m",
        "last_li",
        "last_li",
        "i",
        "i",
        "stack",
        "i",
        "stack",
        "i",
        "m",
        "stack",
        "i",
        "stack",
        "i",
        "stack",
        "i",
        "found",
        "found",
        "wanted_depth",
        "wanted_depth",
        "stack",
        "stack",
        "wanted_depth",
        "stack",
        "wanted_depth",
        "stack",
        "wanted_depth",
        "make_list",
        "m",
        "last_li",
        "last_li",
        "last_li",
        "nl",
        "l",
        "m",
        "li_accumulate",
        "nl",
        "l",
        "m",
        "li_accumulate",
        "add",
        "last_li",
        "loose",
        "li_accumulate",
        "nl",
        "loose",
        "li_accumulate",
        "get_contained_blocks",
        "stack",
        "next",
        "contained",
        "forEach",
        "stack",
        "paragraphify",
        "last_li",
        "last_li",
        "contained",
        "next",
        "next",
        "next_block",
        "is_list_re",
        "next_block",
        "block",
        "next",
        "block",
        "next",
        "hr",
        "ret",
        "ret",
        "hr",
        "forEach",
        "stack",
        "paragraphify",
        "loose",
        "ret",
        "blockquote",
        "block",
        "next",
        "block",
        "block",
        "block",
        "block",
        "lines",
        "lines",
        "prev",
        "lines",
        "line_no",
        "mk_block",
        "prev",
        "block",
        "jsonml",
        "jsonml",
        "abutting",
        "block",
        "mk_block",
        "lines",
        "block",
        "line_no",
        "next",
        "next",
        "next",
        "block",
        "mk_block",
        "block",
        "block",
        "b",
        "b",
        "block",
        "block",
        "input",
        "extract_attr",
        "processedBlock",
        "attr",
        "attr",
        "attr",
        "isEmpty",
        "attr",
        "processedBlock",
        "jsonml",
        "processedBlock",
        "jsonml",
        "referenceDefn",
        "block",
        "next",
        "block",
        "re",
        "extract_attr",
        "extract_attr",
        "attrs",
        "attrs",
        "re",
        "block",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "attrs",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "b",
        "next",
        "mk_block",
        "b",
        "block",
        "para",
        "block",
        "block",
        "oneElement",
        "text",
        "patterns_or_re",
        "previous_nodes",
        "patterns_or_re",
        "patterns_or_re",
        "patterns_or_re",
        "patterns_or_re",
        "m",
        "re",
        "text",
        "m",
        "text",
        "text",
        "m",
        "m",
        "m",
        "m",
        "res",
        "m",
        "text",
        "m",
        "m",
        "previous_nodes",
        "res",
        "res",
        "m",
        "m",
        "res",
        "inline",
        "text",
        "patterns",
        "x",
        "x",
        "x",
        "x",
        "text",
        "res",
        "text",
        "patterns",
        "text",
        "text",
        "res",
        "forEach",
        "res",
        "add",
        "escaped",
        "text",
        "text",
        "text",
        "image",
        "text",
        "text",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "attrs",
        "m",
        "m",
        "attrs",
        "m",
        "text",
        "m",
        "m",
        "m",
        "m",
        "m",
        "link",
        "text",
        "text",
        "inline_until_char",
        "text",
        "res",
        "res",
        "res",
        "text",
        "text",
        "consumed",
        "text",
        "m",
        "m",
        "consumed",
        "m",
        "url",
        "url",
        "url",
        "url",
        "url",
        "url",
        "url",
        "m",
        "len",
        "url",
        "len",
        "url",
        "len",
        "open_parens",
        "open_parens",
        "consumed",
        "url",
        "len",
        "url",
        "url",
        "len",
        "url",
        "url",
        "attrs",
        "url",
        "m",
        "attrs",
        "m",
        "link",
        "attrs",
        "children",
        "consumed",
        "link",
        "m",
        "text",
        "m",
        "consumed",
        "m",
        "attrs",
        "m",
        "children",
        "orig",
        "consumed",
        "link",
        "attrs",
        "children",
        "consumed",
        "link",
        "children",
        "children",
        "attrs",
        "children",
        "orig",
        "consumed",
        "link",
        "attrs",
        "children",
        "consumed",
        "link",
        "autoLink",
        "text",
        "m",
        "text",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "m",
        "inlineCode",
        "text",
        "text",
        "m",
        "m",
        "m",
        "m",
        "m",
        "lineBreak",
        "tag",
        "md",
        "tag",
        "tag",
        "len",
        "len",
        "md",
        "text",
        "state_slot",
        "md",
        "state_slot",
        "text",
        "CloseTag",
        "text",
        "md",
        "other_slot",
        "state_slot",
        "state_slot",
        "md",
        "text",
        "md",
        "res",
        "res",
        "state_slot",
        "last",
        "CloseTag",
        "res",
        "text",
        "last",
        "consumed",
        "tag",
        "res",
        "other_slot",
        "other",
        "state_slot",
        "state",
        "md",
        "md",
        "Gruber",
        "strong_em",
        "Gruber",
        "strong_em",
        "Gruber",
        "strong_em",
        "Gruber",
        "strong_em",
        "Markdown",
        "Gruber",
        "Markdown",
        "Markdown",
        "Markdown",
        "Markdown",
        "DialectHelpers",
        "Gruber",
        "MarkdownHelpers",
        "MarkdownHelpers",
        "Maruku",
        "processMetaHash",
        "meta_string",
        "split_meta_hash",
        "meta_string",
        "i",
        "meta",
        "i",
        "meta",
        "i",
        "attr",
        "meta",
        "i",
        "meta",
        "i",
        "attr",
        "attr",
        "attr",
        "meta",
        "i",
        "attr",
        "meta",
        "i",
        "meta",
        "i",
        "meta",
        "i",
        "attr",
        "s",
        "s",
        "attr",
        "meta_string",
        "meta_string",
        "meta",
        "meta",
        "letter",
        "in_quotes",
        "parts",
        "parts",
        "letter",
        "parts",
        "in_quotes",
        "in_quotes",
        "letter",
        "meta",
        "parts",
        "parts",
        "letter",
        "parts",
        "Maruku",
        "document_meta",
        "block",
        "block",
        "block",
        "extract_attr",
        "block",
        "p",
        "pairs",
        "pairs",
        "p",
        "m",
        "m",
        "key",
        "value",
        "Maruku",
        "block_meta",
        "block",
        "block",
        "m",
        "m",
        "m",
        "hash",
        "extract_attr",
        "node",
        "node",
        "hash",
        "hash",
        "node",
        "hash",
        "a",
        "attr",
        "hash",
        "a",
        "attr",
        "a",
        "block",
        "b",
        "hash",
        "extract_attr",
        "result",
        "hash",
        "hash",
        "result",
        "hash",
        "a",
        "attr",
        "hash",
        "a",
        "attr",
        "a",
        "result",
        "Maruku",
        "definition_list",
        "block",
        "next",
        "m",
        "block",
        "tight",
        "block",
        "next",
        "tight",
        "next",
        "blocks",
        "next",
        "b",
        "blocks",
        "b",
        "blocks",
        "b",
        "tight",
        "m",
        "m",
        "i",
        "i",
        "terms",
        "i",
        "terms",
        "i",
        "i",
        "i",
        "defns",
        "i",
        "defns",
        "i",
        "Maruku",
        "table",
        "block",
        "s",
        "ch",
        "ch",
        "ch",
        "ch",
        "ch",
        "ch",
        "ch",
        "ch",
        "m",
        "s",
        "r",
        "res",
        "m",
        "s",
        "m",
        "res",
        "s",
        "res",
        "m",
        "block",
        "leading_pipe",
        "m",
        "m",
        "m",
        "block",
        "no_leading_pipe",
        "m",
        "m",
        "forEach",
        "m",
        "s",
        "s",
        "html_attrs",
        "s",
        "html_attrs",
        "s",
        "html_attrs",
        "html_attrs",
        "m",
        "_split_on_unescaped",
        "m",
        "i",
        "i",
        "m",
        "i",
        "table",
        "html_attrs",
        "i",
        "m",
        "i",
        "forEach",
        "m",
        "row",
        "row",
        "_split_on_unescaped",
        "row",
        "i",
        "i",
        "row",
        "i",
        "html_row",
        "html_attrs",
        "i",
        "row",
        "i",
        "table",
        "html_row",
        "table",
        "Maruku",
        "inline_meta",
        "text",
        "matches",
        "before",
        "text",
        "m",
        "m",
        "extract_attr",
        "before",
        "attr",
        "attr",
        "before",
        "attr",
        "k",
        "meta",
        "attr",
        "k",
        "meta",
        "k",
        "m",
        "Markdown",
        "Maruku",
        "Markdown",
        "Markdown",
        "Markdown",
        "Markdown",
        "Markdown",
        "expose",
        "Markdown",
        "expose",
        "Markdown",
        "expose",
        "Markdown",
        "expose",
        "Markdown",
        "expose",
        "Markdown"
    ],
    "literals": [
        "\"Markdown.mk_block( \"",
        "\", \"",
        "\", \"",
        "\" )\"",
        "\"util\"",
        "\"Markdown.mk_block( \"",
        "\", \"",
        "\", \"",
        "\" )\"",
        "\"\\n\\n\"",
        "\"[object Array]\"",
        "\"object\"",
        "\"undefined\"",
        "\"object\"",
        "\"Unknown Markdown dialect '\"",
        "\"'\"",
        "\"\"",
        "\"\\n\"",
        "\"\\n\"",
        "\"\\n#\"",
        "\"\\n\"",
        "\"__call__\"",
        "\"didn't return a proper array\"",
        "\"markdown\"",
        "\"undefined\"",
        "\"undefined\"",
        "\"undefined\"",
        "\"__order__\"",
        "\"__call__\"",
        "\"\\\\$1\"",
        "\"\\\\n\"",
        "\"(?:\"",
        "\")\"",
        "\"|\"",
        "\"object\"",
        "\"\\n\\n\"",
        "\"string\"",
        "\"&amp;\"",
        "\"&lt;\"",
        "\"&gt;\"",
        "\"&quot;\"",
        "\"&#39;\"",
        "\"string\"",
        "\"object\"",
        "\"\"",
        "\" \"",
        "'=\"'",
        "'\"'",
        "\"img\"",
        "\"br\"",
        "\"hr\"",
        "\"<\"",
        "\"/>\"",
        "\"<\"",
        "\">\"",
        "\"\"",
        "\"</\"",
        "\">\"",
        "\"function\"",
        "\"string\"",
        "\"header\"",
        "\"h\"",
        "\"bulletlist\"",
        "\"ul\"",
        "\"numberlist\"",
        "\"ol\"",
        "\"listitem\"",
        "\"li\"",
        "\"para\"",
        "\"p\"",
        "\"markdown\"",
        "\"html\"",
        "\"code_block\"",
        "\"pre\"",
        "\"code\"",
        "\"inlinecode\"",
        "\"code\"",
        "\"img\"",
        "\"linebreak\"",
        "\"br\"",
        "\"link\"",
        "\"a\"",
        "\"link_ref\"",
        "\"a\"",
        "\"img_ref\"",
        "\"img\"",
        "\"string\"",
        "\"string\"",
        "\"header\"",
        "\"=\"",
        "\"header\"",
        "\"\"",
        "\"code_block\"",
        "\"\\n\"",
        "\"hr\"",
        "\"\"",
        "\"[*+-]|\\\\d+\\\\.\"",
        "\"^( {0,3})(\"",
        "\")[ \\t]+\"",
        "\"(?: {0,3}\\\\t| {4})\"",
        "\"(?:^(\"",
        "\"{0,\"",
        "\"} {0,3})(\"",
        "\")\\\\s+)|\"",
        "\"(^\"",
        "\"{0,\"",
        "\"}[ ]{0,4})\"",
        "\"    \"",
        "\"para\"",
        "\"para\"",
        "\"string\"",
        "\"string\"",
        "\"^(\"",
        "\"{\"",
        "\"}.*?\\\\n?)*$\"",
        "\"^\"",
        "\"{\"",
        "\"}\"",
        "\"gm\"",
        "\"\"",
        "\"para\"",
        "\"para\"",
        "\"para\"",
        "\"bulletlist\"",
        "\"numberlist\"",
        "\"\"",
        "\"\"",
        "\"\"",
        "\"\"",
        "\"\"",
        "\"listitem\"",
        "\"listitem\"",
        "\"\"",
        "\"\"",
        "\"\"",
        "\">\"",
        "\">\"",
        "\"\\n\"",
        "\"\\n\"",
        "\"\\n\"",
        "\">\"",
        "\"\"",
        "\"blockquote\"",
        "\"<\"",
        "\">\"",
        "\"para\"",
        "\"([\\\\s\\\\S]*?)(\"",
        "\")\"",
        "\"string\"",
        "\"string\"",
        "\"]\"",
        "\"}\"",
        "\"\\\\\"",
        "\"\\\\\"",
        "\"![\"",
        "\"<\"",
        "\">\"",
        "\"\"",
        "\"img\"",
        "\"img_ref\"",
        "\"![\"",
        "\"[\"",
        "\"]\"",
        "\"[\"",
        "\"<\"",
        "\">\"",
        "\"(\"",
        "\")\"",
        "\"\"",
        "\"link\"",
        "\"link_ref\"",
        "\"string\"",
        "\"link_ref\"",
        "\"[\"",
        "\"<\"",
        "\"link\"",
        "\"mailto:\"",
        "\"mailto\"",
        "\"link\"",
        "\"mailto:\"",
        "\"link\"",
        "\"<\"",
        "\"`\"",
        "\"inlinecode\"",
        "\"`\"",
        "\"  \\n\"",
        "\"linebreak\"",
        "\"_state\"",
        "\"strong\"",
        "\"em_state\"",
        "\"strong_state\"",
        "\"close_\"",
        "\"**\"",
        "\"strong\"",
        "\"**\"",
        "\"__\"",
        "\"strong\"",
        "\"__\"",
        "\"*\"",
        "\"em\"",
        "\"*\"",
        "\"_\"",
        "\"em\"",
        "\"_\"",
        "\"class\"",
        "\"class\"",
        "\"class\"",
        "\" \"",
        "\"class\"",
        "\"\"",
        "\"\"",
        "\" \"",
        "\"\"",
        "\"'\"",
        "'\"'",
        "\"\\\\\"",
        "\"\"",
        "\"string\"",
        "\"\"",
        "\"dl\"",
        "\"\"",
        "\"dt\"",
        "\"dd\"",
        "\"$1\"",
        "'\\\\s'",
        "'\\\\'",
        "'^((?:\\\\\\\\.|[^\\\\\\\\'",
        "'])*)'",
        "'(.*)'",
        "''",
        "\"table\"",
        "\"thead\"",
        "\"tr\"",
        "\"tbody\"",
        "''",
        "'|'",
        "\"right\"",
        "\"left\"",
        "\"center\"",
        "''",
        "'|'",
        "'th'",
        "''",
        "'\\n'",
        "'tr'",
        "'|'",
        "'td'",
        "\"{:\"",
        "\"{:\"",
        "\"string\"",
        "\"{:\"",
        "\"{:\"",
        "\"\""
    ],
    "variables": [
        "MarkdownHelpers",
        "util",
        "s",
        "isArray",
        "i",
        "Markdown",
        "mk_block",
        "isArray",
        "md",
        "n",
        "i",
        "re",
        "blocks",
        "m",
        "line_no",
        "cbs",
        "ord",
        "i",
        "res",
        "blocks",
        "old_tree",
        "b",
        "args",
        "m",
        "b",
        "ord",
        "patterns",
        "l",
        "fn",
        "extract_attr",
        "content",
        "attrs",
        "refs",
        "html",
        "input",
        "tag",
        "attributes",
        "content",
        "tag_attrs",
        "i",
        "jsonml",
        "attrs",
        "code",
        "i",
        "DialectHelpers",
        "consumed",
        "nodes",
        "res",
        "forEach",
        "extract_attr",
        "mk_block",
        "isEmpty",
        "inline_until_char",
        "Gruber",
        "m",
        "header",
        "m",
        "level",
        "header",
        "ret",
        "re",
        "b",
        "m",
        "jsonml",
        "contained",
        "any_list",
        "bullet_list",
        "is_list_re",
        "indent_re",
        "add_to",
        "i",
        "what",
        "is_str",
        "re",
        "replace",
        "ret",
        "b",
        "x",
        "last_li",
        "sublist",
        "m",
        "stack",
        "last_li",
        "loose",
        "ret",
        "i",
        "lines",
        "li_accumulate",
        "nl",
        "line_no",
        "l",
        "line_re",
        "wanted_depth",
        "found",
        "contained",
        "next_block",
        "hr",
        "jsonml",
        "lines",
        "prev",
        "line_no",
        "abutting",
        "b",
        "input",
        "old_tree",
        "processedBlock",
        "attr",
        "re",
        "attrs",
        "b",
        "m",
        "res",
        "re",
        "res",
        "res",
        "m",
        "attrs",
        "orig",
        "res",
        "consumed",
        "children",
        "link",
        "attrs",
        "m",
        "url",
        "open_parens",
        "len",
        "m",
        "m",
        "state_slot",
        "other_slot",
        "other",
        "state",
        "res",
        "last",
        "check",
        "consumed",
        "Maruku",
        "extract_attr",
        "forEach",
        "meta",
        "attr",
        "i",
        "s",
        "meta",
        "parts",
        "in_quotes",
        "letter",
        "pairs",
        "m",
        "key",
        "value",
        "m",
        "attr",
        "hash",
        "node",
        "b",
        "result",
        "tight",
        "i",
        "m",
        "blocks",
        "b",
        "m",
        "terms",
        "defns",
        "_split_on_unescaped",
        "res",
        "r",
        "m",
        "leading_pipe",
        "no_leading_pipe",
        "i",
        "m",
        "table",
        "html_attrs",
        "html_row",
        "before",
        "m",
        "meta",
        "attr"
    ],
    "comments": [
        "Released under MIT license",
        "Copyright (c) 2009-2010 Dominic Baggott",
        "Copyright (c) 2009-2010 Ash Berlin",
        "Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)",
        "Date: 2013-09-15T16:12Z",
        "For Spidermonkey based engines",
        "node",
        "Be helpful for default case in tests.",
        "We actually need a String object, not a string primitive",
        "jshint -W053",
        "To make it clear its not just a string",
        "Don't mess with Array.prototype. Its not friendly",
        "Imported functions",
        "dialect will default if undefined",
        "Internal - split source into rough blocks",
        "[\\s\\S] matches _anything_ (newline or space)",
        "[^] is equivalent but doesn't work in IEs.",
        "skip (but count) leading blank lines",
        "D:this.debug( \"Testing\", ord[i] );",
        "D:this.debug(\"  matched\");",
        "D:this.debug( \"\" );",
        "Uhoh! no match! Should we throw an error?",
        "custom_tree means set this.tree to `custom_tree` and restore old value on return",
        "Make tree a member variable so its easier to mess with in extensions",
        "Reference blocks and the like won't return any content",
        "Noop by default",
        "Dont use /g regexps with this",
        "Build default order from insertion order.",
        "Build patterns for inline matcher",
        "__foo__ is reserved and not a pattern",
        "print(\"patterns:\", uneval( patterns ) );",
        "include the root element in the rendered output?",
        "get rid of the tag",
        "get rid of the attributes",
        "convert string input to an MD tree",
        "Now convert the MD tree to an HTML tree",
        "remove references from the tree",
        "basic case",
        "be careful about adding whitespace here for inline elements",
        "shallow clone",
        "Clone attributes if they exist",
        "basic case",
        "convert this node",
        "grab this ref and clean up the attribute node",
        "if the reference exists, make the link",
        "add in the href and title, if present",
        "get rid of the unneeded original text",
        "the reference doesn't exist, so revert to plain text",
        "grab this ref and clean up the attribute node",
        "if the reference exists, make the link",
        "add in the href and title, if present",
        "get rid of the unneeded original text",
        "the reference doesn't exist, so revert to plain text",
        "convert all the children",
        "deal with the attribute node, if it exists",
        "if there are keys, skip over it",
        "if there aren't, remove it",
        "merges adjacent text nodes into a single node",
        "skip the tag name and attribute hash",
        "if it's a string check the next item too",
        "merge the second string into the first and remove it",
        "if it's not a string recurse",
        "Found the character we were looking for",
        "No closing char found. Abort.",
        "Add any returned nodes.",
        "Helper function to make sub-classing a dialect easier",
        "|    Foo",
        "|bar",
        "should be a code block followed by a paragraph. Fun",
        "",
        "There might also be adjacent code block to merge.",
        "4 spaces + content",
        "Now pull out the rest of the lines",
        "Case alluded to in first comment. push it back on as a new block",
        "Check the next block - it might be code too",
        "Pull how how many blanks lines follow - minus two to account for .join",
        "this needs to find any hr in the block to handle abutting blocks",
        "if there's a leading abutting block, process it",
        "if there's a trailing abutting block, stick it into next",
        "There are two types of lists. Tight and loose. Tight lists have no whitespace",
        "between the items (and result in text just in the <li>) and loose lists,",
        "which have an empty line between list items, resulting in (one or more)",
        "paragraphs inside the <li>.",
        "",
        "There are all sorts weird edge cases about the original markdown.pl's",
        "handling of lists:",
        "",
        "if they aren't, you can get a nested list by indenting by less than",
        "four so long as the indent doesn't match an indent of an existing list",
        "item in the 'nest stack'.",
        "",
        "first item at the indent. Subsequent changes are ignored unless they",
        "are for nested lists",
        "",
        "Use a closure to hide a few variables.",
        "Capture leading indent as it matters for determining nested lists.",
        "TODO: Cache this regexp for certain depths.",
        "Create a regexp suitable for matching an li for a given stack depth",
        "m[1] = indent, m[2] = list_type",
        "m[3] = cont",
        "Add inline content `inline` to `li`. inline comes from processInline",
        "so is an array of content",
        "Hmmm, should this be any block level element or just paras?",
        "If there is already some content in this list, add the new line in",
        "contained means have an indent greater than the current one. On",
        "Now remove that indent",
        "passed to stack.forEach to turn list items up the stack into paras",
        "Last stack frame",
        "Keep the same array, but replace the contents",
        "The matcher function",
        "Stack of lists for nesting.",
        "Loop to search over block looking for inner block elements and loose lists",
        "Split into lines preserving new lines at end of line",
        "We have to grab all lines for a li and call processInline on them",
        "once as there are some inline things that can span lines.",
        "Loop over the lines in this block looking for tight lists.",
        "TODO: really should cache this",
        "print( \"line:\", uneval(l), \"\\nline match:\", uneval(m) );",
        "We have a list item",
        "Process the previous list item, if any",
        "Loose mode will have been dealt with. Reset it",
        "print( \"want:\", wanted_depth, \"stack:\", stack.length);",
        "Deep enough for a nested list outright",
        "print ( \"new nested list\" );",
        "We aren't deep enough to be strictly a new level. This is",
        "where Md.pl goes nuts. If the indent matches a level in the",
        "stack, put it there, else put it one deeper then the",
        "wanted_depth deserves.",
        "print(\"not found. l:\", uneval(l));",
        "print(\"Desired depth now\", wanted_depth, \"stack:\", stack.length);",
        "print(\"list:\", uneval(list) );",
        "print (\"made new stack for messy indent\");",
        "print( uneval(list), \"last\", list === stack[stack.length-1].list );",
        "end depth of shenegains",
        "Add content",
        "tight_search",
        "Loose mode will have been dealt with. Reset it",
        "Look at the next block - we might have a loose list. Or an extra",
        "paragraph for the current li",
        "Deal with code blocks or properly nested lists",
        "Make sure all listitems up the stack are paragraphs",
        "Check for an HR following a list: features/lists/hr_abutting",
        "Make sure all listitems up the stack are paragraphs",
        "loose_search",
        "separate out the leading abutting block, if any. I.e. in this case:",
        "",
        "a",
        "> b",
        "",
        "keep shifting lines until you find a crotchet",
        "reassemble new block of just block quotes!",
        "if the next block is also a blockquote merge it in",
        "Strip off the leading \"> \" and re-process as a block.",
        "If any link references were found get rid of them",
        "And then remove the attribute object if it's empty",
        "interesting matches are [ , ref_id, url, , title, title ]",
        "make an attribute node if it doesn't exist",
        "make a references hash if it doesn't exist",
        "everything's a para!",
        "Just boring text",
        "Some un-interesting text matched. Return that first",
        "Default for now to make dev easier. just slurp special and output it.",
        "D:self.debug(\"  adding output\", uneval(x));",
        "These characters are intersting elsewhere, so have rules for them so that",
        "chunks of plain text blocks don't include them",
        "[ length of input processed, node/children to add... ]",
        "Only esacape: \\ ` * _ { } [ ] ( ) # * + - . !",
        "Not an esacpe",
        "Unlike images, alt text is plain text only. no other elements are",
        "allowed in there",
        "![Alt text](/path/to/img.jpg \"Optional title\")",
        "1          2            3       4         <--- captures",
        "![Alt text][id]",
        "We can't check if the reference is known here as it likely wont be",
        "found till after. Check it in md tree->hmtl tree conversion",
        "Just consume the '!['",
        "Inline content is possible inside `link text`",
        "No closing ']' found. Just consume the [",
        "At this point the first [...] has been parsed. See what follows to find",
        "out which kind of link we are (reference or direct url)",
        "[link text](/path/to/img.jpg \"Optional title\")",
        "1            2       3         <--- captures",
        "This will capture up to the last paren in the block. We then pull",
        "back based on if there a matching ones in the url",
        "([here](/url/(test))",
        "The parens have to be balanced",
        "If there is a title we don't have to worry about parens in the url",
        "One open that isn't in the capture",
        "Process escapes only",
        "[Alt text][id]",
        "[Alt text] [id]",
        "[links][] uses links as its reference",
        "We can't check if the reference is known here as it likely wont be",
        "found till after. Check it in md tree->hmtl tree conversion.",
        "Store the original so that conversion can revert if the ref isn't found.",
        "[id]",
        "Only if id is plain (no formatting.)",
        "Just consume the \"[\"",
        "Inline code block. as many backticks as you like to start it",
        "Always skip over the opening ticks.",
        "TODO: No matching end code found - warn!",
        "Meta Helper/generator method for em and strong handling",
        "Most recent em is of this type",
        "D:this.debug(\"closing\", md);",
        "\"Consume\" everything to go back to the recrusion in the else-block below",
        "Store a clone of the em/strong states",
        "D:this.debug_indent += \"  \";",
        "Recurse",
        "D:this.debug_indent = this.debug_indent.substr(2);",
        "D:this.debug(\"processInline from\", tag + \": \", uneval( res ) );",
        "We matched! Huzzah.",
        "Restore the state of the other kind. We might have mistakenly closed it.",
        "We can't reuse the processed result as it could have wrong parsing contexts in it.",
        "End returned function",
        "id: #foo",
        "class: .foo",
        "if class already exists, append the new one",
        "attribute: foo=bar",
        "if we're in a quoted section, keep it",
        "otherwise make a new part",
        "reverse the quotes and move straight on",
        "shift off the next letter to be used straight away.",
        "it was escaped so we'll keep it whatever it is",
        "falls through",
        "we're only interested in the first block",
        "document_meta blocks consist of one or more lines of `Key: Value\\n`",
        "make an attribute node if it doesn't exist",
        "document_meta produces no content!",
        "check if the last line of the block is an meta hash",
        "process the meta hash",
        "if we matched ^ then we need to apply meta to the previous block",
        "if the node is a string (rather than JsonML), bail",
        "create the attribute hash if it doesn't exist",
        "add the attributes in",
        "return nothing so the meta hash is removed",
        "pull the meta hash off the block and process what's left",
        "get or make the attributes hash",
        "attach the attributes to the block",
        "one or more terms followed by one or more definitions, in a single block",
        "see if we're dealing with a tight or loose block",
        "pull subsequent tight DL blocks out of `next`",
        "print( uneval( m ) );",
        "run inline processing over the definition",
        "splits on unescaped instances of @ch. If @ch is not a character the result",
        "can be unpredictable",
        "find at least an unescaped pipe in each line",
        "remove leading pipes in contents",
        "(header and horizontal rule already have the leading pipe left out)",
        "remove trailing pipes, then split on pipes",
        "(no escaped pipes are allowed in horizontal rule)",
        "process alignment",
        "now for the header, avoid escaped pipes",
        "now for body contents",
        "get the preceeding element",
        "match a meta hash",
        "no match, false alarm",
        "attach the attributes to the preceeding element",
        "cut out the string and replace it with nothing",
        "Include all our depndencies and;"
    ],
    "docstrings": [
        "*  class Markdown\n   *\n   *  Markdown processing in Javascript done right. We have very particular views\n   *  on what constitutes 'right' which include:\n   *\n   *  - produces well-formed HTML (this means that em and strong nesting is\n   *    important)\n   *\n   *  - has an intermediate representation to allow processing of parsed data (We\n   *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).\n   *\n   *  - is easily extensible to add new dialects without having to rewrite the\n   *    entire parsing mechanics\n   *\n   *  - has a good test suite\n   *\n   *  This implementation fulfills all of these (except that the test suite could\n   *  do with expanding to automatically run all the fixtures from other Markdown\n   *  implementations.)\n   *\n   *  ##### Intermediate Representation\n   *\n   *  *TODO* Talk about this :) Its JsonML, but document the node names we use.\n   *\n   *  [JsonML]: http://jsonml.org/ \"JSON Markup Language\"\n   *",
        "* Markdown.dialects\n   *\n   * Namespace of built-in dialects.\n   *",
        "*  parse( markdown, [dialect] ) -> JsonML\n   *  - markdown (String): markdown string to parse\n   *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n   *\n   *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.\n   *",
        "*  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]\n   *  - block (String): the block to process\n   *  - next (Array): the following blocks\n   *\n   * Process `block` and return an array of JsonML nodes representing `block`.\n   *\n   * It does this by asking each block level function in the dialect to process\n   * the block until one can. Succesful handling is indicated by returning an\n   * array (with zero or more JsonML nodes), failure by a false value.\n   *\n   * Blocks handlers are responsible for calling [[Markdown#processInline]]\n   * themselves as appropriate.\n   *\n   * If the blocks were split incorrectly or adjacent blocks need collapsing you\n   * can adjust `next` in place using shift/splice etc.\n   *\n   * If any of this default behaviour is not right for the dialect, you can\n   * define a `__call__` method on the dialect that will get invoked to handle\n   * the block processing.",
        "*  Markdown#toTree( source ) -> JsonML\n   *  - source (String): markdown source to parse\n   *\n   *  Parse `source` into a JsonML tree representing the markdown document.\n   *",
        "*  renderJsonML( jsonml[, options] ) -> String\n   *  - jsonml (Array): JsonML array to render to XML\n   *  - options (Object): options\n   *\n   *  Converts the given JsonML into well-formed XML.\n   *\n   *  The options currently understood are:\n   *\n   *  - root (Boolean): wether or not the root node should be included in the\n   *    output, or just its children. The default `false` is to not include the\n   *    root itself.",
        "*  toHTMLTree( markdown, [dialect] ) -> JsonML\n   *  toHTMLTree( md_tree ) -> JsonML\n   *  - markdown (String): markdown string to parse\n   *  - dialect (String | Dialect): the dialect to use, defaults to gruber\n   *  - md_tree (Markdown.JsonML): parsed markdown tree\n   *\n   *  Turn markdown into HTML, represented as a JsonML tree. If a string is given\n   *  to this function, it is first parsed into a markdown tree by calling\n   *  [[parse]].\n   *",
        "*  toHTML( markdown, [dialect]  ) -> String\n   *  toHTML( md_tree ) -> String\n   *  - markdown (String): markdown string to parse\n   *  - md_tree (Markdown.JsonML): parsed markdown tree\n   *\n   *  Take markdown (either as a string or as a JsonML tree) and run it through\n   *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.\n   *",
        "* Gruber dialect\n   *\n   * The default dialect that follows the rules set out by John Gruber's\n   * markdown.pl as closely as possible. Well actually we follow the behaviour of\n   * that script which in some places is not exactly what the syntax web page\n   * says.\n   *",
        "* Nested lists are supposed to be indented by four chars per level. But",
        "* The type of the list (bullet or number) is controlled just by the",
        "*every* line in the block"
    ],
    "functions": [
        "mk_block_toSource",
        "mk_block_inspect",
        "count_lines",
        "escapeHTML",
        "render_tree",
        "convert_tree_to_html",
        "merge_text_nodes",
        "Block",
        "Inline",
        "regex_for_depth",
        "expand_tab",
        "add",
        "get_contained_blocks",
        "paragraphify",
        "make_list",
        "add",
        "strong_em",
        "CloseTag",
        "split_meta_hash"
    ],
    "classes": []
}