{
    "identifiers": [
        "numbers",
        "numpy",
        "np",
        "tensorflow",
        "tf",
        "engine",
        "RegRef",
        "RegRefTransform",
        "tf",
        "Tensor",
        "tf",
        "Variable",
        "p",
        "x",
        "p",
        "x",
        "isinstance",
        "x",
        "Parameter",
        "isinstance",
        "x",
        "RegRef",
        "RegRefTransform",
        "x",
        "isinstance",
        "x",
        "numbers",
        "np",
        "ndarray",
        "_tf_classes",
        "RegRefTransform",
        "x",
        "__class__",
        "isinstance",
        "x",
        "RegRefTransform",
        "deps",
        "update",
        "x",
        "regrefs",
        "x",
        "isinstance",
        "x",
        "numbers",
        "format",
        "x",
        "x",
        "__str__",
        "format_spec",
        "x",
        "__format__",
        "format_spec",
        "isinstance",
        "x",
        "RegRefTransform",
        "Parameter",
        "x",
        "evaluate",
        "other",
        "x",
        "isinstance",
        "other",
        "Parameter",
        "other",
        "x",
        "isinstance",
        "t",
        "_tf_classes",
        "isinstance",
        "other",
        "_tf_classes",
        "other",
        "t",
        "t",
        "other",
        "t",
        "dtype",
        "is_complex",
        "isinstance",
        "other",
        "_tf_classes",
        "other",
        "dtype",
        "is_complex",
        "tf",
        "cast",
        "other",
        "tf",
        "complex128",
        "np",
        "iscomplexobj",
        "other",
        "isinstance",
        "other",
        "_tf_classes",
        "other",
        "dtype",
        "is_complex",
        "tf",
        "cast",
        "t",
        "tf",
        "complex128",
        "t",
        "dtype",
        "is_integer",
        "isinstance",
        "other",
        "isinstance",
        "other",
        "np",
        "ndarray",
        "np",
        "issubdtype",
        "other",
        "dtype",
        "np",
        "floating",
        "isinstance",
        "other",
        "_tf_classes",
        "other",
        "dtype",
        "is_floating",
        "tf",
        "cast",
        "t",
        "tf",
        "float32",
        "t",
        "dtype",
        "is_floating",
        "isinstance",
        "other",
        "_tf_classes",
        "other",
        "dtype",
        "is_integer",
        "tf",
        "cast",
        "other",
        "tf",
        "float32",
        "swap",
        "other",
        "t",
        "t",
        "other",
        "staticmethod",
        "x",
        "isinstance",
        "x",
        "Parameter",
        "x",
        "Parameter",
        "x",
        "other",
        "_unwrap_and_cast",
        "other",
        "_wrap",
        "temp",
        "other",
        "other",
        "_unwrap_and_cast",
        "other",
        "_wrap",
        "other",
        "temp",
        "other",
        "_unwrap_and_cast",
        "other",
        "_wrap",
        "temp",
        "other",
        "other",
        "_unwrap_and_cast",
        "other",
        "_wrap",
        "other",
        "temp",
        "other",
        "_unwrap_and_cast",
        "other",
        "_wrap",
        "temp",
        "other",
        "other",
        "_unwrap_and_cast",
        "other",
        "_wrap",
        "other",
        "temp",
        "other",
        "_unwrap_and_cast",
        "other",
        "_wrap",
        "temp",
        "other",
        "other",
        "_unwrap_and_cast",
        "other",
        "_wrap",
        "other",
        "temp",
        "other",
        "_unwrap_and_cast",
        "other",
        "_wrap",
        "temp",
        "other",
        "other",
        "_unwrap_and_cast",
        "other",
        "_wrap",
        "other",
        "temp",
        "Parameter",
        "x",
        "property",
        "x",
        "shape",
        "AttributeError",
        "other",
        "isinstance",
        "other",
        "Parameter",
        "other",
        "x",
        "x",
        "other",
        "np",
        "abs",
        "tf",
        "abs",
        "np",
        "sign",
        "tf",
        "sign",
        "np",
        "sin",
        "tf",
        "sin",
        "np",
        "cos",
        "tf",
        "cos",
        "np",
        "cosh",
        "tf",
        "cosh",
        "np",
        "tanh",
        "tf",
        "tanh",
        "np",
        "exp",
        "tf",
        "exp",
        "np",
        "log",
        "tf",
        "log",
        "np",
        "sqrt",
        "tf",
        "sqrt",
        "np",
        "arctan",
        "tf",
        "atan",
        "np",
        "arctan2",
        "tf",
        "atan2",
        "np",
        "arcsinh",
        "tf",
        "asinh",
        "np",
        "arccosh",
        "tf",
        "acosh",
        "np",
        "matmul",
        "tf",
        "matmul",
        "np",
        "expand_dims",
        "tf",
        "expand_dims",
        "np",
        "squeeze",
        "tf",
        "squeeze",
        "np",
        "transpose",
        "tf",
        "transpose",
        "np_fn",
        "tf_fn",
        "args",
        "kwargs",
        "isinstance",
        "a",
        "_tf_classes",
        "a",
        "args",
        "tf_fn",
        "args",
        "kwargs",
        "isinstance",
        "a",
        "Parameter",
        "a",
        "args",
        "a",
        "x",
        "isinstance",
        "a",
        "Parameter",
        "a",
        "a",
        "args",
        "Parameter",
        "wrapper",
        "temp",
        "np_fn",
        "args",
        "kwargs",
        "np_fn",
        "math_fn_wrap",
        "__doc__",
        "wrapper",
        "name",
        "fn",
        "np_math_fns",
        "items",
        "globals",
        "math_fn_wrap",
        "fn"
    ],
    "literals": [
        "'Tried initializing a Parameter using a Parameter.'",
        "'Unsupported base object type: '",
        "'{:.4g}'",
        "\"abs\"",
        "\"sign\"",
        "\"sin\"",
        "\"cos\"",
        "\"cosh\"",
        "\"tanh\"",
        "\"exp\"",
        "\"log\"",
        "\"sqrt\"",
        "\"arctan\"",
        "\"arctan2\"",
        "\"arcsinh\"",
        "\"arccosh\"",
        "\"matmul\"",
        "\"expand_dims\"",
        "\"squeeze\"",
        "\"transpose\""
    ],
    "variables": [
        "_tf_classes",
        "__array_ufunc__",
        "deps",
        "x",
        "x",
        "t",
        "other",
        "swap",
        "t",
        "other",
        "swap",
        "other",
        "t",
        "t",
        "other",
        "temp",
        "other",
        "temp",
        "other",
        "temp",
        "other",
        "temp",
        "other",
        "temp",
        "other",
        "temp",
        "other",
        "temp",
        "other",
        "temp",
        "other",
        "temp",
        "other",
        "temp",
        "other",
        "other",
        "np_math_fns",
        "temp",
        "wrapper",
        "wrapper",
        "__doc__",
        "name"
    ],
    "comments": [
        "supported TF classes",
        "turn off the NumPy ufunc dispatching mechanism which is incompatible with our approach (see https://docs.scipy.org/doc/numpy-1.14.0/neps/ufunc-overrides.html)",
        "NOTE: Another possible approach would be to use https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html",
        ": set[RegRef]: parameter value depends on these RegRefs (if any), it can only be evaluated after the corresponding subsystems have been measured",
        "wrap RegRefs in the identity RegRefTransform",
        "add extra dependencies due to RegRefs",
        ": parameter value, or reference",
        "make sure other is the non-tf type for simplicity",
        "only TensorFlow types are cast",
        "the arithmetic methods below basically are just responsible for calling _unwrap_and_cast which exposes self.x, then the arithmetic ops of the supported parameter types take over",
        "pylint: disable=invalid-unary-operand-type",
        "other properties",
        "comparisons",
        "see RegRefTransform.__eq__",
        "corresponding numpy and tensorflow functions",
        "if anything is a tf object, use the tensorflow version of the function",
        "for Parameters, call the function on the data and construct a new instance",
        "otherwise, default to numpy version",
        "HACK, edit the global namespace to have sort-of single dispatch overloading for the standard math functions"
    ],
    "docstrings": [
        "\"\"\"\nGate parameters\n===============\n\n**Module name:** :mod:`strawberryfields.parameters`\n\n.. currentmodule:: strawberryfields.parameters\n\nThe :class:`Parameter` class is an abstraction of a parameter passed to the\nquantum circuit operations represented by :class:`~strawberryfields.ops.ParOperation`.\nThe parameter objects can represent a number, a NumPy array, a value measured from the quantum register\n(:class:`~strawberryfields.engine.RegRefTransform`),\nor a TensorFlow object.\n\n.. currentmodule:: strawberryfields\n\nThe normal lifecycle of a ParOperation object and its associated Parameter instances is as follows:\n\n* A ParOperation instance is created, and given some parameters as input.\n* :meth:`ParOperation.__init__` converts the inputs into Parameter instances.\n  Plain :class:`~engine.RegRef` instances are wrapped in a trivial\n  :class:`~engine.RegRefTransform`.\n  RegRefTransforms add their RegRef dependencies to the Parameter and consequently to the Operation.\n* The Operation instance is applied using its :func:`~ops.Operation.__or__`\n  method inside an :class:`~engine.Engine` context.\n  This creates a :class:`~engine.Command` instance that wraps\n  the Operation and the RegRefs it acts on, which is appended to the Engine command queue.\n* Once the entire program is inputted, Engine optimizes it. This involves merging and commuting Commands\n  inside the circuit graph, the building of which requires knowledge of their dependencies, both direct and Parameter-based.\n* Merging two :class:`~ops.Gate` instances of the same subclass involves\n  adding their first parameters after equality-comparing the others. This is easily done if\n  all the parameters have an immediate value. RegRefTransforms and TensorFlow objects are more complicated,\n  but could in principle be handled.\n\n  .. todo:: For now we simply don't do the merge if RegRefTransforms or TensorFlow objects are involved.\n\n* The optimized command queue is run by Engine, which calls the :func:`~ops.Operation.apply` method\n  of each Operation in turn (and tries :func:`~ops.Operation.decompose`\n  if a :py:exc:`NotImplementedError` exception is raised).\n* :func:`~ops.ParOperation.apply` evaluates the numeric value of any\n  RegRefTransform-based Parameters using :func:`Parameter.evaluate` (other types of Parameters are simply passed through).\n  The parameter values and the subsystem indices are passed to :func:`~ops.Operation._apply`.\n* :func:`~ops.Operation._apply` \"unwraps\" the Parameter instances. There are three different cases:\n\n  1. We still need to do some arithmetic, unwrap after it is done using p.x.\n  2. No arithmetic required, use :func:`~parameters._unwrap`.\n  3. No parameters are used, do nothing.\n\n  Finally, _apply calls the appropriate backend API method using the unwrapped parameters.\n  It is up to the backend to either accept NumPy arrays and Tensorflow objects as parameters, or not.\n\n\nWhat we cannot do at the moment:\n\n* Use anything except integers and RegRefs (or Sequences thereof) as the subsystem parameter\n  for the :func:`~ops.Operation.__or__` method.\n  Technically we could allow any Parameters or valid Parameter initializers that evaluate into an integer.\n* Do arithmetic with RegRefTransforms.\n\n\nParameter methods\n-----------------\n\n.. currentmodule:: strawberryfields.parameters.Parameter\n\n.. autosummary::\n   evaluate\n\n\nCode details\n~~~~~~~~~~~~\n\n\"\"\"",
        "\"\"\"Unwrap a parameter sequence.\n\n    Args:\n      params (Sequence[Parameter]): parameters to unwrap\n\n    Returns:\n      tuple[Number, array, Tensor, Variable]: unwrapped Parameters\n    \"\"\"",
        "\"\"\"Represents a parameter passed to a :class:`strawberryfields.ops.Operation` subclass constructor.\n\n    The supported parameter types are Python and NumPy numeric types, NumPy arrays, :class:`RegRef` instances,\n    :class:`RegRefTransform` instances, and certain TensorFlow objects. RegRef instances are internally represented as\n    trivial RegRefTransforms.\n\n    All but the RR and TensorFlow parameters represent an immediate numeric value that\n    will not change. RR parameters can only be evaluated after the corresponding register\n    subsystems have been measured. TF parameters can be evaluated whenever, but they depend on TF objects that\n    are evaluated using :meth:`tf.Session.run`.\n\n    The class supports various arithmetic operations which may change the internal representation of the result.\n    If a TensorFlow object is involved, the result will always be a TensorFlow object.\n\n    Args:\n      x (Number, array, Tensor, Variable, RegRef, RegRefTransform): parameter value\n    \"\"\"",
        "\"\"\"Evaluate the numerical value of a RegRefTransform-based parameter.\n\n        Returns:\n          Parameter: self, unless self.x is a RegRefTransform in which case it is evaluated and a new Parameter instance is constructed on the result and returned\n        \"\"\"",
        "\"\"\"Unwrap Parameters and cast TensorFlow-type parameters to other dtypes during arithmetic.\n\n        The main reason we need this is that TensorFlow does not automatically promote int to float or float to complex but requires an explicit cast.\n\n        .. todo:: Decide whether to cast to single or double precision by default (both float and complex).\n\n        Args:\n          other: the other input of a binary arithmetic operation\n        Returns:\n          (self, other) unwrapped, cast into compatible dtypes\n        \"\"\"",
        "\"\"\"Wraps x inside a Parameter instance, unless x is a Parameter instance itself.\n\n        Needed because of the way the reverse binary arithmetic methods work.\n\n        Returns:\n          Parameter: x as a Parameter instance\n        \"\"\"",
        "\"\"\"Returns the shape of array parameters.\"\"\"",
        "\"\"\"Equality comparison.\n\n        .. note:: This method may be too permissive, maybe it should return False if either parameter is not a numbers.Number or a np.ndarray?\n\n        Returns:\n          bool: True iff both self and other have immediate, equal values, or identical dependence on measurements, otherwise False.\n        \"\"\"",
        "\"\"\"Wrapper function for the standard math functions.\n\n    It checks the type of the incoming object and calls the appropriate NumPy or TensorFlow function.\n    \"\"\"",
        "\"\"\"wrapper function\"\"\""
    ],
    "functions": [
        "_unwrap",
        "__str__",
        "__format__",
        "evaluate",
        "_unwrap_and_cast",
        "_wrap",
        "__add__",
        "__radd__",
        "__sub__",
        "__rsub__",
        "__mul__",
        "__rmul__",
        "__truediv__",
        "__rtruediv__",
        "__pow__",
        "__rpow__",
        "__neg__",
        "shape",
        "__eq__",
        "math_fn_wrap",
        "wrapper"
    ],
    "classes": [
        "Parameter"
    ]
}