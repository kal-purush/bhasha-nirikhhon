{
    "identifiers": [
        "typing",
        "Optional",
        "Tuple",
        "astroid",
        "nodes",
        "base_node",
        "nodes",
        "NodeNG",
        "stmt_nodes",
        "nodes",
        "NodeNG",
        "Tuple",
        "nodes",
        "NodeNG",
        "nodes",
        "Statement",
        "node",
        "node",
        "statement",
        "future",
        "node",
        "stmt_nodes",
        "len",
        "statements",
        "all",
        "isinstance",
        "stmt",
        "nodes",
        "ExceptHandler",
        "_",
        "stmt",
        "statements",
        "node",
        "stmt",
        "node",
        "stmt",
        "statements",
        "stmt",
        "parent_of",
        "base_node",
        "statements",
        "node",
        "isinstance",
        "parent",
        "nodes",
        "Decorators",
        "parent",
        "node",
        "node_ancestors",
        "node",
        "nodes",
        "NodeNG",
        "Optional",
        "nodes",
        "If",
        "parent",
        "node",
        "node_ancestors",
        "isinstance",
        "parent",
        "nodes",
        "If",
        "parent",
        "base_node",
        "nodes",
        "NodeNG",
        "stmts",
        "frame",
        "offset",
        "offset",
        "base_node",
        "frame",
        "parent",
        "frame",
        "base_node",
        "frame",
        "base_node",
        "parent",
        "base_node",
        "statement",
        "future",
        "myframe",
        "myframe",
        "parent",
        "myframe",
        "parent",
        "frame",
        "Optional",
        "nodes",
        "Statement",
        "base_node",
        "parent",
        "base_node",
        "statement",
        "future",
        "myframe",
        "frame",
        "mystmt",
        "mystmt",
        "fromlineno",
        "mystmt",
        "fromlineno",
        "mystmt",
        "mystmt",
        "fromlineno",
        "offset",
        "_get_filtered_node_statements",
        "base_node",
        "stmts",
        "node",
        "stmt",
        "statements",
        "stmt",
        "fromlineno",
        "stmt",
        "fromlineno",
        "mylineno",
        "mystmt",
        "stmt",
        "_is_from_decorator",
        "base_node",
        "hasattr",
        "node",
        "node",
        "node",
        "scope",
        "node",
        "scope",
        "locals",
        "node",
        "assign_type",
        "node",
        "has_base",
        "base_node",
        "assign_type",
        "_get_filtered_stmts",
        "base_node",
        "node",
        "_stmts",
        "mystmt",
        "done",
        "assign_type",
        "optional_assign",
        "optional_assign",
        "assign_type",
        "parent_of",
        "base_node",
        "node",
        "stmt",
        "parent",
        "isinstance",
        "assign_type",
        "nodes",
        "NamedExpr",
        "_get_if_statement_ancestor",
        "assign_type",
        "if_parent",
        "_get_if_statement_ancestor",
        "if_parent",
        "_stmts",
        "append",
        "node",
        "_stmt_parents",
        "append",
        "stmt",
        "parent",
        "if_parent",
        "is_orelse",
        "node",
        "stmt",
        "parent",
        "_stmts",
        "append",
        "node",
        "_stmt_parents",
        "append",
        "stmt",
        "parent",
        "node",
        "stmt",
        "parent",
        "_stmt_parents",
        "index",
        "stmt",
        "parent",
        "ValueError",
        "_stmts",
        "pindex",
        "assign_type",
        "parent_of",
        "assign_type",
        "optional_assign",
        "nodes",
        "are_exclusive",
        "_stmts",
        "pindex",
        "node",
        "_stmt_parents",
        "pindex",
        "_stmts",
        "pindex",
        "nodes",
        "are_exclusive",
        "base_node",
        "node",
        "isinstance",
        "node",
        "nodes",
        "NamedExpr",
        "nodes",
        "AssignName",
        "isinstance",
        "stmt",
        "nodes",
        "ExceptHandler",
        "stmt",
        "parent_of",
        "base_node",
        "optional_assign",
        "mystmt",
        "stmt",
        "parent",
        "mystmt",
        "parent",
        "isinstance",
        "node",
        "nodes",
        "DelName",
        "_stmts",
        "append",
        "node",
        "isinstance",
        "node",
        "nodes",
        "Arguments",
        "isinstance",
        "node",
        "parent",
        "nodes",
        "Arguments",
        "_stmt_parents",
        "append",
        "stmt",
        "_stmt_parents",
        "append",
        "stmt",
        "parent",
        "_stmts"
    ],
    "literals": [
        "\"assign_type\""
    ],
    "variables": [
        "statements",
        "statements",
        "myframe",
        "myframe",
        "myframe",
        "mystmt",
        "mystmt",
        "mylineno",
        "mylineno",
        "_stmts",
        "_stmt_parents",
        "statements",
        "assign_type",
        "_stmts",
        "done",
        "optional_assign",
        "_stmts",
        "_stmt_parents",
        "if_parent",
        "optional_assign",
        "_stmts",
        "_stmt_parents",
        "_stmts",
        "_stmt_parents",
        "pindex",
        "_stmts",
        "_stmt_parents",
        "_stmts",
        "_stmt_parents",
        "_stmts",
        "_stmt_parents"
    ],
    "comments": [
        "Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html",
        "For details: https://github.com/PyCQA/astroid/blob/main/LICENSE",
        "Next we check if we have ExceptHandlers that are parent",
        "of the underlying variable, in which case the last one survives",
        "if offset == -1, my actual frame is not the inner frame but its parent",
        "",
        "class A(B): pass",
        "",
        "we need this to resolve B correctly",
        "If the frame of this node is the same as the statement",
        "of this node, then the node is part of a class or",
        "a function definition and the frame of this node should be the",
        "the upper frame, not the frame of the definition.",
        "For more information why this is important,",
        "see Pylint issue #295.",
        "For example, for 'b', the statement is the same",
        "as the frame / scope:",
        "",
        "def test(b=1):",
        "...",
        "line filtering if we are in the same frame",
        "",
        "take care node may be missing lineno information (this is the case for",
        "nodes inserted for living objects)",
        "disabling lineno filtering",
        "line filtering is on and we have reached our location, break",
        "Ignore decorators with the same name as the",
        "decorated function",
        "Fixes issue #375",
        "we are inside a loop, loop var assignment is hiding previous",
        "assignment",
        "If the NamedExpr is in an if statement we do some basic control flow inference",
        "If the if statement is within another if statement we append the node",
        "to possible statements",
        "If the if statement is first-level and not within an orelse block",
        "we know that it will be evaluated",
        "Else we do not known enough about the control flow to be 100% certain",
        "and we append to possible statements",
        "XXX comment various branches below!!!",
        "we got a parent index, this means the currently visited node",
        "is at the same block level as a previously visited node",
        "both statements are not at the same block level",
        "if currently visited node is following previously considered",
        "assignment and both are not exclusive, we can drop the",
        "previous one. For instance in the following code ::",
        "",
        "if a:",
        "x = 1",
        "else:",
        "x = 2",
        "print x",
        "",
        "we can't remove neither x = 1 nor x = 2 when looking for 'x'",
        "of 'print x'; while in the following ::",
        "",
        "x = 1",
        "x = 2",
        "print x",
        "",
        "we can remove x = 1 when we see x = 2",
        "",
        "moreover, on loop assignment types, assignment won't",
        "necessarily be done if the loop has no iteration, so we don't",
        "want to clear previous assignments if any (hence the test on",
        "optional_assign)",
        "If base_node and node are exclusive, then we can ignore node",
        "An AssignName node overrides previous assignments if:",
        "1. node's statement always assigns",
        "2. node and base_node are in the same block (i.e., has the same parent as base_node)",
        "If node's statement is an ExceptHandler, then it is the variable",
        "bound to the caught exception. If base_node is not contained within",
        "the exception handler block, node should override previous assignments;",
        "otherwise, node should be ignored, as an exception variable",
        "is local to the handler block.",
        "Remove all previously stored assignments",
        "Add the new assignment",
        "Special case for _stmt_parents when node is a function parameter;",
        "in this case, stmt is the enclosing FunctionDef, which is what we",
        "want to add to _stmt_parents, not stmt.parent. This case occurs when",
        "node is an Arguments node (representing varargs or kwargs parameter),",
        "and when node.parent is an Arguments node (other parameters).",
        "See issue #180."
    ],
    "docstrings": [
        "\"\"\"_filter_stmts and helper functions. This method gets used in LocalsDictnodes.NodeNG._scope_lookup.\nIt is not considered public.\n\"\"\"",
        "\"\"\"Return True if the given node is the child of a decorator\"\"\"",
        "\"\"\"Return the first parent node that is an If node (or None)\"\"\"",
        "\"\"\"Filter the given list of statements to remove ignorable statements.\n\n    If base_node is not a frame itself and the name is found in the inner\n    frame locals, statements will be filtered to remove ignorable\n    statements according to base_node's location.\n\n    :param stmts: The statements to filter.\n    :type stmts: list(nodes.NodeNG)\n\n    :param frame: The frame that all of the given statements belong to.\n    :type frame: nodes.NodeNG\n\n    :param offset: The line offset to filter statements up to.\n    :type offset: int\n\n    :returns: The filtered statements.\n    :rtype: list(nodes.NodeNG)\n    \"\"\""
    ],
    "functions": [
        "_get_filtered_node_statements",
        "_is_from_decorator",
        "_get_if_statement_ancestor",
        "_filter_stmts"
    ],
    "classes": []
}