{
    "identifiers": [
        "Tuple",
        "Maybe",
        "match",
        "a",
        "fn",
        "a",
        "Maybe",
        "fn",
        "mb",
        "Maybe",
        "mb",
        "mb",
        "fn",
        "a",
        "b",
        "Maybe",
        "fn",
        "mb",
        "fn",
        "a",
        "Maybe",
        "fn",
        "m",
        "Maybe",
        "m",
        "id",
        "a",
        "a",
        "Maybe",
        "a",
        "Maybe",
        "value",
        "match",
        "match",
        "Maybe",
        "match",
        "match",
        "value",
        "Just",
        "value",
        "Nothing",
        "match",
        "a",
        "m",
        "eliminator",
        "m",
        "m",
        "match",
        "fn",
        "a",
        "m",
        "morphism",
        "ma",
        "ma",
        "a",
        "Just",
        "fn",
        "a",
        "zero",
        "fn",
        "a",
        "m",
        "morphism",
        "ma",
        "ma",
        "a",
        "fn",
        "a",
        "zero",
        "fn",
        "a",
        "b",
        "ma",
        "mb",
        "ma",
        "mb",
        "ma",
        "a",
        "mb",
        "b",
        "of",
        "fn",
        "a",
        "b",
        "zero",
        "zero",
        "ma",
        "mb",
        "zipWith",
        "Tuple",
        "ma",
        "mb",
        "mf",
        "a",
        "ma",
        "mf",
        "f",
        "ma",
        "a",
        "of",
        "f",
        "a",
        "zero",
        "zero",
        "m1",
        "m2",
        "m1",
        "_",
        "m1",
        "m2",
        "maybes",
        "maybes",
        "v",
        "v",
        "v",
        "zero",
        "maybes",
        "maybes",
        "i",
        "i",
        "maybes",
        "i",
        "x",
        "x",
        "zero",
        "b",
        "b",
        "Maybe",
        "Maybe"
    ],
    "literals": [
        "'use strict'",
        "'tuple'"
    ],
    "variables": [
        "i",
        "x"
    ],
    "comments": [
        "Test to determine whether or not a value is actually contained in the Maybe.",
        "Pass a function into the Maybe container and change the value inside.",
        "Given two Maybes, produce a Tuple if their values if both values exist.",
        "Given two Maybes, combine their values using a given function if they both exist.",
        "Lift a computation which might fail on to values which might not exist.",
        "If this value is Nothing, try the next one.",
        "Inject a value of A into a Maybe.",
        "Pass a function into the Maybe container and change the value inside.",
        "Lift a computation which might fail on to values which might not exist.",
        "Given two Maybes, combine their values using a given function if they both exist.",
        "Given two Maybes, produce a Tuple if their values if both values exist.",
        "Apply a function inside of a Maybe allowing for failure.",
        "If this value is Nothing, try the next one.",
        "Collapse a set of maybes into the leftmost succeeding one.",
        "Collapse a set of maybes into the rightmost succeeding one.",
        "Iterate from the end of the array forward",
        "A boolean interpreted as a value of Maybe<{}>."
    ],
    "docstrings": [
        "* Maybe types and functions on them.\n * \n * @module maybe",
        "* Values which explicitly may not actually be there.\n * \n * For any type A, values of Maybe<A> are either values of A or \"Nothing\" at all.\n * In JavaScript values of type A *always* may contain null, so Maybe<A> may seem\n * to be redundant---and it is!\n * \n * The genuine value of Maybe arises when we assume that for all types A, all values\n * encountered throughout some \"safe\" zone within your program are *never* null. \n * This invariant thus ensures that values (a:A) are always \"real\" values and now \n * Maybe is the only way to encode \"possibly missingness\".\n * \n * From here, types can help us to ensure that we never forget to handle a null.",
        "* Eliminate a Maybe<A> value by providing continuations for both the case where\n   * a value is there (just) and when it is not (nothing).",
        "* If A has a default value then we can use it to convert a value of (k: Maybe<A>)\n   * into either the default value (if k was Nothing) or the contained value (if k \n   * was Just).",
        "* Create an empty value of Maybe. Typically this must be annotated with\n   * the type A.",
        "* Eliminate a Maybe<A> value by providing continuations for both the case where\n   * a value is there (just) and when it is not (nothing)."
    ],
    "functions": [
        "zipWith",
        "bind",
        "orElse",
        "id",
        "isJust",
        "fold",
        "isJust",
        "fold",
        "of",
        "zero",
        "fold",
        "bind",
        "zipWith",
        "ap",
        "leftmost",
        "rightmost",
        "guard"
    ],
    "classes": [
        "Maybe",
        "Just",
        "Nothing"
    ]
}