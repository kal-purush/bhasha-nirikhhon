{
    "identifiers": [
        "async",
        "Trace",
        "BaseError",
        "onFulfilled",
        "value",
        "onRejected",
        "reason",
        "BaseError",
        "reason",
        "reason",
        "promise",
        "msg",
        "State",
        "fulfill",
        "value",
        "reject",
        "reason",
        "a",
        "a",
        "resolve",
        "value",
        "reject",
        "reason",
        "resolve",
        "value",
        "reject",
        "reason",
        "value",
        "reason",
        "promiseIdCounter",
        "State",
        "resolver",
        "resolve",
        "value",
        "reject",
        "reason",
        "trace",
        "trace",
        "longTraces",
        "Trace",
        "unwrappingPromise",
        "unwrappingPromise",
        "resolver",
        "internalResolver",
        "resolver",
        "resolver",
        "y",
        "called",
        "called",
        "y",
        "r",
        "called",
        "called",
        "wrapNonError",
        "r",
        "e",
        "called",
        "wrapNonError",
        "e",
        "called",
        "onFulfilled",
        "value",
        "onRejected",
        "reason",
        "trace",
        "trace",
        "onFulfilled",
        "onRejected",
        "State",
        "onFulfilled",
        "State",
        "onRejected",
        "internalResolver",
        "slave",
        "slave",
        "onFulfilled",
        "onRejected",
        "slave",
        "onFulfilled",
        "value",
        "onRejected",
        "reason",
        "State",
        "onFulfilled",
        "trace",
        "trace",
        "onFulfilled",
        "onRejected",
        "onFulfilled",
        "onRejected",
        "onRejected",
        "reason",
        "onRejected",
        "value",
        "value",
        "internalResolver",
        "p",
        "value",
        "p",
        "reason",
        "internalResolver",
        "p",
        "reason",
        "p",
        "thenables",
        "resolve",
        "reject",
        "thenables",
        "thenables",
        "resolve",
        "thenables",
        "thenables",
        "i",
        "thenables",
        "i",
        "follow",
        "thenables",
        "i",
        "i",
        "t",
        "index",
        "t",
        "t",
        "t",
        "slave",
        "v",
        "result",
        "index",
        "v",
        "remaining",
        "remaining",
        "resolve",
        "result",
        "reason",
        "reject",
        "reason",
        "enable",
        "longTraces",
        "enable",
        "tracer",
        "promise",
        "msg",
        "tracer",
        "trace",
        "tracer",
        "trace",
        "async",
        "source",
        "source",
        "source",
        "x",
        "State",
        "x",
        "x",
        "x",
        "x",
        "x",
        "x",
        "State",
        "x",
        "x",
        "State",
        "x",
        "x",
        "x",
        "x",
        "x",
        "then",
        "getThenError",
        "wrapNonError",
        "getThenError",
        "then",
        "x",
        "then",
        "x",
        "x",
        "x",
        "then",
        "e",
        "getThenError",
        "e",
        "getThenError",
        "value",
        "State",
        "trace",
        "trace",
        "value",
        "State",
        "value",
        "reason",
        "State",
        "trace",
        "trace",
        "reason",
        "State",
        "reason",
        "originalStack",
        "slave",
        "State",
        "trace",
        "trace",
        "slave",
        "slave",
        "slave",
        "then",
        "State",
        "trace",
        "trace",
        "then",
        "slave",
        "y",
        "called",
        "called",
        "y",
        "r",
        "called",
        "called",
        "wrapNonError",
        "r",
        "e",
        "called",
        "wrapNonError",
        "e",
        "called",
        "slave",
        "onFulfilled",
        "onRejected",
        "State",
        "async",
        "h",
        "h",
        "i",
        "h",
        "h",
        "i",
        "l",
        "h",
        "i",
        "i",
        "handler",
        "handler",
        "handler",
        "State",
        "handler",
        "handler",
        "async",
        "handler",
        "async",
        "handler",
        "handler",
        "x",
        "State",
        "handler",
        "handler",
        "handler",
        "slave",
        "trace",
        "trace",
        "callback",
        "State",
        "UnhandledRejectionError",
        "unwrappingPromise",
        "unwrappingPromise",
        "callback",
        "result",
        "result",
        "result",
        "result",
        "p",
        "unwrappingPromise",
        "trace",
        "trace",
        "slave",
        "callback",
        "unwrappingPromise",
        "unwrappingPromise",
        "slave",
        "slave",
        "callback",
        "e",
        "slave",
        "wrapNonError",
        "e",
        "unwrappingPromise",
        "State",
        "slave",
        "slave",
        "handler",
        "handler",
        "handler"
    ],
    "literals": [
        "\"use strict\"",
        "\"./async\"",
        "\"./util\"",
        "\"./Trace\"",
        "\"./BaseError\"",
        "\"UnhandledRejectionError\"",
        "\"unhandled rejection: \"",
        "string",
        "\"construct\"",
        "\"function\"",
        "\"Promise resolver is not a function\"",
        "then(${typeof onFulfilled}, ${typeof onRejected})",
        "\"function\"",
        "\"function\"",
        "\"function\"",
        "done(${typeof onFulfilled}, ${typeof onRejected})",
        "\"thenables must be an Array\"",
        "string",
        "\"function\"",
        "\"cannot resolve Promise to self\"",
        "\"object\"",
        "\"function\"",
        "\"function\"",
        "_fulfill(${typeof value})",
        "_reject(${reason})",
        "\"stack\"",
        "string",
        "\"\\n  from Promise at:\\n\"",
        "_follow([Promise ${slave._id}])",
        "\"_follow([Thenable])\"",
        "_unwrap()",
        "\"function\"",
        "_unwrap(${slave._id})",
        "\"function\""
    ],
    "variables": [
        "trace",
        "longTraces",
        "getThenError",
        "unwrappingPromise",
        "promiseIdCounter",
        "called",
        "slave",
        "p",
        "p",
        "result",
        "remaining",
        "i",
        "slave",
        "then",
        "then",
        "originalStack",
        "called",
        "h",
        "i",
        "i",
        "h",
        "l",
        "handler",
        "callback",
        "slave",
        "result",
        "p"
    ],
    "comments": [
        "istanbul ignore next",
        "ignores Typescript's __extend() function",
        "TODO:",
        "- remove all \"called = true\"-type code in resolvers, replace by single check in _resolve()/_reject()",
        "- add .error(), catching only 'expected exceptions' (i.e. rejections, not thrown errors)",
        "- add possibility for an unhandled-rejections-handler",
        "- full coverage by unit tests",
        "- much more docs",
        "- try to remove mangling of Error's .stack property on rejections with longTraces enabled",
        "istanbul ignore next",
        "no-op, sentinel value",
        "This is basically a marker for the places where we need to check",
        "handling of errors for .error() support.",
        "A no-op for now.",
        "Can be fulfillment value or rejection reason",
        "Internally created promises pass 'internalResolver', signalling",
        "that resolving will be done by calling private methods on the",
        "Promise. This saves having to create 2 closures.",
        "2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,",
        "or multiple calls to the same argument are made, the first call",
        "takes precedence, and any further calls are ignored.",
        "2.3.3.3.1: If/when `resolvePromise` is called with value `y`,",
        "run `[[Resolve]](promise, y)`",
        "2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,",
        "or multiple calls to the same argument are made, the first call",
        "takes precedence, and any further calls are ignored.",
        "2.3.3.3.2: If/when `rejectPromise` is called with reason `r`,",
        "reject `promise` with `r`",
        "2.3.3.3.4: If calling `then` throws an exception `e`,",
        "2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.",
        "2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.",
        "Optimization: handler is short-circuited, so pass the result (value/rejection)",
        "through unmodified.",
        "The typecast is safe, because we either have a fulfillment value",
        "but no handler that could change the type, or a rejection without a",
        "handler that could change it, so R === T in this case.",
        "TODO: verify whether longTraces etc still work as expected",
        "Construct new Promise, but use subclassed constructor, if any",
        "2.1.2.1 When fulfilled, a promise must not transition to any other state.",
        "2.1.3.1 When rejected, a promise must not transition to any other state.",
        "Shortcut for falsy values, most notably void-Promises",
        "2.3.4: If `x` is not an object or function, fulfill `promise` with `x`",
        "2.3.1: If promise and x refer to the same object, reject promise with a TypeError as the reason.",
        "2.3.2: If `x` is a promise, adopt its state",
        "2.3.2.1: If `x` is pending, `promise` must remain pending until `x` is fulfilled or rejected.",
        "2.3.2.2: If/when `x` is fulfilled, fulfill `promise` with the same value.",
        "2.3.2.3: If/when `x` is rejected, reject `promise` with the same reason.",
        "2.3.3: Otherwise, if `x` is an object or function,",
        "2.3.3.1: Let `then` be `x.then`",
        "2.3.3.2: If retrieving the property `x.then` results in a thrown",
        "exception `e`, reject `promise` with `e` as the reason.",
        "2.3.3.3: If `then` is a function, call it with `x` as `this`,",
        "first argument `resolvePromise`, and second argument `rejectPromise`",
        "2.3.3.4: If `then` is not a function, fulfill promise with `x`",
        "2.3.4: If `x` is not an object or function, fulfill `promise` with `x`",
        "2.3.3.1: Let `then` be `x.then`",
        "2.3.3.2: If retrieving the property `x.then` results in a thrown",
        "exception `e`, reject `promise` with `e` as the reason.",
        "2.1.2.1 When fulfilled, a promise must not transition to any other state.",
        "2.1.3.1 When rejected, a promise must not transition to any other state.",
        "2.1.2.2 When fulfilled, a promise must have a value, which must not change.",
        "2.1.2.1 When fulfilled, a promise must not transition to any other state.",
        "2.1.3.1 When rejected, a promise must not transition to any other state.",
        "2.1.3.2 When rejected, a promise must have a reason, which must not change.",
        "TODO: Meh, this always accesses '.stack', which is supposed to be expensive",
        "2.1.2.1 When fulfilled, a promise must not transition to any other state.",
        "2.1.3.1 When rejected, a promise must not transition to any other state.",
        "2.1.2.1 When fulfilled, a promise must not transition to any other state.",
        "2.1.3.1 When rejected, a promise must not transition to any other state.",
        "2.3.3.3: If `then` is a function, call it with `x` as `this`,",
        "first argument `resolvePromise`, and second argument `rejectPromise`",
        "2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,",
        "or multiple calls to the same argument are made, the first call",
        "takes precedence, and any further calls are ignored.",
        "2.3.3.3.1: If/when `resolvePromise` is called with value `y`,",
        "run `[[Resolve]](promise, y)`",
        "2.3.3.3.3: If both `resolvePromise` and `rejectPromise` are called,",
        "or multiple calls to the same argument are made, the first call",
        "takes precedence, and any further calls are ignored.",
        "2.3.3.3.2: If/when `rejectPromise` is called with reason `r`,",
        "reject `promise` with `r`",
        "2.3.3.3.4: If calling `then` throws an exception `e`,",
        "2.3.3.3.4.1: If `resolvePromise` or `rejectPromise` have been called, ignore it.",
        "2.3.3.3.4.2: Otherwise, reject `promise` with `e` as the reason.",
        "we're the return value of an onFulfilled, tell our",
        "'parent' to resolve",
        ".then() callbacks, including the returned promise from .then()",
        ".done() callbacks",
        "Unwrap .done() callbacks",
        "No callback: if we ended in a rejection, throw it, otherwise",
        "all was good.",
        "Don't try-catch, in order to let it break immediately",
        "Common case: no result value",
        "May be a thenable, need to start following it...",
        "Ensure it throws as soon as it's rejected",
        "Unwrap .then() calbacks",
        "2.2.5 handlers must be called as functions"
    ],
    "docstrings": [
        "* Promise implementation in TypeScript.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT",
        "* Currently unwrapping promise, while running one of its then-callbacks.\n * Used to set the source of newly created promises.\n * We guarantee that at most one callback of a then() is running at any time."
    ],
    "functions": [
        "internalResolver",
        "wrapNonError",
        "then",
        "done",
        "resolve",
        "reject",
        "all",
        "follow",
        "setLongTraces",
        "setTracer",
        "flush",
        "_setSource",
        "_resolve",
        "_tryGetThen",
        "_fulfill",
        "_reject",
        "_followPromise",
        "_followThenable",
        "_enqueue",
        "_flush",
        "_unwrap",
        "_unwrapper"
    ],
    "classes": [
        "UnhandledRejectionError"
    ]
}