{
    "identifiers": [
        "net",
        "ripe",
        "db",
        "whois",
        "common",
        "rpsl",
        "java",
        "io",
        "java",
        "io",
        "InputStream",
        "java",
        "io",
        "InputStreamReader",
        "java",
        "io",
        "Reader",
        "java",
        "io",
        "StringReader",
        "java",
        "lang",
        "reflect",
        "Constructor",
        "java",
        "lang",
        "reflect",
        "Field",
        "java",
        "lang",
        "reflect",
        "Modifier",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "regex",
        "Pattern",
        "org",
        "apache",
        "commons",
        "lang3",
        "text",
        "WordUtils",
        "org",
        "apache",
        "commons",
        "lang3",
        "Pair",
        "classLocation",
        "stateTableCache",
        "statePattern",
        "Pattern",
        "compile",
        "attributeType",
        "lexer",
        "stateTable",
        "fieldName",
        "attributeType",
        "WordUtils",
        "capitalize",
        "fieldName",
        "lexer",
        "loadLexerInstance",
        "attributeType",
        "stateTable",
        "generateStateTable",
        "attributeType",
        "fieldName",
        "attributeType",
        "lexerClassName",
        "classLocation",
        "attributeType",
        "SuppressWarnings",
        "lexerClass",
        "Class",
        "forName",
        "lexerClassName",
        "lexerConstructor",
        "lexerClass",
        "getConstructor",
        "nullReader",
        "lexerConstructor",
        "newInstance",
        "nullReader",
        "e",
        "lexerClass",
        "getName",
        "e",
        "attributeType",
        "stateTableCache",
        "containsKey",
        "attributeType",
        "stateTableCache",
        "get",
        "attributeType",
        "parserClassName",
        "classLocation",
        "attributeType",
        "SuppressWarnings",
        "parserClass",
        "Class",
        "forName",
        "parserClassName",
        "stateTable",
        "field",
        "parserClass",
        "getDeclaredFields",
        "modifierMask",
        "Modifier",
        "PUBLIC",
        "Modifier",
        "FINAL",
        "Modifier",
        "STATIC",
        "field",
        "getModifiers",
        "modifierMask",
        "field",
        "getType",
        "statePattern",
        "matcher",
        "field",
        "getName",
        "matches",
        "stateTable",
        "put",
        "field",
        "getShort",
        "field",
        "getName",
        "e",
        "err",
        "field",
        "getName",
        "e",
        "printStackTrace",
        "stateTableCache",
        "put",
        "attributeType",
        "stateTable",
        "stateTable",
        "parse",
        "lexer",
        "yyreset",
        "lexerState",
        "lexer",
        "yylex",
        "capturingKeyword",
        "previousKeyWord",
        "previousTokenList",
        "contextMap",
        "lexerState",
        "lexerState",
        "stateName",
        "stateTable",
        "containsKey",
        "lexerState",
        "lexerState",
        "lexer",
        "yylex",
        "stateName",
        "stateTable",
        "get",
        "lexerState",
        "stateName",
        "startsWith",
        "stateName",
        "stateName",
        "substring",
        "toLowerCase",
        "capturingKeyword",
        "previousKeyWord",
        "previousKeyWord",
        "stateName",
        "previousTokenList",
        "capturingKeyword",
        "previousKeyWord",
        "stateName",
        "lexerState",
        "lexer",
        "yylex",
        "capturingKeyword",
        "previousKeyWord",
        "previousKeyWord",
        "stateName",
        "substring",
        "toLowerCase",
        "lexer",
        "yylength",
        "previousTokenList",
        "previousTokenList",
        "contextMap",
        "add",
        "Pair",
        "of",
        "previousKeyWord",
        "previousTokenList",
        "text",
        "lexer",
        "yytext",
        "text",
        "toLowerCase",
        "equals",
        "attributeType",
        "toLowerCase",
        "lexerState",
        "lexer",
        "yylex",
        "text",
        "startsWith",
        "text",
        "text",
        "substring",
        "toLowerCase",
        "previousTokenList",
        "add",
        "text",
        "lexerState",
        "lexer",
        "yylex",
        "emptyEntries",
        "entry",
        "contextMap",
        "entry",
        "getRight",
        "size",
        "emptyEntries",
        "add",
        "entry",
        "contextMap",
        "removeAll",
        "emptyEntries",
        "contextMap",
        "attr",
        "lexer",
        "attr",
        "getType",
        "getName",
        "lexer",
        "parse",
        "attr",
        "toString",
        "e",
        "err",
        "attr",
        "toString"
    ],
    "literals": [
        "\"net.ripe.db.whois.common.generated.\"",
        "\"((TKN)|(OP)|(KEYW))_[A-Z0-9]+\"",
        "\"Lexer\"",
        "\"unchecked\"",
        "\" is not a valid AttributeParser\"",
        "\"Parser\"",
        "\"unchecked\"",
        "\"Failed to extract value for state table: \"",
        "\"KEYW_\"",
        "\"&\"",
        "\"OP_\"",
        "\"IO error parsing attribute: \""
    ],
    "variables": [
        "attributeType",
        "lexer",
        "stateTable",
        "stateName"
    ],
    "comments": [
        "Attempt to load the lexer class from the classpath. Will throw ClassNotFoundException on fail",
        "This section instantiates the lexer, lots of things can go wrong which we throw upstream as a modified ClassNotFoundException",
        "Pass null now and give a real input when parse is called",
        "Check if we've already cached a state table for this parser",
        "Attempt to load the parser class from the classpath. Will throw ClassNotFoundException on fail",
        "Build a new stateTable by finding state variables in the parser class",
        "State fields have the signature PUBLIC FINAL STATIC short {KEYW}|{OP}|{TKN}_\\w.",
        "This shouldn't fail as we've already typechecked, but we skip on failure.",
        "Cache and return new table",
        "take initial state",
        "concat strings of keywords",
        "256 is parser error code, [-1,2] are parser error (including EOF)",
        "Some characters return unnamed states, print them as errors and continue",
        "Capture the keywords or store the tokens",
        "Remove KEYW_ from the statename",
        "Start a new keyword concat if we'ce just come off a token or this is first run",
        "If the first thing we encounter in the attribute is a token, make an entry for it using its state name",
        "remove TKN_",
        "append the token",
        "Add an entry into the contextmap",
        "Skip adding the attribute key (ie import in import: ...)",
        "Remove OP_ from operations",
        "Append to token list",
        "Advance to next state",
        "Remove empty entires from context map",
        "Return map"
    ],
    "docstrings": [
        "* Copyright (c) 2015 Benjamin Roberts, Nathan Kelly, Andrew Maxwell\n * All rights reserved.",
        "* This class provides a wrapper for the {@link AttributeLexer}s and associated parsers generated by the RIPE RPSL package.\n * It runs the lexer in order to generate a usable representation, \"[(keyword, [values])\", of the parsed attribute.\n * @author Benjamin George Roberts",
        "* Construct the lexer for the provided field\n\t * @param fieldName The name of the attribute/field to instantiate the lexer for. Example: import, filter.\n\t * @throws ClassNotFoundException Thrown if the attribute does not have an assocaited parser & lexer, or if the classes are uninstantiable.",
        "* @see AttributeLexerWrapper#Lexer(String, Reader)\n\t * @param in source of text to parse. Will be wrapped by a reader in {@link AttributeLexerWrapper#Lexer(String, Reader)}",
        "* Locates and instantiates an AttributeLexer instance from the JVM's classpath\n\t * @param attributeType the attribute to load a lexer for. Example: import, filter\n\t * @param in Reader to instantiate the lexer with\n\t * @return The an instance of the lexer of the provided attributeType\n\t * @throws ClassNotFoundException Thrown if the attribute does not have an associated lexer or if the class is uninstantiable.",
        "* Generates a map of state-numbers to state names from the parser of the provided attribute type.\n\t * Successfully generated maps are cached.\n\t * @param attributeType the attribute to load the state table of.\n\t * @return Map of state to name\n\t * @throws ClassNotFoundException Thrown if the attribute does not have an associated parser.",
        "* @see AttributeLexerWrapper#parse(Reader)\n\t * @param in source of text to parse. Will be wrapped by a reader in {@link AttributeLexerWrapper#parse(Reader)}",
        "* Runs the lexer over the input text and builds a more usable representation.\n\t * This representation is structured as a List of {@link Pair}s. \n\t * The left value is the last keyword (or combination of keywords) encountered, \n\t * whilst the right value is a (not null) list of captured tokens and operators.\n\t * If the first item to be encountered is a token (ie ifaddr attributes), the left value\n\t * is the name of the token (ie DNS).\n\t * \n\t * All keywords and operations (and/or/not) are lowercase\n\t * \n\t * Example:\n\t * the string \"import: from AS2 accept AS1, 1.2.3.4/5\" would be returned as\n\t * \"[(from, [AS2]), (accept, [AS1, 1.2.3.4/5])]\"\n\t * \n\t * \n \t * @param in Source of the text to parse\n\t * @return representation of the parsed text\n\t * @throws IOException thrown if an error occurs reading the stream",
        "* Parse an {@link RpslAttribute} object \n\t * @see AttributeLexerWrapper#parse(Reader)\n\t * @return representation of the parsed text or empty list.\n\t * @throws ClassNotFoundException no lexer/parser class exists for this attribute type"
    ],
    "functions": [
        "AttributeLexerWrapper",
        "AttributeLexerWrapper",
        "AttributeLexer",
        "loadLexerInstance",
        "generateStateTable",
        "parse",
        "parse",
        "parse"
    ],
    "classes": [
        "AttributeLexerWrapper"
    ]
}