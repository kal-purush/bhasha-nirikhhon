{
    "identifiers": [
        "socket",
        "sys",
        "list_",
        "join",
        "list_",
        "encode",
        "pack",
        "list_",
        "encode",
        "count",
        "count",
        "count",
        "input_string",
        "pack",
        "input_string",
        "encode",
        "encode",
        "local",
        "socket",
        "create_connection",
        "socket",
        "create_connection",
        "raw_input",
        "starting_key",
        "starting_key",
        "xor_const",
        "byte_",
        "_array_bytes",
        "pack",
        "byte_",
        "_christmas_array",
        "extend",
        "packed",
        "GenInitialChristmasArray",
        "loop_iterations",
        "ModifyChristmasArray",
        "_christmas_array",
        "loop_iterations",
        "i",
        "new_arr",
        "extend",
        "ModifyChristmasArray",
        "_christmas_array",
        "new_arr",
        "target",
        "target",
        "len",
        "target",
        "position",
        "len_encrypt",
        "to_encrypt_array",
        "position",
        "position",
        "to_encrypt",
        "encrypt_array",
        "GenNewChristmasArray",
        "encrypt_array",
        "pop",
        "encrypted",
        "append",
        "pack",
        "ord",
        "ord",
        "xor_byte",
        "position",
        "pack",
        "len_encrypt",
        "encrypted",
        "target",
        "target",
        "encrypt_array",
        "GenNewChristmasArray",
        "encrypt_array",
        "pop",
        "decryped",
        "append",
        "ord",
        "ord",
        "xor_byte",
        "join",
        "chr",
        "decryped",
        "bytes_",
        "target",
        "index",
        "bytes_",
        "christmas_array",
        "append",
        "pack",
        "encode",
        "ord",
        "target",
        "index",
        "christmas_array",
        "christmas_array",
        "EncryptString",
        "target",
        "bytes_",
        "sys",
        "exit",
        "x",
        "ListToHex",
        "_christmas_array",
        "ecx",
        "ecx",
        "ListToHex",
        "_christmas_array",
        "edx",
        "edx",
        "ROL",
        "observed",
        "unrotated",
        "edi",
        "unadded",
        "unrotated",
        "edi",
        "_christmas_array",
        "ecx",
        "ecx",
        "pack",
        "unadded",
        "ecx",
        "ecx",
        "edx",
        "edx",
        "x",
        "join",
        "_christmas_array",
        "join",
        "_christmas_array",
        "flag_array",
        "find",
        "flag_array",
        "flag_pos",
        "flag_pos",
        "buf",
        "LittleEndian",
        "join",
        "buf",
        "ecx_counter",
        "ecx_counter",
        "LittleEndian",
        "join",
        "buf",
        "edx_counter",
        "edx_counter",
        "edi_value",
        "eax_value",
        "ROL",
        "edi_plus_eax",
        "pack",
        "rotated",
        "ecx_counter",
        "ecx_counter",
        "rotated_hex",
        "ecx_counter",
        "ecx_counter",
        "edx_counter",
        "edx_counter",
        "pack",
        "eax_value",
        "bytes_",
        "_sock",
        "recv",
        "bytes_",
        "target",
        "target",
        "seen",
        "seen",
        "_sock",
        "recv",
        "seen",
        "strip",
        "payload",
        "_sock",
        "send",
        "payload",
        "Send",
        "Recv",
        "referral",
        "Send",
        "flag_1",
        "Recv",
        "register",
        "Send",
        "Recv",
        "received_else",
        "Send",
        "RecvUntil",
        "Send",
        "RecvUntil",
        "FindEncryptionKey",
        "Recv",
        "ENCRYPTED_RESPONSE",
        "Send",
        "EncryptString",
        "Recv",
        "received_good",
        "EncryptString",
        "Recv",
        "received_else",
        "EncryptString",
        "Send",
        "EncryptString",
        "DecryptString",
        "Recv",
        "Send",
        "EncryptString",
        "flag_1",
        "DecryptString",
        "Recv",
        "DecryptString",
        "Recv",
        "Send",
        "EncryptString",
        "DecryptString",
        "Recv",
        "DecryptString",
        "Recv",
        "format",
        "stmt",
        "stmt",
        "fortran_program",
        "fortran_program",
        "Send",
        "EncryptString",
        "join",
        "fortran_program",
        "join",
        "st",
        "st",
        "fortran_program",
        "DecryptString",
        "Recv",
        "_",
        "DecryptString",
        "Recv",
        "DecryptString",
        "Recv",
        "_",
        "DecryptString",
        "Recv",
        "DecryptString",
        "Recv",
        "DecryptString",
        "Recv",
        "local",
        "program_output",
        "DecryptString",
        "Recv",
        "len",
        "fortran_output",
        "program_output",
        "program_start_offset",
        "program_output",
        "program_start_offset",
        "program_start_offset",
        "flag_bytes",
        "split",
        "flag",
        "append",
        "chr",
        "two_chars",
        "flag",
        "append",
        "chr",
        "two_chars",
        "join",
        "flag",
        "Send",
        "EncryptString",
        "DecryptString",
        "Recv",
        "Send",
        "EncryptString",
        "flag_2",
        "DecryptString",
        "Recv",
        "Send",
        "EncryptString",
        "DecryptString",
        "Recv",
        "Send",
        "EncryptString",
        "DecryptString",
        "Recv",
        "Send",
        "EncryptString",
        "DecryptString",
        "Recv",
        "DecryptString",
        "Recv",
        "ChristmasChallenge",
        "challenge",
        "RecvUntil",
        "challenge",
        "Secure",
        "challenge",
        "Login",
        "challenge",
        "Fortran",
        "challenge",
        "Private",
        "main"
    ],
    "literals": [
        "''",
        "'hex'",
        "'<L'",
        "'hex'",
        "'<L'",
        "'hex'",
        "'hex'",
        "'0.0.0.0'",
        "'CHRISTMAS{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA}\\n'",
        "'CHRISTMAS{BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB}\\n'",
        "'162.243.220.222'",
        "'CHRISTMAS{mY_crYpt0_sucks_aNd_1_shoU1d_b3_4shaMed}\\n'",
        "'CHRISTMAS{h4cKing_l1ek_it5_1956_all_0v3r_aGa1n}\\n'",
        "'Enter value: '",
        "'<L'",
        "'<B'",
        "'<%dc'",
        "''",
        "'<B'",
        "'hex'",
        "'Incorrect crypto - exiting.'",
        "'<L'",
        "'CHRISTMAS{'",
        "''",
        "''",
        "'CHRISTMAS{'",
        "''",
        "''",
        "'<L'",
        "'<L'",
        "''",
        "'join\\n'",
        "'Does sir have a referral from an upstanding member of the club?\\n'",
        "'Very good sir. And what name would you like to register under?\\n'",
        "'RocketDonkey\\n'",
        "'Will there be anything else today, sir?\\n'",
        "'secure\\n'",
        "'You *do* have your prng token to hand, sir?\\n'",
        "'But of course, Jarvis.\\n'",
        "'Very well, sir, enabling encryption.\\n'",
        "'Oh, well, tra-la-la!\\n'",
        "'Very good sir.\\n'",
        "'Will there be anything else today, sir?\\n'",
        "'login\\n'",
        "'fortran\\n'",
        "'       DIMENSION A(47)'",
        "'       READ TAPE 1,(A(B),B=1,47)'",
        "'     1 FORMAT (I)'",
        "'       PRINT 1,(A(1))'",
        "'       PRINT 1,(A(2))'",
        "'       PRINT 1,(A(3))'",
        "'       PRINT 1,(A(4))'",
        "'       PRINT 1,(A(5))'",
        "'       PRINT 1,(A(6))'",
        "'       PRINT 1,(A(7))'",
        "'       PRINT 1,(A(8))'",
        "'       PRINT 1,(A(9))'",
        "'       PRINT 1,(A(10))'",
        "'       PRINT 1,(A(11))'",
        "'       PRINT 1,(A(12))'",
        "'       PRINT 1,(A(13))'",
        "'       PRINT 1,(A(14))'",
        "'       PRINT 1,(A(15))'",
        "'       PRINT 1,(A(16))'",
        "'       PRINT 1,(A(17))'",
        "'       PRINT 1,(A(18))'",
        "'       PRINT 1,(A(19))'",
        "'       PRINT 1,(A(20))'",
        "'       PRINT 1,(A(21))'",
        "'       PRINT 1,(A(22))'",
        "'       PRINT 1,(A(23))'",
        "'       PRINT 1,(A(24))'",
        "'{:<72s}'",
        "'\\n'",
        "''",
        "'\\n'",
        "'INIT: %s'",
        "'\\n'",
        "'FLAG: %s'",
        "''",
        "'elevate\\n'",
        "'RocketDonkey\\n'",
        "'secret\\n'",
        "'private\\n'",
        "'accessing sensitive services.\\n'",
        "'__main__'"
    ],
    "variables": [
        "ENCRYPTED_RESPONSE",
        "list_",
        "encrypt_array",
        "edx_counter",
        "ecx_counter",
        "local",
        "_sock",
        "flag_1",
        "flag_2",
        "_sock",
        "flag_1",
        "flag_2",
        "starting_key",
        "xor_const",
        "loop_iterations",
        "_array_bytes",
        "ecx_counter",
        "edx_counter",
        "_christmas_array",
        "packed",
        "encrypt_array",
        "new_arr",
        "to_encrypt_array",
        "len_encrypt",
        "position",
        "encrypted",
        "to_encrypt",
        "encrypt_array",
        "xor_byte",
        "decryped",
        "encrypt_array",
        "xor_byte",
        "encrypt_array",
        "christmas_array",
        "_christmas_array",
        "ecx_counter",
        "edx_counter",
        "ecx",
        "edx",
        "x",
        "observed",
        "edi",
        "unrotated",
        "unadded",
        "unadded",
        "ecx",
        "edx",
        "flag_array",
        "flag_pos",
        "eax_value",
        "edi_value",
        "edi_plus_eax",
        "rotated",
        "rotated_hex",
        "buf",
        "ecx_counter",
        "edx_counter",
        "seen",
        "referral",
        "register",
        "received_else",
        "received_good",
        "received_else",
        "fortran_program",
        "fortran_program",
        "fortran_output",
        "program_output",
        "program_start_offset",
        "flag_bytes",
        "flag",
        "two_chars",
        "challenge"
    ],
    "comments": [
        "This is the response required for determining the crypto.",
        "Utility functions.",
        "Some things behave differently locally.",
        "Starting 4-byte /dev/urandom key.",
        "The constant 0x2e1832af at memory address 0x804e220 is XOR'd with the key.",
        "0x804b937       xor    DWORD PTR [ebx+0x124],esi",
        "The key is then AND'd with a constant 0xFF0. This becomes the value that is",
        "checked during the LOOP below. This is at most 4080 (0xFF0).",
        "Following the CHRISTMAS{A*39} string, there are additional junk bytes that are",
        "used when calculating the hash. Note that the final four-byte sequence is",
        "actually determined based on the key value.",
        "Generate the CHRISTMAS_ARRAY based on the above bytes.",
        "Generate the starting buffer based on the random key.",
        "Hash the starting array.",
        "Generate a new CHRISTMAS_ARRAY buffer. This is a 128-byte buffer that is",
        "generated and then used when encrypting strings. When it is exhausted, a new",
        "one is created.",
        "If the array has been exhausted, refill it.",
        "If the array has been exhausted, refill it.",
        "The usage of the xor_const at the end of the array makes brute forcing",
        "impossible. Therefore, reverse the encryption process.",
        "During the first pass, the Christmas array will not be populated. Therefore",
        "we can derive it from the first 128 bytes.",
        "At this point, christmas_array contains the same values as",
        "first_christmas_array, but 'rotated' by a certain amount (since the",
        "starting point is determined by the position of $ecx after the original",
        "array is created). Since there are only 32 possible positions, iterate",
        "through all of them until we find the one that when used creates a matching",
        "hash for the first encrypted array.",
        "NOTE: For some reason, the answer is always found at position 124, with",
        "ecx_counter at 1 and eax_counter at 0. Unclear why this is as it seems",
        "that counter values (17, 16) should be allowed as well ( & 0xFF0 can be",
        "any number between 16 and 4080, step 16).",
        "Look for the CHRISTMAS{ marker.",
        "ecx starts at 1 | edx starts at 0.",
        "Pull the values from the buffer at the positions indicated by",
        "self.ecx_counter and self.edx_counter.",
        "Add the two values, ignoring the carry.",
        "Rotate the digits 13 places left.",
        "Replace the byte at self.ecx_counter*4 in buf with the rotated byte.",
        "Increment the counters, resetting to 0 if either reaches 31.",
        "After modifying the array, return the eax value.",
        "Receive 'Will there by anything else today, sir?\\n'",
        "Decrypt the response, finding both the crypto and the first flag.",
        "Find the flag (CHRISTMAS{mY_crYpt0_sucks_aNd_1_shoU1d_b3_4shaMed})",
        "self.FindFlagOne()",
        "Respond with the passphrase.",
        "Receive 'Very good, sir.\\n'",
        "Receive 'Will there by anything else today, sir?\\n'",
        "'Please provide your membership number to authenticate:'",
        "Flag 1.",
        "'Ah, I see, sir has a basic account. In that case, your limited cloud",
        "execution access has been provisioned.'",
        "'Will there by anything else today, sir?'",
        "FORTRAN banner.",
        "SEND PROGRAM.",
        "Pad the output so that each line is exactly 72 characters.",
        "Add a newline.",
        "Send the program.",
        "WARMING DRUMS.",
        "Consume post-WARMING dots.",
        "SPOOLING TAPE.",
        "Consume post-SPOOLING dots.",
        "LOADING PROGRAM.",
        "Receive the response program.",
        "Print the output plus EXECUTING PROGRAM/newlines.",
        "The next 141 bytes are the bytes we need to translate.",
        "Print the flag.",
        "This consumes up until 'Will there be anything else today sir?'.",
        "Opening flow.",
        "Join. Works fine on the server but not locally because I have no idea why.",
        "challenge.Join()",
        "Secure the connection.",
        "Login.",
        "Fortran.",
        "Elevate.",
        "challenge.Elevate()",
        "Private."
    ],
    "docstrings": [
        "\"\"\"c01db33f Christmas Challenge.\n\nThis challenge involves logging into the server at 0wn.b33f.me and recovering\nthe keys from the service.\n\n  * Flag 1: Encrypted response can be reversed to find the flag.\n  * Flag 2: Execute a FORTRAN program.\n  * Flag 3: (not solved)\n\"\"\"",
        "\"\"\"\\\nTo enhance the security of our members, we have implemented a what-the-factor \\\nauthentication system. If you haven't yet received your passphrase or are \\\nhaving issues using your issued prng token, please contact member support.\nI need your passphrase, sir?\n\"\"\"",
        "\"\"\"Implementation of the x86 rol instruction.\"\"\"",
        "\"\"\"Convert a byte string into its little Endian equivalent.\"\"\"",
        "\"\"\"Interact with http://0wn.b33f.me/ and get the treasures.\"\"\"",
        "\"\"\"Instantiate the connection.\"\"\"",
        "\"\"\"This is used only for testing and is not required on the live version.\"\"\"",
        "\"\"\"Generate the initial state of the christmas_array.\"\"\"",
        "\"\"\"Encrypt a string using the current encryption scheme.\n\n    When a message is encrypted, the same general process is followed, but the\n    difference is that instead of each counter starting at 0 and 1, they start\n    at different positions, pulling data out of the array, adding, rotating and\n    reinserting.\n    \"\"\"",
        "\"\"\"Given a byte stream and its known equivalent, find the encryption key.\n\n    Take the byte stream we get back and see if we can derive the state of the\n    christmas_array at the time that we started encoding the first 128 bytes.\n\n    We can find this by backing into the encrypt_array used to generate the\n    first 128 bytes of the encrypted response (by just XOR'ing the bytes with\n    their known values). The resulting array can then be continuously rotated by\n    blocks of four bytes, stopping when one of the shifted arrays encrypts the\n    target string into the same byte sequence as we observed.\n    \"\"\"",
        "\"\"\"Find the first key.\"\"\"",
        "\"\"\"Modify the christmas_array and return $edi.\"\"\"",
        "\"\"\"Read a number of bytes from the socket.\"\"\"",
        "\"\"\"Read from the socket until the target is found.\"\"\"",
        "\"\"\"Send a payload to the socket.\"\"\"",
        "\"\"\"Join the club.\"\"\"",
        "\"\"\"Secure the connection.\"\"\"",
        "\"\"\"Login to the server.\"\"\"",
        "\"\"\"Interact with the FORTRAN service.\"\"\"",
        "\"\"\"Elevate the membership (using flag_2).\"\"\"",
        "\"\"\"Read the private members.\"\"\"",
        "\"\"\"Interact with the 0wn.b33f.me Christmas challenge.\"\"\""
    ],
    "functions": [
        "ListToHex",
        "ROL",
        "LittleEndian",
        "InitArrays",
        "GenInitialChristmasArray",
        "GenNewChristmasArray",
        "EncryptString",
        "DecryptString",
        "FindEncryptionKey",
        "FindFlagOne",
        "ModifyChristmasArray",
        "Recv",
        "RecvUntil",
        "Send",
        "Join",
        "Secure",
        "Login",
        "Fortran",
        "Elevate",
        "Secret",
        "Private",
        "main"
    ],
    "classes": [
        "ChristmasChallenge"
    ]
}