{
    "identifiers": [],
    "literals": [],
    "variables": [],
    "comments": [],
    "docstrings": [
        "Copyright (C) 2011, The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n\n\n * Contributed by: Giesecke & Devrient GmbH.\n\n\npackage org.simalliance.openmobileapi.service.terminals;\n\nimport android.content.Context;\nimport org.simalliance.openmobileapi.service.CardException;\nimport org.simalliance.openmobileapi.service.SmartcardService;\nimport org.simalliance.openmobileapi.service.Terminal;\nimport org.simalliance.openmobileapi.service.Util;\nimport org.simalliance.openmobileapi.service.security.arf.SecureElementException;\n\n\nimport android.os.ServiceManager;\nimport android.os.SystemProperties;\nimport android.util.Log;\n\nimport com.android.internal.telephony.ITelephony;\nimport com.android.internal.telephony.TelephonyProperties;\n\nimport java.util.MissingResourceException;\nimport java.util.NoSuchElementException;\n\npublic class UiccTerminal extends Terminal {\n\n    private ITelephony manager = null;\n\n    private int[] channelId = new int[20];\n\n    private String currentSelectedFilePath = \"\";\n\n    private byte[] mAtr = null;\n\n    public UiccTerminal(Context context) {\n        super(SmartcardService._UICC_TERMINAL, context);\n\n        try {\n            manager = ITelephony.Stub.asInterface(ServiceManager\n                    .getService(Context.TELEPHONY_SERVICE));\n        } catch (Exception ex) {\n        }\n\n        for (int i = 0; i < channelId.length; i++) {\n            channelId[i] = 0;\n        }\n    }\n\n    @Override\n    public boolean isCardPresent() throws CardException {\n        String prop = SystemProperties\n                .get(TelephonyProperties.PROPERTY_SIM_STATE);\n        if (\"READY\".equals(prop)) {\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    protected void internalConnect() throws CardException {\n        if (manager == null) {\n            throw new CardException(\"Cannot connect to Telephony Service\");\n        }\n        mIsConnected = true;\n    }\n\n    @Override\n    protected void internalDisconnect() throws CardException {\n    }\n\n    private byte[] stringToByteArray(String s) {\n        byte[] b = new byte[s.length() / 2];\n        for (int i = 0; i < b.length; i++) {\n            b[i] = (byte) Integer.parseInt(s.substring(2 * i, 2 * i + 2), 16);\n        }\n        return b;\n    }\n\n    private String byteArrayToString(byte[] b, int start) {\n        StringBuffer s = new StringBuffer();\n        for (int i = start; i < b.length; i++) {\n            s.append(Integer.toHexString(0x100 + (b[i] & 0xff)).substring(1));\n        }\n        return s.toString();\n    }",
        "* Clear the channel number.\n     *\n     * @param cla\n     *\n     * @return the cla without channel number",
        "private byte clearChannelNumber(byte cla) {\n        // bit 7 determines which standard is used\n        boolean isFirstInterindustryClassByteCoding = ((cla & 0x40) == 0x00);\n\n        if (isFirstInterindustryClassByteCoding) {\n            // First Interindustry Class Byte Coding\n            // see 11.1.4.1: channel number is encoded in the 2 rightmost bits\n            return (byte) (cla & 0xFC);\n        } else {\n            // Further Interindustry Class Byte Coding\n            // see 11.1.4.2: channel number is encoded in the 4 rightmost bits\n            return (byte) (cla & 0xF0);\n        }\n    }\n\n    @Override\n    protected byte[] internalTransmit(byte[] command) throws CardException {\n        int cla = clearChannelNumber(command[0]) & 0xff;\n        int ins = command[1] & 0xff;\n        int p1 = command[2] & 0xff;\n        int p2 = command[3] & 0xff;\n        int p3 = -1;\n        if (command.length > 4) {\n            p3 = command[4] & 0xff;\n        }\n        String data = null;\n        if (command.length > 5) {\n            data = byteArrayToString(command, 5);\n        }\n\n        int channelNumber = parseChannelNumber(command[0]);\n\n        if (channelNumber == 0) {\n\n            try {\n                String response = manager.transmitIccBasicChannel(cla, ins, p1,\n                        p2, p3, data);\n                return stringToByteArray(response);\n            } catch (Exception ex) {\n                throw new CardException(\"transmit command failed\");\n            }\n\n        } else {\n            if ((channelNumber > 0) && (channelId[channelNumber] == 0)) {\n                throw new CardException(\"channel not open\");\n            }\n\n            try {\n                String response = manager.transmitIccLogicalChannel(\n                        cla, ins, channelId[channelNumber], p1, p2, p3, data);\n                return stringToByteArray(response);\n            } catch (Exception ex) {\n                throw new CardException(\"transmit command failed\");\n            }\n        }\n    }\n\n    @Override\n    public byte[] getAtr() {\n        if (mAtr == null) {\n            try {\n                String atr = manager.getIccAtr();\n                if (atr.equals(\"\")) {\n                    mAtr = null;\n                } else {\n                    mAtr = stringToByteArray(atr);\n                }\n            } catch (Exception ex) {\n                mAtr = null;\n            }\n        }\n        return mAtr;\n    }",
        "* Exchanges APDU (SELECT, READ/WRITE) to the  given EF by File ID and file\n     * path via iccIO.\n     *\n     * The given command is checked and might be rejected.\n     *\n     * @param fileID\n     * @param filePath\n     * @param cmd\n     * @return",
        "@Override\n    public byte[] simIOExchange(int fileID, String filePath, byte[] cmd)\n            throws Exception {\n        try {\n            int ins = 0;\n            int p1 = cmd[2] & 0xff;\n            int p2 = cmd[3] & 0xff;\n            int p3 = cmd[4] & 0xff;\n            switch(cmd[1]) {\n                case (byte) 0xB0:\n                    ins = 176;\n                    break;\n                case (byte) 0xB2:\n                    ins = 178;\n                    break;\n                case (byte) 0xA4:\n                    ins = 192;\n                    p1 = 0;\n                    p2 = 0;\n                    p3 = 15;\n                    break;\n                default:\n                    throw new SecureElementException(\"Unknown SIM_IO command\");\n            }\n\n            if (filePath != null && filePath.length() > 0) {\n                currentSelectedFilePath = filePath;\n            }\n\n            byte[] ret = manager.transmitIccSimIO(\n                    fileID, ins, p1, p2, p3, currentSelectedFilePath);\n\n            return ret;\n        } catch (Exception e) {\n            throw new Exception(\"SIM IO access error\");\n        }\n    }",
        "* Extracts the channel number from a CLA byte. Specified in GlobalPlatform\n     * Card Specification 2.2.0.7: 11.1.4 Class Byte Coding.\n     *\n     * @param cla\n     *            the command's CLA byte\n     * @return the channel number within [0x00..0x0F]",
        "private int parseChannelNumber(byte cla) {\n        // bit 7 determines which standard is used\n        boolean isFirstInterindustryClassByteCoding = ((cla & 0x40) == 0x00);\n\n        if (isFirstInterindustryClassByteCoding) {\n            // First Interindustry Class Byte Coding\n            // see 11.1.4.1: channel number is encoded in the 2 rightmost bits\n            return cla & 0x03;\n        } else {\n            // Further Interindustry Class Byte Coding\n            // see 11.1.4.2: channel number is encoded in the 4 rightmost bits\n            return (cla & 0x0F) + 4;\n        }\n    }\n\n    @Override\n    protected int internalOpenLogicalChannel() throws Exception {\n        // Select response will always be null because no select command will be\n        // issued.\n        mSelectResponse =  null;\n        for (int i = 1; i < channelId.length; i++) {\n            if (channelId[i] == 0) {\n                channelId[i] = manager.openIccLogicalChannel(\"\");\n\n                if (!(channelId[i] > 0)) {\n                    // channelId[i] == 0, means an error occured.\n                    channelId[i] = 0;\n                    int lastError = manager.getLastError();\n\n                    if (lastError == 2) {\n                        throw new MissingResourceException(\n                                \"all channels are used\", \"\", \"\");\n                    }\n                    if (lastError == 3) {\n                        throw new NoSuchElementException(\"applet not found\");\n                    }\n                    throw new CardException(\"open channel failed\");\n                }\n\n                return i;\n            }\n        }\n        throw new MissingResourceException(\"out of channels\", \"\", \"\");\n    }\n\n    @Override\n    protected int internalOpenLogicalChannel(byte[] aid) throws Exception {\n\n        if (aid == null) {\n            throw new NullPointerException(\"aid must not be null\");\n        }\n        mSelectResponse = null;\n        for (int i = 1; i < channelId.length; i++) {\n            if (channelId[i] == 0) {\n                channelId[i] = manager.openIccLogicalChannel(\n                        byteArrayToString(aid, 0));\n\n                if (!(channelId[i] > 0)) {\n                    // channelId[i] == 0, means an error occured.\n                    channelId[i] = 0;\n                    int lastError = manager.getLastError();\n\n                    if (lastError == 2) {\n                        throw new MissingResourceException(\n                                \"all channels are used\", \"\", \"\");\n                    }\n                    if (lastError == 3) {\n                        throw new NoSuchElementException(\"applet not found\");\n                    }\n                    throw new CardException(\"open channel failed\");\n                }\n\n                // If everything succeeded, set the select response.\n                mSelectResponse = stringToByteArray(\n                                    manager.getIccSelectResponse());\n                return i;\n            }\n        }\n        throw new MissingResourceException(\"out of channels\", \"\", \"\");\n    }\n\n    @Override\n    protected void internalCloseLogicalChannel(int channelNumber)\n            throws CardException {\n        if (channelNumber == 0) {\n            return;\n        }\n        if (channelId[channelNumber] == 0) {\n            throw new CardException(\"channel not open\");\n        }\n        try {\n            if (!manager.closeIccLogicalChannel(channelId[channelNumber])) {\n                throw new CardException(\"close channel failed\");\n            }\n        } catch (Exception ex) {\n            throw new CardException(\"close channel failed\");\n        }\n        channelId[channelNumber] = 0;\n    }\n}"
    ],
    "functions": [],
    "classes": []
}