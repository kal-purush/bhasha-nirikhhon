{
    "identifiers": [
        "Diagnostics",
        "Collections",
        "Generic",
        "Linq",
        "Text",
        "Threading",
        "Tasks",
        "Reactive",
        "Reactive",
        "Linq",
        "Reactive",
        "Subjects",
        "NLog",
        "LibDmd",
        "Input",
        "FrameType",
        "MemoryGrabberBase",
        "Process",
        "p",
        "TimeSpan",
        "FromSeconds",
        "LogManager",
        "GetCurrentClassLogger",
        "p",
        "Process",
        "GetProcesses",
        "AttachGameProcess",
        "p",
        "h",
        "IntPtr",
        "Zero",
        "h",
        "IntPtr",
        "Zero",
        "SetDebugPrivilege",
        "Logger",
        "Info",
        "Name",
        "Subject",
        "Unit",
        "Observable",
        "Timer",
        "TimeSpan",
        "Zero",
        "PollForProcessDelay",
        "TakeUntil",
        "success",
        "Subscribe",
        "_hProcess",
        "FindGameHandle",
        "_hProcess",
        "IntPtr",
        "Zero",
        "StartCapturing",
        "success",
        "OnNext",
        "Unit",
        "Default",
        "IConnectableObservable",
        "FrameType",
        "IConnectableObservable",
        "FrameType",
        "_framesObservable",
        "_framesObservable",
        "Observable",
        "Interval",
        "TimeSpan",
        "FromMilliseconds",
        "FramesPerSecond",
        "Select",
        "WaitForSingleObject",
        "_hProcess",
        "WAIT_OBJECT_0",
        "CloseHandle",
        "_hProcess",
        "_hProcess",
        "IntPtr",
        "Zero",
        "StopCapturing",
        "FrameType",
        "CaptureDMD",
        "Where",
        "frame",
        "Publish",
        "StartPolling",
        "_framesObservable",
        "Logger",
        "Info",
        "Name",
        "FramesPerSecond",
        "_capturer",
        "_framesObservable",
        "Connect",
        "_onResume",
        "OnNext",
        "Unit",
        "Default",
        "Logger",
        "Info",
        "Name",
        "_capturer",
        "Dispose",
        "_onPause",
        "OnNext",
        "Unit",
        "Default",
        "StartPolling",
        "ISubject",
        "Unit",
        "Subject",
        "Unit",
        "ISubject",
        "Unit",
        "Subject",
        "Unit",
        "IObservable",
        "Unit",
        "_onResume",
        "IObservable",
        "Unit",
        "_onPause",
        "Process",
        "process",
        "process",
        "MainModule",
        "procMod",
        "BaseAddress",
        "buf",
        "IntPtr",
        "BitConverter",
        "ToInt32",
        "buf",
        "Process",
        "gameProc",
        "IntPtr",
        "gameBaseAddr",
        "size",
        "bytePattern",
        "offset",
        "size",
        "ReadProcessMemory",
        "gameProc",
        "Handle",
        "gameBaseAddr",
        "memoryRegion",
        "size",
        "IntPtr",
        "Zero",
        "x",
        "memoryRegion",
        "Length",
        "bytePattern",
        "Length",
        "x",
        "y",
        "bytePattern",
        "Length",
        "y",
        "bytePattern",
        "y",
        "bytePattern",
        "y",
        "memoryRegion",
        "x",
        "y",
        "y",
        "bytePattern",
        "Length",
        "gameBaseAddr",
        "offset",
        "x",
        "IntPtr",
        "Zero"
    ],
    "literals": [],
    "variables": [
        "TimeSpan",
        "PollForProcessDelay",
        "FramesPerSecond",
        "Logger",
        "Logger",
        "_capturer",
        "IntPtr",
        "_hProcess",
        "h",
        "success",
        "_framesObservable",
        "_onResume",
        "_onPause",
        "OnResume",
        "OnPause",
        "procMod",
        "memoryRegion",
        "x",
        "y"
    ],
    "comments": [
        "Determine if the given process is the subject process, and attach",
        "to it if so.  On success, this finds the DMD struct(s) within the target",
        "process, stores their addresses in subclass member variables as needed",
        "to read the DMD state on an ongoing basis, establishes any required",
        "hooks in the target process (e.g., the Pinball Arcade \"code cave\"), and",
        "returns the Win32 HANDLE of the open process.  If the process isn't the",
        "subject process, or the DMD struct(s) can't be located, returns null",
        "(IntPtr.Zero).",
        "</summary>",
        "Wait time between polls for the subject process. Stops polling as soon",
        "as the process is found.",
        "",
        "Can be set quite high, just about as long as it takes for subject to start.",
        "</summary>",
        "Frequency with which frames are pulled off the memory.",
        "</summary>",
        "logger",
        "capturer",
        "subject process handle",
        "Search the system process list for the subject process.  Returns a Win32",
        "HANDLE to the process on success, with the memory grabber addresses stored",
        "and any \"code cave\" or other hack into the subject process space established.",
        "Returns IntPtr.Zero if no suitable subject process can be found.",
        "</summary>",
        "search the process list",
        "try this process",
        "if that yielded a handle, use this proces",
        "no matches",
        "Poll for the subject process to start",
        "</summary>",
        "",
        "enable debug privileges to gain access to FX3's memory space",
        "if the process has exited, stop capture",
        "Starts sending frames.",
        "</summary>",
        "Stops sending frames, usually because the subject process terminated.",
        "</summary>",
        "TODO send blank frame",
        "Reactive pause/resume subjects",
        "Reactive pause/resume observables",
        "Get the base address of a process's memory space",
        "Convert a four-byte buffer read from process memory to a 32-bit pointer",
        "Search a process's memory space for a byte pattern.  0xFF in the pattern",
        "is a wildcard that matches any single byte.",
        "Create a byte array to store memory region.",
        "Dump process memory into the array.",
        "Loop into dumped memory region to find the pattern.",
        "If we find the first pattern's byte in memory, loop through the entire array.",
        "If pattern byte is 0xFF, this is a joker, continue pattern loop.",
        "If pattern byte is different than memory byte, we're not at the right place, back to the memory region loop...",
        "We've reached the end of the pattern array, we've found the offset.",
        "We've reached the end of memory region, offset not found."
    ],
    "docstrings": [
        "<summary>",
        "<summary>",
        "<summary>",
        "<summary>",
        "<summary>",
        "<summary>",
        "<summary>"
    ],
    "functions": [
        "IntPtr",
        "AttachGameProcess",
        "IntPtr",
        "FindGameHandle",
        "StartPolling",
        "GetFrames",
        "FrameType",
        "CaptureDMD",
        "StartCapturing",
        "StopCapturing",
        "IntPtr",
        "BaseAddress",
        "IntPtr",
        "B4ToPointer",
        "IntPtr",
        "FindPattern"
    ],
    "classes": [
        "MemoryGrabber"
    ]
}