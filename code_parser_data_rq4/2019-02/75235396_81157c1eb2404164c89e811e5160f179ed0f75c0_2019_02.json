{
    "identifiers": [
        "org",
        "isarnproject",
        "sketches",
        "java",
        "java",
        "lang",
        "java",
        "lang",
        "StringBuilder",
        "java",
        "util",
        "Arrays",
        "java",
        "util",
        "Comparator",
        "java",
        "io",
        "Serializable",
        "java",
        "util",
        "concurrent",
        "ThreadLocalRandom",
        "java",
        "util",
        "Random",
        "C",
        "maxDiscrete",
        "nclusters",
        "M",
        "cent",
        "mass",
        "ftre",
        "COMPRESSION_DEFAULT",
        "INIT_SIZE_DEFAULT",
        "compression",
        "compression",
        "INIT_SIZE_DEFAULT",
        "compression",
        "maxDiscrete",
        "compression",
        "maxDiscrete",
        "INIT_SIZE_DEFAULT",
        "compression",
        "maxDiscrete",
        "sz",
        "compression",
        "maxDiscrete",
        "sz",
        "C",
        "compression",
        "maxDiscrete",
        "maxDiscrete",
        "cent",
        "sz",
        "mass",
        "sz",
        "ftre",
        "sz",
        "ftre",
        "that",
        "C",
        "that",
        "C",
        "maxDiscrete",
        "that",
        "maxDiscrete",
        "nclusters",
        "that",
        "nclusters",
        "M",
        "that",
        "M",
        "cent",
        "Arrays",
        "copyOf",
        "that",
        "cent",
        "nclusters",
        "mass",
        "Arrays",
        "copyOf",
        "that",
        "mass",
        "nclusters",
        "ftre",
        "Arrays",
        "copyOf",
        "that",
        "ftre",
        "nclusters",
        "x",
        "update",
        "x",
        "x",
        "w",
        "updateLogic",
        "x",
        "w",
        "nclusters",
        "maxDiscrete",
        "nclusters",
        "R",
        "recluster",
        "x",
        "w",
        "nclusters",
        "cent",
        "x",
        "M",
        "w",
        "mass",
        "w",
        "ftre",
        "w",
        "nclusters",
        "nclusters",
        "maxDiscrete",
        "j",
        "Arrays",
        "binarySearch",
        "cent",
        "nclusters",
        "x",
        "j",
        "M",
        "w",
        "mass",
        "j",
        "w",
        "ftInc",
        "j",
        "w",
        "newCluster",
        "j",
        "x",
        "w",
        "j",
        "closest",
        "x",
        "x",
        "cent",
        "j",
        "M",
        "w",
        "mass",
        "j",
        "w",
        "ftInc",
        "j",
        "w",
        "m",
        "mass",
        "j",
        "q",
        "ftSum",
        "j",
        "m",
        "M",
        "ub",
        "C",
        "M",
        "q",
        "q",
        "dm",
        "min",
        "w",
        "max",
        "ub",
        "m",
        "rm",
        "w",
        "dm",
        "dm",
        "dc",
        "dm",
        "x",
        "cent",
        "j",
        "m",
        "dm",
        "cent",
        "j",
        "dc",
        "M",
        "dm",
        "mass",
        "j",
        "dm",
        "ftInc",
        "j",
        "dm",
        "rm",
        "newCluster",
        "x",
        "cent",
        "j",
        "j",
        "j",
        "x",
        "rm",
        "that",
        "indexes",
        "that",
        "nclusters",
        "j",
        "j",
        "that",
        "nclusters",
        "j",
        "indexes",
        "j",
        "j",
        "cmp",
        "Override",
        "a",
        "b",
        "signum",
        "that",
        "mass",
        "b",
        "that",
        "mass",
        "a",
        "Arrays",
        "sort",
        "indexes",
        "cmp",
        "j",
        "indexes",
        "update",
        "that",
        "cent",
        "j",
        "that",
        "mass",
        "j",
        "indexes",
        "nclusters",
        "j",
        "j",
        "nclusters",
        "j",
        "indexes",
        "j",
        "j",
        "intShuffle",
        "indexes",
        "sz",
        "cent",
        "length",
        "oldCent",
        "cent",
        "oldMass",
        "mass",
        "cent",
        "sz",
        "mass",
        "sz",
        "reset",
        "j",
        "indexes",
        "updateLogic",
        "oldCent",
        "j",
        "oldMass",
        "j",
        "nclusters",
        "M",
        "j",
        "x",
        "w",
        "newCent",
        "cent",
        "newMass",
        "mass",
        "newFtre",
        "ftre",
        "sz",
        "cent",
        "length",
        "nclusters",
        "sz",
        "szinc",
        "ceil",
        "sz",
        "sz",
        "szinc",
        "newCent",
        "sz",
        "newMass",
        "sz",
        "newFtre",
        "sz",
        "arraycopy",
        "cent",
        "newCent",
        "j",
        "arraycopy",
        "mass",
        "newMass",
        "j",
        "arraycopy",
        "cent",
        "j",
        "newCent",
        "j",
        "nclusters",
        "j",
        "arraycopy",
        "mass",
        "j",
        "newMass",
        "j",
        "nclusters",
        "j",
        "newCent",
        "j",
        "x",
        "newMass",
        "j",
        "w",
        "nclusters",
        "cent",
        "newCent",
        "mass",
        "newMass",
        "ftre",
        "newFtre",
        "Arrays",
        "fill",
        "ftre",
        "nclusters",
        "k",
        "k",
        "nclusters",
        "k",
        "ftInc",
        "k",
        "mass",
        "k",
        "M",
        "w",
        "x",
        "j",
        "Arrays",
        "binarySearch",
        "cent",
        "nclusters",
        "x",
        "j",
        "j",
        "j",
        "j",
        "j",
        "j",
        "j",
        "nclusters",
        "j",
        "dL",
        "x",
        "cent",
        "j",
        "dR",
        "cent",
        "j",
        "x",
        "dL",
        "dR",
        "j",
        "j",
        "nclusters",
        "M",
        "C",
        "maxDiscrete",
        "cent",
        "mass",
        "ftre",
        "nclusters",
        "Override",
        "sb",
        "j",
        "j",
        "nclusters",
        "j",
        "j",
        "sb",
        "append",
        "j",
        "sb",
        "append",
        "sb",
        "append",
        "cent",
        "j",
        "append",
        "append",
        "mass",
        "j",
        "append",
        "append",
        "ftSum",
        "j",
        "append",
        "sb",
        "append",
        "sb",
        "toString",
        "samplePDF",
        "ThreadLocalRandom",
        "current",
        "prng",
        "cdfInverse",
        "prng",
        "nextDouble",
        "samplePMF",
        "ThreadLocalRandom",
        "current",
        "prng",
        "cdfDiscreteInverse",
        "prng",
        "nextDouble",
        "sample",
        "ThreadLocalRandom",
        "current",
        "prng",
        "nclusters",
        "maxDiscrete",
        "cdfDiscreteInverse",
        "prng",
        "nextDouble",
        "cdfInverse",
        "prng",
        "nextDouble",
        "x",
        "j1",
        "rcovj",
        "x",
        "j1",
        "j1",
        "nclusters",
        "j2",
        "j1",
        "c1",
        "cent",
        "j1",
        "c2",
        "cent",
        "j2",
        "tm1",
        "mass",
        "j1",
        "tm2",
        "mass",
        "j2",
        "s",
        "ftSum",
        "j1",
        "d1",
        "j1",
        "tm1",
        "m1",
        "s",
        "d1",
        "m2",
        "m1",
        "tm1",
        "d1",
        "j2",
        "nclusters",
        "tm2",
        "tm2",
        "m",
        "m1",
        "x",
        "c1",
        "m2",
        "m1",
        "c2",
        "c1",
        "min",
        "m2",
        "max",
        "m1",
        "m",
        "M",
        "x",
        "j",
        "rcovj",
        "x",
        "ftSum",
        "j",
        "M",
        "q",
        "q",
        "q",
        "NaN",
        "nclusters",
        "NaN",
        "nclusters",
        "cent",
        "m",
        "q",
        "M",
        "j1",
        "rmcovj",
        "m",
        "j2",
        "j1",
        "c1",
        "cent",
        "j1",
        "c2",
        "cent",
        "j2",
        "tm1",
        "mass",
        "j1",
        "tm2",
        "mass",
        "j2",
        "s",
        "ftSum",
        "j1",
        "d1",
        "j1",
        "tm1",
        "m1",
        "s",
        "d1",
        "m2",
        "m1",
        "tm1",
        "d1",
        "j2",
        "nclusters",
        "tm2",
        "tm2",
        "x",
        "c1",
        "m",
        "m1",
        "c2",
        "c1",
        "m2",
        "m1",
        "min",
        "c2",
        "max",
        "c1",
        "x",
        "q",
        "q",
        "q",
        "NaN",
        "nclusters",
        "NaN",
        "nclusters",
        "cent",
        "m",
        "q",
        "M",
        "j",
        "lmcovj",
        "m",
        "cent",
        "j",
        "m",
        "nclusters",
        "m",
        "m",
        "M",
        "beg",
        "mbeg",
        "end",
        "nclusters",
        "mend",
        "M",
        "end",
        "beg",
        "mid",
        "beg",
        "end",
        "mmid",
        "ftSum",
        "mid",
        "m",
        "mmid",
        "beg",
        "mid",
        "mbeg",
        "mmid",
        "end",
        "mid",
        "mend",
        "mmid",
        "beg",
        "m",
        "nclusters",
        "m",
        "m",
        "M",
        "beg",
        "mbeg",
        "end",
        "nclusters",
        "mend",
        "M",
        "end",
        "beg",
        "mid",
        "beg",
        "end",
        "mmid",
        "ftSum",
        "mid",
        "m",
        "mmid",
        "end",
        "mid",
        "mend",
        "mmid",
        "beg",
        "mid",
        "mbeg",
        "mmid",
        "end",
        "x",
        "j",
        "Arrays",
        "binarySearch",
        "cent",
        "nclusters",
        "x",
        "j",
        "j",
        "j",
        "j",
        "j",
        "j",
        "j",
        "j",
        "s",
        "j",
        "s",
        "ftre",
        "j",
        "j",
        "j",
        "j",
        "s",
        "j",
        "w",
        "j",
        "j",
        "nclusters",
        "ftre",
        "j",
        "w",
        "j",
        "j",
        "j",
        "Override",
        "that",
        "that",
        "that",
        "rhs",
        "that",
        "C",
        "rhs",
        "C",
        "maxDiscrete",
        "rhs",
        "maxDiscrete",
        "nclusters",
        "rhs",
        "nclusters",
        "M",
        "rhs",
        "M",
        "equal",
        "cent",
        "rhs",
        "cent",
        "nclusters",
        "equal",
        "mass",
        "rhs",
        "mass",
        "nclusters",
        "lhs",
        "rhs",
        "n",
        "j",
        "j",
        "n",
        "j",
        "lhs",
        "j",
        "rhs",
        "j",
        "Override",
        "h",
        "nclusters",
        "h",
        "doubleHash",
        "M",
        "nclusters",
        "h",
        "doubleHash",
        "cent",
        "h",
        "doubleHash",
        "mass",
        "h",
        "doubleHash",
        "ftre",
        "nclusters",
        "h",
        "doubleHash",
        "cent",
        "nclusters",
        "h",
        "doubleHash",
        "mass",
        "nclusters",
        "h",
        "doubleHash",
        "ftre",
        "nclusters",
        "nclusters",
        "j",
        "nclusters",
        "h",
        "doubleHash",
        "cent",
        "j",
        "h",
        "doubleHash",
        "mass",
        "j",
        "h",
        "doubleHash",
        "ftre",
        "j",
        "h",
        "x",
        "v",
        "doubleToLongBits",
        "x",
        "v",
        "v",
        "K",
        "C",
        "K",
        "COMPRESSION_DEFAULT",
        "INIT_SIZE_DEFAULT",
        "COMPRESSION_DEFAULT",
        "INIT_SIZE_DEFAULT",
        "compression",
        "compression",
        "INIT_SIZE_DEFAULT",
        "compression",
        "maxDiscrete",
        "compression",
        "maxDiscrete",
        "INIT_SIZE_DEFAULT",
        "compression",
        "maxDiscrete",
        "sz",
        "compression",
        "maxDiscrete",
        "sz",
        "ltd",
        "rtd",
        "ltd",
        "size",
        "rtd",
        "size",
        "merge",
        "rtd",
        "ltd",
        "rtd",
        "size",
        "ltd",
        "rtd",
        "size",
        "ltd",
        "update",
        "rtd",
        "cent",
        "rtd",
        "mass",
        "ltd",
        "rtd",
        "mass",
        "ltd",
        "mass",
        "ltd",
        "merge",
        "rtd",
        "ltd",
        "rtd",
        "merge",
        "ltd",
        "rtd",
        "data",
        "sketch",
        "data",
        "COMPRESSION_DEFAULT",
        "INIT_SIZE_DEFAULT",
        "data",
        "compression",
        "sketch",
        "data",
        "compression",
        "INIT_SIZE_DEFAULT",
        "data",
        "compression",
        "maxDiscrete",
        "sketch",
        "data",
        "compression",
        "maxDiscrete",
        "INIT_SIZE_DEFAULT",
        "data",
        "compression",
        "maxDiscrete",
        "sz",
        "td",
        "empty",
        "compression",
        "maxDiscrete",
        "sz",
        "x",
        "data",
        "td",
        "update",
        "x",
        "td",
        "size",
        "maxDiscrete",
        "td",
        "recluster",
        "td",
        "data",
        "intShuffle",
        "data",
        "data",
        "length",
        "data",
        "end",
        "intShuffle",
        "data",
        "end",
        "data",
        "beg",
        "end",
        "rnd",
        "ThreadLocalRandom",
        "current",
        "end",
        "end",
        "beg",
        "r",
        "rnd",
        "nextInt",
        "beg",
        "end",
        "d",
        "data",
        "end",
        "data",
        "end",
        "data",
        "r",
        "data",
        "r",
        "d",
        "end"
    ],
    "literals": [
        "\"TDigest(\"",
        "\" ...\"",
        "\", \"",
        "\" -> (\"",
        "\", \"",
        "\")\"",
        "\")\""
    ],
    "variables": [
        "C",
        "maxDiscrete"
    ],
    "comments": [
        "ftre is 1-based. set ftre[0] to zero just to be tidy",
        "clusters are empty, so (x,w) becomes the first cluster",
        "we are under the limit for discrete values to track",
        "landed on existing cluster: add its mass and we're done",
        "a new x value: insert as a new discrete cluster",
        "get the index of the cluster closest to x",
        "landed on existing cluster: add its mass and we're done",
        "q is the quantile of the closest cluster to x",
        "(ftSum does the right thing (return 0) for j = 0)",
        "this is the upper-bound for the mass of closest cluster",
        "dm is how much mass we're allowed to add to closest cluster",
        "rm is the remainder of the mass",
        "Add any allowable mass to closest cluster and update its center.",
        "It is safe to update center this way because it will remain",
        "between x and original center, and so cannot move out of its original",
        "ordering relative to its neighbors, because x is by previous logic",
        "closer to cent[j] than any other cluster.",
        "if there is remaining mass, it becomes a new cluster",
        "sort so that largest clusters are first.",
        "inserting large to small yields stable distribution estimations",
        "I suspect it may be possible to improve on this fully-randomized algorithm,",
        "by leveraging the largest-first heuristic I use in cluster merging. See:",
        "http://erikerlandson.github.io/blog/2016/12/19/converging-monoid-addition-for-t-digest/",
        "arraycopy can handle when cent == newCent",
        "do this after copies above",
        "exact match, return its index:",
        "x is not a cluster center, get its insertion index:",
        "x is to left of left-most cluster:",
        "x is to right of right-most cluster:",
        "x is between two clusters, return index of closest:",
        "returns the index of a right mass cover",
        "ftSum(j) <= m < ftSum(j+1)",
        "returns the index of a left mass cover",
        "ftSum(j-1) < m <= ftSum(j)",
        "returns the left index of a right-cover",
        "exact match, return its index:",
        "x is not a cluster center, get its insertion index:",
        "x is to left of left-most cluster:",
        "return the index to the left of x:",
        "cumulative-sum algorithm for a Fenwick tree",
        "dec by least significant nonzero bit of j",
        "increment algorithm for a Fenwick tree",
        "inc by least significant nonzero bit of j",
        "if masses are equal, cumulative ftre had better also be equal",
        "I can't believe java just added this to Arrays in java 9",
        "I can't believe Double doesn't provide a static method for this"
    ],
    "docstrings": [
        "Copyright 2016-2018 Erik Erlandson\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.",
        "* A t-digest sketch of sampled numeric data\n * <pre>\n * Computing Extremely Accurate Quantiles Using t-Digests,\n * Ted Dunning and Otmar Ertl,\n * https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf\n * </pre>\n *\n * <pre>\n * import org.isarnproject.sketches.java.TDigest;\n * double[] data = // data that you would like to sketch\n * TDigest sketch = TDigest.sketch(data)\n * // the cumulative distribution function of the sketch; cdf(x) at x = 0\n * double cdf = sketch.cdf(0.0)\n * // inverse of the CDF, evaluated at q = 0.5\n * double cdfi = sketch.cdfInverse(0.5)\n * </pre>",
        "compression setting (delta in original paper)",
        "maximum number of unique discrete values to track",
        "current number of clusters",
        "total mass of data sampled so far",
        "cluster centers",
        "cluster masses",
        "cumulative cluster masses, represented as a Fenwick Tree",
        "A new t-digest sketching structure with default compression and maximum discrete tracking.",
        "Construct a t-digest with the given compression.\n     * Maximum discrete tracking defaults to zero.\n     * @param compression sketching compression setting. Higher = more compression.\n     * Must be &gt; 0.",
        "Construct a t-digest with the given compression and maximum discrete tracking.\n     * @param compression sketching compression setting. Higher = more compression.\n     * Must be &gt; 0.\n     * @param maxDiscrete maximum number of unique discrete values to track. Must be &ge; 0.\n     * If this number of values is exceeded, the sketch will begin to operate in \n     * normal continuous mode.",
        "Construct a t-digest with the given compression and maximum discrete tracking.\n     * @param compression sketching compression setting. Higher = more compression.\n     * Must be &gt; 0.\n     * @param maxDiscrete maximum number of unique discrete values to track. Must be &ge; 0.\n     * If this number of values is exceeded, the sketch will begin to operate in \n     * normal continuous mode.\n     * @param sz initial capacity to use for internal arrays. Must be &gt; 0.",
        "Construct a deep copy of another t-digest",
        "Update the sketch with a new sampled value\n     * @param x the new sampled value",
        "Update the sketch with a new sampled value\n     * @param x the new sampled value\n     * @param w the weight (aka mass) associated with x",
        "Merge another t-digest into this one.\n     * @param that the t-digest to merge. This t-digest is unaltered.",
        "Re-cluster this t-digest by reinserting its clusters in randomized order.",
        "Reset this t-digest to an empty state",
        "Obtain the number of clusters in this t-digest \n     * @return the number of clusters in this t-digest",
        "Obtain the total mass sampled by this t-digest\n     * @return the total mass",
        "Obtain the compression setting for this t-digest\n     * @return the compression setting",
        "Obtain the maximum discrete setting for this t-digest\n     * @return the maximum discrete setting",
        "Obtain a reference to this t-digest's cluster center array.\n     * NOTE: this array is not safe to modify, and should be used only in \"read-only\" mode!\n     * @return a reference to the cluster center array",
        "Obtain a reference to this t-digest's cluster mass array.\n     * NOTE: this array is not safe to modify, and should be used only in \"read-only\" mode!\n     * @return a reference to the cluster mass array",
        "Obtain a reference to this t-digest's cumulative mass array.\n     * This array stores the cumulative masses of clusters in Fenwick Tree format.\n     * NOTE: this array is not safe to modify, and should be used only in \"read-only\" mode!\n     * @return a reference to the cumulative mass array",
        "Returns true if this t-digest is empty, false otherwise.",
        "* Perform a random sampling from the distribution as sketched by this t-digest, in\n     * \"probability density\" mode.\n     * @return A random number sampled from the sketched distribution",
        "* Perform a random sampling from the distribution as sketched by this t-digest, in\n     * \"probability density\" mode.\n     * @param prng a (pseudo) random number generator to use for the random sampling\n     * @return A random number sampled from the sketched distribution",
        "* Perform a random sampling from the distribution as sketched by this t-digest, in\n     * \"probability mass\" (i.e. discrete) mode.\n     * @return A random number sampled from the sketched distribution",
        "* Perform a random sampling from the distribution as sketched by this t-digest, in\n     * \"probability mass\" (i.e. discrete) mode.\n     * @param prng a (pseudo) random number generator to use for the random sampling\n     * @return A random number sampled from the sketched distribution",
        "* Perform a random sampling from the distribution as sketched by this t-digest,\n     * using \"discrete\" (PMF) mode if the number of clusters &le; maxDiscrete setting,\n     * and \"density\" (PDF) mode otherwise.\n     * @return A random number sampled from the sketched distribution",
        "* Perform a random sampling from the distribution as sketched by this t-digest,\n     * using \"discrete\" (PMF) mode if the number of clusters &le; maxDiscrete setting,\n     * and \"density\" (PDF) mode otherwise.\n     * @param prng a (pseudo) random number generator to use for the random sampling\n     * @return A random number sampled from the sketched distribution",
        "* Compute a cumulative probability (CDF) for a numeric value, from the estimated probability\n     * distribution represented by this t-digest sketch.\n     * @param x a numeric value\n     * @return the cumulative probability that a random sample from the distribution is &le; x",
        "* Compute a cumulative probability (CDF) for a numeric value, from the estimated probability\n     * distribution represented by this t-digest sketch, assuming sketch is \"discrete\"\n     * (e.g. if number of clusters &le; maxDiscrete setting)\n     * @param x a numeric value\n     * @return the cumulative probability that a random sample from the distribution is &le; x",
        "* Compute the inverse cumulative probability (inverse-CDF) for a quantile value, from the\n     * estimated probability distribution represented by this t-digest sketch.\n     * @param q a quantile value.  The value of q is expected to be on interval [0, 1]\n     * @return the value x such that cdf(x) = q",
        "* Compute the inverse cumulative probability (inverse-CDF) for a quantile value, from the\n     * estimated probability distribution represented by this t-digest sketch,\n     * assuming the sketch is \"discrete\" (e.g. if number of clusters &le; maxDiscrete setting)\n     * @param q a quantile value.  The value of q is expected to be on interval [0, 1]\n     * @return the smallest value x such that q &le; cdf(x)",
        "* The t-digest algorithm will re-cluster itself whenever its number of clusters exceeds\n     * (K/delta).  This value is set such that the threshold is about 10x the heuristically\n     * expected number of clusters for the user-specified delta value.  Generally the number of\n     * clusters will only trigger the corresponding re-clustering threshold when data are being\n     * presented in a non-random order.",
        "* Default value for a t-digest compression (aka delta) parameter.\n     * The number of clusters varies, roughly, as\n     * about (50/delta), when data are presented in random order\n     * (it may grow larger if data are not presented randomly).  The default corresponds to\n     * an expected number of clusters of about 100.",
        "Default for the initial cluster array capacity",
        "Obtain an empty t-digest with default compression and maximum discrete tracking. \n     * @return a new empty t-digest",
        "* Obtain an empty t-digest.\n     * maxDiscrete defaults to zero.\n     * @param compression sketching compression setting. Higher = more compression.\n     * Must be &gt; 0.\n     * @return a new empty t-digest",
        "* Obtain an empty t-digest.\n     * @param compression sketching compression setting. Higher = more compression.\n     * Must be &gt; 0.\n     * @param maxDiscrete maximum number of unique discrete values to track. Must be &ge; 0.\n     * If this number of values is exceeded, the sketch will begin to operate in \n     * normal continuous mode.\n     * @return a new empty t-digest",
        "* Obtain an empty t-digest.\n     * @param compression sketching compression setting. Higher = more compression.\n     * Must be &gt; 0.\n     * @param maxDiscrete maximum number of unique discrete values to track. Must be &ge; 0.\n     * If this number of values is exceeded, the sketch will begin to operate in \n     * normal continuous mode.\n     * @param sz initial capacity to use for internal arrays. Must be &gt; 0.\n     * @return a new empty t-digest",
        "Merge the argument with smaller mass into the one with larger mass, and return\n     * the larger as the result.\n     * Note this means either (ltd) or (rtd) will be modified.\n     * @param ltd a t-digest\n     * @param rtd another t-digest\n     * @return if ltd has larger mass, then returns <pre>ltd.merge(rtd)</pre>,\n     * otherwise <pre>rtd.merge(ltd)</pre>",
        "* Sketch data using a t-digest with default compression and maximum discrete tracking.\n     * @param data the data to sketch\n     * @return a t-digest sketch of the data",
        "* Sketch data using a t-digest.\n     * maxDiscrete defaults to zero.\n     * @param data the data to sketch\n     * @param compression sketching compression setting. Higher = more compression.\n     * Must be &gt; 0.\n     * @return a t-digest sketch of the data",
        "* Sketch data using a t-digest.\n     * @param data the data to sketch\n     * @param compression sketching compression setting. Higher = more compression.\n     * Must be &gt; 0.\n     * @param maxDiscrete maximum number of unique discrete values to track. Must be &ge; 0.\n     * If this number of values is exceeded, the sketch will begin to operate in \n     * normal continuous mode.\n     * @return a t-digest sketch of the data",
        "* Sketch data using a t-digest.\n     * @param data the data to sketch\n     * @param compression sketching compression setting. Higher = more compression.\n     * Must be &gt; 0.\n     * @param maxDiscrete maximum number of unique discrete values to track. Must be &ge; 0.\n     * If this number of values is exceeded, the sketch will begin to operate in \n     * normal continuous mode.\n     * @param sz initial capacity to use for internal arrays. Must be &gt; 0.\n     * @return a t-digest sketch of the data"
    ],
    "functions": [
        "TDigest",
        "TDigest",
        "TDigest",
        "TDigest",
        "TDigest",
        "update",
        "update",
        "updateLogic",
        "merge",
        "compare",
        "recluster",
        "reset",
        "newCluster",
        "closest",
        "size",
        "mass",
        "getCompression",
        "getMaxDiscrete",
        "getCentUnsafe",
        "getMassUnsafe",
        "getFTUnsafe",
        "isEmpty",
        "toString",
        "samplePDF",
        "samplePDF",
        "samplePMF",
        "samplePMF",
        "sample",
        "sample",
        "cdf",
        "cdfDiscrete",
        "cdfInverse",
        "cdfDiscreteInverse",
        "rmcovj",
        "lmcovj",
        "rcovj",
        "ftSum",
        "ftInc",
        "equals",
        "equal",
        "hashCode",
        "doubleHash",
        "R",
        "TDigest",
        "empty",
        "TDigest",
        "empty",
        "TDigest",
        "empty",
        "TDigest",
        "empty",
        "TDigest",
        "merge",
        "TDigest",
        "sketch",
        "TDigest",
        "sketch",
        "TDigest",
        "sketch",
        "TDigest",
        "sketch",
        "intShuffle",
        "intShuffle",
        "intShuffle"
    ],
    "classes": [
        "TDigest"
    ]
}