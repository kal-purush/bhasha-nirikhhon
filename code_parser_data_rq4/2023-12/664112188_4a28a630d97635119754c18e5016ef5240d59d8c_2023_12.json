{
    "identifiers": [
        "html",
        "DocPageLayout",
        "Heading",
        "PageComponentProps",
        "CodeSnippet",
        "DocPageLayout",
        "html",
        "Heading",
        "page",
        "Heading",
        "CodeSnippet",
        "CodeSnippet",
        "Heading",
        "CodeSnippet",
        "Heading",
        "CodeSnippet",
        "Heading",
        "CodeSnippet",
        "CodeSnippet"
    ],
    "literals": [
        "'../../src'",
        "'../partials/doc-page-layout'",
        "'../partials/heading'",
        "'../type'",
        "'../partials/code-snippet'",
        "${Heading(page.name)}\n            <p>\n                Markup templates offer a convenient way to tap into its\n                lifecycles, so you can perform setup and teardown actions.\n            </p>\n            ${Heading('onMount', 'h3')}\n            <p>\n                The <code>onMount</code> lifecycle allows you to react to when\n                the template is rendered. This is triggered whenever the\n                <code>render</code> and <code>replace</code>\n                methods successfully render the nodes in the provided target.\n            </p>\n            ${CodeSnippet(\n                'const temp = html`\\n' +\n                    '  <p>sample</p>\\n' +\n                    '`;\\n' +\n                    '\\n' +\n                    'temp.onMount(() => {\\n' +\n                    '  // handle mount\\n' +\n                    '})\\n' +\n                    '\\n' +\n                    'temp.render(document.body)',\n                'typescript'\n            )}\n            <p>\n                You can always check if the place the template was rendered is\n                in the DOM by checking the <code>isConnected</code> on the\n                <code>renderTarget</code>.\n            </p>\n            ${CodeSnippet('temp.renderTarget.isConnected;', 'typescript')}\n            ${Heading('onUnmount', 'h3')}\n            <p>\n                The <code>onUnmount</code> lifecycle allows you to react to when\n                the template is removed from the element it was rendered. This\n                is triggered whenever the <code>unmount</code> method\n                successfully unmounts the template.\n            </p>\n            ${CodeSnippet(\n                'const temp = html`\\n' +\n                    '  <p>sample</p>\\n' +\n                    '`;\\n' +\n                    '\\n' +\n                    'temp.onUnmount(() => {\\n' +\n                    '  // handle unmount\\n' +\n                    '})\\n' +\n                    '\\n' +\n                    'temp.render(document.body)',\n                'typescript'\n            )}\n            <p>\n                You can call the <code>unmount</code> method directly in the\n                code but Markup also tracks templates behind the scenes\n                individually.\n            </p>\n            <p>\n                Whenever templates are no longer needed, the\n                <code>unmount</code> method is called to remove them. Thus, all\n                the cleanup for the template is performed.\n            </p>\n            ${Heading('onUpdate', 'h3')}\n            <p>\n                The <code>onUpdate</code> lifecycle allows you to react to when\n                an update is requested for the template. This can be by calling\n                the <code>update</code> method or automatically is you are using\n                <a href=\"./state-values\">state</a>.\n            </p>\n            ${CodeSnippet(\n                'const [count, setCount] = state(0);\\n\\n' +\n                    'const temp = html`\\n' +\n                    '  <p>${count}</p>\\n' +\n                    '`;\\n' +\n                    '\\n' +\n                    'temp.onUpdate(() => {\\n' +\n                    '  // handle update\\n' +\n                    '})\\n' +\n                    '\\n' +\n                    'temp.render(document.body)',\n                'typescript'\n            )}\n            ${Heading('Chainable methods', 'h3')}\n            <p>\n                Markup allows you to chain the following methods:\n                <code>render</code>, <code>replace</code>, <code>onMount</code>,\n                <code>onUnmount</code>, and <code>onUpdate</code>.\n            </p>\n            ${CodeSnippet(\n                'html`<p>sample</p>`\\n' +\n                    ' .onMount(() => {\\n' +\n                    '   // handle mount\\n' +\n                    ' })\\n' +\n                    ' .onUnmount(() => {\\n' +\n                    '   // handle unmount\\n' +\n                    ' })\\n' +\n                    ' .onUpdate(() => {\\n' +\n                    '   // handle update\\n' +\n                    ' })\\n' +\n                    ' .render(document.body)',\n                'typescript'\n            )}\n            <p>\n                This makes it easy to handle things in a function where you need\n                to return the template.\n            </p>\n            ${CodeSnippet(\n                'const Button = ({content, type, disabled}) => {\\n' +\n                    '  \\n' +\n                    '  return html`\\n' +\n                    '    <button\\n' +\n                    '      type=\"${type}\"\\n' +\n                    '      disabled=\"${disabled}\"\\n' +\n                    '    >\\n' +\n                    '      ${content}\\n' +\n                    '    </button>\\n' +\n                    '  `\\n' +\n                    '     .onUpdate(() => {\\n' +\n                    '       // handle update\\n' +\n                    '     })\\n' +\n                    '}',\n                'typescript'\n            )}",
        "'onMount'",
        "'h3'",
        "'const temp = html`\\n'",
        "'  <p>sample</p>\\n'",
        "'`;\\n'",
        "'\\n'",
        "'temp.onMount(() => {\\n'",
        "'  // handle mount\\n'",
        "'})\\n'",
        "'\\n'",
        "'temp.render(document.body)'",
        "'typescript'",
        "'temp.renderTarget.isConnected;'",
        "'typescript'",
        "'onUnmount'",
        "'h3'",
        "'const temp = html`\\n'",
        "'  <p>sample</p>\\n'",
        "'`;\\n'",
        "'\\n'",
        "'temp.onUnmount(() => {\\n'",
        "'  // handle unmount\\n'",
        "'})\\n'",
        "'\\n'",
        "'temp.render(document.body)'",
        "'typescript'",
        "'onUpdate'",
        "'h3'",
        "'const [count, setCount] = state(0);\\n\\n'",
        "'const temp = html`\\n'",
        "'  <p>${count}</p>\\n'",
        "'`;\\n'",
        "'\\n'",
        "'temp.onUpdate(() => {\\n'",
        "'  // handle update\\n'",
        "'})\\n'",
        "'\\n'",
        "'temp.render(document.body)'",
        "'typescript'",
        "'Chainable methods'",
        "'h3'",
        "'html`<p>sample</p>`\\n'",
        "' .onMount(() => {\\n'",
        "'   // handle mount\\n'",
        "' })\\n'",
        "' .onUnmount(() => {\\n'",
        "'   // handle unmount\\n'",
        "' })\\n'",
        "' .onUpdate(() => {\\n'",
        "'   // handle update\\n'",
        "' })\\n'",
        "' .render(document.body)'",
        "'typescript'",
        "'const Button = ({content, type, disabled}) => {\\n'",
        "'  \\n'",
        "'  return html`\\n'",
        "'    <button\\n'",
        "'      type=\"${type}\"\\n'",
        "'      disabled=\"${disabled}\"\\n'",
        "'    >\\n'",
        "'      ${content}\\n'",
        "'    </button>\\n'",
        "'  `\\n'",
        "'     .onUpdate(() => {\\n'",
        "'       // handle update\\n'",
        "'     })\\n'",
        "'}'",
        "'typescript'"
    ],
    "variables": [],
    "comments": [],
    "docstrings": [],
    "functions": [],
    "classes": []
}