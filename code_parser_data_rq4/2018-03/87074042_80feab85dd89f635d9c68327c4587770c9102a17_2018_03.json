{
    "identifiers": [
        "numpy",
        "np",
        "sklearn",
        "clone",
        "sklearn",
        "cluster",
        "MiniBatchKMeans",
        "AgglomerativeClustering",
        "sklearn",
        "feature_extraction",
        "image",
        "sklearn",
        "externals",
        "joblib",
        "Memory",
        "delayed",
        "Parallel",
        "decomposition",
        "BaseDecomposition",
        "mask_and_reduce",
        "input_data",
        "NiftiMasker",
        "MultiNiftiMasker",
        "NiftiLabelsMasker",
        "_utils",
        "compat",
        "_basestring",
        "data",
        "estimator",
        "clone",
        "estimator",
        "estimator",
        "fit",
        "data",
        "T",
        "estimator",
        "labels_",
        "imgs",
        "confounds",
        "isinstance",
        "imgs",
        "isinstance",
        "imgs",
        "_basestring",
        "imgs",
        "confounds",
        "isinstance",
        "imgs",
        "len",
        "imgs",
        "confounds",
        "isinstance",
        "confounds",
        "isinstance",
        "confounds",
        "_basestring",
        "confounds",
        "len",
        "confounds",
        "len",
        "imgs",
        "ValueError",
        "imgs",
        "confounds",
        "img",
        "masker",
        "confound",
        "masker",
        "fit_transform",
        "img",
        "confounds",
        "confound",
        "signals",
        "BaseDecomposition",
        "method",
        "n_parcels",
        "random_state",
        "mask",
        "smoothing_fwhm",
        "standardize",
        "detrend",
        "low_pass",
        "high_pass",
        "t_r",
        "target_affine",
        "target_shape",
        "memory",
        "Memory",
        "cachedir",
        "memory_level",
        "n_jobs",
        "verbose",
        "method",
        "n_parcels",
        "BaseDecomposition",
        "n_components",
        "random_state",
        "random_state",
        "mask",
        "mask",
        "memory",
        "memory",
        "smoothing_fwhm",
        "smoothing_fwhm",
        "standardize",
        "standardize",
        "detrend",
        "detrend",
        "low_pass",
        "low_pass",
        "high_pass",
        "high_pass",
        "t_r",
        "t_r",
        "target_affine",
        "target_affine",
        "target_shape",
        "target_shape",
        "mask_strategy",
        "mask_args",
        "memory_level",
        "memory_level",
        "n_jobs",
        "n_jobs",
        "verbose",
        "verbose",
        "imgs",
        "y",
        "confounds",
        "VALID_METHODS",
        "method",
        "ValueError",
        "format",
        "valid_methods",
        "method",
        "method",
        "valid_methods",
        "ValueError",
        "format",
        "method",
        "valid_methods",
        "BaseDecomposition",
        "fit",
        "imgs",
        "mask_and_reduce",
        "masker_",
        "imgs",
        "confounds",
        "reduction_ratio",
        "n_components",
        "n_components",
        "random_state",
        "random_state",
        "memory_level",
        "memory_level",
        "n_jobs",
        "n_jobs",
        "memory",
        "memory",
        "verbose",
        "_fit_method",
        "data",
        "data",
        "masker_",
        "mask_img_",
        "method",
        "verbose",
        "format",
        "method",
        "MiniBatchKMeans",
        "n_clusters",
        "n_parcels",
        "init",
        "random_state",
        "random_state",
        "verbose",
        "verbose",
        "_cache",
        "_estimator_fit",
        "func_memory_level",
        "data",
        "kmeans",
        "labels",
        "verbose",
        "format",
        "method",
        "mask_img_",
        "get_data",
        "astype",
        "np",
        "mask_",
        "shape",
        "image",
        "grid_to_graph",
        "n_x",
        "shape",
        "n_y",
        "shape",
        "n_z",
        "shape",
        "mask",
        "mask_",
        "AgglomerativeClustering",
        "n_clusters",
        "n_parcels",
        "connectivity",
        "connectivity",
        "linkage",
        "method",
        "memory",
        "memory",
        "_cache",
        "_estimator_fit",
        "func_memory_level",
        "data",
        "agglomerative",
        "connectivity",
        "labels",
        "hasattr",
        "ValueError",
        "imgs",
        "confounds",
        "_check_fitted",
        "_check_parameters_transform",
        "imgs",
        "confounds",
        "labels_",
        "masker_",
        "inverse_transform",
        "labels",
        "NiftiLabelsMasker",
        "labels_img_",
        "mask_img",
        "masker_",
        "mask_img_",
        "smoothing_fwhm",
        "smoothing_fwhm",
        "standardize",
        "standardize",
        "detrend",
        "detrend",
        "low_pass",
        "low_pass",
        "high_pass",
        "high_pass",
        "t_r",
        "t_r",
        "resampling_target",
        "memory",
        "memory",
        "memory_level",
        "memory_level",
        "verbose",
        "verbose",
        "Parallel",
        "n_jobs",
        "n_jobs",
        "delayed",
        "_cache",
        "_labels_masker_extraction",
        "func_memory_level",
        "img",
        "masker",
        "confound",
        "img",
        "confound",
        "imgs",
        "confounds",
        "region_signals",
        "imgs",
        "confounds",
        "fit",
        "imgs",
        "confounds",
        "confounds",
        "transform",
        "imgs",
        "confounds",
        "confounds"
    ],
    "literals": [
        "\"Number of confounds given does not match with \"",
        "\"the given number of images.\"",
        "'kmeans'",
        "'ward'",
        "'complete'",
        "'average'",
        "'epi'",
        "\"Parcellation method is specified as None. \"",
        "\"Please select one of the method in \"",
        "\"{0}\"",
        "\"The method you have selected is not implemented \"",
        "\"'{0}'. Valid methods are in {1}\"",
        "'auto'",
        "\"[Parcellations] Learning the data\"",
        "'kmeans'",
        "\"[{0} method] Learning\"",
        "'k-means++'",
        "\"[{0} method] Learning\"",
        "'labels_'",
        "\"Object has no labels_ attribute. \"",
        "\"Ensure that fit() is called before transform.\"",
        "'data'"
    ],
    "variables": [
        "estimator",
        "imgs",
        "confounds",
        "confounds",
        "signals",
        "VALID_METHODS",
        "method",
        "n_parcels",
        "valid_methods",
        "data",
        "mask_img_",
        "kmeans",
        "labels",
        "labels_",
        "mask_",
        "shape",
        "connectivity",
        "agglomerative",
        "labels",
        "connectivity_",
        "labels_",
        "imgs",
        "confounds",
        "labels",
        "labels_img_",
        "masker",
        "region_signals"
    ],
    "comments": [
        "Avoid 0 label"
    ],
    "docstrings": [
        "\"\"\"Parcellation tools such as KMeans or Ward for fMRI images\n\"\"\"",
        "\"\"\" Estimator to fit on the reduced data\n\n    Parameters\n    ----------\n    data : numpy arrays\n        list of reduced numpy arrays\n\n    estimator : instance of estimator from sklearn\n        MiniBatchKMeans or AgglomerativeClustering\n\n    Returns\n    -------\n    labels_ : numpy.ndarray\n        labels_ estimated from estimator\n    \"\"\"",
        "\"\"\"A helper function to check the parameters and prepare for processing\n    as a list.\n    \"\"\"",
        "\"\"\" Helper function for parallelizing NiftiLabelsMasker extractor\n    on list of Nifti images.\n\n    Parameters\n    ----------\n    img : 4D Nifti image like object\n        Image to process.\n\n    masker : instance of NiftiLabelsMasker\n        Used for extracting signals with fit_transform\n\n    confound : csv file or numpy array\n        Confound used for signal cleaning while extraction.\n        Passed to signal.clean\n\n    Returns\n    -------\n    signals : numpy array\n        Signals extracted on given img\n    \"\"\"",
        "\"\"\"Learn parcellations on fMRI images.\n\n    Four different types of clustering methods can be used such as kmeans,\n    ward, complete, average. First type kmeans will be used in MiniBatchKMeans\n    and next three types are used in Agglomerative Clustering leveraged from\n    scikit-learn.\n\n    Parameters\n    ----------\n    method : str, {'kmeans', 'ward', 'complete', 'average'}\n        A method to choose between for brain parcellations.\n\n    n_parcels : int, default=50\n        Number of parcellations to divide the brain data into.\n\n    random_state : int or RandomState\n        Pseudo number generator state used for random sampling.\n\n    mask : Niimg-like object or NiftiMasker, MultiNiftiMasker instance\n        Mask/Masker used for masking the data.\n        If mask image if provided, it will be used in the MultiNiftiMasker.\n        If an instance of MultiNiftiMasker is provided, then this instance\n        parameters will be used in masking the data by overriding the default\n        masker parameters.\n        If None, mask will be automatically computed by a MultiNiftiMasker\n        with default parameters.\n\n    smoothing_fwhm : float, optional default=4.\n        If smoothing_fwhm is not None, it gives the full-width half maximum in\n        millimeters of the spatial smoothing to apply to the signal.\n\n    standardize : boolean, optional\n        If standardize is True, the time-series are centered and normed:\n        their mean is put to 0 and their variance to 1 in the time dimension.\n\n    detrend : boolean, optional\n        Whether to detrend signals or not.\n        This parameter is passed to signal.clean. Please see the related\n        documentation for details\n\n    low_pass: None or float, optional\n        This parameter is passed to signal.clean. Please see the related\n        documentation for details\n\n    high_pass: None or float, optional\n        This parameter is passed to signal.clean. Please see the related\n        documentation for details\n\n    t_r : float, optional\n        This parameter is passed to signal.clean. Please see the related\n        documentation for details\n\n    target_affine : 3x3 or 4x4 matrix, optional\n        This parameter is passed to image.resample_img. Please see the\n        related documentation for details. The given affine will be\n        considered as same for all given list of images.\n\n    target_shape : 3-tuple of integers, optional\n        This parameter is passed to image.resample_img. Please see the\n        related documentation for details.\n\n    memory : instance of joblib.Memory or str\n        Used to cache the masking process.\n        By default, no caching is done. If a string is given, it is the\n        path to the caching directory.\n\n    memory_level : integer, optional\n        Rough estimator of the amount of memory used by caching. Higher value\n        means more memory for caching.\n\n    n_jobs : integer, optional\n        The number of CPUs to use to do the computation. -1 means\n        'all CPUs', -2 'all CPUs but one', and so on.\n\n    verbose : integer, optional\n        Indicate the level of verbosity. By default, nothing is printed.\n\n    Returns\n    -------\n    labels_ : numpy.ndarray\n        Labels to each parcellation learned on fmri images.\n\n    masker_ : instance of NiftiMasker or MultiNiftiMasker\n        Useful in recontructing back labels_ to Nifti image.\n        Example using masker_.inverse_transform on labels_.\n\n    connectivity_ : numpy.ndarray\n        voxel-to-voxel connectivity matrix computed from a mask.\n        Note that this attribute is only seen if selected methods are\n        Agglomerative Clustering type, 'ward', 'complete', 'average'.\n\n    \"\"\"",
        "\"\"\" Computes the mask and reduces the dimensionality of images\n        using randomized_svd. Then, fit the parcellation method on this\n        reduced data.\n\n        Parameters\n        ----------\n        imgs : List of Niimg-like objects\n            See http://nilearn.github.io/manipulating_images/input_output.html.\n            Data from which parcellations will be returned.\n\n        confounds : CSV file path or 2D matrix\n            Confounds to clean them from signals.\n            This parameter is passed to nilearn.signal.clean. Please see the\n            related documentation for details\n\n        Returns\n        -------\n        labels_ : numpy.ndarray\n            Labels to each cluster in the brain.\n\n        connectivity_ : numpy.ndarray\n            voxel-to-voxel connectivity matrix computed from a mask.\n            Note that, this attribute is returned only for selected methods\n            such as 'ward', 'complete', 'average'.\n        \"\"\"",
        "\"\"\"Helper function which applies clustering methods on the\n        masked data.\n\n        See the documentation of fit() for full details on returned\n        attributes.\n        \"\"\"",
        "\"\"\"Helper function to check whether fit is called or not.\n        \"\"\"",
        "\"\"\"Extract signals from parcellations learned on fmri images.\n\n        Parameters\n        ----------\n        imgs : List of Nifti-like images\n            See http://nilearn.github.io/manipulating_images/input_output.html.\n            Images to process.\n\n        confounds: List of CSV files or arrays-like, optional\n            Each file or numpy array in a list should have shape\n            (number of scans, number of confounds)\n            This parameter is passed to signal.clean. Please see the related\n            documentation for details. Must be of same length of imgs.\n\n        Returns\n        -------\n        region_signals: List of 2D numpy.ndarray\n            Signals extracted for each label for each image.\n            Example, for single image shape will be\n            (number of scans, number of labels)\n        \"\"\"",
        "\"\"\"Fit the images to parcellations and then transform them.\n\n        Parameters\n        ----------\n        imgs : List of Nifti-like images\n            See http://nilearn.github.io/manipulating_images/input_output.html.\n            Images for process for fit as well for transform to signals.\n\n        confounds : List of CSV files or arrays-like, optional\n            Each file or numpy array in a list should have shape\n            (number of scans, number of confounds).\n            This parameter is passed to signal.clean. Given confounds\n            should have same length as images if given as a list.\n\n            Note: same confounds will used for cleaning signals before\n            learning parcellations.\n\n        Returns\n        -------\n        region_signals: List of 2D numpy.ndarray\n            Signals extracted for each label for each image.\n            Example, for single image shape will be\n            (number of scans, number of labels)\n        \"\"\""
    ],
    "functions": [
        "_estimator_fit",
        "_check_parameters_transform",
        "_labels_masker_extraction",
        "fit",
        "_fit_method",
        "_check_fitted",
        "transform",
        "fit_transform"
    ],
    "classes": [
        "Parcellations"
    ]
}