{
    "identifiers": [
        "okio",
        "samples",
        "java",
        "io",
        "okio",
        "Buffer",
        "okio",
        "BufferedSource",
        "okio",
        "ForwardingSource",
        "okio",
        "Okio",
        "okio",
        "Source",
        "offset",
        "mark",
        "limit",
        "closed",
        "markSource",
        "userSource",
        "markBuffer",
        "userBuffer",
        "source",
        "markSource",
        "source",
        "markBuffer",
        "userSource",
        "Okio",
        "buffer",
        "markSource",
        "userBuffer",
        "userSource",
        "buffer",
        "userSource",
        "readLimit",
        "readLimit",
        "readLimit",
        "closed",
        "userOffset",
        "offset",
        "userBuffer",
        "size",
        "mark",
        "markBuffer",
        "writeAll",
        "userBuffer",
        "mark",
        "userOffset",
        "offset",
        "userOffset",
        "newMarkBufferLimit",
        "userOffset",
        "readLimit",
        "newMarkBufferLimit",
        "newMarkBufferLimit",
        "MAX_VALUE",
        "limit",
        "max",
        "limit",
        "newMarkBufferLimit",
        "userOffset",
        "userOffset",
        "closed",
        "userOffset",
        "mark",
        "userOffset",
        "limit",
        "userOffset",
        "mark",
        "markBuffer",
        "size",
        "offset",
        "userBuffer",
        "size",
        "limit",
        "userOffset",
        "offset",
        "userOffset",
        "userBuffer",
        "clear",
        "source",
        "source",
        "Override",
        "sink",
        "byteCount",
        "closed",
        "mark",
        "result",
        "read",
        "sink",
        "byteCount",
        "result",
        "offset",
        "result",
        "result",
        "offset",
        "mark",
        "markBuffer",
        "size",
        "posInBuffer",
        "offset",
        "mark",
        "result",
        "min",
        "byteCount",
        "markBuffer",
        "size",
        "posInBuffer",
        "markBuffer",
        "copyTo",
        "sink",
        "posInBuffer",
        "result",
        "offset",
        "result",
        "result",
        "offset",
        "limit",
        "byteCountBeforeLimit",
        "limit",
        "mark",
        "markBuffer",
        "size",
        "result",
        "read",
        "markBuffer",
        "min",
        "byteCount",
        "byteCountBeforeLimit",
        "result",
        "markBuffer",
        "copyTo",
        "sink",
        "markBuffer",
        "size",
        "result",
        "result",
        "offset",
        "result",
        "result",
        "result",
        "read",
        "sink",
        "byteCount",
        "result",
        "markBuffer",
        "clear",
        "mark",
        "limit",
        "result",
        "Override",
        "closed",
        "closed",
        "markBuffer",
        "clear",
        "close"
    ],
    "literals": [
        "\"readLimit < 0: \"",
        "\"closed\"",
        "\"closed\"",
        "\"cannot reset to \"",
        "\": out of range\"",
        "\"closed\""
    ],
    "variables": [
        "offset",
        "closed",
        "markSource",
        "userSource",
        "markBuffer",
        "userBuffer"
    ],
    "comments": [
        "Mark the current position in the buffered source.",
        "If this is a new mark promote userBuffer data into the markBuffer.",
        "Grow the limit if necessary.",
        "Long overflow!",
        "userOffset is before mark.",
        "userOffset is beyond limit.",
        "userOffset is in the future.",
        "Stream advanced beyond limit.",
        "Clear userBuffer to cause data at 'offset' to be returned by the next read.",
        "If there's no mark, go to the underlying source.",
        "If we can read from markBuffer, do that.",
        "If we can write to markBuffer, do that.",
        "Attempt to read past the limit. Data will not be saved.",
        "We read past the limit. Discard marked data."
    ],
    "docstrings": [
        "* Copyright (C) 2018 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.",
        "* Builds a buffered source that can rewind to a marked position earlier in the stream.\n *\n * <p>Mark potential positions to rewind back to with {@link #mark}; rewind back to these positions\n * with {@link #reset}. Both operations apply to the position in the {@linkplain #source() buffered\n * source}; resetting will impact the buffer.\n *\n * <p>When marking it is necessary to specify how much data to retain. Once you advance above this\n * limit, the mark is discarded and resetting is not permitted. This may be used to lookahead a\n * fixed number of bytes without loading an entire stream into memory. To reset an arbitrary\n * number of bytes use {@code mark(Long#MAX_VALUE)}.",
        "* This class wraps the underlying source in a MarkSource to support mark and reset. It creates a\n   * BufferedSource for the caller so that it can track its offsets and manipulate its buffer.",
        "* The offset into the underlying source. To compute the user's offset start with this and\n   * subtract userBuffer.size().",
        "The offset of the earliest mark, or -1 for no mark.",
        "The offset of the latest readLimit, or -1 for no mark.",
        "A copy of the underlying source's data beginning at {@code mark}.",
        "Just the userSource's buffer.",
        "* Marks the current position in the stream as one to potentially return back to. Returns the\n   * offset of this position. Call {@link #reset(long)} with this position to return to it later. It\n   * is an error to call {@link #reset(long)} after consuming more than {@code readLimit} bytes from\n   * {@linkplain #source() the source}.",
        "Resets {@linkplain #source() the source} to {@code userOffset}."
    ],
    "functions": [
        "SourceMarker",
        "BufferedSource",
        "source",
        "mark",
        "reset",
        "MarkSource",
        "read",
        "close"
    ],
    "classes": [
        "SourceMarker",
        "MarkSource"
    ]
}