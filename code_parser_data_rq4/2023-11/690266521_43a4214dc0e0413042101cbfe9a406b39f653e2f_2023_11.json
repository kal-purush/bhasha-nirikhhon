{
    "identifiers": [
        "typing",
        "Callable",
        "Union",
        "numpy",
        "np",
        "pandas",
        "pd",
        "scipy",
        "stats",
        "statsmodels",
        "stats",
        "power",
        "TTestIndPower",
        "alpha",
        "beta",
        "means_diff",
        "std",
        "two_tail",
        "two_tail",
        "stats",
        "norm",
        "ppf",
        "alpha",
        "loc",
        "scale",
        "stats",
        "norm",
        "ppf",
        "beta",
        "loc",
        "scale",
        "inv_alpha",
        "inv_beta",
        "means_diff",
        "std",
        "stats",
        "norm",
        "ppf",
        "alpha",
        "loc",
        "scale",
        "stats",
        "norm",
        "ppf",
        "beta",
        "loc",
        "scale",
        "inv_alpha",
        "inv_beta",
        "means_diff",
        "std",
        "alpha",
        "beta",
        "means_diff",
        "std",
        "means_diff",
        "std",
        "TTestIndPower",
        "analysis",
        "solve_power",
        "effect",
        "power",
        "beta",
        "nobs1",
        "ratio",
        "alpha",
        "alpha",
        "result",
        "pos_a",
        "total_a",
        "pos_b",
        "total_b",
        "pos_a",
        "pos_b",
        "pos_a",
        "total_b",
        "pos_b",
        "total_a",
        "stats",
        "hypergeom",
        "cdf",
        "pos_b",
        "total_a",
        "total_b",
        "pos_a",
        "pos_b",
        "total_b",
        "stats",
        "hypergeom",
        "cdf",
        "pos_b",
        "total_a",
        "total_b",
        "pos_a",
        "pos_b",
        "total_b",
        "res",
        "group_a",
        "group_b",
        "func",
        "Callable",
        "np",
        "mean",
        "num_permutations",
        "np",
        "concatenate",
        "group_a",
        "group_b",
        "func",
        "group_b",
        "func",
        "group_a",
        "_",
        "num_permutations",
        "np",
        "random",
        "shuffle",
        "concatenated",
        "concatenated",
        "len",
        "group_a",
        "concatenated",
        "len",
        "group_a",
        "func",
        "perm_group_2",
        "func",
        "perm_group_1",
        "permuted_stats",
        "append",
        "permuted_stat",
        "np",
        "sum",
        "np",
        "array",
        "permuted_stats",
        "observed_stat",
        "num_permutations",
        "p_value",
        "group_a",
        "np",
        "ndarray",
        "group_b",
        "np",
        "ndarray",
        "func",
        "Callable",
        "np",
        "mean",
        "num_samples",
        "_",
        "num_samples",
        "np",
        "random",
        "choice",
        "group_a",
        "len",
        "group_a",
        "replace",
        "np",
        "random",
        "choice",
        "group_b",
        "len",
        "group_b",
        "replace",
        "func",
        "sample_b",
        "func",
        "sample_a",
        "bootstrap_differences",
        "append",
        "difference",
        "np",
        "sum",
        "np",
        "array",
        "bootstrap_differences",
        "len",
        "bootstrap_differences",
        "p_value",
        "bootstrap_differences",
        "group_a",
        "np",
        "ndarray",
        "group_b",
        "np",
        "ndarray",
        "func",
        "Callable",
        "np",
        "mean",
        "num_samples",
        "np",
        "concatenate",
        "group_a",
        "group_b",
        "axis",
        "func",
        "group_b",
        "func",
        "group_a",
        "_",
        "num_samples",
        "np",
        "random",
        "choice",
        "concatenated_group",
        "size",
        "len",
        "concatenated_group",
        "replace",
        "boot_sample",
        "len",
        "group_a",
        "boot_sample",
        "len",
        "group_a",
        "func",
        "boot_sample_a",
        "func",
        "boot_sample_b",
        "bootstrap_stats",
        "append",
        "boot_stat",
        "np",
        "sum",
        "np",
        "array",
        "bootstrap_stats",
        "observed_stat",
        "len",
        "bootstrap_stats",
        "p_value",
        "bootstrap_stats",
        "test",
        "Callable",
        "alpha",
        "beta",
        "effect",
        "mean_a",
        "std_a",
        "std_b",
        "sample_size",
        "num_experiments",
        "std_b",
        "std_a",
        "_",
        "num_experiments",
        "np",
        "random",
        "normal",
        "size",
        "sample_size",
        "scale",
        "loc",
        "np",
        "random",
        "normal",
        "size",
        "sample_size",
        "scale",
        "loc",
        "test",
        "control_group",
        "treatment_group",
        "p_value",
        "alpha",
        "change_detected"
    ],
    "literals": [],
    "variables": [
        "inv_alpha",
        "inv_beta",
        "inv_alpha",
        "inv_beta",
        "effect",
        "analysis",
        "result",
        "res",
        "res",
        "res",
        "concatenated",
        "observed_stat",
        "permuted_stats",
        "perm_group_1",
        "perm_group_2",
        "permuted_stat",
        "p_value",
        "bootstrap_differences",
        "sample_a",
        "sample_b",
        "difference",
        "p_value",
        "concatenated_group",
        "observed_stat",
        "bootstrap_stats",
        "boot_sample",
        "boot_sample_a",
        "boot_sample_b",
        "boot_stat",
        "p_value",
        "std_b",
        "change_detected",
        "control_group",
        "treatment_group",
        "p_value"
    ],
    "comments": [
        "def bootstrap_ci(",
        "group_a: np.ndarray, group_b: np.ndarray, func: Callable = np.mean, num_samples: int = 1000",
        "):",
        "n = 1000",
        "B = 10000",
        "alpha = 0.05",
        "pe = np.quantile(values_b, 0.9) - np.quantile(values_a, 0.9)",
        "bootstrap_values_a = np.random.choice(values_a, (B, len(group_a)), True)",
        "bootstrap_metrics_a = np.quantile(bootstrap_values_a, 0.9, axis=1)",
        "bootstrap_values_b = np.random.choice(values_b, (B, len(group_a)), True)",
        "bootstrap_metrics_b = np.quantile(bootstrap_values_b, 0.9, axis=1)",
        "bootstrap_stats = bootstrap_metrics_b - bootstrap_metrics_a",
        "ci = np.quantile(bootstrap_stats, [alpha / 2, 1 - alpha / 2])",
        "return ci",
        "def find_percentiles(df: pd.DataFrame, percentile: float):",
        "percentiles = df.apply(lambda col: np.percentile(col, percentile))",
        "if (\"conv\" in df.columns) and (\"revenue\" in df.columns):",
        "percentiles[\"revenue_nonzeros\"] = np.percentile(df[df[\"conv\"] != 0][\"revenue\"], percentile)",
        "return percentiles",
        "def permutation_test(old: pd.DataFrame, new: pd.DataFrame, num_permutations=500):",
        "df = pd.DataFrame(columns=[\"statistic\", \"p_value\"], index=old.columns)",
        "for col in old.columns:",
        "test = stats.permutation_test(",
        "(np.array(old[col], dtype=float), np.array(new[col], dtype=float)),",
        "statistic=lambda x, y: x.mean() - y.mean(),",
        "n_resamples=num_permutations,",
        ")",
        "df.loc[col] = test.statistic, test.pvalue",
        "print(f\"{col} done\")",
        "if (\"conv\" in old.columns) and (\"revenue\" in old.columns):",
        "test = stats.permutation_test(",
        "(",
        "np.array(old[old[\"conv\"] != 0][\"revenue\"], dtype=float),",
        "np.array(new[new[\"conv\"] != 0][\"revenue\"], dtype=float),",
        "),",
        "statistic=lambda x, y: x.mean() - y.mean(),",
        "n_resamples=num_permutations,",
        ")",
        "df.loc[\"revenue_nonzeros\"] = test.statistic, test.pvalue",
        "print(f\"revenue_nonzeros done\")",
        "return df",
        "def t_test(old: pd.Series, new: pd.Series):",
        "df = pd.DataFrame(columns=[\"statistic\", \"p_value\"], index=old.columns)",
        "for col in old.columns:",
        "df.loc[col] = stats.ttest_ind(",
        "np.array(old[col], dtype=float), np.array(new[col], dtype=float)",
        ")",
        "if (\"conv\" in old.columns) and (\"revenue\" in old.columns):",
        "df.loc[\"revenue_nonzeros\"] = stats.ttest_ind(",
        "np.array(old[old[\"conv\"] != 0][\"revenue\"], dtype=float),",
        "np.array(new[new[\"conv\"] != 0][\"revenue\"], dtype=float),",
        ")",
        "return df",
        "def reduce_uids(df: pd.DataFrame):",
        "return df.groupby(\"uid\").agg(max)",
        "if __name__ == \"__main__\":",
        "import utils",
        "import pandas as pd",
        "import numpy as np",
        "import seaborn as sns",
        "df = utils.generate_df(ids_num=int(1e5))",
        "old = df[df.group == 0].drop(columns=[\"uid\", \"group\"])",
        "new = df[df.group == 1].drop(columns=[\"uid\", \"group\"])",
        "print(permutation_test(old, new))"
    ],
    "docstrings": [
        "\"\"\"\n    only for normal distributed values\n    alpha -- type I error\n    beta -- type II error\n    returns lower bound of size for each group\n    https://rugg2.github.io/AB%20testing%20-%20a%20simple%20explanation%20of%20what%20power%20analysis%20does.html\n    \"\"\"",
        "\"\"\"\n    only for normal distributed values\n    alpha -- type I error\n    beta -- type II error\n    \"\"\""
    ],
    "functions": [
        "lower_bound",
        "lower_bound_statsmodels",
        "permutation_shares",
        "permutation",
        "bootstrap",
        "bootstrap_concat",
        "simulation_normal",
        "simulation_bernoulli"
    ],
    "classes": []
}