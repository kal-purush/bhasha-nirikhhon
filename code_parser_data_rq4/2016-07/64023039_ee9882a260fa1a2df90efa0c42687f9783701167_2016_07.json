{
    "identifiers": [
        "com",
        "tomirio",
        "schakert",
        "agent",
        "com",
        "tomirio",
        "schakert",
        "chessboard",
        "ChessBoard",
        "com",
        "tomirio",
        "schakert",
        "chessboard",
        "ChessColour",
        "com",
        "tomirio",
        "schakert",
        "chessboard",
        "ChessPiece",
        "com",
        "tomirio",
        "schakert",
        "game",
        "Player",
        "com",
        "tomirio",
        "schakert",
        "moves",
        "Move",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "concurrent",
        "Callable",
        "skippedNodes",
        "eval",
        "searchDepth",
        "visitedNodes",
        "playerColour",
        "chessBoard",
        "playerColour",
        "chessBoard",
        "visitedNodes",
        "searchDepth",
        "eval",
        "Override",
        "getPlay",
        "parentNode",
        "hasTurn",
        "childNodes",
        "pieces",
        "chessBoard",
        "getPieces",
        "hasTurn",
        "piece",
        "pieces",
        "succesivePieceMoves",
        "piece",
        "getPossibleMoves",
        "move",
        "succesivePieceMoves",
        "childNode",
        "parentNode",
        "move",
        "childNodes",
        "add",
        "childNode",
        "childNodes",
        "Override",
        "startTime",
        "nanoTime",
        "rootNode",
        "toPlay",
        "negaMax",
        "rootNode",
        "searchDepth",
        "NEGATIVE_INFINITY",
        "POSITIVE_INFINITY",
        "playerColour",
        "endTime",
        "nanoTime",
        "elapsedTime",
        "endTime",
        "startTime",
        "pow",
        "visitedNodes",
        "size",
        "skippedNodes",
        "elapsedTime",
        "skippedNodes",
        "elapsedTime",
        "visitedNodes",
        "clear",
        "skippedNodes",
        "move",
        "toPlay",
        "first",
        "getRootMove",
        "move",
        "Override",
        "move",
        "node",
        "depth",
        "alpha",
        "beta",
        "hasTurn",
        "depth",
        "chessBoard",
        "isStaleMate",
        "chessBoard",
        "isCheckMate",
        "ChessColour",
        "Black",
        "chessBoard",
        "isCheckMate",
        "ChessColour",
        "White",
        "node",
        "eval",
        "evaluate",
        "chessBoard",
        "playerColour",
        "hasTurn",
        "childNodes",
        "generateChildNodes",
        "node",
        "hasTurn",
        "bestValue",
        "NEGATIVE_INFINITY",
        "bestNode",
        "node",
        "child",
        "childNodes",
        "child",
        "move",
        "doMove",
        "result",
        "negaMax",
        "child",
        "depth",
        "beta",
        "alpha",
        "hasTurn",
        "getOpposite",
        "child",
        "move",
        "undoMove",
        "v",
        "result",
        "second",
        "v",
        "bestValue",
        "bestValue",
        "v",
        "bestNode",
        "result",
        "first",
        "alpha",
        "max",
        "alpha",
        "v",
        "alpha",
        "beta",
        "bestNode",
        "bestValue",
        "bestNode",
        "bestValue"
    ],
    "literals": [
        "\"Searched nodes:\"",
        "\"Skipped nodes:\"",
        "\"Elapsed time:\"",
        "\"Nodes per second:\"",
        "\"\\n\"",
        "\"Agents do not implement this method!\""
    ],
    "variables": [
        "eval",
        "searchDepth",
        "visitedNodes"
    ],
    "comments": [
        "Only necessary for human players.",
        "if (child.move.isCaptureMove()) {",
        "System.out.println(\"Het stuk dat werd gecaptured was:\" + child.move.getNewPos());",
        "System.out.println(\"De waarde van eval was \" + v + \" met de volgende kleur aan zet:\" + hasTurn);",
        "System.out.println(\"Het bord was als volgt:\\n\" + chessBoard);",
        "}"
    ],
    "docstrings": [
        "* Copyright (C) 2016 Tom Sandmann\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.",
        "*\n * @author Tom Sandmann",
        "* Skipped nodes",
        "* Evaluation class",
        "* The search depth",
        "* Visited nodes",
        "* The AI\n     *\n     * @param playerColour The colour the AI plays with.\n     * @param chessBoard The chess board.",
        "* Generate the next set moves for the given colour.\n     *\n     * @param node The root node.\n     * @param hasTurn The colour for which we want to generate the moves.\n     * @return ArrayList containing all the future chess boards.",
        "*\n     * @return The move",
        "* <head>Perform NegaMax search with alpha beta pruning</head>\n     *\n     * @see <a href=\"https://en.wikipedia.org/wiki/Negamax\">\n     * https://en.wikipedia.org/wiki/Negamax\n     * </a>\n     *\n     * <b>\"Negamax always searches for the maximum value for all its nodes\"</b>\n     * The prevailing search routine is <b>negamax</b>, and for good reason.\n     * It's clear, simple, and can be extended from something very basic all the\n     * way to parallel search. Once you get it working the next step is replace\n     * the evaluation call with <b>quiescence search</b> at the leaf nodes (to\n     * prevent terrible, terrible blunders because of an abrupt search horizon)\n     *\n     * <h1>Techniques to add:</h1>\n     * - Null Move Pruning - Check Extension - Late Move Reduction - NegaMax\n     * search - Quiescence search - Move Ordering\n     *\n     * <h1>Monitoring the application</h1>\n     * See VisualVM, which is a free and good java profiler.\n     * @see\n     * <a href=\"http://stackoverflow.com/questions/17379849/simple-minimax-evaluation-function-for-chess-position\">\n     * http://stackoverflow.com/questions/17379849/simple-minimax-evaluation-function-for-chess-position\n     * </a>\n     *\n     * <h1>Debugging move generation</h1>\n     * <b>Perft</b>, (performance test, move path enumeration) a debugging\n     * function to walk the move generation tree of strictly legal moves to\n     * count all the leaf nodes of a certain depth, which can be compared to\n     * predetermined values and used to isolate bugs.\n     *\n     * @param node The node we want to evaluate.\n     * @param depth The depth.\n     * @param alpha Alpha used in alpha-beta pruning.\n     * @param beta Beta used in alpha-beta pruning.\n     * @param hasTurn The colour of the player.\n     * @return The best value possible See\n     * http://stackoverflow.com/questions/25615312/negamax-chess-algorithm-how-to-use-final-return",
        "This is the time whether we know what the best play is for the \n            resulting board configuration. If we do know that, we use this value.\n            Lets make the hash of the current chessboard the key to get the transpoition entry.\n            If we do not know this, we search it."
    ],
    "functions": [
        "AI",
        "Move",
        "call",
        "generateChildNodes",
        "Move",
        "getPlay",
        "makeMove",
        "negaMax"
    ],
    "classes": [
        "AI"
    ]
}