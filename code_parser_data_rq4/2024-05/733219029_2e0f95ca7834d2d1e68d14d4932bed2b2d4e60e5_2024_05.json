{
    "identifiers": [
        "warnings",
        "random",
        "lxml",
        "html",
        "networkx",
        "nx",
        "numpy",
        "np",
        "heapq",
        "prairielearn",
        "pl",
        "pygraphviz",
        "collections",
        "deque",
        "element",
        "lxml",
        "html",
        "HtmlElement",
        "data",
        "pl",
        "QuestionData",
        "pl",
        "get_string_attrib",
        "element",
        "pl",
        "from_json",
        "data",
        "input_param_name",
        "nx",
        "nx_agraph",
        "to_agraph",
        "networkx_graph",
        "G",
        "element",
        "lxml",
        "html",
        "HtmlElement",
        "data",
        "pl",
        "QuestionData",
        "pl",
        "get_string_attrib",
        "element",
        "PARAMS_NAME_DEFAULT",
        "pl",
        "get_string_attrib",
        "element",
        "input_param_matrix",
        "input_param_name",
        "ValueError",
        "pl",
        "get_string_attrib",
        "element",
        "PARAMS_NAME_LABELS_DEFAULT",
        "pl",
        "get_boolean_attrib",
        "element",
        "NEGATIVE_WEIGHTS_DEFAULT",
        "np",
        "array",
        "pl",
        "from_json",
        "data",
        "input_param_name",
        "pl",
        "get_boolean_attrib",
        "element",
        "WEIGHTS_DEFAULT",
        "pl",
        "get_integer_attrib",
        "element",
        "WEIGHTS_DIGITS_DEFAULT",
        "pl",
        "get_string_attrib",
        "element",
        "WEIGHTS_PRESENTATION_TYPE_DEFAULT",
        "lower",
        "pl",
        "get_boolean_attrib",
        "element",
        "DIRECTED_DEFAULT",
        "input_label",
        "np",
        "array",
        "pl",
        "from_json",
        "data",
        "input_label",
        "mat",
        "shape",
        "mat",
        "shape",
        "ValueError",
        "input_param_name",
        "mat",
        "shape",
        "mat",
        "shape",
        "label",
        "label",
        "mat_label",
        "shape",
        "mat",
        "shape",
        "ValueError",
        "mat_label",
        "shape",
        "input_label",
        "mat",
        "shape",
        "input_param_name",
        "mat",
        "shape",
        "directed",
        "np",
        "allclose",
        "mat",
        "mat",
        "T",
        "ValueError",
        "input_param_name",
        "show_weights",
        "x",
        "x",
        "mat",
        "flatten",
        "pygraphviz",
        "AGraph",
        "directed",
        "directed",
        "G",
        "add_nodes_from",
        "mat_label",
        "in_node",
        "row",
        "mat_label",
        "mat",
        "out_node",
        "x",
        "mat_label",
        "row",
        "x",
        "negative_weights",
        "x",
        "show_weights",
        "G",
        "add_edge",
        "out_node",
        "in_node",
        "label",
        "pl",
        "string_from_2darray",
        "x",
        "presentation_type",
        "presentation_type",
        "digits",
        "digits",
        "G",
        "add_edge",
        "out_node",
        "in_node",
        "G",
        "min_nodes",
        "max_nodes",
        "min_edges",
        "max_edges",
        "directed",
        "weighted",
        "tree",
        "random",
        "randint",
        "min_nodes",
        "max_nodes",
        "min_edges",
        "n",
        "max_edges",
        "round",
        "n",
        "tree",
        "nx",
        "random_tree",
        "n",
        "create_using",
        "nx",
        "DiGraph",
        "directed",
        "nx",
        "Graph",
        "directed",
        "nx",
        "DiGraph",
        "u",
        "v",
        "u",
        "v",
        "G",
        "edges",
        "nx",
        "random_tree",
        "n",
        "create_using",
        "nx",
        "DiGraph",
        "directed",
        "nx",
        "Graph",
        "random",
        "randint",
        "min_edges",
        "max_edges",
        "directed",
        "n",
        "n",
        "G",
        "edges",
        "m",
        "len",
        "existing_edges",
        "u",
        "n",
        "v",
        "u",
        "n",
        "directed",
        "possible_edges",
        "add",
        "u",
        "v",
        "possible_edges",
        "add",
        "v",
        "u",
        "possible_edges",
        "add",
        "u",
        "v",
        "possible_edges",
        "existing_edges",
        "random",
        "sample",
        "available_edges",
        "remaining_edges",
        "u",
        "v",
        "additional_edges",
        "G",
        "add_edge",
        "u",
        "v",
        "weighted",
        "u",
        "v",
        "G",
        "edges",
        "G",
        "edges",
        "u",
        "v",
        "random",
        "randint",
        "ascii_letters",
        "n",
        "i",
        "ascii_labels",
        "i",
        "i",
        "n",
        "nx",
        "relabel_nodes",
        "G",
        "mapping",
        "G",
        "element_html",
        "data",
        "pl",
        "QuestionData",
        "pl",
        "load_all_extensions",
        "data",
        "extension",
        "extensions",
        "values",
        "hasattr",
        "extension",
        "optional_attribs",
        "extend",
        "extension",
        "optional_attribs",
        "lxml",
        "html",
        "fragment_fromstring",
        "element_html",
        "pl",
        "check_attribs",
        "element",
        "required_attribs",
        "optional_attribs",
        "optional_attribs",
        "element_html",
        "data",
        "pl",
        "QuestionData",
        "lxml",
        "html",
        "fragment_fromstring",
        "element_html",
        "pl",
        "get_string_attrib",
        "element",
        "ENGINE_DEFAULT",
        "pl",
        "get_boolean_attrib",
        "element",
        "LOG_WARNINGS_DEFAULT",
        "pl",
        "get_string_attrib",
        "element",
        "pl",
        "get_string_attrib",
        "element",
        "pl",
        "get_string_attrib",
        "element",
        "pl",
        "get_string_attrib",
        "element",
        "pl",
        "get_string_attrib",
        "element",
        "pl",
        "get_string_attrib",
        "element",
        "random_graph",
        "pl",
        "get_integer_attrib",
        "element",
        "pl",
        "get_integer_attrib",
        "element",
        "pl",
        "get_integer_attrib",
        "element",
        "pl",
        "get_integer_attrib",
        "element",
        "pl",
        "get_boolean_attrib",
        "element",
        "pl",
        "get_boolean_attrib",
        "element",
        "pl",
        "get_boolean_attrib",
        "element",
        "generate_graph",
        "min_nodes",
        "max_nodes",
        "min_edges",
        "max_edges",
        "directed_random",
        "weighted",
        "tree",
        "nx",
        "nx_agraph",
        "to_agraph",
        "networkx_graph",
        "weighted",
        "edge",
        "agraph",
        "edges",
        "edge",
        "edge",
        "attr",
        "networkx_graph",
        "u",
        "v",
        "agraph",
        "to_string",
        "graphviz_from_adj_matrix",
        "graphviz_from_networkx",
        "pl",
        "load_all_extensions",
        "data",
        "extension",
        "extensions",
        "values",
        "matrix_backends",
        "update",
        "extension",
        "backends",
        "pl",
        "get_string_attrib",
        "element",
        "PARAMS_NAME_DEFAULT",
        "pl",
        "get_string_attrib",
        "element",
        "input_param_matrix",
        "pl",
        "get_string_attrib",
        "element",
        "PARAMS_TYPE_DEFAULT",
        "len",
        "element",
        "text",
        "input_param_name",
        "ValueError",
        "input_param_name",
        "input_type",
        "matrix_backends",
        "matrix_backends",
        "input_type",
        "element",
        "data",
        "ValueError",
        "input_type",
        "element",
        "text",
        "pygraphviz",
        "AGraph",
        "graphviz_data",
        "translated_dotcode",
        "replace",
        "translated_dotcode_string",
        "warnings",
        "catch_warnings",
        "log_warnings",
        "warnings",
        "simplefilter",
        "translated_dotcode",
        "draw",
        "format",
        "prog",
        "engine",
        "decode",
        "graph_data",
        "node_fill_color",
        "edge_fill_color",
        "select_nodes",
        "select_edges",
        "svg",
        "javascript_function",
        "element_html",
        "data",
        "lxml",
        "html",
        "fragment_fromstring",
        "element_html",
        "pl",
        "get_string_attrib",
        "element",
        "pl",
        "get_string_attrib",
        "element",
        "pl",
        "get_string_attrib",
        "element",
        "select_nodes",
        "len",
        "data",
        "data",
        "data",
        "select_edges",
        "len",
        "data",
        "data",
        "data",
        "select_nodes",
        "eval",
        "data",
        "select_edges",
        "eval",
        "data",
        "data",
        "pygraphviz",
        "AGraph",
        "random_graph",
        "eval",
        "pl",
        "from_json",
        "element",
        "get",
        "pl",
        "from_json",
        "element",
        "get",
        "pl",
        "from_json",
        "element",
        "get",
        "grading",
        "dfs_agraph",
        "graph",
        "graph",
        "nodes",
        "grading",
        "bfs_agraph",
        "graph",
        "graph",
        "nodes",
        "grading",
        "dijkstra_agraph",
        "graph",
        "graph",
        "nodes",
        "select_nodes",
        "preserve_ordering",
        "i",
        "len",
        "user_selected_nodes",
        "user_selected_nodes",
        "i",
        "correct_answer",
        "score",
        "i",
        "len",
        "correct_answer",
        "i",
        "len",
        "user_selected_nodes",
        "correct_answer",
        "i",
        "user_selected_nodes",
        "i",
        "score",
        "partial_credit",
        "score",
        "len",
        "correct_answer",
        "score",
        "len",
        "correct_answer",
        "data",
        "score",
        "select_edges",
        "preserve_ordering",
        "i",
        "len",
        "user_selected_edges",
        "user_selected_edges",
        "i",
        "correct_answer",
        "score",
        "i",
        "len",
        "correct_answer",
        "i",
        "len",
        "user_selected_edges",
        "correct_answer",
        "i",
        "user_selected_edges",
        "i",
        "score",
        "partial_credit",
        "score",
        "len",
        "correct_answer",
        "score",
        "len",
        "correct_answer",
        "data",
        "score",
        "data",
        "string_graph",
        "data",
        "pygraphviz",
        "AGraph",
        "string_graph",
        "graph",
        "agraph",
        "start",
        "start",
        "stack",
        "stack",
        "pop",
        "node",
        "visited",
        "visited",
        "add",
        "node",
        "order",
        "append",
        "node",
        "stack",
        "extend",
        "reversed",
        "n",
        "n",
        "agraph",
        "successors",
        "node",
        "n",
        "visited",
        "order",
        "agraph",
        "start_node",
        "start_node",
        "deque",
        "start_node",
        "queue",
        "queue",
        "popleft",
        "order",
        "append",
        "current_node",
        "neighbor",
        "agraph",
        "successors",
        "current_node",
        "neighbor",
        "visited",
        "visited",
        "add",
        "neighbor",
        "queue",
        "append",
        "neighbor",
        "order",
        "agraph",
        "start_node",
        "node",
        "node",
        "agraph",
        "nodes",
        "start_node",
        "pq",
        "heapq",
        "heappop",
        "pq",
        "current_node",
        "visited_set",
        "visited_set",
        "add",
        "current_node",
        "visited_order",
        "append",
        "current_node",
        "neighbor",
        "agraph",
        "successors",
        "current_node",
        "agraph",
        "get_edge",
        "current_node",
        "neighbor",
        "edge",
        "attr",
        "get",
        "label",
        "label",
        "ValueError",
        "current_distance",
        "weight",
        "distance",
        "distances",
        "neighbor",
        "distance",
        "heapq",
        "heappush",
        "pq",
        "distance",
        "neighbor",
        "visited_order"
    ],
    "literals": [
        "\"dot\"",
        "\"adjacency-matrix\"",
        "\"f\"",
        "\"params-name\"",
        "\"params\"",
        "\"params-name-matrix\"",
        "\"params-name\"",
        "'\"params-name\" is a required attribute.'",
        "\"params-name-labels\"",
        "\"negative-weights\"",
        "\"params\"",
        "\"weights\"",
        "\"weights-digits\"",
        "\"weights-presentation-type\"",
        "\"directed\"",
        "\"params\"",
        "f'Non-square adjacency matrix \"{input_param_name}\" of size ({mat.shape[0]}, {mat.shape[1]}) given as input.'",
        "f'Dimension {mat_label.shape[0]} of the label \"{input_label}\"'",
        "f'is not consistent with the dimension {mat.shape[0]} of the matrix \"{input_param_name}\".'",
        "f'Input matrix \"{input_param_name}\" must be symmetric if rendering is set to be undirected.'",
        "'weight'",
        "\"preserve-ordering\"",
        "\"answers\"",
        "\"grading\"",
        "\"partial-credit\"",
        "\"node-fill-color\"",
        "\"edge-fill-color\"",
        "\"select-nodes\"",
        "\"select-edges\"",
        "\"random-graph\"",
        "\"directed-random\"",
        "\"min-nodes\"",
        "\"max-nodes\"",
        "\"min-edges\"",
        "\"max-edges\"",
        "\"weighted\"",
        "\"tree\"",
        "\"engine\"",
        "\"directed\"",
        "\"params-name-matrix\"",
        "\"params-name\"",
        "\"weights\"",
        "\"weights-digits\"",
        "\"weights-presentation-type\"",
        "\"params-name-labels\"",
        "\"params-type\"",
        "\"negative-weights\"",
        "\"log-warnings\"",
        "\"optional_attribs\"",
        "\"engine\"",
        "\"log-warnings\"",
        "\"node-fill-color\"",
        "\"red\"",
        "\"edge-fill-color\"",
        "\"red\"",
        "\"select-nodes\"",
        "\"True\"",
        "\"select-edges\"",
        "\"random-graph\"",
        "\"grading\"",
        "\"True\"",
        "\"min-nodes\"",
        "\"max-nodes\"",
        "\"min-edges\"",
        "\"max-nodes\"",
        "\"directed-random\"",
        "\"weighted\"",
        "\"tree\"",
        "'label'",
        "'weight'",
        "\"adjacency-matrix\"",
        "\"networkx\"",
        "\"params-name-matrix\"",
        "\"params-name\"",
        "\"params-type\"",
        "\"No graph source given! Must either define graph in HTML or provide source in params.\"",
        "f'Unknown graph type \"{input_type}\".'",
        "'\\\"\\\"'",
        "\"G\"",
        "\"ignore\"",
        "\"svg\"",
        "\"utf-8\"",
        "\"strict\"",
        "f\"\"\"\n    <input type=\"hidden\" id=\"random-graph\" name=\"random-graph\" value=\"{graph_data}\">\n    <input type=\"hidden\" id=\"selectedNodes\" name=\"selectedNodes\" value=\"\">\n    <input type=\"hidden\" id=\"selectedEdges\" name=\"selectedEdges\" value=\"\">\n    <div id=\"selectedNodeList\"></div>\n    <div id=\"selectedEdgeList\"></div>\n    <script>\n    function clickable() {{\n    window.addEventListener('DOMContentLoaded', (event) => {{\n        let nodes = document.querySelectorAll('.node > ellipse');\n        let edges = document.querySelectorAll('.edge > path');\n        let selectedNodes = []; // Array to store selected node labels\n        let selectedEdges = [];\n        let nodeFillColor = \"{node_fill_color}\";\n        let edgeFillColor = \"{edge_fill_color}\";\n\n        let selectNodes = \"{select_nodes}\"\n        let selectEdges = \"{select_edges}\"\n        // Ensure text elements do not intercept mouse events\n        let nodeTexts = document.querySelectorAll('.node > text');\n        nodeTexts.forEach(text => {{\n            text.style.pointerEvents = 'none';\n        }});\n        \n        // Move edge labels to the right by 5 units\n        document.querySelectorAll('.edge text[text-anchor=\"middle\"]').forEach(function(text) {{\n            var currentX = parseFloat(text.getAttribute('x'));\n            var newX = currentX + 5;\n            text.setAttribute('x', newX.toString());\n         }});\n\n\n\n        if (selectNodes == \"True\") {{\n            document.getElementById(\"selectedNodeList\").style.visibility= \"visible\";\n            nodes.forEach(node => {{\n                // Set a transparent fill for each ellipse\n                node.setAttribute('fill', 'rgba(0,0,0,0)');\n\n                node.addEventListener('click', function(event) {{\n                    event.stopPropagation();\n\n                    // Get the ID of the node, which should ideally be its label/name\n                    // and get the text content of the sibling <text> node\n                    let nodeId = node.parentNode.getAttribute(\"id\"); // Get the ID of the node\n                    let nodeLabel = node.parentNode.querySelector(\"text\").textContent; // Get the text content of the node\n\n                    // Toggle node stroke color\n\n                    //instead of red, do select-color\n                    if (node.getAttribute('fill') !== nodeFillColor) {{\n                        node.setAttribute('fill', nodeFillColor);\n                        selectedNodes.push(nodeLabel); // Add to selected nodes, using the text label\n                    }} else {{\n                        node.setAttribute('fill', 'rgba(0,0,0,0)'); // changed to transparent instead of white\n                        const index = selectedNodes.indexOf(nodeLabel); // Use nodeLabel instead of nodeId\n                        if (index > -1) {{\n                            selectedNodes.splice(index, 1)// Remove from selected nodes\n                        }}\n                    }}\n\n                    // Update the hidden input with the current list of selected nodes\n                    document.getElementById(\"selectedNodes\").value = JSON.stringify(selectedNodes);\n                    updateNodeListDisplay(selectedNodes);\n\n                }});\n            }})\n            }};\n            if (selectEdges == \"True\") {{\n                    document.getElementById(\"selectedEdgeList\").style.visibility= \"visible\";\n\n                    edges.forEach(edge => {{\n                        edge.setAttribute('stroke-width', '5'); \n                        }});\n                edges.forEach(edge => {{\n                    edge.addEventListener('click', function(event) {{\n                        event.stopPropagation();\n                        let edgeTitle = edge.parentNode.querySelector('title').textContent;\n\n                        if (!selectedEdges.includes(edgeTitle)) {{\n                            edge.setAttribute('stroke', edgeFillColor); // Use stroke for edge selection visual\n                            edge.setAttribute('stroke-width', \"5\");\n                            selectedEdges.push(edgeTitle);\n                        }} else {{\n                            edge.setAttribute('stroke', 'black'); // Reset to default or specify non-selected stroke color\n                            const index = selectedEdges.indexOf(edgeTitle);\n                            if (index > -1) {{\n                                selectedEdges.splice(index, 1);\n                            }}\n                        }}\n\n                        document.getElementById(\"selectedEdges\").value = JSON.stringify(selectedEdges);\n                        updateEdgeListDisplay(selectedEdges); // Format for display\n                    }});\n                }})\n            }};\n\n    }});\n\n    function updateNodeListDisplay(selectedNodes) {{\n    let listHTML = selectedNodes.map((nodeLabel) => \n        `<li>${{nodeLabel}}</li>`\n    ).join('');\n    document.getElementById(\"selectedNodeList\").innerHTML = `<ol>${{listHTML}}</ol>`;\n    }}\n\n    function updateEdgeListDisplay(selectedEdges) {{\n    let listHTML = selectedEdges.map(edgeTitle => \n        `<li>${{edgeTitle}}</li>`\n    ).join('');\n\n    document.getElementById(\"selectedEdgeList\").innerHTML = `<ol>${{listHTML}}</ol>`; // Ensure you have a corresponding div for edges\n}}\n    }}\n    clickable();\n    </script>\n    \"\"\"",
        "f'<div class=\"pl-graph\">{svg}</div>{javascript_function}'",
        "\"select-nodes\"",
        "\"False\"",
        "\"select-edges\"",
        "\"False\"",
        "\"grading\"",
        "\"True\"",
        "\"submitted_answers\"",
        "\"selectedNodes\"",
        "\"partial_scores\"",
        "\"score\"",
        "\"score\"",
        "\"weight\"",
        "\"feedback\"",
        "\"no nodes selected\"",
        "\"True\"",
        "\"submitted_answers\"",
        "\"selectedEdges\"",
        "\"partial_scores\"",
        "\"score\"",
        "\"score\"",
        "\"weight\"",
        "\"feedback\"",
        "\"no edges selected\"",
        "\"True\"",
        "\"submitted_answers\"",
        "\"selectedNodes\"",
        "\"True\"",
        "\"submitted_answers\"",
        "\"selectedEdges\"",
        "\"submitted_answers\"",
        "\"random-graph\"",
        "\"answers\"",
        "\"[]\"",
        "\"preserve-ordering\"",
        "\"partial-credit\"",
        "'dfs'",
        "'bfs'",
        "'dijkstras'",
        "\"True\"",
        "\"True\"",
        "\"True\"",
        "\"partial_scores\"",
        "\"score\"",
        "\"score\"",
        "\"weight\"",
        "\"True\"",
        "\"True\"",
        "\"True\"",
        "\"partial_scores\"",
        "\"score\"",
        "\"score\"",
        "\"weight\"",
        "\"submitted_answers\"",
        "\"random-graph\"",
        "'inf'",
        "'label'"
    ],
    "variables": [
        "PRESERVE_ORDERING",
        "ANSWERS",
        "PARTIAL_CREDIT",
        "ENGINE_DEFAULT",
        "PARAMS_NAME_MATRIX_DEFAULT",
        "PARAMS_NAME_DEFAULT",
        "PARAMS_NAME_LABELS_DEFAULT",
        "PARAMS_TYPE_DEFAULT",
        "WEIGHTS_DEFAULT",
        "WEIGHTS_DIGITS_DEFAULT",
        "WEIGHTS_PRESENTATION_TYPE_DEFAULT",
        "NEGATIVE_WEIGHTS_DEFAULT",
        "DIRECTED_DEFAULT",
        "LOG_WARNINGS_DEFAULT",
        "AUTOGRADING",
        "input_param_name",
        "networkx_graph",
        "G",
        "input_param_matrix",
        "input_param_name",
        "input_label",
        "negative_weights",
        "mat",
        "show_weights",
        "digits",
        "presentation_type",
        "directed",
        "label",
        "label",
        "mat_label",
        "mat_label",
        "show_weights",
        "G",
        "n",
        "min_edges",
        "max_edges",
        "G",
        "G",
        "G",
        "m",
        "existing_edges",
        "remaining_edges",
        "possible_edges",
        "available_edges",
        "additional_edges",
        "ascii_labels",
        "mapping",
        "G",
        "optional_attribs",
        "extensions",
        "element",
        "element",
        "engine",
        "log_warnings",
        "node_fill_color",
        "edge_fill_color",
        "select_nodes",
        "select_edges",
        "random_graph",
        "grading",
        "min_nodes",
        "max_nodes",
        "min_edges",
        "max_edges",
        "directed_random",
        "weighted",
        "tree",
        "networkx_graph",
        "agraph",
        "u",
        "v",
        "graphviz_data",
        "matrix_backends",
        "extensions",
        "input_param_matrix",
        "input_param_name",
        "input_type",
        "graphviz_data",
        "graphviz_data",
        "translated_dotcode",
        "translated_dotcode_string",
        "graph_data",
        "svg",
        "javascript_function",
        "element",
        "select_nodes",
        "select_edges",
        "grading",
        "user_selected_nodes",
        "user_selected_edges",
        "score",
        "random_graph",
        "graph",
        "correct_answer",
        "preserve_ordering",
        "partial_credit",
        "correct_answer",
        "correct_answer",
        "correct_answer",
        "score",
        "score",
        "score",
        "score",
        "score",
        "score",
        "random_graph",
        "graph",
        "visited",
        "stack",
        "order",
        "node",
        "visited",
        "queue",
        "order",
        "current_node",
        "distances",
        "distances",
        "start_node",
        "pq",
        "visited_set",
        "visited_order",
        "current_distance",
        "current_node",
        "edge",
        "label",
        "weight",
        "weight",
        "distance",
        "distances",
        "neighbor"
    ],
    "comments": [
        "Default pl-interactive-graph",
        "Legacy default",
        "Legacy input with passthrough",
        "Exception to make typechecker happy.",
        "by default display weights for stochastic matrices",
        "if displaying weights how many digits to round to",
        "Sanity checking",
        "Auto detect showing weights if any of the weights are not 1 or 0",
        "Create pygraphviz graph representation",
        "If showing negative weights, show every entry that is not None",
        "Otherwise, only show positive weights",
        "Step 1: Determine the number of nodes",
        "Step 2: Ensure that the graph has at least n-1 edges if min_edges is 0",
        "Set a reasonable upper limit on edges if max_edges is 0",
        "Step 3: Generate the graph",
        "Generate a connected non-tree graph by ensuring a spanning tree first",
        "Add additional edges to meet the minimum and maximum constraints",
        "Add remaining edges randomly from available pairs",
        "Step 4: Add weights if necessary",
        "Step 5: Relabel nodes to ASCII labels",
        "Load attributes from extensions if they have any",
        "Get attribs",
        "if random_graph is true, generate a random graph instead of using existing functions",
        "Original logic to choose between networkx and adjacency matrix based on input_type",
        "load color",
        "Load all extensions",
        "Legacy input with passthrough",
        "Read the contents of this element as the data to render",
        "we dump the string to json to ensure that newlines are",
        "properly encoded",
        "print(translated_dotcode_string)",
        "stored_graph_data = translated_dotcode.string.split(\" \")[:split]",
        "graph_data = translated_dotcode_string.split(\" \")[split:]",
        "Only apply ignore filter if we enable hiding warnings",
        "print(graph_data)",
        "select_nodes = pl.from_json(element.get(\"select-nodes\"))",
        "Use 'submitted_answers' instead of data[\"submitted_answers\"]",
        "Helper #########",
        "",
        "Always need to run this #####",
        "",
        "Algorithms ####################################",
        "",
        "Set of visited nodes",
        "Stack for DFS",
        "Order of visited nodes",
        "Get successors of the node in reverse order to maintain the correct order when popped from stack",
        "Set of visited nodes",
        "Queue for BFS",
        "Order of visited nodes",
        "Dequeue a node from queue",
        "Visit all the unvisited neighbors",
        "Initialize distances from start_node to infinity, except for start_node itself which is 0",
        "Priority queue to select the node with the smallest distance",
        "Set and list to record the order of visited nodes",
        "Pop the node with the smallest distance",
        "Skip if this node has already been visited",
        "Mark the current node as visited",
        "Explore the neighbors of the current node",
        "Extract the edge's label, which contains the weight as a string",
        "If the label exists and is not None, convert it to float. Otherwise, use default weight.",
        "In case the label cannot be converted to float, use a default weight.",
        "Calculate new distance to the neighboring node",
        "If the new distance is shorter, update the path and distances",
        "Use a tuple of (distance, neighbor) to maintain a min heap based on distance"
    ],
    "docstrings": [],
    "functions": [
        "graphviz_from_networkx",
        "graphviz_from_adj_matrix",
        "generate_graph",
        "prepare",
        "render",
        "grade",
        "string_to_graph",
        "dfs_agraph",
        "bfs_agraph",
        "dijkstra_agraph"
    ],
    "classes": []
}