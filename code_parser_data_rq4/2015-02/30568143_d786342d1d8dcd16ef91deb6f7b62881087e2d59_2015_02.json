{
    "identifiers": [
        "FileCursor",
        "match",
        "match",
        "match",
        "match",
        "match",
        "match",
        "parseInt",
        "match",
        "parseInt",
        "match",
        "match",
        "parseInt",
        "match",
        "parseInt",
        "match",
        "match",
        "parseFloat",
        "match",
        "match",
        "parseInt",
        "match",
        "match",
        "match",
        "match",
        "match",
        "match",
        "match",
        "pattern",
        "pattern",
        "pattern",
        "pattern",
        "action",
        "action",
        "action",
        "match",
        "action",
        "condition",
        "condition",
        "condition",
        "rule_definitions",
        "rule_definitions",
        "rule_definition",
        "standardizePattern",
        "rule_definition",
        "standardizeAction",
        "rule_definition",
        "standardizeCondition",
        "rule_definition",
        "name",
        "rule",
        "rule",
        "name",
        "Machine",
        "pdf_rules",
        "state",
        "state",
        "file_cursor",
        "yy",
        "yy",
        "file_cursor",
        "token",
        "token",
        "token",
        "length",
        "length",
        "length",
        "Buffer",
        "Buffer",
        "new_buffer",
        "Buffer",
        "length",
        "block_buffer",
        "FileCursor",
        "block_buffer",
        "machine",
        "current_state",
        "rule",
        "current_rules",
        "i",
        "i",
        "rule",
        "match",
        "match",
        "rule",
        "match",
        "token",
        "PDFLexer"
    ],
    "literals": [
        "'../FileCursor'",
        "string",
        "string",
        "string",
        "string",
        "'HEXSTRING'",
        "'true'",
        "'BOOLEAN'",
        "'false'",
        "'FALSE'",
        "'INPARENS'",
        "'OPENPARENS'",
        "'NAME'",
        "'<<'",
        "'>>'",
        "'['",
        "']'",
        "'REFERENCE'",
        "'INDIRECT_OBJECT_IDENTIFIER'",
        "'END_INDIRECT_OBJECT'",
        "'NUMBER'",
        "'NUMBER'",
        "'STREAM'",
        "'START_STREAM'",
        "'STREAM'",
        "'endstream'",
        "'END_STREAM'",
        "'STREAM'",
        "''",
        "'STREAM_BUFFER'",
        "'INPARENS'",
        "'INPARENS'",
        "'CHAR'",
        "'INPARENS'",
        "'INITIAL'",
        "'CLOSEPARENS'",
        "'CHAR'",
        "'INPARENS'",
        "'CHAR'",
        "string",
        "string",
        "string",
        "'object'",
        "'^'",
        "'^'",
        "string",
        "'function'",
        "string",
        "string",
        "string",
        "string",
        "'INITIAL'",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "''",
        "'INITIAL'",
        "''",
        "string",
        "string",
        "string",
        "'ascii'",
        "'EOF'",
        "Invalid language; could not find a match in input: ${this.buffer.slice(0, 128)}"
    ],
    "variables": [
        "pdf_rules",
        "machine",
        "token",
        "new_buffer",
        "block_buffer",
        "current_state",
        "current_rules",
        "i",
        "rule",
        "match",
        "token"
    ],
    "comments": [
        "Lexer minimum:\n\n  lexer.lex() => string\n  lexer.setInput(input, yy: {lexer: [Circular], parser: jison.Parser}): void\n\nAlso uses:\n\n  lexer.yytext: any; // the content represented by the current input\n  lexer.yyleng: number; // length of yytext\n  lexer.yylineno: number; // the current line number in the input\n  lexer.yyloc: {\n    first_line: number = 1,\n    first_column: number = 0,\n    last_line: number = 1,\n    last_column: number = 0,\n    range: [number, number],\n  };\n  lexer.yylloc: ...; // last location --\n\n  lexer.options: {\n    ranges: boolean = false,\n  }\n\nError messages:\n\n  use:\n    lexer.match: string\n    lexer.yylineno: number\n\n  options:\n    lexer.showPosition()",
        "when pattern is a string, it must match the input exactly.",
        "when it is a RegExp, it implicitly has ^ prepended to it.",
        "when action is a string, it is simply returned.",
        "when it is null, it returns null (meaning, no output).",
        "when it is a function, it is called with the activating match,",
        "and bound to the lexer. The lexer.yytext value will already have been set",
        "to the full text of the match.",
        "if condition is set, the rule only applies when a state matching that",
        "condition is on top of the state stack. defaults to INITIAL",
        "= 'INITIAL';",
        "convert each RuleDefinition to a standard Rule",
        "implementation",
        "initialize",
        "parse until we get a non-null token",
        "pull in more data from the underlying file if we're running low and there's more to be had",
        "return special 'EOF' token if we are at EOF"
    ],
    "docstrings": [],
    "functions": [
        "standardizePattern",
        "standardizeAction",
        "standardizeCondition",
        "getRules",
        "pushState",
        "popState",
        "currentState",
        "setInput",
        "lex",
        "readBuffer",
        "next"
    ],
    "classes": [
        "Machine",
        "PDFLexer"
    ]
}