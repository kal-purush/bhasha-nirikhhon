{
    "identifiers": [
        "stepcode",
        "Part21",
        "Parser",
        "os",
        "glob",
        "re",
        "geomdl",
        "NURBS",
        "geomdl",
        "compatibility",
        "geomdl",
        "utilities",
        "geomdl",
        "evaluators",
        "collections",
        "namedtuple",
        "namedtuple",
        "numpy",
        "np",
        "np",
        "finfo",
        "eps",
        "rotAxis",
        "theta",
        "np",
        "linalg",
        "norm",
        "rotAxis",
        "rotNorm",
        "eps",
        "rotAxis",
        "rotNorm",
        "rotAxis",
        "tolist",
        "np",
        "sin",
        "theta",
        "np",
        "cos",
        "theta",
        "c",
        "rotAxis",
        "x",
        "s",
        "rotAxis",
        "y",
        "s",
        "rotAxis",
        "z",
        "s",
        "rotAxis",
        "x",
        "C",
        "rotAxis",
        "y",
        "C",
        "rotAxis",
        "z",
        "C",
        "rotAxis",
        "x",
        "yC",
        "rotAxis",
        "y",
        "zC",
        "rotAxis",
        "z",
        "xC",
        "rotAxis",
        "x",
        "xC",
        "rotAxis",
        "y",
        "yC",
        "rotAxis",
        "z",
        "zC",
        "np",
        "array",
        "xxC",
        "c",
        "xyC",
        "zs",
        "zxC",
        "ys",
        "xyC",
        "zs",
        "yyC",
        "c",
        "yzC",
        "xs",
        "zxC",
        "ys",
        "yzC",
        "xs",
        "zzC",
        "c",
        "axis",
        "theta",
        "np",
        "sqrt",
        "np",
        "dot",
        "axis",
        "axis",
        "SDAA",
        "RuntimeError",
        "axis",
        "SDAA",
        "np",
        "cos",
        "theta",
        "axis",
        "np",
        "sin",
        "theta",
        "a",
        "a",
        "b",
        "b",
        "c",
        "c",
        "d",
        "d",
        "b",
        "c",
        "a",
        "d",
        "a",
        "c",
        "a",
        "b",
        "b",
        "d",
        "c",
        "d",
        "np",
        "array",
        "aa",
        "bb",
        "cc",
        "dd",
        "bc",
        "ad",
        "bd",
        "ac",
        "bc",
        "ad",
        "aa",
        "cc",
        "bb",
        "dd",
        "cd",
        "ab",
        "bd",
        "ac",
        "cd",
        "ab",
        "aa",
        "dd",
        "bb",
        "cc",
        "xyz",
        "xyz",
        "np",
        "array",
        "xyz",
        "xyz",
        "xyz",
        "xyz",
        "Point",
        "np",
        "array",
        "xyz",
        "x",
        "xyz",
        "y",
        "xyz",
        "z",
        "xyz",
        "np",
        "ndarray",
        "RuntimeError",
        "xyz",
        "x",
        "y",
        "np",
        "sqrt",
        "x",
        "y",
        "np",
        "arctan2",
        "y",
        "x",
        "rho",
        "phi",
        "rho",
        "phi",
        "rho",
        "np",
        "cos",
        "phi",
        "rho",
        "np",
        "sin",
        "phi",
        "x",
        "y",
        "a",
        "A",
        "np",
        "isclose",
        "a",
        "b",
        "atol",
        "eps",
        "np",
        "isclose",
        "a",
        "b",
        "atol",
        "eps",
        "np",
        "isclose",
        "a",
        "b",
        "atol",
        "eps",
        "b",
        "A",
        "T",
        "pointArray",
        "len",
        "pointArray",
        "RuntimeError",
        "xyz",
        "xyz",
        "pointArray",
        "max",
        "xRange",
        "max",
        "xRange",
        "min",
        "xRange",
        "xyz",
        "xyz",
        "pointArray",
        "max",
        "yRange",
        "max",
        "yRange",
        "min",
        "yRange",
        "xyz",
        "xyz",
        "pointArray",
        "max",
        "zRange",
        "max",
        "zRange",
        "min",
        "zRange",
        "np",
        "array",
        "xCentroid",
        "yCentroid",
        "zCentroid",
        "p1",
        "p2",
        "isinstance",
        "p2",
        "RuntimeError",
        "isinstance",
        "p1",
        "sqrt",
        "p1",
        "x",
        "p2",
        "x",
        "p1",
        "y",
        "p2",
        "y",
        "p1",
        "z",
        "p2",
        "z",
        "isinstance",
        "p1",
        "np",
        "sqrt",
        "pp",
        "x",
        "p2",
        "x",
        "pp",
        "y",
        "p2",
        "y",
        "pp",
        "z",
        "p2",
        "z",
        "pp",
        "p1",
        "RuntimeError",
        "os",
        "path",
        "normpath",
        "os",
        "path",
        "normpath",
        "os",
        "path",
        "normpath",
        "testDir",
        "glob",
        "glob",
        "filepath",
        "len",
        "checkPath",
        "open",
        "filepath",
        "f",
        "f",
        "read",
        "STEPdata",
        "replace",
        "STEPdata",
        "replace",
        "STEPdata",
        "replace",
        "Parser",
        "P",
        "parse",
        "STEPdata",
        "model",
        "sections",
        "entities",
        "cs",
        "STEP_entities",
        "hasattr",
        "cs",
        "cs",
        "type_name",
        "ClosedShells",
        "append",
        "cs",
        "s",
        "s",
        "ref2index",
        "STEP_entities",
        "len",
        "STEP_entities",
        "STEP_entities",
        "sort",
        "key",
        "x",
        "x",
        "STEP_entities",
        "s",
        "STEP_entities",
        "ref2index",
        "s",
        "s",
        "padded_STEP_entities",
        "p1",
        "p2",
        "p3",
        "p2",
        "p1",
        "p3",
        "p1",
        "p3",
        "p2",
        "np",
        "cross",
        "t",
        "u",
        "np",
        "linalg",
        "norm",
        "w",
        "wsl",
        "np",
        "dot",
        "w",
        "w",
        "wsl",
        "np",
        "dot",
        "t",
        "t",
        "np",
        "dot",
        "u",
        "u",
        "p1",
        "u",
        "tt",
        "np",
        "dot",
        "u",
        "v",
        "t",
        "uu",
        "np",
        "dot",
        "t",
        "v",
        "iwsl2",
        "np",
        "sqrt",
        "tt",
        "uu",
        "np",
        "dot",
        "v",
        "v",
        "iwsl2",
        "circRadius",
        "circCenter",
        "S",
        "p",
        "maxSearch",
        "localExtrema",
        "curvatureTest",
        "uv_xyz",
        "eps1",
        "eps2",
        "deltaFactor",
        "eps_bspline",
        "np",
        "isclose",
        "np",
        "array",
        "s",
        "np",
        "array",
        "s",
        "s",
        "S",
        "ctrlpts2d",
        "eps_bspline",
        "all",
        "np",
        "isclose",
        "np",
        "array",
        "S",
        "ctrlpts2d",
        "np",
        "array",
        "S",
        "ctrlpts2d",
        "eps_bspline",
        "all",
        "len",
        "S",
        "knotvector_u",
        "deltaFactor",
        "len",
        "S",
        "knotvector_v",
        "deltaFactor",
        "U",
        "V",
        "isClosedU",
        "isClosedV",
        "u",
        "U",
        "isClosedU",
        "v",
        "V",
        "isClosedV",
        "v",
        "u",
        "U",
        "V",
        "u",
        "U",
        "V",
        "u",
        "U",
        "V",
        "u",
        "U",
        "V",
        "u",
        "U",
        "V",
        "u",
        "U",
        "V",
        "u",
        "U",
        "V",
        "u",
        "U",
        "V",
        "u",
        "U",
        "V",
        "v",
        "N",
        "C",
        "S",
        "NE",
        "E",
        "SE",
        "u",
        "U",
        "V",
        "v",
        "V",
        "u",
        "U",
        "V",
        "v",
        "V",
        "u",
        "U",
        "V",
        "v",
        "V",
        "NW",
        "N",
        "NE",
        "W",
        "C",
        "E",
        "SW",
        "S",
        "SE",
        "u",
        "v",
        "S",
        "np",
        "linspace",
        "S",
        "knotvector_u",
        "S",
        "knotvector_u",
        "num",
        "len",
        "S",
        "knotvector_u",
        "deltaFactor",
        "endpoint",
        "closedU",
        "np",
        "linspace",
        "S",
        "knotvector_v",
        "S",
        "knotvector_v",
        "num",
        "len",
        "S",
        "knotvector_v",
        "deltaFactor",
        "endpoint",
        "closedV",
        "np",
        "zeros",
        "len",
        "uSamples",
        "len",
        "vSamples",
        "vi",
        "vS",
        "vSamples",
        "ui",
        "uS",
        "uSamples",
        "ui",
        "len",
        "vSamples",
        "vi",
        "uS",
        "vS",
        "np",
        "array",
        "S",
        "evaluate_list",
        "uvArray",
        "CC",
        "uv",
        "neighbouringUV",
        "len",
        "uSamples",
        "len",
        "vSamples",
        "closedU",
        "closedV",
        "pArray",
        "CC",
        "pArray",
        "CC",
        "pArray",
        "CC",
        "pArray",
        "CC",
        "pArray",
        "CC",
        "pArray",
        "CC",
        "pArray",
        "CC",
        "pArray",
        "CC",
        "pArray",
        "CC",
        "np",
        "linalg",
        "norm",
        "p",
        "pNW",
        "np",
        "linalg",
        "norm",
        "p",
        "pN",
        "np",
        "linalg",
        "norm",
        "p",
        "pNE",
        "np",
        "linalg",
        "norm",
        "p",
        "pE",
        "np",
        "linalg",
        "norm",
        "p",
        "pC",
        "np",
        "linalg",
        "norm",
        "p",
        "pW",
        "np",
        "linalg",
        "norm",
        "p",
        "pSW",
        "np",
        "linalg",
        "norm",
        "p",
        "pS",
        "np",
        "linalg",
        "norm",
        "p",
        "pSE",
        "maxSearch",
        "dpuv",
        "dpuv_NW",
        "dpuv",
        "dpuv_N",
        "dpuv",
        "dpuv_NE",
        "dpuv",
        "dpuv_W",
        "dpuv",
        "dpuv_E",
        "dpuv",
        "dpuv_SW",
        "dpuv",
        "dpuv_S",
        "dpuv",
        "dpuv_SE",
        "np",
        "linalg",
        "norm",
        "pC",
        "pN",
        "np",
        "linalg",
        "norm",
        "pC",
        "pE",
        "np",
        "linalg",
        "norm",
        "pC",
        "pW",
        "np",
        "linalg",
        "norm",
        "pC",
        "pS",
        "maxBound",
        "append",
        "max",
        "b_N",
        "b_E",
        "b_W",
        "b_S",
        "extremaUV",
        "append",
        "uvArray",
        "CC",
        "extremaP",
        "append",
        "pArray",
        "CC",
        "dpuv",
        "dpuv_NW",
        "dpuv",
        "dpuv_N",
        "dpuv",
        "dpuv_NE",
        "dpuv",
        "dpuv_W",
        "dpuv",
        "dpuv_E",
        "dpuv",
        "dpuv_SW",
        "dpuv",
        "dpuv_S",
        "dpuv",
        "dpuv_SE",
        "np",
        "linalg",
        "norm",
        "pC",
        "pN",
        "np",
        "linalg",
        "norm",
        "pC",
        "pE",
        "np",
        "linalg",
        "norm",
        "pC",
        "pW",
        "np",
        "linalg",
        "norm",
        "pC",
        "pS",
        "maxBound",
        "append",
        "max",
        "b_N",
        "b_E",
        "b_W",
        "b_S",
        "extremaUV",
        "append",
        "uvArray",
        "CC",
        "extremaP",
        "append",
        "pArray",
        "CC",
        "extremaUV",
        "extremaP",
        "maxBound",
        "np",
        "linspace",
        "S",
        "knotvector_u",
        "S",
        "knotvector_u",
        "num",
        "len",
        "S",
        "knotvector_u",
        "deltaFactor",
        "endpoint",
        "closedU",
        "np",
        "linspace",
        "S",
        "knotvector_v",
        "S",
        "knotvector_v",
        "num",
        "len",
        "S",
        "knotvector_v",
        "deltaFactor",
        "endpoint",
        "closedV",
        "np",
        "zeros",
        "len",
        "uSamples",
        "len",
        "vSamples",
        "vi",
        "vS",
        "vSamples",
        "ui",
        "uS",
        "uSamples",
        "ui",
        "len",
        "vSamples",
        "vi",
        "uS",
        "vS",
        "np",
        "array",
        "S",
        "evaluate_list",
        "uvArray",
        "np",
        "inf",
        "len",
        "uvArray",
        "CC",
        "uv",
        "neighbouringUV",
        "len",
        "uSamples",
        "len",
        "vSamples",
        "closedU",
        "closedV",
        "np",
        "array",
        "pArray",
        "CC",
        "radiusCentre3points_2",
        "pArray",
        "CC",
        "puv",
        "pArray",
        "CC",
        "radiusCentre3points_2",
        "pArray",
        "CC",
        "puv",
        "pArray",
        "CC",
        "pur",
        "np",
        "inf",
        "pvr",
        "np",
        "inf",
        "pvcc",
        "puv",
        "pur",
        "np",
        "inf",
        "pvr",
        "np",
        "inf",
        "pucc",
        "puv",
        "pur",
        "np",
        "inf",
        "pvr",
        "np",
        "inf",
        "S",
        "sample_size_u",
        "uv",
        "uv",
        "np",
        "inf",
        "pucc",
        "puv",
        "pvcc",
        "puv",
        "np",
        "linalg",
        "norm",
        "kuv",
        "puv",
        "np",
        "linalg",
        "norm",
        "p",
        "puv",
        "np",
        "linalg",
        "norm",
        "kuv",
        "p",
        "S",
        "sample_size_u",
        "uv",
        "uv",
        "dkuv",
        "np",
        "linalg",
        "norm",
        "p",
        "puv",
        "np",
        "linalg",
        "norm",
        "kuv",
        "p",
        "S",
        "sample_size_u",
        "uv",
        "uv",
        "dkuv",
        "discreteK",
        "discreteK",
        "CC",
        "uv",
        "neighbouringUV",
        "len",
        "S",
        "knotvector_u",
        "deltaFactor",
        "len",
        "S",
        "knotvector_v",
        "deltaFactor",
        "closedU",
        "closedV",
        "CC",
        "CC",
        "CC",
        "CC",
        "discreteK",
        "ssn",
        "np",
        "inf",
        "ssn",
        "surroundNodes",
        "maxSearch",
        "all",
        "np",
        "abs",
        "discreteK",
        "ssn",
        "discreteK",
        "S",
        "sample_size_u",
        "uv",
        "uv",
        "ssn",
        "surroundNodes",
        "discreteK",
        "S",
        "sample_size_u",
        "uv",
        "uv",
        "np",
        "array",
        "S",
        "evaluate_single",
        "uv",
        "localExtremaP",
        "pC",
        "maxBound",
        "append",
        "max",
        "np",
        "linalg",
        "norm",
        "pC",
        "np",
        "array",
        "S",
        "evaluate_single",
        "uvk",
        "uvk",
        "surroundNodes",
        "leu",
        "append",
        "uv",
        "all",
        "np",
        "abs",
        "discreteK",
        "ssn",
        "discreteK",
        "S",
        "sample_size_u",
        "uv",
        "uv",
        "ssn",
        "surroundNodes",
        "discreteK",
        "S",
        "sample_size_u",
        "uv",
        "uv",
        "np",
        "array",
        "S",
        "evaluate_single",
        "uv",
        "localExtremaP",
        "pC",
        "maxBound",
        "append",
        "max",
        "np",
        "linalg",
        "norm",
        "pC",
        "np",
        "array",
        "S",
        "evaluate_single",
        "uvk",
        "uvk",
        "surroundNodes",
        "leu",
        "append",
        "uv",
        "leu",
        "mpU",
        "mpV",
        "tol",
        "S",
        "delta_u",
        "S",
        "delta_v",
        "np",
        "linalg",
        "norm",
        "p",
        "np",
        "array",
        "S",
        "evaluate_single",
        "mpU",
        "mpV",
        "tolFlag",
        "divU",
        "divV",
        "mpU",
        "divU",
        "mpV",
        "divV",
        "mpU",
        "mpV",
        "divV",
        "mpU",
        "divU",
        "mpV",
        "divV",
        "mpU",
        "divU",
        "mpV",
        "mpU",
        "mpV",
        "mpU",
        "divU",
        "mpV",
        "mpU",
        "divU",
        "mpV",
        "divV",
        "mpU",
        "mpV",
        "divV",
        "mpU",
        "divU",
        "mpV",
        "divV",
        "sdv",
        "subDivs",
        "sdv",
        "sdv",
        "sdv",
        "sdv",
        "S",
        "evaluate_list",
        "subDivs",
        "np",
        "linalg",
        "norm",
        "p",
        "pSubDivs",
        "np",
        "linalg",
        "norm",
        "p",
        "pSubDivs",
        "np",
        "linalg",
        "norm",
        "p",
        "pSubDivs",
        "np",
        "linalg",
        "norm",
        "p",
        "pSubDivs",
        "np",
        "linalg",
        "norm",
        "p",
        "pSubDivs",
        "np",
        "linalg",
        "norm",
        "p",
        "pSubDivs",
        "np",
        "linalg",
        "norm",
        "p",
        "pSubDivs",
        "np",
        "linalg",
        "norm",
        "p",
        "pSubDivs",
        "dpuv_NW",
        "dpuv_N",
        "dpuv_NE",
        "dpuv_W",
        "dpuv_E",
        "dpuv_SW",
        "dpuv_S",
        "dpuv_SE",
        "maxSearch",
        "np",
        "abs",
        "max",
        "dispUV",
        "dpuvlocal",
        "tol",
        "dispUV",
        "index",
        "max",
        "dispUV",
        "subDivs",
        "maxUVindex",
        "subDivs",
        "maxUVindex",
        "max",
        "dispUV",
        "tolFlag",
        "np",
        "abs",
        "min",
        "dispUV",
        "dpuvlocal",
        "tol",
        "dispUV",
        "index",
        "min",
        "dispUV",
        "subDivs",
        "minUVindex",
        "subDivs",
        "minUVindex",
        "min",
        "dispUV",
        "tolFlag",
        "mpU",
        "mpV",
        "cuv",
        "maxits",
        "uv",
        "e",
        "r",
        "e",
        "e",
        "e",
        "e",
        "e",
        "e",
        "np",
        "dot",
        "Su",
        "r",
        "np",
        "dot",
        "Sv",
        "r",
        "f",
        "g",
        "np",
        "dot",
        "Su",
        "Su",
        "np",
        "dot",
        "Suu",
        "r",
        "np",
        "dot",
        "Su",
        "Sv",
        "np",
        "dot",
        "Suv",
        "r",
        "np",
        "dot",
        "Su",
        "Sv",
        "np",
        "dot",
        "Svu",
        "r",
        "np",
        "dot",
        "Sv",
        "Sv",
        "np",
        "dot",
        "Svv",
        "r",
        "J00",
        "J01",
        "J10",
        "J11",
        "np",
        "linalg",
        "solve",
        "J",
        "k",
        "d",
        "uv",
        "i",
        "maxits",
        "cuv",
        "cuv",
        "cuv",
        "cuv",
        "np",
        "inf",
        "np",
        "inf",
        "np",
        "array",
        "S",
        "derivatives",
        "cuv",
        "cuv",
        "e",
        "p",
        "np",
        "linalg",
        "norm",
        "dif",
        "c1v",
        "eps1",
        "np",
        "dot",
        "e",
        "dif",
        "np",
        "linalg",
        "norm",
        "e",
        "c1v",
        "c2an",
        "c2ad",
        "c2av",
        "eps2",
        "np",
        "dot",
        "e",
        "dif",
        "np",
        "linalg",
        "norm",
        "e",
        "c1v",
        "c2bn",
        "c2bd",
        "c2bv",
        "eps2",
        "c1",
        "c2a",
        "c2b",
        "cuv",
        "n",
        "cuv",
        "e",
        "dif",
        "ct",
        "S",
        "knotvector_u",
        "closedU",
        "S",
        "knotvector_u",
        "S",
        "knotvector_u",
        "ct",
        "ct",
        "S",
        "knotvector_u",
        "eps_bspline",
        "ct",
        "ct",
        "S",
        "knotvector_u",
        "closedU",
        "S",
        "knotvector_u",
        "ct",
        "S",
        "knotvector_u",
        "ct",
        "S",
        "knotvector_u",
        "eps_bspline",
        "ct",
        "ct",
        "S",
        "knotvector_v",
        "closedV",
        "ct",
        "S",
        "knotvector_v",
        "S",
        "knotvector_v",
        "ct",
        "ct",
        "S",
        "knotvector_v",
        "eps_bspline",
        "ct",
        "S",
        "knotvector_v",
        "closedV",
        "ct",
        "S",
        "knotvector_v",
        "ct",
        "S",
        "knotvector_v",
        "S",
        "knotvector_v",
        "ct",
        "S",
        "knotvector_v",
        "eps_bspline",
        "np",
        "linalg",
        "norm",
        "ct",
        "cuv",
        "e",
        "np",
        "linalg",
        "norm",
        "ct",
        "cuv",
        "e",
        "c3v0",
        "c3v1",
        "eps1",
        "cuv",
        "ct",
        "i",
        "i",
        "maxits",
        "np",
        "inf",
        "np",
        "inf",
        "cuv",
        "curvatureTest",
        "localCurvatureExtrema",
        "curvatureSearch",
        "localNeighbourSearch",
        "S",
        "len",
        "localExtremaUV",
        "luv",
        "lp",
        "mb",
        "localExtremaUV",
        "localExtremaP",
        "maxBound",
        "NewtonRaphson",
        "luv",
        "np",
        "inf",
        "mUV",
        "np",
        "linalg",
        "norm",
        "lp",
        "np",
        "array",
        "S",
        "evaluate_single",
        "mUV",
        "mb",
        "extremaUV",
        "append",
        "mUV",
        "np",
        "inf",
        "np",
        "inf",
        "np",
        "inf",
        "mUV",
        "subSearchUV",
        "luv",
        "luv",
        "eps_bspline",
        "extremaUV",
        "append",
        "mUV",
        "m",
        "extremaUV",
        "np",
        "isclose",
        "m",
        "u",
        "eps1",
        "all",
        "u",
        "extremaUnique",
        "extremaUnique",
        "append",
        "m",
        "localExtrema",
        "len",
        "extremaUnique",
        "localExtrema",
        "uv_xyz",
        "extremaUnique",
        "np",
        "array",
        "S",
        "evaluate_single",
        "extremaUnique",
        "localExtrema",
        "uv_xyz",
        "extremaUnique",
        "S",
        "evaluate_list",
        "extremaUnique",
        "S",
        "evaluate_list",
        "extremaUnique",
        "np",
        "linalg",
        "norm",
        "np",
        "array",
        "e",
        "p",
        "e",
        "extremaUniquePoint",
        "maxSearch",
        "uv_xyz",
        "extremaUnique",
        "dispsExtrema",
        "index",
        "max",
        "dispsExtrema",
        "np",
        "array",
        "extremaUniquePoint",
        "dispsExtrema",
        "index",
        "max",
        "dispsExtrema",
        "uv_xyz",
        "extremaUnique",
        "dispsExtrema",
        "index",
        "min",
        "dispsExtrema",
        "np",
        "array",
        "extremaUniquePoint",
        "dispsExtrema",
        "index",
        "min",
        "dispsExtrema",
        "C",
        "p",
        "maxSearch",
        "localExtrema",
        "curvatureTest",
        "uv_xyz",
        "eps1",
        "eps2",
        "deltaFactor",
        "eps_bspline",
        "len",
        "C",
        "knotvector",
        "deltaFactor",
        "np",
        "isclose",
        "np",
        "linalg",
        "norm",
        "np",
        "array",
        "C",
        "ctrlpts",
        "np",
        "array",
        "C",
        "ctrlpts",
        "eps_bspline",
        "i",
        "closedC",
        "len",
        "pts",
        "closedC",
        "i",
        "np",
        "array",
        "pts",
        "np",
        "array",
        "pts",
        "np",
        "array",
        "pts",
        "i",
        "len",
        "pts",
        "np",
        "array",
        "pts",
        "np",
        "array",
        "pts",
        "np",
        "array",
        "pts",
        "np",
        "array",
        "pts",
        "i",
        "np",
        "array",
        "pts",
        "i",
        "np",
        "array",
        "pts",
        "i",
        "i",
        "i",
        "i",
        "len",
        "pts",
        "np",
        "linalg",
        "norm",
        "p0",
        "p",
        "np",
        "linalg",
        "norm",
        "p1",
        "p",
        "np",
        "linalg",
        "norm",
        "p2",
        "p",
        "i",
        "i",
        "len",
        "pts",
        "dp1",
        "dp2",
        "np",
        "linalg",
        "norm",
        "p2",
        "p",
        "maxSearch",
        "dp1",
        "dp2",
        "dp1",
        "dp0",
        "localExtremaU",
        "append",
        "kvs",
        "i",
        "dp1",
        "dp2",
        "dp1",
        "dp0",
        "localExtremaU",
        "append",
        "kvs",
        "i",
        "localExtremaU",
        "np",
        "inf",
        "len",
        "pts",
        "i",
        "closedC",
        "len",
        "pts",
        "closedC",
        "i",
        "np",
        "array",
        "pts",
        "np",
        "array",
        "pts",
        "np",
        "array",
        "pts",
        "i",
        "len",
        "pts",
        "np",
        "array",
        "pts",
        "np",
        "array",
        "pts",
        "np",
        "array",
        "pts",
        "np",
        "array",
        "pts",
        "i",
        "np",
        "array",
        "pts",
        "i",
        "np",
        "array",
        "pts",
        "i",
        "radiusCentre3points",
        "p0",
        "p1",
        "p2",
        "pur",
        "pur",
        "np",
        "inf",
        "np",
        "dot",
        "p",
        "p1",
        "pucc",
        "p1",
        "np",
        "linalg",
        "norm",
        "pucc",
        "p1",
        "pur",
        "pur",
        "i",
        "closedC",
        "len",
        "discreteK",
        "closedC",
        "i",
        "discreteK",
        "discreteK",
        "discreteK",
        "i",
        "len",
        "discreteK",
        "discreteK",
        "discreteK",
        "discreteK",
        "discreteK",
        "i",
        "discreteK",
        "i",
        "discreteK",
        "i",
        "k0",
        "np",
        "inf",
        "k1",
        "np",
        "inf",
        "k2",
        "np",
        "inf",
        "np",
        "abs",
        "k1",
        "np",
        "abs",
        "k2",
        "np",
        "abs",
        "k1",
        "np",
        "abs",
        "k0",
        "k1",
        "maxSearch",
        "localExtremaU",
        "append",
        "kvs",
        "i",
        "k1",
        "maxSearch",
        "localExtremaU",
        "append",
        "kvs",
        "i",
        "localExtremaU",
        "C",
        "mpU",
        "tol",
        "C",
        "delta",
        "np",
        "linalg",
        "norm",
        "p",
        "C",
        "evaluate_single",
        "mpU",
        "tolFlag",
        "divU",
        "mpU",
        "divU",
        "mpU",
        "mpU",
        "divU",
        "C",
        "evaluate_list",
        "subDivs",
        "np",
        "linalg",
        "norm",
        "p",
        "pSubDivs",
        "np",
        "linalg",
        "norm",
        "p",
        "pSubDivs",
        "dpu_L",
        "dpulocal",
        "dpu_R",
        "maxSearch",
        "np",
        "abs",
        "max",
        "dispU",
        "dpulocal",
        "tol",
        "dispU",
        "index",
        "max",
        "dispU",
        "subDivs",
        "maxUindex",
        "max",
        "dispU",
        "tolFlag",
        "np",
        "abs",
        "min",
        "dispU",
        "dpulocal",
        "tol",
        "dispU",
        "index",
        "min",
        "dispU",
        "subDivs",
        "minUindex",
        "min",
        "dispU",
        "tolFlag",
        "mpU",
        "cu",
        "maxits",
        "u2",
        "e1",
        "d",
        "u2",
        "np",
        "dot",
        "e1",
        "d",
        "np",
        "dot",
        "e1",
        "d",
        "np",
        "dot",
        "e1",
        "e1",
        "i",
        "maxits",
        "np",
        "array",
        "C",
        "derivatives",
        "cu",
        "order",
        "e",
        "p",
        "np",
        "linalg",
        "norm",
        "dif",
        "np",
        "dot",
        "e",
        "dif",
        "np",
        "linalg",
        "norm",
        "e",
        "c1v",
        "c2n",
        "c2d",
        "c1v",
        "eps1",
        "np",
        "abs",
        "c2v",
        "eps2",
        "cu",
        "cu",
        "np",
        "dot",
        "e",
        "dif",
        "np",
        "dot",
        "e",
        "dif",
        "np",
        "dot",
        "e",
        "e",
        "ct",
        "C",
        "knotvector",
        "closedC",
        "C",
        "knotvector",
        "ct",
        "C",
        "knotvector",
        "C",
        "knotvector",
        "C",
        "knotvector",
        "eps_bspline",
        "ct",
        "C",
        "knotvector",
        "closedC",
        "C",
        "knotvector",
        "ct",
        "C",
        "knotvector",
        "C",
        "knotvector",
        "C",
        "knotvector",
        "eps_bspline",
        "np",
        "linalg",
        "norm",
        "np",
        "multiply",
        "ct",
        "cu",
        "e",
        "c3v",
        "eps1",
        "cu",
        "ct",
        "i",
        "i",
        "maxits",
        "np",
        "inf",
        "cu",
        "splineToPolyline",
        "C",
        "curveSampleFactor",
        "deltaFactor",
        "curvatureTest",
        "localCurvatureTest",
        "localDispTest",
        "len",
        "localExtremaU",
        "lu",
        "localExtremaU",
        "NewtonRaphson",
        "lu",
        "mU",
        "np",
        "inf",
        "extremaU",
        "append",
        "mU",
        "subSearchU",
        "C",
        "lu",
        "eps_bspline",
        "extremaU",
        "append",
        "mU",
        "m",
        "extremaU",
        "np",
        "isclose",
        "m",
        "u",
        "eps1",
        "all",
        "u",
        "extremaUnique",
        "extremaUnique",
        "append",
        "m",
        "localExtrema",
        "len",
        "extremaUnique",
        "localExtrema",
        "uv_xyz",
        "extremaUnique",
        "np",
        "array",
        "C",
        "evaluate_single",
        "extremaUnique",
        "localExtrema",
        "uv_xyz",
        "extremaUnique",
        "C",
        "evaluate_list",
        "extremaUnique",
        "C",
        "evaluate_list",
        "extremaUnique",
        "np",
        "linalg",
        "norm",
        "np",
        "array",
        "e",
        "p",
        "e",
        "extremaUniquePoint",
        "maxSearch",
        "uv_xyz",
        "extremaUnique",
        "dispsExtrema",
        "index",
        "max",
        "dispsExtrema",
        "np",
        "array",
        "extremaUniquePoint",
        "dispsExtrema",
        "index",
        "max",
        "dispsExtrema",
        "uv_xyz",
        "extremaUnique",
        "dispsExtrema",
        "index",
        "min",
        "dispsExtrema",
        "np",
        "array",
        "extremaUniquePoint",
        "dispsExtrema",
        "index",
        "min",
        "dispsExtrema",
        "p",
        "v1",
        "v2",
        "_refDir",
        "_auxDir",
        "_normDir",
        "aCentreP",
        "rotSym",
        "np",
        "array",
        "_refDir",
        "_auxDir",
        "_normDir",
        "np",
        "matmul",
        "rotM",
        "v1",
        "aCentreP",
        "np",
        "arctan2",
        "v1UV",
        "v1UV",
        "np",
        "matmul",
        "rotM",
        "v2",
        "aCentreP",
        "np",
        "arctan2",
        "v2UV",
        "v2UV",
        "isinstance",
        "p",
        "pp",
        "p",
        "np",
        "matmul",
        "rotM",
        "pp",
        "aCentreP",
        "np",
        "arctan2",
        "ppUV",
        "ppUV",
        "pUV_angle",
        "append",
        "ppUV_angle",
        "isinstance",
        "p",
        "np",
        "ndarray",
        "np",
        "matmul",
        "rotM",
        "p",
        "aCentreP",
        "np",
        "arctan2",
        "pUV",
        "pUV",
        "isinstance",
        "p",
        "pp",
        "pp",
        "pUV",
        "zTest",
        "v1UV",
        "v2UV",
        "pUV",
        "v1UV",
        "v2UV",
        "max",
        "zTest",
        "min",
        "zTest",
        "eps_STEP_AP21",
        "planeTestFail",
        "isinstance",
        "p",
        "ppUV_angle",
        "pUV_angle",
        "ppUV_angle",
        "v1UV_angle",
        "ppUV_angle",
        "v2UV_angle",
        "v1UV_angle",
        "v2UV_angle",
        "returnList",
        "append",
        "returnList",
        "append",
        "returnList",
        "max",
        "zTest",
        "min",
        "zTest",
        "returnList",
        "pUV_angle",
        "v1UV_angle",
        "pUV_angle",
        "v2UV_angle",
        "v1UV_angle",
        "v2UV_angle",
        "returnBool",
        "planeTestFail",
        "max",
        "zTest",
        "min",
        "zTest",
        "returnBool",
        "p",
        "v1",
        "v2",
        "_refDir",
        "_auxDir",
        "_normDir",
        "aCentreP",
        "rotSym",
        "isinstance",
        "p",
        "p",
        "np",
        "array",
        "_refDir",
        "_auxDir",
        "_normDir",
        "np",
        "matmul",
        "rotM",
        "v1",
        "aCentreP",
        "np",
        "arctan2",
        "v1UV",
        "v1UV",
        "np",
        "matmul",
        "rotM",
        "v2",
        "aCentreP",
        "np",
        "arctan2",
        "v2UV",
        "v2UV",
        "np",
        "abs",
        "v1UV_angle",
        "eps_STEP_AP21",
        "v1UV_angle",
        "v2UV_angle",
        "eps_STEP_AP21",
        "v1UV_angle",
        "np",
        "pi",
        "pp",
        "p",
        "np",
        "matmul",
        "rotM",
        "pp",
        "aCentreP",
        "np",
        "arctan2",
        "ppUV",
        "ppUV",
        "ppUV_angle",
        "v1UV_angle",
        "ppUV_angle",
        "ppUV_angle",
        "np",
        "pi",
        "pUV_angle",
        "append",
        "ppUV_angle",
        "np",
        "pi",
        "pUV_a",
        "v1UV_angle",
        "pUV_a",
        "v2UV_angle",
        "pUV_a",
        "pUV_angle",
        "withinVertex1andVertex2",
        "np",
        "argsort",
        "pUV_angle",
        "pUV_a",
        "np",
        "pi",
        "pUV_a",
        "pUV_angle",
        "p",
        "axP",
        "axN",
        "p",
        "axP",
        "axP",
        "axN",
        "vpn",
        "np",
        "dot",
        "vpp",
        "vpn",
        "np",
        "dot",
        "vpn",
        "vpn",
        "p",
        "centrePoint",
        "normAxis",
        "radius",
        "interior",
        "np",
        "dot",
        "p",
        "centrePoint",
        "normAxis",
        "p",
        "np",
        "dot",
        "d",
        "normAxis",
        "np",
        "linalg",
        "norm",
        "pUV",
        "centrePoint",
        "np",
        "isclose",
        "ppCentreDisp",
        "centrePoint",
        "pUV",
        "centrePoint",
        "ppCentreDisp",
        "centrePoint",
        "radius",
        "pUVdir",
        "centrePoint",
        "radius",
        "pUVdir",
        "ppCentreDisp",
        "radius",
        "nUVmin",
        "nUVmax",
        "pUV",
        "centrePoint",
        "centreOffset",
        "np",
        "linalg",
        "norm",
        "centreOffset",
        "centrePoint",
        "radius",
        "centreOffset",
        "interior",
        "pUV",
        "centrePoint",
        "radius",
        "centreOffset",
        "nUVmin",
        "nUVmax",
        "p",
        "eCentre",
        "eLocalXaxis",
        "eLocalYaxis",
        "eNormalAxis",
        "eMajorRadius",
        "eMinorRadius",
        "interior",
        "np",
        "array",
        "eLocalXaxis",
        "eLocalYaxis",
        "eNormalAxis",
        "np",
        "matmul",
        "rotM",
        "p",
        "eCentre",
        "np",
        "linalg",
        "norm",
        "p",
        "eCentre",
        "eps",
        "np",
        "array",
        "pUV",
        "pUV",
        "np",
        "arctan2",
        "eMajorRadius",
        "pUV",
        "eMinorRadius",
        "pUV",
        "pUV",
        "eMajorRadius",
        "eMinorRadius",
        "np",
        "linalg",
        "norm",
        "pUV",
        "i",
        "i",
        "radiusConst",
        "np",
        "cos",
        "theta",
        "np",
        "sin",
        "theta",
        "pUV",
        "eMajorRadius",
        "np",
        "sin",
        "theta",
        "pUV",
        "eMinorRadius",
        "np",
        "cos",
        "theta",
        "radiusConst",
        "np",
        "cos",
        "theta",
        "np",
        "sin",
        "theta",
        "pUV",
        "eMajorRadius",
        "np",
        "cos",
        "theta",
        "pUV",
        "eMinorRadius",
        "np",
        "sin",
        "theta",
        "theta",
        "f",
        "f_",
        "np",
        "array",
        "eMajorRadius",
        "np",
        "cos",
        "theta",
        "eMinorRadius",
        "np",
        "sin",
        "theta",
        "np",
        "allclose",
        "n0",
        "n",
        "np",
        "linalg",
        "norm",
        "n",
        "pUVdisp",
        "interior",
        "np",
        "matmul",
        "rotM",
        "T",
        "pUV",
        "eCentre",
        "np",
        "matmul",
        "rotM",
        "T",
        "n",
        "eCentre",
        "np",
        "matmul",
        "rotM",
        "T",
        "np",
        "array",
        "n",
        "n",
        "eCentre",
        "n",
        "nUVmin",
        "nUVmax",
        "vertex0",
        "vertex1",
        "planeNorm",
        "planePoint",
        "precision",
        "eps_STEP_AP21",
        "vertex1",
        "vertex0",
        "np",
        "dot",
        "planeNorm",
        "s",
        "abs",
        "SprojP",
        "precision",
        "np",
        "dot",
        "planeNorm",
        "vertex0",
        "planePoint",
        "SprojP",
        "F",
        "vertex0",
        "np",
        "dot",
        "s",
        "F",
        "pPoint",
        "pNorm",
        "cPoint",
        "cNorm",
        "cRadius",
        "tol",
        "eps_STEP_AP21",
        "np",
        "abs",
        "np",
        "dot",
        "pNorm",
        "cNorm",
        "tol",
        "np",
        "cross",
        "pNorm",
        "cNorm",
        "np",
        "cross",
        "d",
        "pNorm",
        "pPoint",
        "v1",
        "p1",
        "pPoint",
        "np",
        "dot",
        "cNorm",
        "L",
        "np",
        "abs",
        "cosl",
        "tol",
        "L",
        "np",
        "dot",
        "cNorm",
        "pPoint",
        "cPoint",
        "cosl",
        "pPoint",
        "L",
        "l1",
        "d",
        "l1",
        "l2",
        "l2",
        "l1",
        "l2",
        "l1",
        "l2",
        "l1",
        "l2",
        "l1",
        "l1",
        "cPoint",
        "l2",
        "l1",
        "l1",
        "cPoint",
        "l2",
        "l1",
        "l1",
        "cPoint",
        "cPoint",
        "sPoint",
        "sPoint",
        "l1",
        "l1",
        "l1",
        "cPoint",
        "l1",
        "cPoint",
        "l1",
        "cPoint",
        "l1",
        "cRadius",
        "b",
        "b",
        "a",
        "c",
        "i",
        "i",
        "b",
        "a",
        "l1",
        "mu",
        "l2",
        "l1",
        "l1",
        "mu",
        "l2",
        "l1",
        "l1",
        "mu",
        "l2",
        "l1",
        "ipt",
        "i",
        "b",
        "np",
        "sqrt",
        "i",
        "a",
        "l1",
        "mu",
        "l2",
        "l1",
        "l1",
        "mu",
        "l2",
        "l1",
        "l1",
        "mu",
        "l2",
        "l1",
        "b",
        "np",
        "sqrt",
        "i",
        "a",
        "l1",
        "mu",
        "l2",
        "l1",
        "l1",
        "mu",
        "l2",
        "l1",
        "l1",
        "mu",
        "l2",
        "l1",
        "ipt1",
        "ipt2",
        "planeNormal",
        "planePoint",
        "arcCentrePoint",
        "arcRefDir",
        "arcAuxDir",
        "arcNormal",
        "arcRadius",
        "arcVertex1",
        "arcVertex2",
        "intersectPlaneCircle",
        "planePoint",
        "planeNormal",
        "arcCentrePoint",
        "arcNormal",
        "arcRadius",
        "circleIntersectPoints",
        "len",
        "circleIntersectPoints",
        "len",
        "circleIntersectPoints",
        "cip",
        "circleIntersectPoints",
        "pointInArc",
        "cip",
        "arcVertex1",
        "arcVertex2",
        "arcRefDir",
        "arcAuxDir",
        "arcNormal",
        "arcCentrePoint",
        "rotSym",
        "validatedPoints",
        "append",
        "cip",
        "validatedPoints",
        "p",
        "s0",
        "s1",
        "s1",
        "s0",
        "p",
        "s0",
        "np",
        "dot",
        "w",
        "v",
        "c1",
        "s0",
        "np",
        "linalg",
        "norm",
        "w",
        "np",
        "dot",
        "v",
        "v",
        "c2",
        "c1",
        "s1",
        "np",
        "linalg",
        "norm",
        "p",
        "s1",
        "c1",
        "c2",
        "s0",
        "b",
        "v",
        "pb",
        "np",
        "linalg",
        "norm",
        "p",
        "pb",
        "refStr",
        "irregularL",
        "e",
        "i",
        "irregularL",
        "e",
        "flattenList",
        "i",
        "irregularL",
        "irregularL",
        "flattenList",
        "refStr",
        "i",
        "i",
        "sp",
        "isinstance",
        "i",
        "re",
        "match",
        "i",
        "i",
        "sp",
        "i",
        "i",
        "sp",
        "i",
        "sp",
        "v1",
        "v2",
        "centreP",
        "normV",
        "radius",
        "v2",
        "v1",
        "np",
        "cross",
        "v2",
        "v1",
        "normV",
        "midPv",
        "np",
        "linalg",
        "norm",
        "midPv",
        "centreP",
        "midPv",
        "radius",
        "np",
        "cross",
        "normV",
        "midPv",
        "orthoPv",
        "np",
        "linalg",
        "norm",
        "orthoPv",
        "midP",
        "radius",
        "orthoPv",
        "midP",
        "radius",
        "orthoPv",
        "farP",
        "radius",
        "orthoPv",
        "farP",
        "radius",
        "orthoPv",
        "p1",
        "p2",
        "p3",
        "p4",
        "STEPobject",
        "pointRefString",
        "STEPobject",
        "ref2index",
        "pointRefString",
        "np",
        "array",
        "R3",
        "R3",
        "R3",
        "strRef",
        "STEPobj",
        "STEPobj",
        "ref2index",
        "strRef",
        "type_name",
        "STEPobj",
        "ref2index",
        "strRef",
        "STEPobj",
        "ref2index",
        "strRef",
        "offset",
        "STEPobj",
        "ref2index",
        "axisPoint",
        "type_name",
        "CP2point",
        "STEPobj",
        "axisPoint",
        "STEP_entities",
        "ref2index",
        "strRef",
        "offset",
        "STEP_entities",
        "ref2index",
        "auxDir",
        "type_name",
        "CP2point",
        "STEP_entities",
        "auxDir",
        "STEP_entities",
        "ref2index",
        "strRef",
        "offset",
        "STEP_entities",
        "ref2index",
        "refDir",
        "type_name",
        "CP2point",
        "STEP_entities",
        "refDir",
        "axisPoint",
        "auxDir",
        "refDir",
        "strRef",
        "STEPobj",
        "STEPobj",
        "ref2index",
        "strRef",
        "type_name",
        "STEPobj",
        "ref2index",
        "strRef",
        "type_name",
        "cleanSubRefs",
        "STEPobj",
        "ref2index",
        "strRef",
        "STEPobj",
        "ref2index",
        "subRefList",
        "type_name",
        "CP2point",
        "STEPobj",
        "subRefList",
        "len",
        "subRefList",
        "STEPobj",
        "ref2index",
        "subRefList",
        "type_name",
        "CP2point",
        "STEPobj",
        "subRefList",
        "len",
        "subRefList",
        "STEPobj",
        "ref2index",
        "subRefList",
        "type_name",
        "CP2point",
        "STEPobj",
        "subRefList",
        "axisPoint",
        "normDir",
        "refDir",
        "c",
        "curveSampleFactor",
        "c",
        "ctrlpts_size",
        "c",
        "degree",
        "curveSampleFactor",
        "c",
        "knotvector",
        "c",
        "knotvector",
        "numSamples",
        "np",
        "array",
        "c",
        "knotvector",
        "span",
        "i",
        "i",
        "numSamples",
        "c",
        "evaluate_list",
        "kvs",
        "pts",
        "kvs",
        "localCentroid",
        "mPoint",
        "AFSdata",
        "mPoint",
        "v1",
        "v2",
        "v1",
        "mPoint",
        "v1",
        "np",
        "dot",
        "m_v1",
        "sNorm",
        "sNorm",
        "v2",
        "mPoint",
        "v2",
        "np",
        "dot",
        "m_v2",
        "sNorm",
        "sNorm",
        "p_v1",
        "mPoint",
        "p_v2",
        "mPoint",
        "np",
        "sign",
        "np",
        "cross",
        "mppv1",
        "mppv2",
        "dot",
        "sNorm",
        "np",
        "dot",
        "mppv1",
        "mppv2",
        "np",
        "linalg",
        "norm",
        "mppv1",
        "np",
        "linalg",
        "norm",
        "mppv2",
        "np",
        "abs",
        "v1v2cos",
        "eps_STEP_AP21",
        "sign",
        "np",
        "arccos",
        "np",
        "clip",
        "v1v2cos",
        "np",
        "linalg",
        "norm",
        "mPoint",
        "localCentroid",
        "sNormDen",
        "eps_STEP_AP21",
        "mPoint",
        "localCentroid",
        "sNormDen",
        "AFSdata",
        "edge",
        "AFSdata",
        "edge",
        "edge",
        "edge",
        "edge",
        "edge",
        "vertexLoopCount",
        "splineToPolyline",
        "edge",
        "curveSampleFactor",
        "BsplineCurveExtremaDisp",
        "edge",
        "mPoint",
        "maxSearch",
        "uv_xyz",
        "np",
        "array",
        "edge",
        "evaluate_list",
        "nearestSplinePointU",
        "np",
        "linalg",
        "norm",
        "mPoint",
        "nearestSplinePoint",
        "eps_STEP_AP21",
        "np",
        "isclose",
        "nearestSplinePointU",
        "splU",
        "splU",
        "splinePolylineU",
        "np",
        "insert",
        "splinePolylineU",
        "splinePolylineU",
        "searchsorted",
        "nearestSplinePointU",
        "nearestSplinePointU",
        "np",
        "argmin",
        "np",
        "abs",
        "splinePolylineU",
        "nearestSplinePointU",
        "np",
        "array",
        "spl",
        "spl",
        "splinePolyline",
        "np",
        "insert",
        "splinePolyline",
        "iu",
        "nearestSplinePoint",
        "axis",
        "i",
        "len",
        "splinePolyline",
        "edgeTotalAngle",
        "vertexAngle",
        "mPoint",
        "splinePolyline",
        "i",
        "splinePolyline",
        "i",
        "edge",
        "edge",
        "edge",
        "vertexLoopCount",
        "pointCircleMinMaxDisp",
        "mPoint",
        "edge",
        "edge",
        "edge",
        "pointInArc",
        "nearArcPoint",
        "v1",
        "v2",
        "edge",
        "edge",
        "edge",
        "edge",
        "rotSym",
        "edgeTotalAngle",
        "vertexAngle",
        "mPoint",
        "v1",
        "nearArcPoint",
        "edgeTotalAngle",
        "vertexAngle",
        "mPoint",
        "nearArcPoint",
        "v2",
        "edge",
        "edge",
        "edge",
        "vertexLoopCount",
        "pointEllipseMinMaxDisp",
        "mPoint",
        "edge",
        "edge",
        "edge",
        "edge",
        "edge",
        "edge",
        "interior",
        "pointInArc",
        "nearArcPoint",
        "v1",
        "v2",
        "edge",
        "edge",
        "edge",
        "edge",
        "rotSym",
        "edgeTotalAngle",
        "vertexAngle",
        "mPoint",
        "v1",
        "nearArcPoint",
        "edgeTotalAngle",
        "vertexAngle",
        "mPoint",
        "nearArcPoint",
        "v2",
        "edgeTotalAngle",
        "vertexAngle",
        "mPoint",
        "v1",
        "v2",
        "AFS",
        "AFS",
        "np",
        "abs",
        "edgeTotalAngle",
        "np",
        "pi",
        "eps_STEP_AP21",
        "vertexLoopCount",
        "np",
        "array",
        "AFSdata",
        "edge",
        "AFSdata",
        "edge",
        "pointCircleMinMaxDisp",
        "mPoint",
        "edge",
        "edge",
        "edge",
        "curvedEdgeNearestPoint",
        "append",
        "np",
        "array",
        "nearArcPoint",
        "edge",
        "pointEllipseMinMaxDisp",
        "mPoint",
        "edge",
        "edge",
        "edge",
        "edge",
        "edge",
        "edge",
        "curvedEdgeNearestPoint",
        "append",
        "np",
        "array",
        "nearArcPoint",
        "edge",
        "np",
        "array",
        "AFSdata",
        "np",
        "cross",
        "mPoint",
        "axisPoint",
        "normDir",
        "np",
        "cross",
        "planeNorm",
        "normDir",
        "np",
        "dot",
        "axisPoint",
        "mPoint",
        "orthoPlane",
        "splineToPolyline",
        "edge",
        "curveSampleFactor",
        "i",
        "len",
        "sPolyline",
        "intersectSegmentPlane",
        "np",
        "array",
        "sPolyline",
        "i",
        "np",
        "array",
        "sPolyline",
        "i",
        "planeNorm",
        "mPoint",
        "nearArcPoint",
        "nearArcPointSet",
        "append",
        "nearArcPoint",
        "U",
        "append",
        "i",
        "len",
        "nearArcPointSet",
        "len",
        "nearArcPointSet",
        "nearArcPointSet",
        "U",
        "i_naps",
        "naps",
        "nearArcPointSet",
        "np",
        "dot",
        "axisPoint",
        "naps",
        "orthoPlane",
        "napsSign",
        "mSign",
        "naps",
        "U",
        "i_naps",
        "iu",
        "len",
        "sPolylineU",
        "sPolylineU",
        "iu",
        "sPolyline",
        "iu",
        "sPolylineU",
        "iu",
        "sPolyline",
        "iu",
        "hiU",
        "loU",
        "eps_STEP_AP21",
        "loU",
        "hiU",
        "loU",
        "np",
        "array",
        "edge",
        "evaluate_single",
        "midU",
        "intersectSegmentPlane",
        "loP",
        "midP",
        "planeNorm",
        "mPoint",
        "nearArcPoint",
        "midP",
        "midU",
        "intersectSegmentPlane",
        "midP",
        "hiP",
        "planeNorm",
        "mPoint",
        "nearArcPoint",
        "midP",
        "midU",
        "curvedEdgeNearestPoint",
        "append",
        "np",
        "array",
        "nearArcPoint",
        "len",
        "curvedEdgeNearestPoint",
        "curvedEdgeNearestPoint",
        "mPoint",
        "len",
        "curvedEdgeNearestPoint",
        "all",
        "np",
        "dot",
        "mPoint",
        "cenp",
        "normDir",
        "cenp",
        "curvedEdgeNearestPoint",
        "AFS",
        "np",
        "abs",
        "edgeTotalAngle",
        "eps_STEP_AP21",
        "len",
        "AFSdata",
        "np",
        "abs",
        "edgeTotalAngle",
        "np",
        "pi",
        "eps_STEP_AP21",
        "len",
        "AFSdata",
        "AFSdata",
        "edgeTotalAngle",
        "np",
        "pi",
        "eps_STEP_AP21",
        "edgeTotalAngle",
        "edgeTotalAngle",
        "np",
        "pi",
        "eps_STEP_AP21",
        "edgeTotalAngle",
        "localCentroid",
        "ParsedEdge",
        "STEP_entities_",
        "ParsedEdge",
        "cleanSubRefs",
        "edgeType_",
        "cet",
        "cleanEdgeType",
        "STEP_entities_",
        "ref2index",
        "cet",
        "type_name",
        "CP2point",
        "STEP_entities_",
        "cet",
        "linePoint",
        "STEP_entities_",
        "ref2index",
        "cet",
        "type_name",
        "STEP_entities_",
        "ref2index",
        "cet",
        "lineVectorDisp",
        "STEP_entities_",
        "ref2index",
        "cet",
        "STEP_entities_",
        "ref2index",
        "lineVectorDir",
        "type_name",
        "CP2point",
        "STEP_entities_",
        "lineVectorDir",
        "lineVectorDir",
        "pointSegmentMinDisp",
        "localCentroid",
        "ParsedEdge",
        "ParsedEdge",
        "v1ext",
        "v2ext",
        "ParsedEdge",
        "insert",
        "minPoint",
        "ParsedEdge",
        "insert",
        "minPointCentroidDisp",
        "np",
        "linalg",
        "norm",
        "minPoint",
        "ParsedEdge",
        "np",
        "linalg",
        "norm",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "insert",
        "u",
        "localCentroid",
        "ParsedEdge",
        "STEP_entities_",
        "ParsedEdge",
        "edgeType_",
        "radius",
        "axis2Placement3D_2",
        "edgeType_",
        "STEP_entities_",
        "axisPoint",
        "normDir",
        "refDir",
        "np",
        "cross",
        "normDir",
        "refDir",
        "auxDir",
        "np",
        "linalg",
        "norm",
        "auxDir",
        "auxDir",
        "np",
        "dot",
        "localCentroid",
        "axisPoint",
        "normDir",
        "localCentroid",
        "np",
        "dot",
        "Cdisp",
        "normDir",
        "np",
        "linalg",
        "norm",
        "Cproj",
        "axisPoint",
        "pointCircleMinMaxDisp",
        "localCentroid",
        "axisPoint",
        "normDir",
        "radius",
        "interior",
        "ParsedEdge",
        "ParsedEdge",
        "maxPoint",
        "extrema",
        "append",
        "np",
        "array",
        "maxPoint",
        "minPoint",
        "extrema",
        "append",
        "np",
        "array",
        "minPoint",
        "pointOrderInArc",
        "extrema",
        "v1",
        "v2",
        "refDir",
        "auxDir",
        "normDir",
        "axisPoint",
        "pointsInArc",
        "poi",
        "poi",
        "pointOrderIndex",
        "extrema",
        "poi",
        "poi",
        "pointOrderIndex",
        "uArc",
        "poi",
        "poi",
        "pointOrderIndex",
        "i",
        "i",
        "v",
        "extrema",
        "pointsInArc",
        "v",
        "ex_i",
        "ex",
        "extrema",
        "np",
        "isclose",
        "v1",
        "ex",
        "all",
        "np",
        "isclose",
        "v2",
        "ex",
        "all",
        "np",
        "isclose",
        "uArc",
        "ex_i",
        "uu",
        "uu",
        "ParsedEdge",
        "ParsedEdge",
        "insert",
        "ex",
        "ParsedEdge",
        "insert",
        "np",
        "linalg",
        "norm",
        "ex",
        "localCentroid",
        "ParsedEdge",
        "insert",
        "uArc",
        "ex_i",
        "rotSymDisp",
        "eps_STEP_AP21",
        "ParsedEdge",
        "axisPoint",
        "ParsedEdge",
        "radius",
        "ParsedEdge",
        "np",
        "sqrt",
        "radius",
        "np",
        "linalg",
        "norm",
        "axisPoint",
        "localCentroid",
        "localCentroid",
        "ParsedEdge",
        "STEP_entities_",
        "ParsedEdge",
        "cleanSubRefs",
        "edgeType_",
        "cleanEdgeType",
        "majorRadius",
        "cleanEdgeType",
        "minorRadius",
        "axis2Placement3D_2",
        "edgeType_",
        "STEP_entities_",
        "axisPoint",
        "normDir",
        "refDir",
        "np",
        "cross",
        "normDir",
        "refDir",
        "auxDir",
        "np",
        "linalg",
        "norm",
        "auxDir",
        "auxDir",
        "pointEllipseMinMaxDisp",
        "localCentroid",
        "axisPoint",
        "refDir",
        "auxDir",
        "normDir",
        "majorRadius",
        "minorRadius",
        "interior",
        "ParsedEdge",
        "ParsedEdge",
        "maxPoint",
        "minPoint",
        "pointOrderInArc",
        "extrema",
        "v1",
        "v2",
        "refDir",
        "auxDir",
        "normDir",
        "axisPoint",
        "pointsInArc",
        "poi",
        "poi",
        "pointOrderIndex",
        "extrema",
        "poi",
        "poi",
        "pointOrderIndex",
        "uArc",
        "poi",
        "poi",
        "pointOrderIndex",
        "i",
        "i",
        "v",
        "extrema",
        "pointsInArc",
        "v",
        "ex_i",
        "ex",
        "extrema",
        "np",
        "isclose",
        "v1",
        "ex",
        "all",
        "np",
        "isclose",
        "v2",
        "ex",
        "all",
        "ParsedEdge",
        "insert",
        "ex",
        "ParsedEdge",
        "insert",
        "np",
        "linalg",
        "norm",
        "ex",
        "localCentroid",
        "ParsedEdge",
        "insert",
        "uArc",
        "ex_i",
        "localCentroid",
        "ParsedEdge",
        "STEP_entities_",
        "ParsedEdge",
        "edgeType",
        "edgeType",
        "offset",
        "edgeType",
        "offset",
        "edgeType",
        "offset",
        "edgeType",
        "offset",
        "edgeType",
        "offset",
        "edgeType",
        "offset",
        "edgeType",
        "offset",
        "edgeType",
        "offset",
        "curveDegree",
        "controlPointsRefs",
        "curveForm",
        "closedCurve",
        "selfIntersect",
        "knotMultiplicities",
        "knots",
        "knotSpec",
        "cpl",
        "controlPointsRefs",
        "STEP_entities_",
        "ref2index",
        "cpl",
        "type_name",
        "CP2point",
        "STEP_entities_",
        "cleanSubRefs",
        "cpl",
        "controlPoints",
        "append",
        "controlPoint",
        "controlPoints",
        "kml",
        "len",
        "knotMultiplicities",
        "i",
        "knotMultiplicities",
        "kml",
        "knotvector",
        "append",
        "knots",
        "kml",
        "knotvector",
        "len",
        "knotvector",
        "len",
        "controlPoints",
        "curveDegree",
        "NURBS",
        "Curve",
        "curveDegree",
        "BsplineKnotCurve",
        "set_ctrlpts",
        "compatibility",
        "combine_ctrlpts_weights",
        "controlPoints",
        "weights",
        "utilities",
        "generate_knot_vector",
        "BsplineKnotCurve",
        "degree",
        "len",
        "BsplineKnotCurve",
        "ctrlpts",
        "BsplineKnotCurve",
        "BsplineCurveExtremaDisp",
        "BsplineKnotCurve",
        "localCentroid",
        "localExtrema",
        "maxSearch",
        "uv_xyz",
        "BsplineKnotCurve",
        "evaluate_list",
        "maxPointsU",
        "BsplineCurveExtremaDisp",
        "BsplineKnotCurve",
        "localCentroid",
        "localExtrema",
        "maxSearch",
        "uv_xyz",
        "BsplineKnotCurve",
        "evaluate_list",
        "minPointsU",
        "maxPointsU",
        "minPointsU",
        "maxPoints",
        "minPoints",
        "len",
        "maximaPoints",
        "np",
        "argsort",
        "maximaU",
        "maximaU",
        "eui",
        "eui",
        "extremaUindex",
        "maximaPoints",
        "eui",
        "eui",
        "extremaUindex",
        "maximaU",
        "mu",
        "maximaU",
        "mu",
        "eps_STEP_AP21",
        "mu",
        "len",
        "maximaU",
        "maxima_truth",
        "mu",
        "mu",
        "mt",
        "maximaU",
        "maxima_truth",
        "mt",
        "mp",
        "mp",
        "mt",
        "maximaPoints",
        "maxima_truth",
        "mt",
        "np",
        "linalg",
        "norm",
        "mp",
        "localCentroid",
        "mp",
        "maximaPoints",
        "np",
        "linalg",
        "norm",
        "ParsedEdge",
        "localCentroid",
        "np",
        "linalg",
        "norm",
        "ParsedEdge",
        "localCentroid",
        "np",
        "abs",
        "vertex1centroidDisp",
        "centroidDisp",
        "eps_STEP_AP21",
        "maximaU",
        "pop",
        "maximaPoints",
        "pop",
        "centroidDisp",
        "insert",
        "vertex1centroidDisp",
        "np",
        "abs",
        "vertex2centroidDisp",
        "centroidDisp",
        "eps_STEP_AP21",
        "maximaU",
        "pop",
        "maximaPoints",
        "pop",
        "centroidDisp",
        "append",
        "vertex2centroidDisp",
        "ParsedEdge",
        "np",
        "array",
        "ParsedEdge",
        "maximaPoints",
        "ParsedEdge",
        "ParsedEdge",
        "maximaU",
        "ParsedEdge",
        "centroidDisp",
        "np",
        "array",
        "BsplineKnotCurve",
        "ctrlpts",
        "mean",
        "axis",
        "np",
        "linalg",
        "norm",
        "splineMeanPoint",
        "sc",
        "sc",
        "BsplineKnotCurve",
        "ctrlpts",
        "max",
        "np",
        "abs",
        "ctrlptsDelta",
        "eps_STEP_AP21",
        "BsplineKnotCurve",
        "edgeInstance_",
        "STEP_entities_",
        "STEP_entities_",
        "ref2index",
        "edgeInstance_",
        "type_name",
        "STEP_entities_",
        "ref2index",
        "edgeInstance_",
        "VOR",
        "STEP_entities_",
        "ref2index",
        "edgeInstance_",
        "STEP_entities_",
        "ref2index",
        "edgeCurveRef",
        "type_name",
        "STEP_entities_",
        "ref2index",
        "edgeCurveRef",
        "cleanSubRefs",
        "edgeCurveParams",
        "STEP_entities_",
        "ref2index",
        "edgeCurveParams",
        "type_name",
        "STEP_entities_",
        "ref2index",
        "edgeCurveParams",
        "CP2point",
        "STEP_entities_",
        "cleanSubRefs",
        "vertex1",
        "VOR",
        "np",
        "array",
        "vertex1",
        "STEP_entities_",
        "ref2index",
        "edgeCurveParams",
        "np",
        "array",
        "vertex1",
        "STEP_entities_",
        "ref2index",
        "edgeCurveParams",
        "STEP_entities_",
        "ref2index",
        "edgeCurveParams",
        "type_name",
        "STEP_entities_",
        "ref2index",
        "edgeCurveParams",
        "CP2point",
        "STEP_entities_",
        "cleanSubRefs",
        "vertex2",
        "VOR",
        "np",
        "array",
        "vertex2",
        "STEP_entities_",
        "ref2index",
        "edgeCurveParams",
        "np",
        "array",
        "vertex2",
        "STEP_entities_",
        "ref2index",
        "edgeCurveParams",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "np",
        "linalg",
        "norm",
        "centroid",
        "vertex1",
        "np",
        "linalg",
        "norm",
        "centroid",
        "vertex2",
        "ParsedEdge",
        "STEP_entities_",
        "ref2index",
        "edgeCurveParams",
        "STEP_entities_",
        "ref2index",
        "edgeCurveParams",
        "type_name",
        "STEP_entities_",
        "ref2index",
        "edgeCurveParams",
        "edgeTypeName",
        "edgeRef",
        "edgeType",
        "ParsedEdge",
        "c",
        "ParsedEdge",
        "STEP_entities_",
        "ParsedEdge",
        "segmentParse",
        "c",
        "ParsedEdge",
        "STEP_entities_",
        "ParsedEdge",
        "circleParse",
        "c",
        "ParsedEdge",
        "STEP_entities_",
        "ParsedEdge",
        "ellipseParse",
        "c",
        "ParsedEdge",
        "STEP_entities_",
        "ParsedEdge",
        "BsplineCurveWithKnotsParse",
        "c",
        "ParsedEdge",
        "STEP_entities_",
        "ParsedEdge",
        "AFS",
        "localCentroid",
        "minimaExtrema",
        "AFS",
        "get",
        "AFS",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "axis2Placement3D_2",
        "AFS",
        "STEP_entities",
        "np",
        "cross",
        "normDir",
        "refDir",
        "auxDir",
        "np",
        "linalg",
        "norm",
        "auxDir",
        "AFS",
        "radius",
        "centrePoint",
        "normDir",
        "refDir",
        "auxDir",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "minimaExtrema",
        "np",
        "linalg",
        "norm",
        "centrePoint",
        "localCentroid",
        "sphereCentroidOffset",
        "eps_STEP_AP21",
        "ParsedSurface",
        "centrePoint",
        "ParsedSurface",
        "radius",
        "centrePoint",
        "localCentroid",
        "sphereCentroidOffset",
        "centrePoint",
        "sphereCentreCentroidDir",
        "radius",
        "centrePoint",
        "sphereCentreCentroidDir",
        "radius",
        "insideOutsideSurfaceTest",
        "localCentroid",
        "maxPoint",
        "AFS",
        "ParsedSurface",
        "append",
        "maxPoint",
        "ParsedSurface",
        "append",
        "np",
        "linalg",
        "norm",
        "maxPoint",
        "localCentroid",
        "ParsedSurface",
        "append",
        "ParsedSurface",
        "append",
        "insideOutsideSurfaceTest",
        "localCentroid",
        "minPoint",
        "AFS",
        "ParsedSurface",
        "append",
        "minPoint",
        "ParsedSurface",
        "append",
        "np",
        "linalg",
        "norm",
        "minPoint",
        "localCentroid",
        "ParsedSurface",
        "append",
        "ParsedSurface",
        "append",
        "ParsedSurface",
        "AFS",
        "localCentroid",
        "minimaExtrema",
        "AFS",
        "get",
        "AFS",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "axis2Placement3D_2",
        "AFS",
        "STEP_entities",
        "np",
        "cross",
        "normDir",
        "refDir",
        "auxDir",
        "np",
        "linalg",
        "norm",
        "auxDir",
        "AFS",
        "AFS",
        "axisPoint",
        "normDir",
        "refDir",
        "auxDir",
        "minorRadius",
        "majorRadius",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "minimaExtrema",
        "np",
        "linalg",
        "norm",
        "centroid",
        "axisPoint",
        "np",
        "dot",
        "centroid",
        "axisPoint",
        "normDir",
        "normDir",
        "rotSymDisp",
        "eps_STEP_AP21",
        "ParsedEdge",
        "axisPoint",
        "pointCircleMinMaxDisp",
        "localCentroid",
        "axisPoint",
        "normDir",
        "majorRadius",
        "majorMinPoint",
        "axisPoint",
        "np",
        "linalg",
        "norm",
        "majorMinPoint",
        "axisPoint",
        "np",
        "cross",
        "majorMinRadialDir",
        "normDir",
        "majorMinTangentDir",
        "np",
        "linalg",
        "norm",
        "majorMinTangentDir",
        "pointCircleMinMaxDisp",
        "localCentroid",
        "majorMinPoint",
        "majorMinTangentDir",
        "minorRadius",
        "majorMaxPoint",
        "axisPoint",
        "np",
        "linalg",
        "norm",
        "majorMaxPoint",
        "axisPoint",
        "np",
        "cross",
        "majorMaxRadialDir",
        "auxDir",
        "majorMaxTangentDir",
        "np",
        "linalg",
        "norm",
        "majorMaxTangentDir",
        "pointCircleMinMaxDisp",
        "localCentroid",
        "majorMaxPoint",
        "majorMaxTangentDir",
        "minorRadius",
        "insideOutsideSurfaceTest",
        "localCentroid",
        "minorMaxPoint",
        "AFS",
        "ParsedSurface",
        "append",
        "minorMaxPoint",
        "ParsedSurface",
        "append",
        "np",
        "linalg",
        "norm",
        "minorMaxPoint",
        "localCentroid",
        "ParsedSurface",
        "append",
        "ParsedSurface",
        "append",
        "insideOutsideSurfaceTest",
        "localCentroid",
        "minorMinPoint",
        "AFS",
        "ParsedSurface",
        "append",
        "minorMinPoint",
        "ParsedSurface",
        "append",
        "np",
        "linalg",
        "norm",
        "minorMinPoint",
        "localCentroid",
        "ParsedSurface",
        "append",
        "ParsedSurface",
        "append",
        "ParsedSurface",
        "AFS",
        "localCentroid",
        "minimaExtrema",
        "AFS",
        "get",
        "AFS",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "axis2Placement3D_2",
        "AFS",
        "STEP_entities",
        "np",
        "cross",
        "normDir",
        "refDir",
        "auxDir",
        "np",
        "linalg",
        "norm",
        "auxDir",
        "AFS",
        "radius",
        "axisPoint",
        "normDir",
        "refDir",
        "auxDir",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "minimaExtrema",
        "np",
        "linalg",
        "norm",
        "localCentroid",
        "axisPoint",
        "np",
        "dot",
        "localCentroid",
        "axisPoint",
        "normDir",
        "normDir",
        "rotSymDisp",
        "eps_STEP_AP21",
        "localCentroid",
        "edge",
        "AFS",
        "cd",
        "edge",
        "np",
        "isclose",
        "cd",
        "radius",
        "eps",
        "edgeMinimaCount",
        "edgeMinimaCount",
        "ParsedSurface",
        "localCentroid",
        "ParsedSurface",
        "radius",
        "pointProjectAxis",
        "localCentroid",
        "axisPoint",
        "normDir",
        "centroidProjAxisPoint",
        "localCentroid",
        "np",
        "linalg",
        "norm",
        "centroidAxisDir",
        "centroidAxisDir",
        "centroidAxisDisp",
        "centroidAxisDisp",
        "radius",
        "centroidAxisDir",
        "np",
        "linalg",
        "norm",
        "localCentroid",
        "smp",
        "np",
        "linalg",
        "norm",
        "localCentroid",
        "smp",
        "localCentroid",
        "smp",
        "localCentroid",
        "smp",
        "insideOutsideSurfaceTest",
        "localCentroid",
        "surfaceMinPoint",
        "AFS",
        "ParsedSurface",
        "append",
        "surfaceMinPoint",
        "ParsedSurface",
        "append",
        "np",
        "linalg",
        "norm",
        "surfaceMinPoint",
        "localCentroid",
        "ParsedSurface",
        "append",
        "ParsedSurface",
        "append",
        "ParsedSurface",
        "AFS",
        "localCentroid",
        "minimaExtrema",
        "AFS",
        "get",
        "AFS",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "axis2Placement3D_2",
        "AFS",
        "STEP_entities",
        "np",
        "cross",
        "normDir",
        "refDir",
        "auxDir",
        "np",
        "linalg",
        "norm",
        "auxDir",
        "AFS",
        "AFS",
        "axisPoint",
        "normDir",
        "refDir",
        "auxDir",
        "semiAngle",
        "radius",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "minimaExtrema",
        "np",
        "linalg",
        "norm",
        "localCentroid",
        "axisPoint",
        "np",
        "dot",
        "localCentroid",
        "axisPoint",
        "normDir",
        "normDir",
        "radius",
        "np",
        "tan",
        "semiAngle",
        "axisPoint",
        "axisPointApexDisp",
        "normDir",
        "np",
        "linalg",
        "norm",
        "centroid",
        "apexPoint",
        "np",
        "linalg",
        "norm",
        "centroid",
        "axisPoint",
        "insideOutsideSurfaceTest",
        "localCentroid",
        "apexPoint",
        "AFS",
        "ParsedEdge",
        "apexPoint",
        "ParsedEdge",
        "rotSymDisp",
        "eps_STEP_AP21",
        "np",
        "cross",
        "apexPoint",
        "localCentroid",
        "apexPoint",
        "axisPoint",
        "minPlaneNorm",
        "np",
        "linalg",
        "norm",
        "minPlaneNorm",
        "np",
        "dot",
        "rotationMatrix",
        "minPlaneNorm",
        "semiAngle",
        "apexPoint",
        "axisPoint",
        "coneEdgeCW",
        "np",
        "linalg",
        "norm",
        "coneEdgeCW",
        "pointProjectAxis",
        "localCentroid",
        "apexPoint",
        "coneEdgeCW",
        "np",
        "dot",
        "rotationMatrix",
        "minPlaneNorm",
        "semiAngle",
        "apexPoint",
        "axisPoint",
        "coneEdgeCCW",
        "np",
        "linalg",
        "norm",
        "coneEdgeCCW",
        "pointProjectAxis",
        "localCentroid",
        "apexPoint",
        "coneEdgeCCW",
        "np",
        "linalg",
        "norm",
        "localCentroid",
        "coneMinCW",
        "np",
        "linalg",
        "norm",
        "localCentroid",
        "coneMinCCW",
        "coneMinCCW",
        "coneMinCW",
        "insideOutsideSurfaceTest",
        "localCentroid",
        "coneMin",
        "AFS",
        "ParsedSurface",
        "append",
        "coneMin",
        "ParsedSurface",
        "append",
        "np",
        "linalg",
        "norm",
        "coneMin",
        "localCentroid",
        "ParsedSurface",
        "append",
        "ParsedSurface",
        "append",
        "np",
        "linalg",
        "norm",
        "centroid",
        "apexPoint",
        "np",
        "cos",
        "semiAngle",
        "apexPoint",
        "coneMinimaCentreDisp",
        "normDir",
        "np",
        "linalg",
        "norm",
        "centroid",
        "apexPoint",
        "np",
        "sin",
        "semiAngle",
        "edge",
        "AFS",
        "cd",
        "edge",
        "np",
        "isclose",
        "cd",
        "rotSymCentroidDisp",
        "eps_STEP_AP21",
        "edgeMinimaCount",
        "edgeMinimaCount",
        "ParsedSurface",
        "coneMinimaCentrePoint",
        "ParsedSurface",
        "np",
        "linalg",
        "norm",
        "coneMinimaCentrePoint",
        "apexPoint",
        "np",
        "tan",
        "semiAngle",
        "ParsedSurface",
        "AFS",
        "localCentroid",
        "STEP_entities_",
        "minimaExtrema",
        "AFS",
        "get",
        "AFS",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "AFS",
        "AFS",
        "offset",
        "AFS",
        "offset",
        "AFS",
        "offset",
        "AFS",
        "offset",
        "AFS",
        "offset",
        "AFS",
        "offset",
        "AFS",
        "offset",
        "AFS",
        "offset",
        "AFS",
        "offset",
        "AFS",
        "offset",
        "AFS",
        "offset",
        "AFS",
        "offset",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "surfaceUdegree",
        "surfaceVdegree",
        "controlPointsRefs",
        "surfaceForm",
        "closedU",
        "closedV",
        "selfIntersect",
        "knotUmultiplicities",
        "knotVmultiplicities",
        "knotsU",
        "knotsV",
        "knotSpec",
        "len",
        "controlPointsRefs",
        "len",
        "controlPointsRefs",
        "cplU",
        "controlPointsRefs",
        "cplV",
        "cplU",
        "STEP_entities_",
        "ref2index",
        "cplV",
        "type_name",
        "controlPoints",
        "append",
        "CP2point",
        "STEP_entities_",
        "cleanSubRefs",
        "cplV",
        "controlPoints",
        "kml",
        "len",
        "knotUmultiplicities",
        "i",
        "knotUmultiplicities",
        "kml",
        "STEPknotUvector",
        "append",
        "knotsU",
        "kml",
        "STEPknotUvector",
        "len",
        "STEPknotUvector",
        "len",
        "controlPoints",
        "surfaceUdegree",
        "kml",
        "len",
        "knotVmultiplicities",
        "i",
        "knotVmultiplicities",
        "kml",
        "STEPknotVvector",
        "append",
        "knotsV",
        "kml",
        "STEPknotVvector",
        "len",
        "STEPknotVvector",
        "len",
        "controlPoints",
        "surfaceVdegree",
        "NURBS",
        "Surface",
        "surfaceUdegree",
        "surfaceVdegree",
        "controlPointsLenU",
        "controlPointsLenV",
        "compatibility",
        "combine_ctrlpts_weights",
        "controlPoints",
        "weights",
        "BsplineKnotSurface",
        "set_ctrlpts",
        "ctrlptsw",
        "controlPointsLenU",
        "controlPointsLenV",
        "utilities",
        "generate_knot_vector",
        "surfaceUdegree",
        "controlPointsLenU",
        "utilities",
        "generate_knot_vector",
        "surfaceVdegree",
        "controlPointsLenV",
        "BsplineKnotSurface",
        "minimaExtrema",
        "ParsedSurface",
        "rationalSurfaceExtremaParam_5",
        "BsplineKnotSurface",
        "localCentroid",
        "maxSearch",
        "localExtrema",
        "curvatureTest",
        "uv_xyz",
        "BsplineKnotSurface",
        "evaluate_list",
        "maxPointsUV",
        "rationalSurfaceExtremaParam_5",
        "BsplineKnotSurface",
        "localCentroid",
        "maxSearch",
        "localExtrema",
        "curvatureTest",
        "uv_xyz",
        "BsplineKnotSurface",
        "evaluate_list",
        "minPointsUV",
        "len",
        "maxPoints",
        "len",
        "minPoints",
        "len",
        "maxPoints",
        "len",
        "minPoints",
        "np",
        "array",
        "maxPointsUV",
        "minPointsUV",
        "np",
        "array",
        "maxPoints",
        "minPoints",
        "len",
        "maximaPoints",
        "maximaUV",
        "ravel",
        "view",
        "dtype",
        "maximaUV",
        "dtype",
        "maximaUV",
        "dtype",
        "np",
        "argsort",
        "maximaUV_field",
        "order",
        "maximaUV",
        "euvi",
        "euvi",
        "extremaUVindex",
        "maximaPoints",
        "euvi",
        "euvi",
        "extremaUVindex",
        "maxima",
        "euvi",
        "euvi",
        "extremaUVindex",
        "minima",
        "euvi",
        "euvi",
        "extremaUVindex",
        "np",
        "allclose",
        "maximaUV",
        "mu",
        "maximaUV",
        "mu",
        "eps_STEP_AP21",
        "mu",
        "len",
        "maximaUV",
        "maxima_truth",
        "mu",
        "mu",
        "mt",
        "maximaUV",
        "maxima_truth",
        "mt",
        "mp",
        "mp",
        "mt",
        "maximaPoints",
        "maxima_truth",
        "mt",
        "ParsedSurface",
        "maximaPoints",
        "ParsedSurface",
        "maximaUV",
        "ParsedSurface",
        "np",
        "linalg",
        "norm",
        "mp",
        "localCentroid",
        "mp",
        "maximaPoints",
        "ParsedSurface",
        "maxima",
        "ParsedSurface",
        "minima",
        "np",
        "array",
        "np",
        "array",
        "s",
        "mean",
        "axis",
        "s",
        "BsplineKnotSurface",
        "ctrlpts2d",
        "s",
        "len",
        "spinePoints",
        "np",
        "linalg",
        "norm",
        "spinePoints",
        "s",
        "sc",
        "sc",
        "BsplineKnotSurface",
        "ctrlpts2d",
        "s",
        "rowDelta",
        "append",
        "max",
        "ctrlptsRowDisp",
        "min",
        "ctrlptsRowDisp",
        "spinePoints",
        "mean",
        "axis",
        "np",
        "linalg",
        "svd",
        "spinePoints",
        "spinePointsMean",
        "vv",
        "spinePointsMean",
        "s",
        "spinePointsMean",
        "s",
        "spinePoints",
        "np",
        "dot",
        "spineDir",
        "spineDir",
        "np",
        "dot",
        "s",
        "spineDir",
        "spineIP",
        "s",
        "spinePointDir",
        "spinePointsMean",
        "pspd",
        "spineDir",
        "pspd",
        "projSpinePointDir",
        "np",
        "linalg",
        "norm",
        "projSpinePoint",
        "n",
        "spinePoints",
        "n",
        "n",
        "len",
        "spinePoints",
        "max",
        "rowDelta",
        "eps_STEP_AP21",
        "max",
        "spineDeviations",
        "eps_STEP_AP21",
        "ParsedSurface",
        "spinePointsMean",
        "ParsedSurface",
        "AFS",
        "localCentroid",
        "minimaExtrema",
        "AFS",
        "get",
        "AFS",
        "ParsedSurface",
        "ParsedSurface",
        "axis2Placement3D_2",
        "AFS",
        "STEP_entities",
        "axisPoint",
        "normDir",
        "refDir",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "minimaExtrema",
        "ParsedSurface",
        "localCentroid",
        "np",
        "dot",
        "localCentroid",
        "axisPoint",
        "normDir",
        "normDir",
        "insideOutsideSurfaceTest",
        "localCentroid",
        "surfaceMinPoint",
        "AFS",
        "ParsedSurface",
        "surfaceMinPoint",
        "ParsedSurface",
        "np",
        "linalg",
        "norm",
        "surfaceMinPoint",
        "localCentroid",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "AFS",
        "c",
        "STEP_entities",
        "minimaExtrema",
        "AFS",
        "AFS",
        "AFS",
        "sphereSurfaceParse",
        "AFS",
        "c",
        "minimaExtrema",
        "AFS",
        "toroidSurfaceParse",
        "AFS",
        "c",
        "minimaExtrema",
        "AFS",
        "cylinderSurfaceParse",
        "AFS",
        "c",
        "minimaExtrema",
        "AFS",
        "coneSurfaceParse",
        "AFS",
        "c",
        "minimaExtrema",
        "AFS",
        "planeSurfaceParse_2",
        "AFS",
        "c",
        "minimaExtrema",
        "AFS",
        "BSplineSurfaceWithKnotsParse",
        "AFS",
        "c",
        "STEP_entities",
        "minimaExtrema",
        "se",
        "STEP_entities",
        "hasattr",
        "se",
        "se",
        "type_name",
        "se",
        "type_name",
        "se",
        "cleanSubRefs",
        "se",
        "SurfaceNormalOutwards",
        "se2",
        "afRefs",
        "hasattr",
        "STEP_entities",
        "ref2index",
        "se2",
        "STEP_entities",
        "ref2index",
        "se2",
        "type_name",
        "afTypeName",
        "afTypeName",
        "STEP_entities",
        "ref2index",
        "se2",
        "cleanSubRefs",
        "se3",
        "STEP_entities",
        "ref2index",
        "se3",
        "type_name",
        "STEP_entities",
        "ref2index",
        "se3",
        "afTypeName",
        "se2",
        "STEP_entities",
        "ref2index",
        "se2",
        "hasattr",
        "STEP_entities",
        "ref2index",
        "se2",
        "AdvancedFaceSurfaces",
        "append",
        "SurfaceClass",
        "ABSR",
        "STEP_entities",
        "hasattr",
        "ABSR",
        "ABSR",
        "type_name",
        "cleanSubRefs",
        "ABSR",
        "STEP_entities",
        "ref2index",
        "cleanABSR",
        "type_name",
        "cleanSubRefs",
        "STEP_entities",
        "ref2index",
        "cleanABSR",
        "vp",
        "STEP_entities",
        "hasattr",
        "vp",
        "vp",
        "type_name",
        "len",
        "vp",
        "vp",
        "ABSRpointRef",
        "outermostPoints",
        "append",
        "np",
        "array",
        "vp",
        "vp",
        "vp",
        "medianPoint",
        "outermostPoints",
        "AFS",
        "AdvancedFaceSurfaces",
        "AFS",
        "edgeRefInstance",
        "EdgeLoops",
        "edgeSTEPparse",
        "edgeRefInstance",
        "STEP_entities",
        "edgeParse",
        "centroid",
        "ParsedEdge",
        "STEP_entities",
        "ParsedEdgeLoop",
        "append",
        "ParsedEdge",
        "ParsedEdge",
        "cleanSubRefs",
        "ParsedEdge",
        "STEP_entities",
        "ref2index",
        "cleanEdgeType",
        "type_name",
        "ParsedEdge",
        "STEP_entities",
        "ref2index",
        "cleanEdgeType",
        "ParsedEdge",
        "edgeRef",
        "ParsedEdge",
        "STEP_entities",
        "ref2index",
        "cleanEdgeType",
        "ParsedEdge",
        "STEP_entities",
        "ref2index",
        "edgeRef",
        "type_name",
        "edgeParse",
        "centroid",
        "ParsedEdge",
        "STEP_entities",
        "ParsedEdge",
        "pel",
        "pel",
        "ParsedEdgeLoop",
        "ParsedEdgeLoop",
        "append",
        "ParsedEdge",
        "cet",
        "cleanEdgeType",
        "STEP_entities",
        "ref2index",
        "cet",
        "type_name",
        "STEP_entities",
        "ref2index",
        "cet",
        "surfaceRef",
        "AFS2",
        "AFS2",
        "AdvancedFaceSurfaces",
        "ParsedEdgeLoop",
        "surfaceParse",
        "AFS",
        "centroid",
        "STEP_entities",
        "Surfaces",
        "AFS",
        "Surfaces",
        "AFS",
        "get",
        "AFS",
        "get",
        "outermostPoints",
        "append",
        "mp",
        "mp",
        "AFS",
        "edge",
        "AFS",
        "edge",
        "get",
        "edge",
        "get",
        "outermostPoints",
        "append",
        "mp",
        "mp",
        "edge",
        "medianPoint",
        "outermostPoints",
        "centroid",
        "medianOfFeaturePoints",
        "AdvancedFaceSurfaces",
        "np",
        "linalg",
        "norm",
        "lastCentroid",
        "centroid",
        "eps",
        "AFS",
        "AdvancedFaceSurfaces",
        "edge",
        "AFS",
        "edgeParse",
        "centroid",
        "edge",
        "STEP_entities",
        "surfaceParse",
        "AFS",
        "centroid",
        "STEP_entities",
        "minimaExtrema",
        "centroid",
        "medianOfFeaturePoints",
        "AdvancedFaceSurfaces",
        "np",
        "linalg",
        "norm",
        "lastCentroid",
        "centroid",
        "centroid",
        "surfaceParse",
        "AFS",
        "centroid",
        "STEP_entities",
        "minimaExtrema",
        "A",
        "color",
        "i",
        "xyz",
        "A",
        "format",
        "i",
        "xyz",
        "xyz",
        "xyz",
        "color",
        "color",
        "color",
        "AFS",
        "afs_index",
        "afs",
        "AFS",
        "se_index",
        "se",
        "afs",
        "sRef",
        "se",
        "get",
        "sRef",
        "se",
        "sRef",
        "sRef",
        "afs2_index",
        "afs2",
        "AFS",
        "te_index",
        "te",
        "afs2",
        "et",
        "et",
        "te",
        "values",
        "et",
        "ref1",
        "te_strings",
        "tRef",
        "te",
        "get",
        "tRef",
        "te",
        "tRef",
        "ref2",
        "ref1",
        "se",
        "indexDictName",
        "afs2_index",
        "te_index",
        "parseAdjacentFeatures",
        "AdvancedFaceSurfaces",
        "AFS",
        "AFSindex",
        "AFS",
        "AdvancedFaceSurfaces",
        "edge",
        "AFS",
        "edge",
        "get",
        "edge",
        "get",
        "edge",
        "get",
        "edge",
        "rsf",
        "len",
        "edge",
        "allRotSymFeatures",
        "append",
        "edge",
        "rsf",
        "allRotSymFeatures",
        "append",
        "edge",
        "rsf",
        "allRotSymFeatures",
        "append",
        "edge",
        "allRotSymFeatures",
        "append",
        "edge",
        "allRotSymFeatures",
        "append",
        "edge",
        "allRotSymFeatures",
        "append",
        "edge",
        "AFS",
        "get",
        "AFS",
        "get",
        "AFS",
        "get",
        "AFS",
        "rsf",
        "len",
        "AFS",
        "allRotSymFeatures",
        "append",
        "AFS",
        "rsf",
        "allRotSymFeatures",
        "append",
        "AFS",
        "rsf",
        "allRotSymFeatures",
        "append",
        "AFS",
        "allRotSymFeatures",
        "append",
        "AFS",
        "allRotSymFeatures",
        "append",
        "AFS",
        "allRotSymFeatures",
        "append",
        "AFS",
        "len",
        "allRotSymFeatures",
        "allRotSymFeatures",
        "arfsc",
        "len",
        "allRotSymFeatures",
        "np",
        "allclose",
        "np",
        "abs",
        "allRotSymFeatures",
        "arfsc",
        "np",
        "abs",
        "nds",
        "eps",
        "nds",
        "normDirSet",
        "normDirSet",
        "append",
        "allRotSymFeatures",
        "arfsc",
        "ndc",
        "normDirSet",
        "arfsc",
        "len",
        "allRotSymFeatures",
        "np",
        "allclose",
        "np",
        "abs",
        "allRotSymFeatures",
        "arfsc",
        "np",
        "abs",
        "ndc",
        "eps",
        "axisUniqueSet",
        "append",
        "arfsc",
        "superAxisUniqueSet",
        "append",
        "axisUniqueSet",
        "saus",
        "superAxisUniqueSet",
        "np",
        "linalg",
        "norm",
        "allRotSymFeatures",
        "s",
        "centroid",
        "s",
        "saus",
        "saus",
        "centreDisps",
        "index",
        "max",
        "centreDisps",
        "np",
        "linalg",
        "norm",
        "allRotSymFeatures",
        "s",
        "allRotSymFeatures",
        "maxCentreDisps",
        "s",
        "saus",
        "np",
        "argsort",
        "axisDisps",
        "saus",
        "ads",
        "ads",
        "axisDispsSorted",
        "centreDisps",
        "ads",
        "ads",
        "axisDispsSorted",
        "allRotSymFeatures",
        "s",
        "s",
        "saus",
        "allRotSymFeatures",
        "s",
        "s",
        "saus",
        "superAxesSet",
        "append",
        "axisSet",
        "sas",
        "superAxesSet",
        "sas",
        "sas",
        "sas",
        "s",
        "len",
        "sas",
        "np",
        "allclose",
        "sas",
        "s",
        "sas",
        "s",
        "eps",
        "np",
        "isclose",
        "sas",
        "s",
        "sas",
        "s",
        "eps",
        "axisSet2",
        "append",
        "sas",
        "s",
        "axisSet2",
        "append",
        "sas",
        "s",
        "axisSet2",
        "append",
        "sas",
        "s",
        "superAxesSet2",
        "append",
        "axisSet2",
        "superAxesSet2",
        "sas",
        "superAxesSet",
        "len",
        "sas",
        "len",
        "sas",
        "sas",
        "s",
        "len",
        "sas",
        "sas",
        "s",
        "sas",
        "s",
        "sas",
        "s",
        "sas",
        "s",
        "sas",
        "sas",
        "sas",
        "s",
        "sas",
        "s",
        "sas",
        "s",
        "sas",
        "s",
        "sas",
        "sas",
        "sas",
        "superAxesSet",
        "getRotSymFeatures",
        "AdvancedFaceSurfaces",
        "AdvancedFaceSurface",
        "AdvancedFaceSurfaces",
        "extremaType",
        "v",
        "AFSindex",
        "AFS",
        "AdvancedFaceSurfaces",
        "edge",
        "AFS",
        "edge",
        "get",
        "edge",
        "edge",
        "get",
        "v",
        "edge",
        "vertexXref",
        "v",
        "extrema",
        "keys",
        "v",
        "edge",
        "vertexXref",
        "v",
        "extrema",
        "keys",
        "vseRef",
        "edge",
        "vertexXref_surroundIndex",
        "v",
        "keys",
        "adjacentEdgeRefs",
        "append",
        "vseRef",
        "edge",
        "vertexXref_surroundIndex",
        "v",
        "vseRef",
        "AdvancedFaceSurfaces",
        "vse",
        "vse",
        "AdvancedFaceSurfaces",
        "vse",
        "vse",
        "vertexXref",
        "v",
        "edge",
        "vertexXref",
        "v",
        "pfSurround",
        "append",
        "adjPF",
        "reversedOrder",
        "append",
        "adjPF",
        "copy",
        "reversePF",
        "reverse",
        "adjPF",
        "copy",
        "reversePF",
        "reverse",
        "adjPF",
        "copy",
        "reversePF",
        "reverse",
        "pfSurround",
        "append",
        "reversePF",
        "reversedOrder",
        "append",
        "extremaType",
        "all",
        "pfs",
        "pfs",
        "eps_STEP_AP21",
        "pfs",
        "pfSurround",
        "array3x1match",
        "edge",
        "vertexX",
        "v",
        "pointFeatures",
        "pointFeatures",
        "append",
        "edge",
        "vertexX",
        "v",
        "pointFeatures",
        "append",
        "pfSurround",
        "pointFeatures",
        "append",
        "pointFeatures",
        "append",
        "extremaType",
        "all",
        "pfs",
        "pfs",
        "eps_STEP_AP21",
        "pfs",
        "pfSurround",
        "array3x1match",
        "edge",
        "vertexX",
        "v",
        "pointFeatures",
        "pointFeatures",
        "append",
        "edge",
        "vertexX",
        "v",
        "pointFeatures",
        "append",
        "pfSurround",
        "pointFeatures",
        "append",
        "pointFeatures",
        "append",
        "max",
        "len",
        "pfs",
        "pfs",
        "pfSurround",
        "maxPFlen",
        "crawlindex",
        "maxPFlen",
        "pfsIndex",
        "pfs",
        "pfSurround",
        "crawlindex",
        "len",
        "pfs",
        "pfs",
        "crawlindex",
        "pfs",
        "crawlindex",
        "pfs",
        "crawlindex",
        "reversedOrder",
        "pfsIndex",
        "len",
        "pfs",
        "crawlindex",
        "crawlindex",
        "extremaType",
        "pfcd1",
        "pfcd0",
        "eps_STEP_AP21",
        "pfcd1",
        "pfcd2",
        "eps_STEP_AP21",
        "array3x1match",
        "pfs",
        "u",
        "pointFeatures",
        "pointFeatures",
        "append",
        "pfs",
        "u",
        "pointFeatures",
        "append",
        "pfcd1",
        "pointFeatures",
        "append",
        "pointFeatures",
        "append",
        "extremaType",
        "pfcd1",
        "pfcd0",
        "eps_STEP_AP21",
        "pfcd1",
        "pfcd2",
        "eps_STEP_AP21",
        "array3x1match",
        "pfs",
        "u",
        "pointFeatures",
        "pointFeatures",
        "append",
        "pfs",
        "u",
        "pointFeatures",
        "append",
        "pfcd1",
        "pointFeatures",
        "append",
        "pointFeatures",
        "append",
        "crawlindex",
        "pointFeatures",
        "vertexExtremaSearch",
        "AdvancedFaceSurfaces",
        "extremaType",
        "vertexExtremaSearch",
        "AdvancedFaceSurfaces",
        "extremaType",
        "v",
        "AFSindex",
        "AFS",
        "AdvancedFaceSurfaces",
        "edge",
        "AFS",
        "edge",
        "get",
        "edge",
        "edge",
        "get",
        "v",
        "edge",
        "vertexXref",
        "v",
        "extrema",
        "keys",
        "v",
        "edge",
        "vertexXref",
        "v",
        "extrema",
        "keys",
        "vseRef",
        "edge",
        "vertexXref_surroundIndex",
        "v",
        "keys",
        "adjacentEdgeRefs",
        "append",
        "vseRef",
        "edge",
        "vertexXref_surroundIndex",
        "v",
        "vseRef",
        "AdvancedFaceSurfaces",
        "vse",
        "vse",
        "AdvancedFaceSurfaces",
        "vse",
        "vse",
        "vertexXref",
        "v",
        "edge",
        "vertexXref",
        "v",
        "pfSurround",
        "append",
        "adjPF",
        "reversedOrder",
        "append",
        "adjPF",
        "copy",
        "reversePF",
        "reverse",
        "adjPF",
        "copy",
        "reversePF",
        "reverse",
        "adjPF",
        "copy",
        "reversePF",
        "reverse",
        "pfSurround",
        "append",
        "reversePF",
        "reversedOrder",
        "append",
        "extremaType",
        "all",
        "pfs",
        "pfs",
        "eps_STEP_AP21",
        "pfs",
        "pfSurround",
        "array3x1match",
        "edge",
        "vertexX",
        "v",
        "surfaceMaxPoint",
        "surfaceMaxPoint",
        "append",
        "edge",
        "vertexX",
        "v",
        "surfaceMaxFeatureCentroidDisp",
        "append",
        "pfSurround",
        "extremaType",
        "all",
        "pfs",
        "pfs",
        "eps_STEP_AP21",
        "pfs",
        "pfSurround",
        "array3x1match",
        "edge",
        "vertexX",
        "v",
        "surfaceMinPoint",
        "surfaceMinPoint",
        "append",
        "edge",
        "vertexX",
        "v",
        "surfaceMinFeatureCentroidDisp",
        "append",
        "pfSurround",
        "max",
        "len",
        "pfs",
        "pfs",
        "pfSurround",
        "maxPFlen",
        "crawlindex",
        "maxPFlen",
        "pfsIndex",
        "pfs",
        "pfSurround",
        "crawlindex",
        "len",
        "pfs",
        "pfs",
        "crawlindex",
        "pfs",
        "crawlindex",
        "pfs",
        "crawlindex",
        "reversedOrder",
        "pfsIndex",
        "len",
        "pfs",
        "crawlindex",
        "crawlindex",
        "extremaType",
        "pfcd1",
        "pfcd0",
        "eps_STEP_AP21",
        "pfcd1",
        "pfcd2",
        "eps_STEP_AP21",
        "array3x1match",
        "pfs",
        "u",
        "surfaceMaxPoint",
        "surfaceMaxPoint",
        "append",
        "pfs",
        "u",
        "surfaceMaxFeatureCentroidDisp",
        "append",
        "pfcd1",
        "extremaType",
        "pfcd1",
        "pfcd0",
        "eps_STEP_AP21",
        "pfcd1",
        "pfcd2",
        "eps_STEP_AP21",
        "array3x1match",
        "pfs",
        "u",
        "surfaceMinPoint",
        "surfaceMinPoint",
        "append",
        "pfs",
        "u",
        "surfaceMinFeatureCentroidDisp",
        "append",
        "pfcd1",
        "crawlindex",
        "AFS",
        "AdvancedFaceSurfaces",
        "AFS",
        "get",
        "index_xyz",
        "xyz",
        "AFS",
        "array3x1match",
        "xyz",
        "surfacePointFeature",
        "surfacePointFeature",
        "append",
        "xyz",
        "surfacePointFeature",
        "append",
        "AFS",
        "index_xyz",
        "surfacePointFeature",
        "append",
        "AFS",
        "index_xyz",
        "surfacePointFeature",
        "append",
        "AFS",
        "index_xyz",
        "AFS",
        "AFS",
        "AFS",
        "AFS"
    ],
    "literals": [
        "\"Point\"",
        "\"x y z\"",
        "\"rotationMatrix() zero div error (0,0,0)?\"",
        "\"input type error\"",
        "\"medianPoint() malformed input\"",
        "\"pointDisp second variable must be single point\"",
        "\"pointDisp error\"",
        "r\"/media/foobert/Dell2HDD/PY_DELL2/SWKS_Rhino_compare_circle/primitives\"",
        "r\"/home/foobert/STEP_test_files/primitives\"",
        "r\"/home/foobert/STEP_test_files\"",
        "\"/Drexel_blended_cylinder.step\"",
        "\"pathname failure\"",
        "\"file failure\"",
        "\";\\n\"",
        "\";;\"",
        "\"\\n\"",
        "\"\"",
        "\";;\"",
        "\";\\n\"",
        "\"type_name\"",
        "\"CLOSED_SHELL\"",
        "\"pointInArc() transform error: \"",
        "\"pointInArc() transform deviation: \"",
        "\"pointOrderInArc() undertested\"",
        "\"pointOrderInArc() input point(s) in list\"",
        "\"should be 2x maxima/minima, write some code\"",
        "\"tangent exception\"",
        "\"#[0-9]+\"",
        "'AXIS2_PLACEMENT_3D'",
        "'#'",
        "'CARTESIAN_POINT'",
        "'DIRECTION'",
        "'DIRECTION'",
        "'AXIS2_PLACEMENT_3D'",
        "\"axis2Placement3D_2 assignment failure: \"",
        "'CARTESIAN_POINT'",
        "'DIRECTION'",
        "'DIRECTION'",
        "\"insideOutsideSurfaceTest(): edge warning\"",
        "\"insideOutsideSurfaceTest(): median localCentroid at surface, surface normal substituted\"",
        "'ParsedSurface'",
        "'normDir'",
        "'outerBoundEdgeLoop'",
        "'vertex1'",
        "'vertex2'",
        "'typeName'",
        "'B_SPLINE_CURVE_WITH_KNOTS'",
        "'vertex1ref'",
        "'vertex2ref'",
        "'BsplineKnotCurve'",
        "'BsplineKnotCurve'",
        "'BsplineKnotCurve'",
        "'insideOutsideSurfaceTest(): spline edge warning - ignore polyline warnings'",
        "'typeName'",
        "'CIRCLE'",
        "'vertex1ref'",
        "'vertex2ref'",
        "'axisPoint'",
        "'normDir'",
        "'radius'",
        "'refDir'",
        "'auxDir'",
        "'normDir'",
        "'axisPoint'",
        "\"untested circle arc division\"",
        "'typeName'",
        "'ELLIPSE'",
        "'vertex1ref'",
        "'vertex2ref'",
        "'axisPoint'",
        "'refDir'",
        "'auxDir'",
        "'normDir'",
        "'majorRadius'",
        "'minorRadius'",
        "'refDir'",
        "'auxDir'",
        "'normDir'",
        "'axisPoint'",
        "\"untested ellipse arc division\"",
        "'SurfaceTypeName'",
        "'CYLINDRICAL_SURFACE'",
        "'SurfaceTypeName'",
        "'CONICAL_SURFACE'",
        "'ParsedSurface'",
        "'normDir'",
        "'outerBoundEdgeLoop'",
        "'typeName'",
        "'CIRCLE'",
        "'axisPoint'",
        "'normDir'",
        "'radius'",
        "'typeName'",
        "'ELLIPSE'",
        "'axisPoint'",
        "'refDir'",
        "'auxDir'",
        "'normDir'",
        "'majorRadius'",
        "'minorRadius'",
        "'typeName'",
        "'B_SPLINE_CURVE_WITH_KNOTS'",
        "'ParsedSurface'",
        "'axisPoint'",
        "'BsplineKnotCurve'",
        "'BsplineKnotCurve'",
        "\"fail\"",
        "\"insideOutsideSurfaceTest cylinder/conical fail\"",
        "'SurfaceTypeName'",
        "'PLANE'",
        "'outerBoundEdgeLoop'",
        "'outerBoundEdgeLoop'",
        "'SurfaceNormalOutwards'",
        "'edgeType'",
        "'CARTESIAN_POINT'",
        "'linePoint'",
        "'VECTOR'",
        "'lineVectorDisp'",
        "'DIRECTION'",
        "'lineVectorDir'",
        "'vertex1'",
        "'vertex2'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'vertex1'",
        "'vertex2'",
        "'vertex1'",
        "'pointFeature'",
        "'u'",
        "'edgeType'",
        "'radius'",
        "'axisPoint'",
        "'normDir'",
        "'refDir'",
        "'auxDir'",
        "'vertex1'",
        "'vertex2'",
        "'pointFeature'",
        "'u'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'u'",
        "'rotSymFeature'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymFeature'",
        "'rotSymRadius'",
        "'rotSymFeature'",
        "'radiusCentroidDisp'",
        "'edgeType'",
        "'majorRadius'",
        "'minorRadius'",
        "'axisPoint'",
        "'normDir'",
        "'refDir'",
        "'auxDir'",
        "'vertex1'",
        "'vertex2'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'u'",
        "'edgeType'",
        "'T'",
        "'T'",
        "'curveDegree'",
        "'controlPointsRefs'",
        "'curveForm'",
        "'closedCurve'",
        "'selfIntersect'",
        "'knotMultiplicities'",
        "'knots'",
        "'knotSpec'",
        "'CARTESIAN_POINT'",
        "'controlPoints'",
        "'STEPknotvector'",
        "\"maldefined B-spline!\"",
        "'BsplineKnotCurve'",
        "'vertex1'",
        "'vertex2'",
        "'pointFeature'",
        "'xyz'",
        "'vertex1'",
        "'vertex2'",
        "'pointFeature'",
        "'u'",
        "'pointFeature'",
        "'centroidDisp'",
        "'rotSymFlag'",
        "'BsplineKnotCurve'",
        "'ORIENTED_EDGE'",
        "'F'",
        "'VOR'",
        "'EDGE_CURVE'",
        "'VERTEX_POINT'",
        "'vertex1'",
        "'vertex1ref'",
        "'vertex2'",
        "'vertex2ref'",
        "'VERTEX_POINT'",
        "'vertex2'",
        "'vertex2ref'",
        "'vertex1'",
        "'vertex1ref'",
        "'pointFeature'",
        "'pointFeature'",
        "'xyz'",
        "'vertex1'",
        "'vertex2'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'u'",
        "'typeName'",
        "'edgeRef'",
        "'edgeType'",
        "'typeName'",
        "'LINE'",
        "'typeName'",
        "'CIRCLE'",
        "'typeName'",
        "'ELLIPSE'",
        "'typeName'",
        "'B_SPLINE_CURVE_WITH_KNOTS'",
        "\"simpleEdgeParse unknown edge type: \"",
        "'typeName'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'axisPoint'",
        "'normDir'",
        "'refDir'",
        "'auxDir'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'radius'",
        "'axisPoint'",
        "'normDir'",
        "'refDir'",
        "'auxDir'",
        "'pointFeature'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'ParsedSurface'",
        "'sphereFeatureFlag'",
        "'rotSymFeature'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymFeature'",
        "'rotSymRadius'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'axisPoint'",
        "'normDir'",
        "'refDir'",
        "'auxDir'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'axisPoint'",
        "'normDir'",
        "'refDir'",
        "'auxDir'",
        "'minorRadius'",
        "'majorRadius'",
        "'pointFeature'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'ParsedSurface'",
        "'rotSymFeature'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'axisPoint'",
        "'normDir'",
        "'refDir'",
        "'auxDir'",
        "'radius'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'radius'",
        "'axisPoint'",
        "'normDir'",
        "'refDir'",
        "'auxDir'",
        "'pointFeature'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'ParsedSurface'",
        "'outerBoundEdgeLoop'",
        "'pointFeature'",
        "'centroidDisp'",
        "'rotSymFeature'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymFeature'",
        "'rotSymRadius'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'axisPoint'",
        "'normDir'",
        "'refDir'",
        "'auxDir'",
        "'radius'",
        "'semiAngle'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'axisPoint'",
        "'normDir'",
        "'refDir'",
        "'auxDir'",
        "'semiAngle'",
        "'radius'",
        "'pointFeature'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'rotSymFeature'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymFeature'",
        "'rotSymRadius'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'outerBoundEdgeLoop'",
        "'pointFeature'",
        "'centroidDisp'",
        "'rotSymFeature'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymFeature'",
        "'rotSymRadius'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'surfaceUdegree'",
        "'surfaceVdegree'",
        "'controlPointsRefs'",
        "'surfaceForm'",
        "'closedU'",
        "'closedV'",
        "'selfIntersect'",
        "'knotUmultiplicities'",
        "'knotVmultiplicities'",
        "'knotsU'",
        "'knotsV'",
        "'knotSpec'",
        "'controlPoints'",
        "'STEPknotUvector'",
        "'STEPknotVvector'",
        "'BsplineKnotCurve'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'T'",
        "'SurfaceParams'",
        "'T'",
        "'SurfaceParams'",
        "'T'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'SurfaceParams'",
        "'pointFeature'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'surfaceUdegree'",
        "'surfaceVdegree'",
        "'controlPointsRefs'",
        "'surfaceForm'",
        "'closedU'",
        "'closedV'",
        "'selfIntersect'",
        "'knotUmultiplicities'",
        "'knotVmultiplicities'",
        "'knotsU'",
        "'knotsV'",
        "'knotSpec'",
        "'CARTESIAN_POINT'",
        "'controlPoints'",
        "'STEPknotUvector'",
        "\"maldefined B-spline surface (U) !\"",
        "'STEPknotVvector'",
        "\"maldefined B-spline surface (V) !\"",
        "'BsplineKnotCurve'",
        "'ParsedSurface'",
        "'u'",
        "'v'",
        "'u'",
        "'v'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'uv'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'rotSymFeature'",
        "'rotSymFeature'",
        "'rotSymRadius'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'axisPoint'",
        "'normDir'",
        "'SurfaceParams'",
        "'axisPoint'",
        "'normDir'",
        "'refDir'",
        "'pointFeature'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'ParsedSurface'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'centroidDisp'",
        "'pointFeature'",
        "'maxima'",
        "'pointFeature'",
        "'minima'",
        "'ParsedSurface'",
        "'SurfaceTypeName'",
        "'SPHERICAL_SURFACE'",
        "'TOROIDAL_SURFACE'",
        "'CYLINDRICAL_SURFACE'",
        "'CONICAL_SURFACE'",
        "'PLANE'",
        "'B_SPLINE_SURFACE_WITH_KNOTS'",
        "\"Untreated surface type: \"",
        "'SurfaceTypeName'",
        "'SurfaceTypeName'",
        "'SPHERICAL_SURFACE'",
        "'SurfaceTypeName'",
        "'TOROIDAL_SURFACE'",
        "'SurfaceTypeName'",
        "'CYLINDRICAL_SURFACE'",
        "'SurfaceTypeName'",
        "'CONICAL_SURFACE'",
        "'SurfaceTypeName'",
        "'PLANE'",
        "'SurfaceTypeName'",
        "'B_SPLINE_SURFACE_WITH_KNOTS'",
        "'type_name'",
        "'ADVANCED_FACE'",
        "'FACE_SURFACE'",
        "'T'",
        "'SurfaceNormalOutwards'",
        "'SurfaceTypeName'",
        "'SurfaceRef'",
        "'SurfaceParams'",
        "'EdgeLoopList'",
        "'type_name'",
        "'FACE_OUTER_BOUND'",
        "'FACE_BOUND'",
        "'EDGE_LOOP'",
        "'EdgeLoopList'",
        "'SurfaceTypeName'",
        "'SurfaceRef'",
        "'SurfaceParams'",
        "'type_name'",
        "'complex entity @todo'",
        "'type_name'",
        "'ADVANCED_BREP_SHAPE_REPRESENTATION'",
        "'AXIS2_PLACEMENT_3D'",
        "'type_name'",
        "'CARTESIAN_POINT'",
        "'EdgeLoopList'",
        "'typeName'",
        "'SEAM_CURVE'",
        "'SURFACE_CURVE'",
        "'edgeType'",
        "'superTypeName'",
        "'typeName'",
        "'superEdgeRef'",
        "'edgeRef'",
        "'edgeRef'",
        "'superEdgeType'",
        "'edgeType'",
        "'edgeType'",
        "'superTypeName'",
        "'typeName'",
        "'typeName'",
        "'edgeRef'",
        "'edgeRef'",
        "'PCURVE'",
        "'SurfaceRef'",
        "'undetected surface! PCURVE'",
        "'undetermined surfacetype failure line2824'",
        "'outerBoundEdgeLoop'",
        "'ParsedSurface'",
        "'pointFeature'",
        "'ParsedSurface'",
        "'pointFeature'",
        "'xyz'",
        "'ParsedSurface'",
        "'pointFeature'",
        "'xyz'",
        "'outerBoundEdgeLoop'",
        "'pointFeature'",
        "'pointFeature'",
        "'xyz'",
        "'pointFeature'",
        "'xyz'",
        "'outerBoundEdgeLoop'",
        "'centroid update: '",
        "'centroid: '",
        "'import FreeCAD as App'",
        "'import Draft'",
        "'P{:} = Draft.make_point( {:1.8f}, {:1.8f}, {:1.8f}, color=({:1.8f}, {:1.8f}, {:1.8f}))'",
        "'App.ActiveDocument.recompute()'",
        "'outerBoundEdgeLoop'",
        "'vertex1ref'",
        "'vertex2ref'",
        "'_surroundIndex'",
        "'outerBoundEdgeLoop'",
        "'edgeRef'",
        "'rotSymCentre'",
        "'rotSymRadius'",
        "'normDir'",
        "'outerBoundEdgeLoop'",
        "'rotSymFeature'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymFeature'",
        "'rotSymRadius'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymCentre'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymRadius'",
        "'rotSymFeature'",
        "'rotSymRadius'",
        "'normDir'",
        "'normDir'",
        "'rotSymCentre'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymRadius'",
        "'rotSymFeature'",
        "'rotSymRadius'",
        "'normDir'",
        "'normDir'",
        "'ParsedSurface'",
        "'rotSymFeature'",
        "'ParsedSurface'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'ParsedSurface'",
        "'rotSymFeature'",
        "'rotSymRadius'",
        "'ParsedSurface'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'ParsedSurface'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymCentre'",
        "'ParsedSurface'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymRadius'",
        "'ParsedSurface'",
        "'rotSymFeature'",
        "'rotSymRadius'",
        "'normDir'",
        "'ParsedSurface'",
        "'normDir'",
        "'rotSymCentre'",
        "'ParsedSurface'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymRadius'",
        "'ParsedSurface'",
        "'rotSymFeature'",
        "'rotSymRadius'",
        "'normDir'",
        "'ParsedSurface'",
        "'normDir'",
        "'normDir'",
        "'normDir'",
        "'rotSymCentre'",
        "'normDir'",
        "'normDir'",
        "'rotSymCentre'",
        "'normDir'",
        "'rotSymCentre'",
        "'rotSymCentre'",
        "'rotSymCentre'",
        "'centreCentroidDisp'",
        "'rotSymCentre'",
        "'rotSymCentre'",
        "'rotSymRadius'",
        "'rotSymRadius'",
        "'rotSymCentre'",
        "'rotSymCentre'",
        "'rotSymRadius'",
        "'rotSymRadius'",
        "'centreCentroidDisp'",
        "'centreCentroidDisp'",
        "'rotSymCentre'",
        "'rotSymCentre'",
        "'rotSymCentre'",
        "'rotSymRadius'",
        "'rotSymRadius'",
        "'rotSymCentre'",
        "'rotSymCentre'",
        "'rotSymRadius'",
        "'rotSymRadius'",
        "'centreCentroidDisp'",
        "'centreCentroidDisp'",
        "'maxima'",
        "'rotSymCentre'",
        "'minima'",
        "'rotSymCentre'",
        "'maxima'",
        "'rotSymCentre'",
        "'rotSymRadius'",
        "'rotSymRadius'",
        "'rotSymRadius'",
        "'rotSymRadius'",
        "'maxima'",
        "'minima'",
        "'rotSymRadius'",
        "'rotSymRadius'",
        "'rotSymRadius'",
        "'rotSymRadius'",
        "'maxima'",
        "'minima'",
        "'maxima'",
        "'maxima'",
        "'xyz'",
        "'centroidDisp'",
        "'maxima'",
        "'minima'",
        "'vertex1'",
        "'vertex2'",
        "'vertex1ref'",
        "'vertex2ref'",
        "'vertex1ref_surroundIndex'",
        "'vertex2ref_surroundIndex'",
        "'outerBoundEdgeLoop'",
        "'superTypeNameFlag'",
        "'superTypeName'",
        "'SEAM_CURVE'",
        "\"is this code reachable??\"",
        "'pointFeature'",
        "\"missing pointFeature field\"",
        "'outerBoundEdgeLoop'",
        "'pointFeature'",
        "'outerBoundEdgeLoop'",
        "'u'",
        "'u'",
        "'u'",
        "'xyz'",
        "'xyz'",
        "'xyz'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'maxima'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'xyz'",
        "'xyz'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'maxima'",
        "'minima'",
        "'minima'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'xyz'",
        "'xyz'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'maxima'",
        "'minima'",
        "'u'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'u'",
        "'maxima'",
        "'xyz'",
        "'xyz'",
        "'xyz'",
        "'xyz'",
        "'centroidDisp'",
        "'maxima'",
        "'minima'",
        "'minima'",
        "'xyz'",
        "'xyz'",
        "'xyz'",
        "'xyz'",
        "'centroidDisp'",
        "'maxima'",
        "'minima'",
        "'maxima'",
        "'minima'",
        "'vertex1'",
        "'vertex2'",
        "'vertex1ref'",
        "'vertex2ref'",
        "'vertex1ref_surroundIndex'",
        "'vertex2ref_surroundIndex'",
        "'maxima'",
        "'outerBoundEdgeLoop'",
        "'superTypeNameFlag'",
        "'superTypeName'",
        "'SEAM_CURVE'",
        "\"is this code reachable??\"",
        "'pointFeature'",
        "\"missing pointFeature field\"",
        "'outerBoundEdgeLoop'",
        "'pointFeature'",
        "'outerBoundEdgeLoop'",
        "'u'",
        "'u'",
        "'u'",
        "'xyz'",
        "'xyz'",
        "'xyz'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'maxima'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'minima'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'u'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'centroidDisp'",
        "'u'",
        "'maxima'",
        "'xyz'",
        "'xyz'",
        "'minima'",
        "'xyz'",
        "'xyz'",
        "'xyz'",
        "'centroidDisp'",
        "'maxima'",
        "'minima'",
        "'rotSymCentre'",
        "'rotSymRadius'",
        "'ParsedSurface'",
        "'ParsedSurface'",
        "'pointFeature'",
        "'xyz'",
        "'xyz'",
        "'xyz'",
        "'centroidDisp'",
        "'ParsedSurface'",
        "'pointFeature'",
        "'centroidDisp'",
        "'maxima'",
        "'ParsedSurface'",
        "'pointFeature'",
        "'maxima'",
        "'minima'",
        "'ParsedSurface'",
        "'pointFeature'",
        "'minima'",
        "'SurfaceTypeName'",
        "'SPHERICAL_SURFACE'",
        "'ParsedSurface'",
        "'sphereFeatureFlag'",
        "'rotSymCentre'",
        "'ParsedSurface'",
        "'pointFeature'",
        "'rotSymFeature'",
        "'rotSymCentre'",
        "'rotSymRadius'",
        "'ParsedSurface'",
        "'pointFeature'",
        "'rotSymFeature'",
        "'rotSymRadius'"
    ],
    "variables": [
        "Point",
        "eps",
        "eps_STEP_AP21",
        "iterativeScaledPrecision",
        "rotNorm",
        "rotAxis",
        "rotAxis",
        "s",
        "c",
        "C",
        "xs",
        "ys",
        "zs",
        "xC",
        "yC",
        "zC",
        "xyC",
        "yzC",
        "zxC",
        "xxC",
        "yyC",
        "zzC",
        "SDAA",
        "axis",
        "a",
        "b",
        "c",
        "d",
        "aa",
        "bb",
        "cc",
        "dd",
        "bc",
        "ad",
        "ac",
        "ab",
        "bd",
        "cd",
        "xyz",
        "xyz",
        "rho",
        "phi",
        "x",
        "y",
        "T",
        "xRange",
        "xCentroid",
        "yRange",
        "yCentroid",
        "zRange",
        "zCentroid",
        "primitivesDir",
        "primitivesDir",
        "testDir",
        "filepath",
        "checkPath",
        "STEPdata",
        "STEPdata",
        "STEPdata",
        "STEPdata",
        "P",
        "model",
        "STEP_entities",
        "ClosedShells",
        "FaceInstances",
        "padded_STEP_entities",
        "padded_STEP_entities",
        "STEP_entities",
        "t",
        "u",
        "v",
        "w",
        "wsl",
        "wsl",
        "iwsl2",
        "tt",
        "uu",
        "circCenter",
        "circRadius",
        "S",
        "delta_u",
        "S",
        "delta_v",
        "NW",
        "N",
        "NE",
        "W",
        "C",
        "E",
        "SW",
        "S",
        "SE",
        "NW",
        "W",
        "SW",
        "N",
        "C",
        "S",
        "NE",
        "E",
        "SE",
        "extremaUV",
        "extremaP",
        "maxBound",
        "uSamples",
        "vSamples",
        "uvArray",
        "uvArray",
        "pArray",
        "pNW",
        "pN",
        "pNE",
        "pE",
        "pC",
        "pW",
        "pSW",
        "pS",
        "pSE",
        "dpuv_NW",
        "dpuv_N",
        "dpuv_NE",
        "dpuv_E",
        "dpuv",
        "dpuv_W",
        "dpuv_SW",
        "dpuv_S",
        "dpuv_SE",
        "b_N",
        "b_E",
        "b_W",
        "b_S",
        "b_N",
        "b_E",
        "b_W",
        "b_S",
        "uSamples",
        "vSamples",
        "uvArray",
        "uvArray",
        "pArray",
        "discreteK",
        "puv",
        "pur",
        "pucc",
        "pvr",
        "pvcc",
        "kuv",
        "kuv",
        "discreteK",
        "kuv",
        "dkuv",
        "discreteK",
        "discreteK",
        "leu",
        "surroundNodes",
        "pC",
        "pC",
        "tolFlag",
        "divU",
        "divV",
        "dpuvlocal",
        "subDivs",
        "sdv",
        "sdv",
        "sdv",
        "sdv",
        "pSubDivs",
        "dpuv_NW",
        "dpuv_N",
        "dpuv_NE",
        "dpuv_W",
        "dpuv_E",
        "dpuv_SW",
        "dpuv_S",
        "dpuv_SE",
        "dispUV",
        "maxUVindex",
        "mpU",
        "mpV",
        "dpuvlocal",
        "minUVindex",
        "mpU",
        "mpV",
        "dpuvlocal",
        "Su",
        "Sv",
        "Suu",
        "Svv",
        "Suv",
        "Svu",
        "f",
        "g",
        "k",
        "J00",
        "J01",
        "J10",
        "J11",
        "J",
        "d",
        "i",
        "e",
        "dif",
        "c1v",
        "c1",
        "c2an",
        "c2ad",
        "c2av",
        "c2a",
        "c2bn",
        "c2bd",
        "c2bv",
        "c2b",
        "ct",
        "ct",
        "ct",
        "ct",
        "ct",
        "ct",
        "ct",
        "ct",
        "ct",
        "c3v0",
        "c3v1",
        "cuv",
        "localExtremaUV",
        "localExtremaP",
        "maxBound",
        "localExtremaUV",
        "localExtremaP",
        "maxBound",
        "extremaUV",
        "mUV",
        "mUV",
        "mUV",
        "extremaUnique",
        "extremaUniquePoint",
        "dispsExtrema",
        "C",
        "delta",
        "localExtremaU",
        "p0",
        "p1",
        "p2",
        "p0",
        "p1",
        "p2",
        "p0",
        "p1",
        "p2",
        "dp0",
        "dp1",
        "dp2",
        "dp0",
        "dp1",
        "dp2",
        "discreteK",
        "localExtremaU",
        "p0",
        "p1",
        "p2",
        "p0",
        "p1",
        "p2",
        "p0",
        "p1",
        "p2",
        "pur",
        "pucc",
        "discreteK",
        "i",
        "discreteK",
        "i",
        "k0",
        "k1",
        "k2",
        "k0",
        "k1",
        "k2",
        "k0",
        "k1",
        "k2",
        "tolFlag",
        "divU",
        "dpulocal",
        "subDivs",
        "pSubDivs",
        "dpu_L",
        "dpu_R",
        "dispU",
        "maxUindex",
        "mpU",
        "dpulocal",
        "minUindex",
        "mpU",
        "dpulocal",
        "i",
        "e",
        "dif",
        "c1v",
        "c2n",
        "c2d",
        "c2v",
        "ct",
        "ct",
        "ct",
        "ct",
        "ct",
        "c3v",
        "cu",
        "pts",
        "kvs",
        "localExtremaU",
        "localExtremaU",
        "extremaU",
        "mU",
        "mU",
        "extremaUnique",
        "extremaUniquePoint",
        "dispsExtrema",
        "rotM",
        "v1UV",
        "v1UV_angle",
        "v2UV",
        "v2UV_angle",
        "pUV_angle",
        "ppUV",
        "ppUV_angle",
        "pUV",
        "pUV_angle",
        "zTest",
        "zTest",
        "zTest",
        "planeTestFail",
        "returnList",
        "returnBool",
        "p",
        "rotM",
        "v1UV",
        "v1UV_angle",
        "v2UV",
        "v2UV_angle",
        "v1UV_angle",
        "v2UV_angle",
        "pUV_angle",
        "ppUV",
        "ppUV_angle",
        "withinVertex1andVertex2",
        "vpp",
        "vpn",
        "d",
        "pUV",
        "ppCentreDisp",
        "pUVdir",
        "nUVmin",
        "nUVmax",
        "centreOffset",
        "centreOffset",
        "nUVmax",
        "nUVmin",
        "nUVmin",
        "rotM",
        "pUV",
        "pUV",
        "theta",
        "i",
        "n0",
        "radiusConst",
        "pUVdisp",
        "f",
        "f_",
        "theta",
        "n",
        "nUVmin",
        "nUVmin",
        "nUVmax",
        "n0",
        "s",
        "SprojP",
        "F",
        "d",
        "v1",
        "p1",
        "L",
        "cosl",
        "L",
        "l1",
        "l2",
        "a",
        "b",
        "c",
        "i",
        "mu",
        "ipt",
        "mu",
        "ipt1",
        "mu",
        "ipt2",
        "validatedPoints",
        "circleIntersectPoints",
        "v",
        "w",
        "c1",
        "c2",
        "b",
        "pb",
        "flattenList",
        "sp",
        "sp",
        "sp",
        "sp",
        "midP",
        "midPv",
        "midPv",
        "farP",
        "orthoPv",
        "orthoPv",
        "p1",
        "p2",
        "p3",
        "p4",
        "R3",
        "offset",
        "offset",
        "axisPoint",
        "axisPoint",
        "auxDir",
        "auxDir",
        "refDir",
        "refDir",
        "axisPoint",
        "normDir",
        "refDir",
        "subRefList",
        "axisPoint",
        "normDir",
        "refDir",
        "numSamples",
        "span",
        "kvs",
        "pts",
        "m_v1",
        "p_v1",
        "m_v2",
        "p_v2",
        "mppv1",
        "mppv2",
        "sign",
        "v1v2cos",
        "sNormDen",
        "sNorm",
        "sNorm",
        "edgeTotalAngle",
        "vertexLoopCount",
        "v1",
        "v2",
        "splinePolyline",
        "splinePolylineU",
        "nearestSplinePointU",
        "nearestSplinePoint",
        "splinePolylineU",
        "iu",
        "splinePolyline",
        "splinePolyline",
        "nearArcPoint",
        "_",
        "nearArcPoint",
        "_",
        "curvedEdgeNearestPoint",
        "normDir",
        "nearArcPoint",
        "_",
        "nearArcPoint",
        "_",
        "axisPoint",
        "planeNorm",
        "orthoPlane",
        "mSign",
        "sPolyline",
        "sPolylineU",
        "nearArcPointSet",
        "U",
        "nearArcPoint",
        "nearArcPoint",
        "iu",
        "napsSign",
        "nearArcPoint",
        "iu",
        "_1",
        "hiU",
        "hiP",
        "loU",
        "loP",
        "midU",
        "midP",
        "nearArcPoint",
        "hiP",
        "hiU",
        "nearArcPoint",
        "loP",
        "loU",
        "edgeType_",
        "cleanEdgeType",
        "linePoint",
        "ParsedEdge",
        "lineVectorDisp",
        "ParsedEdge",
        "lineVectorDir",
        "lineVectorDir",
        "ParsedEdge",
        "minPoint",
        "minPointCentroidDisp",
        "v1ext",
        "v2ext",
        "u",
        "edgeType_",
        "radius",
        "ParsedEdge",
        "axisPoint",
        "normDir",
        "refDir",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "auxDir",
        "auxDir",
        "ParsedEdge",
        "Cdisp",
        "Cproj",
        "rotSymDisp",
        "minPoint",
        "maxPoint",
        "v1",
        "v2",
        "extrema",
        "pointsInArc",
        "pointOrderIndex",
        "uArc",
        "pointsInArc",
        "extrema",
        "uArc",
        "extrema",
        "ParsedEdge",
        "edgeType_",
        "cleanEdgeType",
        "majorRadius",
        "ParsedEdge",
        "minorRadius",
        "ParsedEdge",
        "axisPoint",
        "normDir",
        "refDir",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "auxDir",
        "auxDir",
        "ParsedEdge",
        "minPoint",
        "maxPoint",
        "v1",
        "v2",
        "extrema",
        "pointsInArc",
        "pointOrderIndex",
        "uArc",
        "pointsInArc",
        "extrema",
        "uArc",
        "extrema",
        "edgeType",
        "offset",
        "offset",
        "curveDegree",
        "controlPointsRefs",
        "curveForm",
        "closedCurve",
        "selfIntersect",
        "knotMultiplicities",
        "knots",
        "knotSpec",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "controlPoints",
        "controlPoint",
        "ParsedEdge",
        "knotvector",
        "ParsedEdge",
        "BsplineKnotCurve",
        "BsplineKnotCurve",
        "degree",
        "BsplineKnotCurve",
        "knotvector",
        "ParsedEdge",
        "maxPointsU",
        "maxPoints",
        "minPointsU",
        "minPoints",
        "maximaU",
        "maximaPoints",
        "extremaUindex",
        "maximaU",
        "maximaPoints",
        "maxima_truth",
        "maxima_truth",
        "maximaU",
        "maximaPoints",
        "centroidDisp",
        "vertex1centroidDisp",
        "vertex2centroidDisp",
        "splineMeanPoint",
        "ctrlptsDelta",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "VOR",
        "ParsedEdge",
        "edgeCurveRef",
        "edgeCurveParams",
        "edgeCurveParams",
        "vertex1",
        "vertex1",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "vertex2",
        "vertex2",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "edgeType",
        "edgeTypeName",
        "edgeRef",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedSurface",
        "centrePoint",
        "normDir",
        "refDir",
        "auxDir",
        "centrePoint",
        "normDir",
        "refDir",
        "auxDir",
        "auxDir",
        "radius",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "AFS",
        "sphereCentroidOffset",
        "ParsedSurface",
        "ParsedSurface",
        "sphereCentreCentroidDir",
        "maxPoint",
        "minPoint",
        "AFS",
        "ParsedSurface",
        "axisPoint",
        "normDir",
        "refDir",
        "auxDir",
        "ParsedSurface",
        "axisPoint",
        "normDir",
        "refDir",
        "auxDir",
        "auxDir",
        "minorRadius",
        "majorRadius",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "AFS",
        "rotSymDisp",
        "ParsedEdge",
        "majorMinPoint",
        "majorMaxPoint",
        "majorMinRadialDir",
        "majorMinTangentDir",
        "majorMinTangentDir",
        "minorMinPoint",
        "_",
        "majorMaxRadialDir",
        "majorMaxTangentDir",
        "majorMaxTangentDir",
        "minorMaxPoint",
        "_",
        "AFS",
        "ParsedSurface",
        "axisPoint",
        "normDir",
        "refDir",
        "auxDir",
        "radius",
        "axisPoint",
        "normDir",
        "refDir",
        "auxDir",
        "auxDir",
        "radius",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "AFS",
        "rotSymDisp",
        "minSurfaceDispPoint",
        "edgeMinimaCount",
        "ParsedSurface",
        "centroidProjAxisPoint",
        "centroidAxisDir",
        "centroidAxisDisp",
        "centroidAxisDir",
        "smp",
        "surfaceMinPoint",
        "surfaceMinPoint",
        "AFS",
        "ParsedSurface",
        "axisPoint",
        "normDir",
        "refDir",
        "auxDir",
        "radius",
        "semiAngle",
        "axisPoint",
        "normDir",
        "refDir",
        "auxDir",
        "auxDir",
        "semiAngle",
        "radius",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "AFS",
        "AFS",
        "rotSymDisp",
        "axisPointApexDisp",
        "apexPoint",
        "ParsedEdge",
        "minPlaneNorm",
        "minPlaneNorm",
        "coneEdgeCW",
        "coneEdgeCW",
        "coneMinCW",
        "coneEdgeCCW",
        "coneEdgeCCW",
        "coneMinCCW",
        "coneMin",
        "coneMin",
        "coneMinimaCentreDisp",
        "coneMinimaCentrePoint",
        "rotSymCentroidDisp",
        "edgeMinimaCount",
        "ParsedSurface",
        "AFS",
        "ParsedSurface",
        "surfaceUdegree",
        "surfaceVdegree",
        "controlPointsRefs",
        "surfaceForm",
        "closedU",
        "closedV",
        "selfIntersect",
        "knotUmultiplicities",
        "knotVmultiplicities",
        "knotsU",
        "knotsV",
        "knotSpec",
        "controlPoints",
        "STEPknotUvector",
        "STEPknotVvector",
        "BsplineKnotSurface",
        "offset",
        "offset",
        "surfaceUdegree",
        "surfaceVdegree",
        "controlPointsRefs",
        "surfaceForm",
        "closedU",
        "closedV",
        "selfIntersect",
        "knotUmultiplicities",
        "knotVmultiplicities",
        "knotsU",
        "knotsV",
        "knotSpec",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "controlPointsLenU",
        "controlPointsLenV",
        "controlPoints",
        "ParsedSurface",
        "STEPknotUvector",
        "ParsedSurface",
        "STEPknotVvector",
        "ParsedSurface",
        "BsplineKnotSurface",
        "BsplineKnotSurface",
        "degree_u",
        "BsplineKnotSurface",
        "degree_v",
        "BsplineKnotSurface",
        "ctrlpts_size_u",
        "BsplineKnotSurface",
        "ctrlpts_size_v",
        "ctrlptsw",
        "BsplineKnotSurface",
        "knotvector_u",
        "BsplineKnotSurface",
        "knotvector_v",
        "ParsedSurface",
        "AFS",
        "maxPointsUV",
        "maxPoints",
        "minPointsUV",
        "minPoints",
        "maxima",
        "minima",
        "maximaUV",
        "maximaPoints",
        "maximaUV_field",
        "extremaUVindex",
        "maximaUV",
        "maximaPoints",
        "maxima",
        "minima",
        "maxima_truth",
        "maxima_truth",
        "maximaUV",
        "maximaPoints",
        "spinePoints",
        "rowDelta",
        "ctrlptsRowDisp",
        "spinePointsMean",
        "uu",
        "dd",
        "vv",
        "spineDir",
        "spinePointDir",
        "spineIP",
        "projSpinePointDir",
        "projSpinePoint",
        "spineDeviations",
        "ParsedSurface",
        "AFS",
        "ParsedSurface",
        "axisPoint",
        "normDir",
        "ParsedSurface",
        "axisPoint",
        "normDir",
        "refDir",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "ParsedSurface",
        "AFS",
        "surfaceMinPoint",
        "AFS",
        "AdvancedFaceSurfaces",
        "SurfaceNormalOutwards",
        "afRefs",
        "SurfaceClass",
        "afTypeName",
        "se3",
        "se3",
        "SurfaceClass",
        "SurfaceClass",
        "SurfaceClass",
        "SurfaceClass",
        "outermostPoints",
        "ABSRpointRef",
        "cleanABSR",
        "ABSRpointRef",
        "centroid",
        "EdgeLoops",
        "ParsedEdgeLoop",
        "ParsedEdge",
        "cleanEdgeType",
        "edgeTypeName",
        "ParsedEdge",
        "edgeRef",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "ParsedEdge",
        "surfaceRef",
        "_1",
        "_1",
        "AFS",
        "outermostPoints",
        "lastCentroid",
        "centroid",
        "lastCentroid",
        "centroid",
        "ref1",
        "indexDictName",
        "se",
        "indexDictName",
        "te_strings",
        "ref2",
        "ref2",
        "allRotSymFeatures",
        "allRotSymFeatures",
        "allRotSymFeatures",
        "allRotSymFeatures",
        "normDirSet",
        "superAxisUniqueSet",
        "axisUniqueSet",
        "superAxesSet",
        "axisSet",
        "centreDisps",
        "maxCentreDisps",
        "axisDisps",
        "axisDispsSorted",
        "saus",
        "axisSet",
        "axisSet",
        "axisSet",
        "superAxesSet2",
        "axisSet2",
        "axisSet2",
        "axisSet2",
        "axisSet2",
        "superAxesSet",
        "sas",
        "sas",
        "s",
        "s",
        "s",
        "s",
        "rotSymFeatures",
        "surfaceMinPoint",
        "surfaceMinFeatureCentroidDisp",
        "surfaceMaxPoint",
        "surfaceMaxFeatureCentroidDisp",
        "pointFeatures",
        "pointFeatures",
        "pointFeatures",
        "pointFeatures",
        "pointFeatures",
        "vertexX",
        "vertexXref",
        "vertexXref_surroundIndex",
        "extrema",
        "pfSurround",
        "adjacentEdgeRefs",
        "reversedOrder",
        "vse",
        "adjPF",
        "reversePF",
        "reversePF",
        "reversePF",
        "reversePF",
        "maxPFlen",
        "crawlindex",
        "pfcd0",
        "pfcd1",
        "pfcd2",
        "u",
        "u",
        "maxPointFeatures",
        "minPointFeatures",
        "_1",
        "vertexX",
        "vertexXref",
        "vertexXref_surroundIndex",
        "extremaType",
        "extrema",
        "pfSurround",
        "adjacentEdgeRefs",
        "reversedOrder",
        "vse",
        "adjPF",
        "reversePF",
        "reversePF",
        "reversePF",
        "reversePF",
        "maxPFlen",
        "crawlindex",
        "pfcd0",
        "pfcd1",
        "pfcd2",
        "u",
        "u",
        "surfacePointFeature",
        "surfacePointFeature",
        "surfacePointFeature",
        "surfacePointFeature",
        "surfacePointFeature",
        "surfaceSphericalFeature",
        "surfaceSphericalFeature",
        "surfaceSphericalFeature",
        "surfaceSphericalFeature",
        "surfaceSphericalFeature"
    ],
    "comments": [
        "continuation of scratch_6, addressing complex edges with multiple maxima/minima",
        "introduction of dict structure, featureExtrema, to maintain local extrema (x, y) value, centroid disp value, u spline value, v spline surface optional value",
        "remove pre-calculation of ParsedEdge['vertex1extremaMax'], ParsedEdge['vertex2extremaMax'] flags",
        "from geomdl import BSpline",
        "import copy",
        "PyCharm bug will flag this as type error",
        "from scipy import spatial # numpy version < 1.24",
        "eps machine precision constant",
        "STEP precision seems to end here",
        "eps_bspline = 1E-10 # precision used in bspline/NURB surface subroutines",
        "machine_EPS = np.finfo(float).eps # float comparison",
        "need a precision factor that reflects increasing accuracy arising from iterative calculations of centroid --------------------------------------<<<<<<<<<<<<<<<<<",
        "also scale factor affecting numerical precision",
        "also STEP seems to be E-6 decimal places at best",
        "for testing",
        "todo: dict data arrays like ParsedEdge should become classes, once all required fields & methods identified",
        "normalise to unit vector",
        "if rotAxis.__class__.__name__ == \"list\":",
        "rotAxis = Point(rotAxis[0], rotAxis[1], rotAxis[2])",
        "Euler-Rodrigues formula",
        "http://stackoverflow.com/questions/6802577/python-rotation-of-3d-vector",
        "from numpy import asarray, array, dot",
        "from math import sqrt, cos, sin",
        "axis = np.asarray(axis)",
        "theta = np.asarray(theta)",
        "does one find a centroid through axis-intersection?",
        "a number of axes that pass through a common point?",
        "equidistant corners?",
        "from statistics import median # apparently slow/accurate",
        "from numpy import median",
        "noinspection PyUnresolvedReferences",
        "def checkFilePath(filePath):",
        "if os.path.isfile(filePath) and os.access(filePath, os.R_OK):",
        "return filePath",
        "else:",
        "raise Exception(\"{0} is not a readable filepath\".format(filePath))",
        "filepath = primitivesDir + \"/Cube/unit_cube_inc8.0_blend.06.stp\"",
        "filepath = primitivesDir + \"/Cylinder/unit_cyl.stp\"",
        "filepath = primitivesDir + \"/Primitive_Cone-PartCone.step\"",
        "filepath = r\"/home/foobert/Downloads/RR_STEP_test_1.step\"",
        "filepath = r\"/home/foobert/Downloads/RR_STEP_test_N.step\"",
        "filepath = r\"/home/foobert/Downloads/00000001_1ffb81a71e5b402e966b9341_step_000.step\"",
        "filepath = r\"/home/foobert/Downloads/00000010_b4b99d35e04b4277931f9a9c_step_000.step\"",
        "filepath = r\"/home/foobert/Downloads/LEA-M8F(AP203).STEP\"",
        "filepath = testDir + \"/simpleSpindle1.step\"",
        "filepath = testDir + \"/Maltese_cruciform.step\"",
        "filepath = testDir + \"/TiltedConeAP203.step\"",
        "filepath = testDir + \"/OffsetCone_AP214_noPlacement_noParametric.step\"",
        "filepath = testDir + \"/OffsetCone-PartCone.step\"",
        "filepath = testDir + \"/TiltedCylinder4_AP214_PC.step\"",
        "filepath = testDir + \"/Cylinder5_AP214_PC.step\"",
        "filepath = testDir + \"/DrexelBlendedCylinder_topOvalPlane.step\"",
        "DrexelBlendedCylinder_curvedBlend.step",
        "filepath = testDir + \"/DrexelBlendedCylinder_midriffTube.step\"",
        "filepath = testDir + \"/TiltedCylinder2.step\"",
        "filepath = primitivesDir + \"/Cube/unit_cube.stp\"",
        "filepath = testDir + \"/DrexelBlendedCylinder_curvedBlend.step\"",
        "not all surface min/max found",
        "edge min/max found - require local maxima for local centroid determination",
        "filepath = testDir + \"/TiltedCylinder.step\"",
        "filepath = testDir + \"/Synth_ellipse_plain.step\"",
        "filepath sanity check",
        "model = P.parse(/home/foobert/.config/JetBrains/PyCharmCE2023.1/scratches/simple_schema.exp)",
        "stepcode.Part21.ComplexEntity type missing attribute",
        "encountering step files with non-contiguous line and #ref indices",
        "radius + centre from 3 point circle",
        "triangle normal",
        "triangle area too small (additionally check points for colinearity)",
        "circAxis   = w / np.sqrt(wsl)",
        "easy to find a minimum, but a maximum found through the original hillclimbing algorithm will settle on local maxima",
        "for surfaces, minimize the following:",
        "",
        "f = Su(u,v) * r = 0",
        "g = Sv(u,v) * r = 0",
        "",
        "where r = S(u,v) - P",
        "",
        "Requires Newton-Raphson iteration, objective function is vector valued",
        "",
        "J d = k",
        "",
        "d =   [ u* - u, v* - v ] (alternatively u[i+1] -  u[i], v[i+1]- v[i])",
        "k = - [ f(u,v), g(u,v) ]",
        "J =     |Su|^2   +  Suu * r       Su*Sv  +  Suv * r",
        "Su*Sv   +  Svu * r      |Sv|^2  +  Svv * r",
        "",
        "halting conditions:",
        "point coincidence",
        "",
        "|S(u,v) - p| < e1",
        "",
        "cosine",
        "",
        "|Su(u,v)*(S(u,v) - P)|",
        "----------------------  < e2",
        "|Su(u,v)| |S(u,v) - P|",
        "",
        "|Sv(u,v)*(S(u,v) - P)|",
        "----------------------  < e2",
        "|Sv(u,v)| |S(u,v) - P|",
        "",
        "1) first check 2 & 3",
        "2) if at least one of these is not, compute new value, otherwise halt",
        "3) ensure the parameter stays within range",
        "4)  if |(u* - u)C'(u)| < e1, halt",
        "todo: take value from STEP fields",
        "check if surface closed along U and V",
        "eps_STEP_AP21",
        "S.delta = delta  # set evaluation delta",
        "tradeoff between sample density and feature identification",
        "deltaFactor = 5",
        "deltaFactor = 4",
        "S.delta_u = 1 / (S.ctrlpts_size_u * deltaFactor)",
        "S.delta_v = 1 / (S.ctrlpts_size_v * deltaFactor)",
        "if S.evalpts == None:  # evaluate surface points---------appears redundant",
        "S.evaluate()",
        "central instance",
        "print([NW, N, NE])",
        "print([W, C, E])",
        "print([SW, S, SE])",
        "print(\"==========\")",
        "print([u, v, ((u * V) + v) ])",
        "print(\"==========\")",
        "if v==V - 2:",
        "_1=1",
        "if C==3:",
        "_1=1",
        "def _neighbouringUV(U, V, isClosedU, isClosedV):",
        "# generator function to yield neighbouring indices over a matrix of size U x V",
        "",
        "openU = not isClosedU",
        "openV = not isClosedV",
        "",
        "for u in range(openU, U - openU):",
        "for v in range(openV, V - openV):",
        "",
        "if v == 0:  # closed in v direction",
        "if u == U - 1:",
        "NW = V - 1",
        "else:",
        "NW = ((u + 2) * V) + v - 1",
        "",
        "W = (V * (u + 1)) - 1",
        "",
        "if u == 0:",
        "SW = (U * V) - 1  # V - 1",
        "else:",
        "SW = (u * V) - 1",
        "",
        "if u == U - 1:  # closed in u direction",
        "N = v",
        "else:",
        "N = V * (u + 1)",
        "",
        "C = u * V",
        "",
        "if u == 0:",
        "S = V * (U - 1)",
        "else:",
        "S = V * (u - 1)",
        "",
        "if v == 1:",
        "if u == U - 1:  # closed in u direction",
        "NW = v - 1",
        "else:",
        "NW = ((u + 1) * V) + v - 1",
        "",
        "W = (u * V) + v - 1",
        "",
        "if u == 0:",
        "SW = ((U - 1) * V) + v - 1",
        "else:",
        "SW = ((u - 1) * V) + v - 1",
        "",
        "if u == U - 1:  # closed in v direction",
        "N = v",
        "else:",
        "N = ((u + 1) * V) + v",
        "",
        "C = (u * V) + v",
        "",
        "if u == 0:",
        "S = ((U - 1) * V) + 1",
        "else:",
        "S = ((u - 1) * V) + v",
        "",
        "if v > 1:",
        "NW = N",
        "W = C  # central instance",
        "SW = S",
        "",
        "N = NE",
        "C = E",
        "S = SE",
        "",
        "if v == V - 1:  # closed in v direction",
        "if u < U - 1:",
        "NE = (u + 1) * V",
        "elif u == U - 1:  # closed in u direction",
        "NE = 0",
        "",
        "if u < U - 1:",
        "E = u * V",
        "elif u == U - 1:",
        "E = ((u - 1) * V) + v + 1",
        "",
        "if u == 0:",
        "SE = ((U - 1) * V)",
        "elif u < U - 1:",
        "SE = (u - 1) * V",
        "elif u == U - 1:",
        "SE = ((u - 2) * V) + v + 1",
        "",
        "elif v < V - 1:",
        "if u < U - 1:  # only have to calculate this once per loop",
        "NE = ((u + 1) * V) + v + 1",
        "elif u == U - 1:  # closed in u direction",
        "NE = v + 1",
        "",
        "if u < U - 1:  # only have to calculate this once per loop",
        "E = (u * V) + v + 1",
        "elif u == U - 1:",
        "E = (u * V) + v + 1",
        "",
        "if u == 0:",
        "SE = ((U - 1) * V) + v + 1",
        "elif u < U - 1:  # only have to calculate this once per loop",
        "SE = ((u - 1) * V) + v + 1",
        "elif u == U - 1:",
        "SE = ((u - 1) * V) + v + 1",
        "",
        "# print([NW, N, NE])",
        "# print([W, C, E])",
        "# print([SW, S, SE])",
        "# print(\"==========\")",
        "",
        "yield ([NW, N, NE, W, C, E, SW, S, SE], (u, v))",
        "not S.evalpts",
        "uSamples = np.linspace(S.knotvector_u[0], S.knotvector_u[-1], num=len(S.knotvector_u) * deltaFactor)",
        "vSamples = np.linspace(S.knotvector_v[0], S.knotvector_v[-1], num=len(S.knotvector_v) * deltaFactor)",
        "test1 = S.evaluate_single(uvArray[0]) #(0.0, 0.0))",
        "test2 = S.evaluate_single(uvArray[207]) #(0.0, 1.0))",
        "minSample=[]",
        "testSample = [pNW, pN, pNE, pW, pC, pE, pSW, pS, pSE]",
        "if ((dpuv_S <= dpuv_NW) and (dpuv_S <= dpuv_N) and (dpuv_S <= dpuv_NE) and",
        "(dpuv_S <= dpuv_W) and (dpuv_S <= dpuv_E) and",
        "(dpuv_S <= dpuv_SW) and (dpuv_S <= dpuv) and (dpuv_S <= dpuv_SE)):",
        "minSample.append(pS)",
        "b_NW = np.linalg.norm(pC - pNW)",
        "b_NE = np.linalg.norm(pC - pNE)",
        "b_SW = np.linalg.norm(pC - pSW)",
        "b_SE = np.linalg.norm(pC - pSE)",
        "uv[0]*S.sample_size_v + uv[1]",
        "minS",
        "where a point is orthogonal to a planar surface -> sphere radius test, or accept minima",
        "b_NW = np.linalg.norm(pC - pNW)",
        "b_NE = np.linalg.norm(pC - pNE)",
        "b_SW = np.linalg.norm(pC - pSW)",
        "b_SE = np.linalg.norm(pC - pSE)",
        "not S.evalpts",
        "find media point of U curvature centre and V curvature, kuv",
        "p is on the same side of the surface as the median curvature",
        "smallest radius, with curvature centre on far side of surface from p",
        "todo: examine issue with non-colinear curve centre and projecting point",
        "e.g. proj(p)",
        "if np.dot(p - p1, pucc - p1)/np.linalg.norm(pucc - p1) > 0:",
        "discreteK[i] = pur",
        "else:",
        "discreteK[i] = -pur",
        "localExtremaP = []",
        "maxBound = []",
        "this version excludes negative curves from surrounding curvature values",
        "if all(np.abs(discreteK[ssn]) > discreteK[S.sample_size_u * u + v] or",
        "(discreteK[ssn]<0) for ssn in surroundNodes) and",
        "(discreteK[S.sample_size_u * u + v] > 0):",
        "create simple subdivisions around a minimum point as simple hillclimb search",
        "dpuvlocal = np.inner(p - np.array(S.evaluate_single((mpU, mpV,))))",
        "test np.inner",
        "dispUV = [np.inner(p - psd) for psd in pSubDivs]",
        "dpuv = np.linalg.norm(p - pSubDivs[4])",
        "dpuvlocal,",
        "np.abs(max(dispUV) - dpuvlocal) >= tol:",
        "def f(uv):",
        "return surface.derivatives(uv[0], uv[1], 2)",
        "e[0][0], the surface point itself",
        "e[0][1], the 1st derivative w.r.t. v",
        "e[2][1], the 2nd derivative w.r.t. u and 1st derivative w.r.t. v",
        "np.array inputs",
        "f = Su(u,v) * r = 0",
        "g = Sv(u,v) * r = 0",
        "d =   [ u* - u, v* - v ]",
        "k = - [ f(u,v), g(u,v) ]",
        "J =   |Su|^2   +  Suu * r       Su*Sv  +  Suv * r",
        "Su*Sv   +  Svu * r      |Sv|^2  +  Svv * r",
        "e = None",
        "derivatives sometimes > |2|",
        "test = S.derivatives(1.0, 0.0, 0)",
        "e[0][0] is surface point evaluated at cuv(u,v)",
        "|S(u,v) - p| < e1 (point coincidence)",
        "|Su(u,v)*(S(u,v) - P)|",
        "----------------------  < e2 (cosine minima)",
        "|Su(u,v)| |S(u,v) - P|",
        "|Sv(u,v)*(S(u,v) - P)|",
        "----------------------  < e2 (cosine minima)",
        "|Sv(u,v)| |S(u,v) - P|",
        "exit if all tolerance are met,",
        "otherwise, take a step",
        "correct for exceeding bounds",
        "[ maxu - ( ct[0] - minu ), ct[1] ]",
        "if closedU(): ct = [S.knotvector_u[0] + ct[0] % (S.knotvector_u[-1] - S.knotvector_u[0]), ct[1]]",
        "if closedU(): ct = [S.knotvector_u[-1] - ct[0] % (S.knotvector_u[-1] - S.knotvector_u[0]), ct[1]]",
        "if closedV(): ct = [ct[0], S.knotvector_v[0] + ct[1] % (S.knotvector_v[-1] - S.knotvector_v[0])]",
        "if closedV(): ct = [ct[0], S.knotvector_v[0] + (ct[1] - S.knotvector_v[-1])]",
        "if |(u* - u) C'(u)| < e1, halt",
        "Newton-Raphson fails",
        "discrete grid summing curvatures along U and V axes",
        "find a maximum deviation to indicate when N-R fails",
        "Newton-Raphson fail, try hillclimb",
        "print(S.evalpts[(S.sample_size_u * luv[0]) + luv[1]])",
        "filter out identical values",
        "displacement between any 2 points < eps1",
        "compare u, v individually to reduce comparison pool",
        "if there is only one extrema, localextrema is moot",
        "return single value in list for compatibility",
        "return single maxima",
        "return single value in list for compatibility",
        "minsearch",
        "def rationalSurfaceExtremaParam_5(S, p,",
        "maxSearch=True,",
        "localExtrema=False,",
        "curvatureTest=False,",
        "uv_xyz=True,",
        "eps1=0.0001,",
        "eps2=0.0005,",
        "deltaFactor=4,",
        "eps_bspline = 1E-10):",
        "'''",
        "Use either Newton-Raphson, or a hillclimbing neighbour search to find minimal or maximal distance on a surface, S, from a supplied point, p",
        "- not tested with surfaces closed along U & V",
        "maxSearch: search for most distant point from p if true, else nearest if false",
        "localExtrema: find any local extrema which differs from surrounding sample points, tolerance not sufficiently defined",
        "curvatureTest: rather than displacement of sampled points to provide seed locations for N-R/hillclimb search,",
        "use a combination of the centres of curvature at any point across U-axis and V-axis to identify C2 inflection point.",
        "uv_xyz: return u,v normalised values or cartesian x,y,z values",
        "eps1: point coincidence limit, halt N-R on reaching this minima",
        "eps2: cosine angle limit, halt N-R on reaching this minima",
        "delta: sample interval dividing surface into points",
        "'''",
        "",
        "# easy to find a minimum, but a maximum found through the original hillclimbing algorithm will settle on local maxima",
        "# for surfaces, minimize the following:",
        "#",
        "# f = Su(u,v) * r = 0",
        "# g = Sv(u,v) * r = 0",
        "#",
        "#   where r = S(u,v) - P",
        "#",
        "# Requires Newton-Raphson iteration, objective function is vector valued",
        "#",
        "#     J d = k",
        "#",
        "#     d =   [ u* - u, v* - v ] (alternatively u[i+1] -  u[i], v[i+1]- v[i])",
        "#     k = - [ f(u,v), g(u,v) ]",
        "#     J =     |Su|^2   +  Suu * r       Su*Sv  +  Suv * r",
        "#              Su*Sv   +  Svu * r      |Sv|^2  +  Svv * r",
        "#",
        "# halting conditions:",
        "# point coincidence",
        "#",
        "#         |S(u,v) - p| < e1",
        "#",
        "# cosine",
        "#",
        "#    |Su(u,v)*(S(u,v) - P)|",
        "#    ----------------------  < e2",
        "#    |Su(u,v)| |S(u,v) - P|",
        "#",
        "#    |Sv(u,v)*(S(u,v) - P)|",
        "#    ----------------------  < e2",
        "#    |Sv(u,v)| |S(u,v) - P|",
        "#",
        "# 1) first check 2 & 3",
        "# 2) if at least one of these is not, compute new value, otherwise halt",
        "# 3) ensure the parameter stays within range",
        "#     * if not closed, don't allow outside of range a-b",
        "#     * if closed (e.g. circle), allow to move back to beginning",
        "# 4)  if |(u* - u)C'(u)| < e1, halt",
        "",
        "# todo: take value from STEP fields",
        "# check if surface closed along U and V",
        "",
        "def closedV():",
        "return np.isclose([np.array(s[0]) - np.array(s[-1]) for s in S.ctrlpts2d], eps_bspline).all()",
        "",
        "def closedU():",
        "return np.isclose(np.array(S.ctrlpts2d[0]) - np.array(S.ctrlpts2d[-1]), eps_bspline).all()  # eps_STEP_AP21",
        "",
        "#S.delta = delta  # set evaluation delta",
        "# tradeoff between sample density and feature identification",
        "",
        "#deltaFactor = 5",
        "deltaFactor = 4",
        "",
        "# S.delta_u = 1 / (S.ctrlpts_size_u * deltaFactor)",
        "# S.delta_v = 1 / (S.ctrlpts_size_v * deltaFactor)",
        "",
        "S.delta_u = 1 / len(S.knotvector_u) * deltaFactor",
        "S.delta_v = 1 / len(S.knotvector_v) * deltaFactor",
        "",
        "# if S.evalpts == None:  # evaluate surface points---------appears redundant",
        "#     S.evaluate()",
        "",
        "def neighbouringUV(U, V, isClosedU, isClosedV):",
        "",
        "for u in range(0, U - 2 + (2 * isClosedV)):",
        "for v in range(0, V - 2 + (2 * isClosedU)):",
        "",
        "if v == 0:",
        "NW = (((u + 2) % U) * V)",
        "N = (((u + 2) % U) * V) + 1",
        "NE = (((u + 2) % U) * V) + 2",
        "",
        "W = (((u + 1) % U) * V)",
        "C = (((u + 1) % U) * V) + 1",
        "E = (((u + 1) % U) * V) + 2",
        "",
        "SW = ((u % U) * V)",
        "S = ((u % U) * V) + 1",
        "SE = ((u % U) * V) + 2",
        "",
        "if v >= 1:",
        "NW = N",
        "W = C  # central instance",
        "SW = S",
        "",
        "N = NE",
        "C = E",
        "S = SE",
        "",
        "NE = (((u + 2) % U) * V) + ((v + 2) % V)",
        "E = (((u + 1) % U) * V) + ((v + 2) % V)",
        "SE = ((u % U) * V) + ((v + 2) % V)",
        "",
        "# print([NW, N, NE])",
        "# print([W, C, E])",
        "# print([SW, S, SE])",
        "# print(\"==========\")",
        "# print([u, v, ((u * V) + v) ])",
        "# print(\"==========\")",
        "",
        "yield ([NW, N, NE, W, C, E, SW, S, SE], (u, v))",
        "",
        "# def _neighbouringUV(U, V, isClosedU, isClosedV):",
        "#     # generator function to yield neighbouring indices over a matrix of size U x V",
        "#",
        "#     openU = not isClosedU",
        "#     openV = not isClosedV",
        "#",
        "#     for u in range(openU, U - openU):",
        "#         for v in range(openV, V - openV):",
        "#",
        "#             if v == 0:  # closed in v direction",
        "#                 if u == U - 1:",
        "#                     NW = V - 1",
        "#                 else:",
        "#                     NW = ((u + 2) * V) + v - 1",
        "#",
        "#                 W = (V * (u + 1)) - 1",
        "#",
        "#                 if u == 0:",
        "#                     SW = (U * V) - 1  # V - 1",
        "#                 else:",
        "#                     SW = (u * V) - 1",
        "#",
        "#                 if u == U - 1:  # closed in u direction",
        "#                     N = v",
        "#                 else:",
        "#                     N = V * (u + 1)",
        "#",
        "#                 C = u * V",
        "#",
        "#                 if u == 0:",
        "#                     S = V * (U - 1)",
        "#                 else:",
        "#                     S = V * (u - 1)",
        "#",
        "#             if v == 1:",
        "#                 if u == U - 1:  # closed in u direction",
        "#                     NW = v - 1",
        "#                 else:",
        "#                     NW = ((u + 1) * V) + v - 1",
        "#",
        "#                 W = (u * V) + v - 1",
        "#",
        "#                 if u == 0:",
        "#                     SW = ((U - 1) * V) + v - 1",
        "#                 else:",
        "#                     SW = ((u - 1) * V) + v - 1",
        "#",
        "#                 if u == U - 1:  # closed in v direction",
        "#                     N = v",
        "#                 else:",
        "#                     N = ((u + 1) * V) + v",
        "#",
        "#                 C = (u * V) + v",
        "#",
        "#                 if u == 0:",
        "#                     S = ((U - 1) * V) + 1",
        "#                 else:",
        "#                     S = ((u - 1) * V) + v",
        "#",
        "#             if v > 1:",
        "#                 NW = N",
        "#                 W = C  # central instance",
        "#                 SW = S",
        "#",
        "#                 N = NE",
        "#                 C = E",
        "#                 S = SE",
        "#",
        "#             if v == V - 1:  # closed in v direction",
        "#                 if u < U - 1:",
        "#                     NE = (u + 1) * V",
        "#                 elif u == U - 1:  # closed in u direction",
        "#                     NE = 0",
        "#",
        "#                 if u < U - 1:",
        "#                     E = u * V",
        "#                 elif u == U - 1:",
        "#                     E = ((u - 1) * V) + v + 1",
        "#",
        "#                 if u == 0:",
        "#                     SE = ((U - 1) * V)",
        "#                 elif u < U - 1:",
        "#                     SE = (u - 1) * V",
        "#                 elif u == U - 1:",
        "#                     SE = ((u - 2) * V) + v + 1",
        "#",
        "#             elif v < V - 1:",
        "#                 if u < U - 1:  # only have to calculate this once per loop",
        "#                     NE = ((u + 1) * V) + v + 1",
        "#                 elif u == U - 1:  # closed in u direction",
        "#                     NE = v + 1",
        "#",
        "#                 if u < U - 1:  # only have to calculate this once per loop",
        "#                     E = (u * V) + v + 1",
        "#                 elif u == U - 1:",
        "#                     E = (u * V) + v + 1",
        "#",
        "#                 if u == 0:",
        "#                     SE = ((U - 1) * V) + v + 1",
        "#                 elif u < U - 1:  # only have to calculate this once per loop",
        "#                     SE = ((u - 1) * V) + v + 1",
        "#                 elif u == U - 1:",
        "#                     SE = ((u - 1) * V) + v + 1",
        "#",
        "#             # print([NW, N, NE])",
        "#             # print([W, C, E])",
        "#             # print([SW, S, SE])",
        "#             # print(\"==========\")",
        "#",
        "#             yield ([NW, N, NE, W, C, E, SW, S, SE], (u, v))",
        "",
        "def localNeighbourSearch(S):",
        "extremaUV = []",
        "extremaP = []",
        "maxBound = []",
        "",
        "# not S.evalpts",
        "uSamples = np.linspace(S.knotvector_u[0], S.knotvector_u[-1], num=len(S.knotvector_u) * deltaFactor, endpoint=(closedU()))",
        "vSamples = np.linspace(S.knotvector_v[0], S.knotvector_v[-1], num=len(S.knotvector_v) * deltaFactor, endpoint=(closedV()))",
        "uvArray = np.zeros((len(uSamples) * len(vSamples), 2))",
        "",
        "for vi, vS in enumerate(vSamples):",
        "for ui, uS in enumerate(uSamples):",
        "uvArray[(ui * len(vSamples)) + vi] = [uS, vS]",
        "",
        "pArray = np.array(S.evaluate_list(uvArray))",
        "",
        "for CC, uv in neighbouringUV(len(uSamples), len(vSamples), closedU(), closedV()):",
        "",
        "pNW = pArray[CC[0]]",
        "pN  = pArray[CC[1]]",
        "pNE = pArray[CC[2]]",
        "pE  = pArray[CC[3]]",
        "pC =  pArray[CC[4]]",
        "pW  = pArray[CC[5]]",
        "pSW = pArray[CC[6]]",
        "pS  = pArray[CC[7]]",
        "pSE = pArray[CC[8]]",
        "",
        "dpuv_NW = np.linalg.norm(p - pNW)",
        "dpuv_N  = np.linalg.norm(p - pN)",
        "dpuv_NE = np.linalg.norm(p - pNE)",
        "dpuv_E  = np.linalg.norm(p - pE)",
        "dpuv    = np.linalg.norm(p - pC)",
        "dpuv_W  = np.linalg.norm(p - pW)",
        "dpuv_SW = np.linalg.norm(p - pSW)",
        "dpuv_S  = np.linalg.norm(p - pS)",
        "dpuv_SE = np.linalg.norm(p - pSE)",
        "",
        "testSample = [pNW, pN, pNE, pW, pC, pE, pSW, pS, pSE]",
        "",
        "if maxSearch:",
        "if ((dpuv >= dpuv_NW) and (dpuv >= dpuv_N) and (dpuv >= dpuv_NE) and",
        "(dpuv >= dpuv_W) and (dpuv >= dpuv_E) and",
        "(dpuv >= dpuv_SW) and (dpuv >= dpuv_S) and (dpuv >= dpuv_SE)):",
        "",
        "#b_NW = np.linalg.norm(pC - pNW)",
        "b_N = np.linalg.norm(pC - pN)",
        "#b_NE = np.linalg.norm(pC - pNE)",
        "b_E = np.linalg.norm(pC - pE)",
        "",
        "b_W = np.linalg.norm(pC - pW)",
        "#b_SW = np.linalg.norm(pC - pSW)",
        "b_S = np.linalg.norm(pC - pS)",
        "#b_SE = np.linalg.norm(pC - pSE)",
        "",
        "maxBound.append(max([b_N, b_E, b_W, b_S]))",
        "extremaUV.append(uvArray[CC[4]]) # uv[0]*S.sample_size_v + uv[1]",
        "extremaP.append(pArray[CC[4]])",
        "",
        "else:  # minS",
        "if ((dpuv <= dpuv_NW) and (dpuv <= dpuv_N) and (dpuv <= dpuv_NE) and",
        "(dpuv <= dpuv_W) and (dpuv <= dpuv_E) and",
        "(dpuv <= dpuv_SW) and (dpuv <= dpuv_S) and (dpuv <= dpuv_SE)):",
        "# where a point is orthogonal to a planar surface -> sphere radius test, or accept minima",
        "",
        "",
        "#b_NW = np.linalg.norm(pC - pNW)",
        "b_N = np.linalg.norm(pC - pN)",
        "#b_NE = np.linalg.norm(pC - pNE)",
        "b_E = np.linalg.norm(pC - pE)",
        "",
        "b_W = np.linalg.norm(pC - pW)",
        "#b_SW = np.linalg.norm(pC - pSW)",
        "b_S = np.linalg.norm(pC - pS)",
        "#b_SE = np.linalg.norm(pC - pSE)",
        "",
        "maxBound.append(max([b_N, b_E, b_W, b_S]))",
        "extremaUV.append(uvArray[CC[4]])",
        "extremaP.append(pArray[CC[4]])",
        "",
        "return extremaUV, extremaP, maxBound",
        "",
        "def curvatureSearch():",
        "",
        "# not S.evalpts",
        "uSamples = np.linspace(S.knotvector_u[0], S.knotvector_u[-1], num=len(S.knotvector_u) * deltaFactor,",
        "endpoint=(closedU()))",
        "vSamples = np.linspace(S.knotvector_v[0], S.knotvector_v[-1], num=len(S.knotvector_v) * deltaFactor,",
        "endpoint=(closedV()))",
        "uvArray = np.zeros((len(uSamples) * len(vSamples), 2))",
        "",
        "for vi, vS in enumerate(vSamples):",
        "for ui, uS in enumerate(uSamples):",
        "uvArray[(ui * len(vSamples)) + vi] = [uS, vS]",
        "",
        "pArray = np.array(S.evaluate_list(uvArray))",
        "",
        "discreteK = [np.inf] * len(uvArray)",
        "for CC, uv in neighbouringUV(len(uSamples), len(vSamples), closedU(), closedV()):",
        "",
        "puv = np.array(pArray[CC[4]])",
        "pur, pucc = radiusCentre3points_2(pArray[CC[3]], puv, pArray[CC[5]])",
        "pvr, pvcc = radiusCentre3points_2(pArray[CC[7]], puv, pArray[CC[1]])",
        "",
        "# S.evalpts[(S.sample_size_u * u) + v]",
        "",
        "# find media point of U curvature centre and V curvature, kuv",
        "if pur is np.inf and pvr is not np.inf:",
        "kuv = pvcc - puv",
        "elif pur is not np.inf and pvr is np.inf:",
        "kuv = pucc - puv",
        "elif pur is np.inf and pvr is np.inf:",
        "discreteK[(S.sample_size_u * uv[0]) + uv[1]] = np.inf",
        "break",
        "else:",
        "kuv = ((pucc - puv) + (pvcc - puv)) / 2",
        "",
        "dkuv = np.linalg.norm(kuv - puv)",
        "",
        "if np.linalg.norm(p - puv) > np.linalg.norm(kuv - p):",
        "# p is on the same side of the surface as the median curvature",
        "discreteK[(S.sample_size_u * uv[0]) + uv[1]] = dkuv",
        "",
        "if np.linalg.norm(p - puv) < np.linalg.norm(kuv - p):",
        "# smallest radius, with curvature centre on far side of surface from p",
        "discreteK[(S.sample_size_u * uv[0]) + uv[1]] = -dkuv",
        "",
        "# todo: examine issue with non-colinear curve centre and projecting point",
        "# e.g. proj(p)",
        "#                 if np.dot(p - p1, pucc - p1)/np.linalg.norm(pucc - p1) > 0:",
        "#                     discreteK[i] = pur",
        "#                 else:",
        "#                     discreteK[i] = -pur",
        "",
        "return discreteK",
        "",
        "def localCurvatureExtrema(discreteK):",
        "leu = []",
        "",
        "for CC, uv in neighbouringUV(S.sample_size_u, S.sample_size_v, closedU(), closedV()):",
        "surroundNodes = [CC[1], CC[3], CC[5], CC[7]]",
        "",
        "if not any(discreteK[ssn] == np.inf for ssn in surroundNodes):",
        "if maxSearch:",
        "if (all((np.abs(discreteK[ssn]) >= discreteK[(S.sample_size_u * uv[0]) + uv[1]]) for ssn in surroundNodes) and",
        "(discreteK[(S.sample_size_u * uv[0]) + uv[1]] > 0)):",
        "# this version excludes negative curves from surrounding curvature values",
        "# if all(np.abs(discreteK[ssn]) > discreteK[S.sample_size_u * u + v] or",
        "# (discreteK[ssn]<0) for ssn in surroundNodes) and",
        "# (discreteK[S.sample_size_u * u + v] > 0):",
        "leu.append(uv)",
        "else:",
        "if all((np.abs(discreteK[ssn]) >= discreteK[(S.sample_size_u * uv[0]) + uv[1]]) for ssn in",
        "surroundNodes) and (discreteK[(S.sample_size_u * uv[0]) + uv[1]] < 0):",
        "leu.append(uv)",
        "",
        "# , localExtremaP, maxBound",
        "return leu",
        "",
        "def subSearchUV(mpU, mpV, tol):",
        "# create simple subdivisions around a minimum point as simple hillclimb search",
        "tolFlag = 0",
        "divU = S.delta_u",
        "divV = S.delta_v",
        "dpuvlocal = np.linalg.norm(p - np.array(S.evaluate_single((mpU, mpV,))))",
        "#dpuvlocal = np.inner(p - np.array(S.evaluate_single((mpU, mpV,))))",
        "",
        "while not tolFlag:",
        "divU /= 2",
        "divV /= 2",
        "",
        "subDivs = [[mpU - divU, mpV + divV],",
        "[mpU, mpV + divV],",
        "[mpU + divU, mpV + divV],",
        "[mpU - divU, mpV],",
        "[mpU, mpV],",
        "[mpU + divU, mpV],",
        "[mpU - divU, mpV - divV],",
        "[mpU, mpV - divV],",
        "[mpU + divU, mpV - divV]]",
        "",
        "for sdv in subDivs:",
        "if sdv[0] > 1.0: sdv[0] = 1.0",
        "if sdv[0] < 0.0: sdv[0] = 0.0",
        "if sdv[1] > 1.0: sdv[1] = 1.0",
        "if sdv[1] < 0.0: sdv[1] = 0.0",
        "",
        "pSubDivs = S.evaluate_list(subDivs)",
        "",
        "# test np.inner",
        "# dispUV = [np.inner(p - psd) for psd in pSubDivs]",
        "",
        "dpuv_NW = np.linalg.norm(p - pSubDivs[0])",
        "dpuv_N = np.linalg.norm(p - pSubDivs[1])",
        "dpuv_NE = np.linalg.norm(p - pSubDivs[2])",
        "",
        "dpuv_W = np.linalg.norm(p - pSubDivs[3])",
        "# dpuv = np.linalg.norm(p - pSubDivs[4])",
        "dpuv_E = np.linalg.norm(p - pSubDivs[5])",
        "",
        "dpuv_SW = np.linalg.norm(p - pSubDivs[6])",
        "dpuv_S = np.linalg.norm(p - pSubDivs[7])",
        "dpuv_SE = np.linalg.norm(p - pSubDivs[8])",
        "",
        "dispUV = [dpuv_NW,",
        "dpuv_N,",
        "dpuv_NE,",
        "dpuv_W,",
        "#dpuvlocal,",
        "dpuv_E,",
        "dpuv_SW,",
        "dpuv_S,",
        "dpuv_SE]",
        "",
        "if maxSearch:",
        "if np.abs(max(dispUV) - dpuvlocal) >= tol:",
        "#np.abs(max(dispUV) - dpuvlocal) >= tol:",
        "maxUVindex = dispUV.index(max(dispUV))",
        "mpU = subDivs[maxUVindex][0]",
        "mpV = subDivs[maxUVindex][1]",
        "dpuvlocal = max(dispUV)",
        "else:",
        "tolFlag += 1",
        "else:",
        "if np.abs(min(dispUV) - dpuvlocal) >= tol:",
        "minUVindex = dispUV.index(min(dispUV))",
        "mpU = subDivs[minUVindex][0]",
        "mpV = subDivs[minUVindex][1]",
        "dpuvlocal = min(dispUV)",
        "else:",
        "tolFlag += 1",
        "return (mpU, mpV,)",
        "",
        "def NewtonRaphson(cuv, maxits=5):",
        "",
        "# def f(uv):",
        "#     return surface.derivatives(uv[0], uv[1], 2)",
        "",
        "# e[0][0], the surface point itself",
        "# e[0][1], the 1st derivative w.r.t. v",
        "# e[2][1], the 2nd derivative w.r.t. u and 1st derivative w.r.t. v",
        "",
        "def n(uv, e, r):  # np.array inputs",
        "#   f = Su(u,v) * r = 0",
        "#   g = Sv(u,v) * r = 0",
        "",
        "Su = e[1][0]",
        "Sv = e[0][1]",
        "",
        "Suu = e[2][0]",
        "Svv = e[0][2]",
        "",
        "Suv = e[1][1]",
        "Svu = e[1][1]",
        "",
        "f = np.dot(Su, r)",
        "g = np.dot(Sv, r)",
        "k = [-f, -g]",
        "",
        "J00 = np.dot(Su, Su) + np.dot(Suu, r)",
        "J01 = np.dot(Su, Sv) + np.dot(Suv, r)",
        "J10 = np.dot(Su, Sv) + np.dot(Svu, r)",
        "J11 = np.dot(Sv, Sv) + np.dot(Svv, r)",
        "",
        "# d =   [ u* - u, v* - v ]",
        "# k = - [ f(u,v), g(u,v) ]",
        "# J =   |Su|^2   +  Suu * r       Su*Sv  +  Suv * r",
        "#        Su*Sv   +  Svu * r      |Sv|^2  +  Svv * r",
        "",
        "J = [[J00, J01], [J10, J11]]",
        "d = np.linalg.solve(J, k)",
        "return d + uv",
        "",
        "i = 0",
        "# e = None",
        "while i < maxits:",
        "if (cuv[0] < 0) or (cuv[0] > 1) or (cuv[1] < 0) or (cuv[1] > 1):",
        "return (np.inf, np.inf) # derivatives sometimes > |2|",
        "",
        "#test = S.derivatives(1.0, 0.0, 0)",
        "",
        "e = np.array(S.derivatives(cuv[0], cuv[1], 2))",
        "dif = e[0][0] - p # e[0][0] is surface point evaluated at cuv(u,v)",
        "c1v = np.linalg.norm(dif)",
        "c1 = c1v < eps1 #  |S(u,v) - p| < e1 (point coincidence)",
        "",
        "#  |Su(u,v)*(S(u,v) - P)|",
        "#  ----------------------  < e2 (cosine minima)",
        "#  |Su(u,v)| |S(u,v) - P|",
        "",
        "c2an = np.dot(e[1][0], dif)",
        "c2ad = np.linalg.norm(e[1][0]) * c1v",
        "c2av = c2an / c2ad",
        "c2a = c2av < eps2",
        "",
        "#  |Sv(u,v)*(S(u,v) - P)|",
        "#  ----------------------  < e2 (cosine minima)",
        "#  |Sv(u,v)| |S(u,v) - P|",
        "",
        "c2bn = np.dot(e[0][1], dif)",
        "c2bd = np.linalg.norm(e[0][1]) * c1v",
        "c2bv = c2bn / c2bd",
        "c2b = c2bv < eps2",
        "",
        "# exit if all tolerance are met,",
        "if (c1 and c2a and c2b):",
        "return cuv",
        "",
        "# otherwise, take a step",
        "ct = n(cuv, e, dif)",
        "",
        "#  correct for exceeding bounds",
        "if ct[0] < S.knotvector_u[0]: # [ maxu - ( ct[0] - minu ), ct[1] ]",
        "if closedU(): ct = [S.knotvector_u[-1] - (S.knotvector_u[0] - ct[0]), ct[1]]",
        "#if closedU(): ct = [S.knotvector_u[0] + ct[0] % (S.knotvector_u[-1] - S.knotvector_u[0]), ct[1]]",
        "else: ct = [S.knotvector_u[0] + eps_bspline, ct[1]]",
        "",
        "elif ct[0] > S.knotvector_u[-1]:",
        "if closedU(): ct = [S.knotvector_u[0] + (ct[0] - S.knotvector_u[-1]), ct[1]]",
        "#if closedU(): ct = [S.knotvector_u[-1] - ct[0] % (S.knotvector_u[-1] - S.knotvector_u[0]), ct[1]]",
        "else: ct = [S.knotvector_u[-1] - eps_bspline, ct[1]]",
        "",
        "if ct[1] < S.knotvector_v[0]:",
        "if closedV(): ct = [ct[0], S.knotvector_v[-1] - (S.knotvector_v[0] - ct[1])]",
        "#if closedV(): ct = [ct[0], S.knotvector_v[0] + ct[1] % (S.knotvector_v[-1] - S.knotvector_v[0])]",
        "else: ct = [ct[0], S.knotvector_v[0] + eps_bspline]",
        "",
        "elif ct[1] > S.knotvector_v[-1]:",
        "#if closedV(): ct = [ct[0], S.knotvector_v[0] + (ct[1] - S.knotvector_v[-1])]",
        "if closedV(): ct = [ct[0], S.knotvector_v[-1] - ct[1] % (S.knotvector_v[-1] - S.knotvector_v[0])]",
        "else: ct = [ct[0], S.knotvector_v[-1] - eps_bspline]",
        "",
        "c3v0 = np.linalg.norm((ct[0] - cuv[0]) * e[1][0])",
        "c3v1 = np.linalg.norm((ct[1] - cuv[1]) * e[0][1])",
        "",
        "# if |(u* - u) C'(u)| < e1, halt",
        "if (c3v0 + c3v1 < eps1):",
        "return cuv",
        "cuv = ct",
        "i += 1",
        "",
        "if i == maxits:  # Newton-Raphson fails",
        "return (np.inf, np.inf)",
        "return cuv",
        "",
        "if curvatureTest:  # discrete grid summing curvatures along U and V axes",
        "localExtremaUV, localExtremaP, maxBound = localCurvatureExtrema(curvatureSearch())",
        "else:",
        "localExtremaUV, localExtremaP, maxBound = localNeighbourSearch(S)",
        "",
        "extremaUV = []",
        "for luv, lp, mb in zip(localExtremaUV, localExtremaP, maxBound):",
        "#mUV = subSearchUV(luv[0], luv[1], eps_bspline)",
        "mUV = NewtonRaphson(luv)",
        "",
        "if not np.inf in mUV:",
        "# find a maximum deviation to indicate when N-R fails",
        "if np.linalg.norm(lp - np.array(S.evaluate_single(mUV))) <= mb:",
        "extremaUV.append(mUV)",
        "else:",
        "mUV = (np.inf, np.inf)",
        "if np.inf in mUV:",
        "# Newton-Raphson fail, try hillclimb",
        "mUV = subSearchUV(luv[0], luv[1], eps_bspline)",
        "extremaUV.append(mUV)",
        "# print(S.evalpts[(S.sample_size_u * luv[0]) + luv[1]])",
        "",
        "# filter out identical values",
        "extremaUnique = []",
        "for m in extremaUV:",
        "# displacement between any 2 points < eps1",
        "# compare u, v individually to reduce comparison pool",
        "if not any([np.isclose(m, u, eps1).all() for u in extremaUnique]):",
        "extremaUnique.append(m)",
        "",
        "# print(S.evaluate_list(extremaUnique))",
        "",
        "if len(extremaUnique) == 0: return []",
        "",
        "if (localExtrema and (len(extremaUnique) == 1)) or not localExtrema:  # if there is only one extrema, localextrema is moot",
        "if uv_xyz: return extremaUnique # return single value in list for compatibility",
        "else: return [np.array(S.evaluate_single(extremaUnique[0])),]",
        "else:",
        "if localExtrema:",
        "if uv_xyz: return extremaUnique",
        "else: return S.evaluate_list(extremaUnique)",
        "else: # return single maxima",
        "extremaUniquePoint = S.evaluate_list(extremaUnique)",
        "dispsExtrema = [np.linalg.norm(np.array(e) - p) for e in extremaUniquePoint]",
        "if maxSearch: # return single value in list for compatibility",
        "if uv_xyz: return [extremaUnique[dispsExtrema.index(max(dispsExtrema))],]",
        "else: return [np.array(extremaUniquePoint[dispsExtrema.index(max(dispsExtrema))]),]",
        "else: # minsearch",
        "if uv_xyz: return [extremaUnique[dispsExtrema.index(min(dispsExtrema))],]",
        "else: return [np.array(extremaUniquePoint[dispsExtrema.index(min(dispsExtrema))]),]",
        "def rationalSurfaceExtremaParam_4(S, p,",
        "maxSearch=True,",
        "localExtrema=False,",
        "curvatureTest=False,",
        "uv_xyz=True,",
        "eps1=0.0001,",
        "eps2=0.0005,",
        "delta=0.025,",
        "eps_bspline = 1E-10):",
        "'''",
        "Use either Newton-Raphson, or a hillclimbing neighbour search to find minimal or maximal distance on a surface, S, from a supplied point, p",
        "- not tested with surfaces closed along U & V",
        "maxSearch: search for most distant point from p if true, else nearest if false",
        "localExtrema: find any local extrema which differs from surrounding sample points, tolerance not sufficiently defined",
        "curvatureTest: rather than displacement of sampled points to provide seed locations for N-R/hillclimb search,",
        "use a combination of the centres of curvature at any point across U-axis and V-axis to identify C2 inflection point.",
        "uv_xyz: return u,v normalised values or cartesian x,y,z values",
        "eps1: point coincidence limit, halt N-R on reaching this minima",
        "eps2: cosine angle limit, halt N-R on reaching this minima",
        "delta: sample interval dividing surface into points",
        "'''",
        "",
        "# easy to find a minimum, but a maximum found through the original hillclimbing algorithm will settle on local maxima",
        "# for surfaces, minimize the following:",
        "#",
        "# f = Su(u,v) * r = 0",
        "# g = Sv(u,v) * r = 0",
        "#",
        "#   where r = S(u,v) - P",
        "#",
        "# Requires Newton-Raphson iteration, objective function is vector valued",
        "#",
        "#     J d = k",
        "#",
        "#     d =   [ u* - u, v* - v ] (alternatively u[i+1] -  u[i], v[i+1]- v[i])",
        "#     k = - [ f(u,v), g(u,v) ]",
        "#     J =     |Su|^2   +  Suu * r       Su*Sv  +  Suv * r",
        "#              Su*Sv   +  Svu * r      |Sv|^2  +  Svv * r",
        "#",
        "# halting conditions:",
        "# point coincidence",
        "#",
        "#         |S(u,v) - p| < e1",
        "#",
        "# cosine",
        "#",
        "#    |Su(u,v)*(S(u,v) - P)|",
        "#    ----------------------  < e2",
        "#    |Su(u,v)| |S(u,v) - P|",
        "#",
        "#    |Sv(u,v)*(S(u,v) - P)|",
        "#    ----------------------  < e2",
        "#    |Sv(u,v)| |S(u,v) - P|",
        "#",
        "# 1) first check 2 & 3",
        "# 2) if at least one of these is not, compute new value, otherwise halt",
        "# 3) ensure the parameter stays within range",
        "#     * if not closed, don't allow outside of range a-b",
        "#     * if closed (e.g. circle), allow to move back to beginning",
        "# 4)  if |(u* - u)C'(u)| < e1, halt",
        "",
        "# todo: take value from STEP fields",
        "# check if surface closed along U and V",
        "",
        "def closedU():",
        "return np.isclose([np.array(s[0]) - np.array(s[-1]) for s in S.ctrlpts2d], eps_bspline).all()",
        "",
        "def closedV():",
        "return np.isclose(np.array(S.ctrlpts2d[0]) - np.array(S.ctrlpts2d[-1]), eps_bspline).all()  # eps_STEP_AP21",
        "",
        "S.delta = delta  # set evaluation delta",
        "# tradeoff between sample density and feature identification",
        "",
        "if S.evalpts == None:  # evaluate surface points---------appears redundant",
        "S.evaluate()",
        "",
        "def neighbouringUV(S):",
        "# generator function to yield neighbouring indices over a matrix of size U x V",
        "",
        "U = S.sample_size_u",
        "V = S.sample_size_v",
        "",
        "openU = not closedU()",
        "openV = not closedV()",
        "",
        "for v in range(openV, V - openV):",
        "for u in range(openU, U - openU):",
        "",
        "if openV == 0 and openU == 0:",
        "if ((u == 0 and v == 0) or",
        "(u == 0 and v == V - 1) or",
        "(u == U - 1 and v == 0) or",
        "(u == U - 1 and v == V - 1)):",
        "# how does the topology of closed U & V work anyway?",
        "continue",
        "",
        "if u == 0:  # closed in u direction",
        "if v == V - 1:  # closed in v direction",
        "NW = (U * (v + 1)) - 1",
        "else:",
        "NW = (U * (v + 2)) - 1",
        "",
        "W = (U * (v + 1)) - 1",
        "",
        "if v == 0:",
        "SW = U - 1",
        "else:",
        "SW = (U * v) - 1",
        "",
        "if v == V - 1:  # closed in v direction",
        "N = u",
        "else:",
        "N = U * (v + 1)",
        "",
        "C = U * v",
        "",
        "if v == 0:",
        "S = U",
        "else:",
        "S = U * (v - 1)",
        "",
        "if u == 1:",
        "if v == V - 1:  # closed in v direction",
        "NW = u - 1",
        "else:",
        "NW = U * (v + 1)",
        "",
        "W = U * v",
        "",
        "if v == 0:",
        "SW = U * (V - 1)",
        "else:",
        "SW = U * (v - 1)  # ??",
        "",
        "if v == V - 1:  # closed in v direction",
        "N = u",
        "else:",
        "N = (U * (v + 1)) + 1",
        "",
        "C = (U * v) + 1",
        "",
        "if v == 0:",
        "S = (U * (V - 1)) + 1",
        "else:",
        "S = (U * (v - 1)) + 1",
        "",
        "if u > 1:",
        "NW = N",
        "W = C  # central instance",
        "SW = S",
        "",
        "N = NE",
        "C = E",
        "S = SE",
        "",
        "elif u == U - 1:  # closed in u direction",
        "if v == V - 1:  # closed in v direction",
        "NE = u",
        "else:",
        "NE = (U * (v + 1)) + 1",
        "",
        "E = (U * v) + 1",
        "",
        "if v == 0:",
        "SE = (U * (V - 1)) + u + 1",
        "else:",
        "SE = (U * (v - 2)) + 1",
        "",
        "if u < U - 1:  # only have to calculate this once per loop",
        "if v == V - 1:  # closed in v direction",
        "NE = u + 1",
        "else:",
        "NE = (U * (v + 1)) + u + 1",
        "",
        "E = (U * v) + u + 1",
        "",
        "if v == 0:",
        "SE = (U * (V - 1)) + u + 1",
        "else:",
        "SE = (U * (v - 1)) + u + 1",
        "",
        "# print([NW, N, NE])",
        "# print([W, C, E])",
        "# print([SW, S, SE])",
        "# print(\"==========\")",
        "",
        "yield ([NW, N, NE, W, C, E, SW, S, SE], (v, u))",
        "",
        "def localNeighbourSearch():",
        "extremaUV = []",
        "",
        "for CC, uv in neighbouringUV(S):",
        "dpuv_NW = np.linalg.norm(p - np.array(S.evalpts[CC[0]]))",
        "dpuv_N  = np.linalg.norm(p - np.array(S.evalpts[CC[1]]))",
        "dpuv_NE = np.linalg.norm(p - np.array(S.evalpts[CC[2]]))",
        "dpuv_E  = np.linalg.norm(p - np.array(S.evalpts[CC[3]]))",
        "dpuv    = np.linalg.norm(p - np.array(S.evalpts[CC[4]]))",
        "dpuv_W  = np.linalg.norm(p - np.array(S.evalpts[CC[5]]))",
        "dpuv_SW = np.linalg.norm(p - np.array(S.evalpts[CC[6]]))",
        "dpuv_S  = np.linalg.norm(p - np.array(S.evalpts[CC[7]]))",
        "dpuv_SE = np.linalg.norm(p - np.array(S.evalpts[CC[8]]))",
        "",
        "if maxSearch:",
        "if ((dpuv >= dpuv_NW) and (dpuv >= dpuv_N) and (dpuv >= dpuv_NE) and",
        "(dpuv >= dpuv_W) and (dpuv >= dpuv_E) and",
        "(dpuv >= dpuv_SW) and (dpuv >= dpuv_S) and (dpuv >= dpuv_SE)):",
        "extremaUV.append(uv)",
        "else:  # minS",
        "if ((dpuv <= dpuv_NW) and (dpuv <= dpuv_N) and (dpuv <= dpuv_NE) and",
        "(dpuv <= dpuv_W) and (dpuv <= dpuv_E) and",
        "(dpuv <= dpuv_SW) and (dpuv <= dpuv_S) and (dpuv <= dpuv_SE)):",
        "# where a point is orthogonal to a planar surface -> sphere radius test, or accept minima",
        "extremaUV.append(uv)",
        "",
        "return extremaUV",
        "",
        "def curvatureSearch():",
        "discreteK = [np.inf] * len(S.evalpts)",
        "for CC, uv in neighbouringUV(S):",
        "",
        "puv = np.array(S.evalpts[CC[4]])",
        "pur, pucc = radiusCentre3points_2(np.array(S.evalpts[CC[3]]), puv, np.array(S.evalpts[CC[5]]))",
        "pvr, pvcc = radiusCentre3points_2(np.array(S.evalpts[CC[7]]), puv, np.array(S.evalpts[CC[1]]))",
        "",
        "# S.evalpts[(S.sample_size_u * u) + v]",
        "",
        "# find media point of U curvature centre and V curvature, kuv",
        "if pur is np.inf and pvr is not np.inf:",
        "kuv = pvcc - puv",
        "elif pur is not np.inf and pvr is np.inf:",
        "kuv = pucc - puv",
        "elif pur is np.inf and pvr is np.inf:",
        "discreteK[(S.sample_size_u * uv[0]) + uv[1]] = np.inf",
        "break",
        "else:",
        "kuv = ((pucc - puv) + (pvcc - puv)) / 2",
        "",
        "dkuv = np.linalg.norm(kuv - puv)",
        "",
        "if np.linalg.norm(p - puv) > np.linalg.norm(kuv - p):",
        "# p is on the same side of the surface as the median curvature",
        "discreteK[(S.sample_size_u * uv[0]) + uv[1]] = dkuv",
        "",
        "if np.linalg.norm(p - puv) < np.linalg.norm(kuv - p):",
        "# smallest radius, with curvature centre on far side of surface from p",
        "discreteK[(S.sample_size_u * uv[0]) + uv[1]] = -dkuv",
        "",
        "# todo: examine issue with non-colinear curve centre and projecting point",
        "# e.g. proj(p)",
        "#                 if np.dot(p - p1, pucc - p1)/np.linalg.norm(pucc - p1) > 0:",
        "#                     discreteK[i] = pur",
        "#                 else:",
        "#                     discreteK[i] = -pur",
        "",
        "return discreteK",
        "",
        "def localCurvatureExtrema(discreteK):",
        "leu = []",
        "for CC, uv in neighbouringUV(S):",
        "surroundNodes = [CC[1], CC[3], CC[5], CC[7]]",
        "",
        "if not any(discreteK[ssn] == np.inf for ssn in surroundNodes):",
        "if maxSearch:",
        "if (all((np.abs(discreteK[ssn]) >= discreteK[(S.sample_size_u * uv[0]) + uv[1]]) for ssn in surroundNodes) and",
        "(discreteK[(S.sample_size_u * uv[0]) + uv[1]] > 0)):",
        "# this version excludes negative curves from surrounding curvature values",
        "# if all(np.abs(discreteK[ssn]) > discreteK[S.sample_size_u * u + v] or",
        "# (discreteK[ssn]<0) for ssn in surroundNodes) and",
        "# (discreteK[S.sample_size_u * u + v] > 0):",
        "leu.append(uv)",
        "else:",
        "if all((np.abs(discreteK[ssn]) >= discreteK[(S.sample_size_u * uv[0]) + uv[1]]) for ssn in",
        "surroundNodes) and (discreteK[(S.sample_size_u * uv[0]) + uv[1]] < 0):",
        "leu.append(uv)",
        "return leu",
        "",
        "def subSearchUV(mpU, mpV, tol):",
        "# create simple subdivisions around a minimum point as simple hillclimb search",
        "tolFlag = 0",
        "divU = S.delta_u",
        "divV = S.delta_v",
        "dpuvlocal = np.linalg.norm(p - S.evaluate_single((mpU, mpV,)))",
        "",
        "while not tolFlag:",
        "divU /= 2",
        "divV /= 2",
        "",
        "subDivs = [(mpU - divU, mpV + divV),",
        "(mpU, mpV + divV),",
        "(mpU + divU, mpV + divV),",
        "(mpU - divU, mpV),",
        "(mpU, mpV),",
        "(mpU + divU, mpV),",
        "(mpU - divU, mpV - divV),",
        "(mpU, mpV - divV),",
        "(mpU + divU, mpV - divV)]",
        "",
        "pSubDivs = S.evaluate_list(subDivs)",
        "",
        "dpuv_NW = np.linalg.norm(p - pSubDivs[0])",
        "dpuv_N = np.linalg.norm(p - pSubDivs[1])",
        "dpuv_NE = np.linalg.norm(p - pSubDivs[2])",
        "",
        "dpuv_W = np.linalg.norm(p - pSubDivs[3])",
        "# dpuv = np.linalg.norm(p - pSubDivs[4])",
        "dpuv_E = np.linalg.norm(p - pSubDivs[5])",
        "",
        "dpuv_SW = np.linalg.norm(p - pSubDivs[6])",
        "dpuv_S = np.linalg.norm(p - pSubDivs[7])",
        "dpuv_SE = np.linalg.norm(p - pSubDivs[8])",
        "",
        "dispUV = [dpuv_NW,",
        "dpuv_N,",
        "dpuv_NE,",
        "dpuv_W,",
        "dpuvlocal,",
        "dpuv_E,",
        "dpuv_SW,",
        "dpuv_S,",
        "dpuv_SE]",
        "",
        "if maxSearch:",
        "if np.abs(max(dispUV) - dpuvlocal) >= tol:",
        "maxUVindex = dispUV.index(max(dispUV))",
        "mpU = subDivs[maxUVindex][0]",
        "mpV = subDivs[maxUVindex][1]",
        "dpuvlocal = max(dispUV)",
        "else:",
        "tolFlag += 1",
        "else:",
        "if np.abs(min(dispUV) - dpuvlocal) >= tol:",
        "minUVindex = dispUV.index(min(dispUV))",
        "mpU = subDivs[minUVindex][0]",
        "mpV = subDivs[minUVindex][1]",
        "dpuvlocal = min(dispUV)",
        "else:",
        "tolFlag += 1",
        "return (mpU, mpV,)",
        "",
        "def NewtonRaphson(cuv, maxits=5):",
        "",
        "# def f(uv):",
        "#     return surface.derivatives(uv[0], uv[1], 2)",
        "",
        "def n(uv, e, r):  # np.array inputs",
        "#   f = Su(u,v) * r = 0",
        "#   g = Sv(u,v) * r = 0",
        "",
        "Su = e[1][0]",
        "Sv = e[0][1]",
        "",
        "Suu = e[2][0]",
        "Svv = e[0][2]",
        "",
        "Suv = e[1][1]",
        "Svu = e[1][1]",
        "",
        "f = np.dot(Su, r)",
        "g = np.dot(Sv, r)",
        "k = [-f, -g]",
        "",
        "J00 = np.dot(Su, Su) + np.dot(Suu, r)",
        "J01 = np.dot(Su, Sv) + np.dot(Suv, r)",
        "J10 = np.dot(Su, Sv) + np.dot(Svu, r)",
        "J11 = np.dot(Sv, Sv) + np.dot(Svv, r)",
        "",
        "# d =   [ u* - u, v* - v ]",
        "# k = - [ f(u,v), g(u,v) ]",
        "# J =   |Su|^2   +  Suu * r       Su*Sv  +  Suv * r",
        "#        Su*Sv   +  Svu * r      |Sv|^2  +  Svv * r",
        "",
        "J = [[J00, J01], [J10, J11]]",
        "d = np.linalg.solve(J, k)",
        "return d + uv",
        "",
        "i = 0",
        "# e = None",
        "while i < maxits:",
        "",
        "e = np.array(S.derivatives(cuv[0], cuv[1], 2))",
        "dif = e[0][0] - p",
        "c1v = np.linalg.norm(dif)   #  |S(u,v) - p| < e1 (point coincidence)",
        "",
        "#  |Su(u,v)*(S(u,v) - P)|",
        "#  ----------------------  < e2 (cosine minima)",
        "#  |Su(u,v)| |S(u,v) - P|",
        "",
        "c2an = np.dot(e[1][0], dif)",
        "c2ad = np.linalg.norm(e[1][0]) * c1v",
        "c2bn = np.dot(e[0][1], dif)",
        "c2bd = np.linalg.norm(e[0][1]) * c1v",
        "c2av = c2an / c2ad",
        "c2bv = c2bn / c2bd",
        "c1 = c1v < eps1",
        "c2a = c2av < eps2",
        "c2b = c2bv < eps2",
        "",
        "# exit if all tolerance are met,",
        "if (c1 and c2a and c2b): return cuv",
        "",
        "# otherwise, take a step",
        "ct = n(cuv, e, dif)",
        "",
        "#  correct for exceeding bounds",
        "if ct[0] < S.knotvector_u[0]: # [ maxu - ( ct[0] - minu ), ct[1] ]",
        "#if closedU(): ct = [S.knotvector_u[-1] - (ct[0] - S.knotvector_u[0]), ct[1]] #- incorrect in Piegel Tiller NURBS book",
        "if closedU(): ct = [S.knotvector_u[-1] - (S.knotvector_u[0] - ct[0]), ct[1]]",
        "else: ct = [S.knotvector_u[0] + eps_bspline, ct[1]]",
        "",
        "elif ct[0] > S.knotvector_u[-1]: # [ minu + ( ct[0] - maxu ), ct[1] ]",
        "#if closedU(): ct = [S.knotvector_u[0] + (ct[0] - S.knotvector_u[-1]), ct[1]]",
        "if closedU(): ct = [S.knotvector_u[0] + (ct[0] % S.knotvector_u[-1]), ct[1]]",
        "#if closedU(): ct = [S.knotvector_u[0] + (S.knotvector_u[-1] - ct[0]), ct[1]]",
        "else: ct = [S.knotvector_u[-1] - eps_bspline, ct[1]]",
        "",
        "if ct[1] < S.knotvector_v[0]: # [ ct[0], maxv - ( ct[1] - minv ) ]",
        "if closedV(): ct = [ct[0], S.knotvector_v[-1] - (ct[1] - S.knotvector_v[0])]",
        "#if closedV(): ct = [ct[0], S.knotvector_v[-1] - (S.knotvector_v[0] - ct[1])]",
        "else: ct = [ct[0], S.knotvector_v[0] + eps_bspline]",
        "",
        "elif ct[1] > S.knotvector_v[-1]: # [ ct[0], minv + ( ct[0] - maxv ) ]",
        "if closedV(): ct = [ct[0], S.knotvector_v[0] + (ct[0] - S.knotvector_v[-1])]",
        "else: ct = [ct[0], S.knotvector_v[-1] - eps_bspline]",
        "",
        "# if ( ct[0] < minu ){",
        "#                 ct = closedu ? [ maxu - ( ct[0] - minu ), ct[1] ] : [ minu + Constants.EPSILON, ct[1] ];",
        "#             } else if (ct[0] > maxu){",
        "#                 ct = closedu ? [ minu + ( ct[0] - maxu ), ct[1] ] : [ maxu - Constants.EPSILON, ct[1] ];",
        "#             }",
        "#",
        "#             if ( ct[1] < minv ){",
        "#                 ct = closedv ? [ ct[0], maxv - ( ct[1] - minv ) ] : [ ct[0], minv + Constants.EPSILON ];",
        "#             } else if (ct[1] > maxv){",
        "#                 ct = closedv ? [ ct[0], minv + ( ct[0] - maxv ) ] : [ ct[0], maxv - Constants.EPSILON ];",
        "#             }",
        "",
        "c3v0 = np.linalg.norm((ct[0] - cuv[0]) * e[1][0])",
        "c3v1 = np.linalg.norm((ct[1] - cuv[1]) * e[0][1])",
        "",
        "# if |(u* - u) C'(u)| < e1, halt",
        "if (c3v0 + c3v1 < eps1):",
        "return cuv",
        "cuv = ct",
        "i += 1",
        "",
        "if i == maxits:  # Newton-Raphson fails",
        "return (np.inf, np.inf)",
        "return cuv",
        "",
        "if curvatureTest:  # discrete grid summing curvatures along U and V axes",
        "localExtremaUV = localCurvatureExtrema(curvatureSearch())",
        "else:",
        "localExtremaUV = localNeighbourSearch()",
        "",
        "extremaUV = []",
        "for luv in localExtremaUV:",
        "# print(luv[0] * S.delta_u, luv[1] * S.delta_v,)",
        "# tc = NewtonRaphson((luv[0] * S.delta_u, luv[1] * S.delta_v,))",
        "# print(S.evaluate_single(tc))",
        "mUV = NewtonRaphson((luv[0] * S.delta_u, luv[1] * S.delta_v,))",
        "if np.inf not in mUV:",
        "extremaUV.append(mUV)",
        "else:",
        "# Newton-Raphson fail, try hillclimb",
        "mUV = subSearchUV(luv[0] * S.delta_u, luv[1] * S.delta_v, eps_bspline)",
        "extremaUV.append(mUV)",
        "# print(S.evalpts[(S.sample_size_u * luv[0]) + luv[1]])",
        "",
        "# filter out identical values",
        "extremaUnique = []",
        "for m in extremaUV:",
        "# displacement between any 2 points < eps1",
        "# compare u, v individually to reduce comparison pool",
        "if not any([np.isclose(m, u, eps1).all() for u in extremaUnique]):",
        "extremaUnique.append(m)",
        "",
        "# print(S.evaluate_list(extremaUnique))",
        "",
        "if len(extremaUnique) == 0: return []",
        "",
        "# if localExtrema and (len(extremaUnique) > 1):  # if there is only one extrema, localextrema is moot",
        "#     if uv_xyz: return extremaUnique",
        "#     else: return S.evaluate_list(extremaUnique)",
        "# else:",
        "#     extremaUniquePoint = S.evaluate_list(extremaUnique)",
        "#     dispsExtrema = [np.linalg.norm(np.array(e) - p) for e in extremaUniquePoint]",
        "#     if maxSearch:",
        "#         if uv_xyz: return [extremaUnique[dispsExtrema.index(max(dispsExtrema))],]",
        "#         else: return [extremaUniquePoint[dispsExtrema.index(max(dispsExtrema))],]",
        "#     else:",
        "#         if uv_xyz: return [extremaUnique[dispsExtrema.index(min(dispsExtrema))],]",
        "#         else: return [extremaUniquePoint[dispsExtrema.index(min(dispsExtrema))].]",
        "",
        "if (localExtrema and (len(extremaUnique) == 1)) or not localExtrema:  # if there is only one extrema, localextrema is moot",
        "if uv_xyz: return extremaUnique # return single value in list for compatibility",
        "else: return [np.array(S.evaluate_single(extremaUnique[0])),]",
        "else:",
        "if localExtrema:",
        "if uv_xyz: return extremaUnique",
        "else: return S.evaluate_list(extremaUnique)",
        "else: # return single maxima",
        "extremaUniquePoint = S.evaluate_list(extremaUnique)",
        "dispsExtrema = [np.linalg.norm(np.array(e) - p) for e in extremaUniquePoint]",
        "if maxSearch: # return single value in list for compatibility",
        "if uv_xyz: return [extremaUnique[dispsExtrema.index(max(dispsExtrema))],]",
        "else: return [np.array(extremaUniquePoint[dispsExtrema.index(max(dispsExtrema))]),]",
        "else: # minsearch",
        "if uv_xyz: return [extremaUnique[dispsExtrema.index(min(dispsExtrema))],]",
        "else: return [np.array(extremaUniquePoint[dispsExtrema.index(min(dispsExtrema))]),]",
        "def BsplineCurveExtremaDisp(curve, p,",
        "maxSearch=True,",
        "localExtrema=False,",
        "curvatureTest=False,",
        "uv_xyz=True,",
        "eps1=0.0001,",
        "eps2=0.0005,",
        "delta=0.025,",
        "eps_bspline = 1E-10):",
        "",
        "# based on Nurbs Book, Piegl & Tiller p.230",
        "# same idea to find orthogonal tangent, but at maximum/minimum displacement from a centroid point",
        "# revised to test minima segment candidates using 3-point defined circle parameters",
        "",
        "# def radiusCentre3points2(p1, p2, p3):",
        "#     # radius + centre from 3 point circle",
        "#",
        "#     #collinear test",
        "#     coords = np.array([p1, p2, p3])",
        "#     coords -= coords[0]  # offset for collinear points to intersect the origin",
        "#     if np.linalg.matrix_rank(coords, tol=None) == 1:",
        "#         return np.inf, []",
        "#",
        "#     t = p2 - p1",
        "#     u = p3 - p1",
        "#     v = p3 - p2",
        "#",
        "#     w = np.cross(t, u)  # triangle normal",
        "#     wsl = np.linalg.norm(w)",
        "#     if (wsl < 10e-14):",
        "#         return False  # triangle area too small",
        "#",
        "#     wsl = np.dot(w, w)",
        "#     iwsl2 = 1. / (2. * wsl)",
        "#     tt = np.dot(t, t)",
        "#     uu = np.dot(u, u)",
        "#",
        "#     circCenter = p1 + (u * tt * (np.dot(u, v)) - t * uu * (np.dot(t, v))) * iwsl2",
        "#     circRadius = np.sqrt(tt * uu * (np.dot(v, v)) * iwsl2 * 0.5)",
        "#     # circAxis   = w / np.sqrt(wsl)",
        "#",
        "#     return circRadius, circCenter",
        "",
        "# eps1 = 0.0001   # Euclidean distance measure",
        "# eps2 = 0.0005   # zero cosine measure",
        "# eps_bspline = 1E-10",
        "minU = curve.knotvector[0]",
        "maxU = curve.knotvector[-1]",
        "",
        "def closedC():",
        "return np.isclose(np.linalg.norm(np.array(curve.ctrlpts[0]) - np.array(curve.ctrlpts[-1])), eps_bspline)",
        "",
        "def subSearchU(C, mpU, tol):",
        "# create simple subdivisions around a minimum point on curve as simple hillclimb search",
        "tolFlag = 0",
        "divU = C.delta",
        "dpulocal = np.linalg.norm(p - C.evaluate_single(mpU))",
        "",
        "while not tolFlag:",
        "divU /= 2",
        "subDivs = [mpU - divU, mpU, mpU + divU]",
        "pSubDivs = C.evaluate_list(subDivs)",
        "",
        "dpu_L = np.linalg.norm(p - pSubDivs[0])",
        "dpu_R = np.linalg.norm(p - pSubDivs[1])",
        "",
        "dispU = [dpu_L, dpulocal, dpu_R]",
        "",
        "if maxSearch:",
        "if np.abs(max(dispU) - dpulocal) >= tol:",
        "maxUindex = dispU.index(max(dispU))",
        "mpU = subDivs[maxUindex]",
        "dpulocal = max(dispU)",
        "else:",
        "tolFlag += 1",
        "else:",
        "if np.abs(min(dispU) - dpulocal) >= tol:",
        "minUindex = dispU.index(min(dispU))",
        "mpU = subDivs[minUindex]",
        "dpulocal = min(dispU)",
        "else:",
        "tolFlag += 1",
        "return mpU",
        "",
        "def NewtonRaphson(cu, maxits=5):",
        "",
        "def n(u2, e1, d):",
        "#   Newton's method: \t u* = u - f / f'",
        "#   use product rule to form derivative, f':   f' = C\"(u) * ( C(u) - p ) + C'(u) * C'(u)",
        "#   d:  ( C(u) - p )",
        "return u2 - (np.dot(e1[1], d) / (np.dot(e1[2], d) + np.dot(e1[1], e1[1])))",
        "",
        "i = 0",
        "while (i < maxits):",
        "# Newton iteration to find orthogonal tangent and is max/min agnostic",
        "e = np.array(curve.derivatives(cu, order=2))  # f(cu)",
        "dif = e[0] - p                      # C(u) - p",
        "c1v = np.linalg.norm(dif)           # |C(u) - p|",
        "c2n = np.dot(e[1], dif)             # C'(u) * (C(u) - P)",
        "c2d = np.linalg.norm(e[1]) * c1v    # |C'(u)||C(u) - P|",
        "c2v = c2n / c2d                     # |C'(u) * (C(u) - P)| / |C'(u)||C(u) - P|",
        "# c2v = np.dot(e[1], dif) / (np.linalg.norm(e[1]) * np.linalg.norm(dif))",
        "",
        "if (c1v < eps1) and (np.abs(c2v) < eps2):",
        "return cu",
        "# ct = n(cu, e, dif)                           #   u* = u - f / f'",
        "ct = cu - (np.dot(e[1], dif) / (np.dot(e[2], dif) + np.dot(e[1], e[1])))",
        "",
        "if ct < minU:",
        "if closedC(): ct = maxU - (minU - ct) # ct = maxU - (ct - minU) # NURBS book",
        "else: ct = minU",
        "",
        "elif ct > maxU:",
        "if closedC(): ct = minU + (ct - maxU)",
        "else: ct = maxU",
        "",
        "c3v = np.linalg.norm(np.multiply(ct - cu, e[1]))",
        "if c3v < eps1:",
        "return cu",
        "",
        "cu = ct",
        "i += 1",
        "",
        "if i == maxits:  # Newton-Raphson fails",
        "return np.inf",
        "return cu",
        "",
        "# numSamples = curve.ctrlpts_size * curve.degree * curveSampleFactor",
        "# span = (curve.knotvector[-1] - curve.knotvector[0]) / (numSamples - 1)",
        "# kvs = np.array([curve.knotvector[0] + (span * i) for i in range(0, numSamples)])",
        "# pts = curve.evaluate_list(kvs)",
        "",
        "#pts, kvs = splineToPolyline(curve, curveSampleFactor=delta) todo 1/curve.delta?",
        "pts, kvs = splineToPolyline(curve, curveSampleFactor=2)",
        "",
        "# original version fails on points of equal minimal curvature",
        "",
        "# 2-part selection for global maxima using both displacement and curve inflection",
        "# curve inflection determined from local curvature minima - prob doesn't work for self intersecting curves",
        "# get set of local minima curvature - use for curve characterisation",
        "# from set, find minima/maxima disp from point-of-interest to curve point tangent",
        "",
        "# curvature approach fails without C2 continuity at minima/maxima?",
        "# not much of an issue with STEP spline limitations",
        "",
        "if curvatureTest: discreteK = [np.inf] * len(pts)",
        "",
        "localDisp = [0] * len(pts)",
        "localExtremaU = []",
        "",
        "# get discrete curvature values and point displacement",
        "for i in range(1-closedC(), len(pts) - 1 + closedC()):",
        "if (i == 0):",
        "p0 = np.array(pts[-1])",
        "p1 = np.array(pts[0])",
        "p2 = np.array(pts[1])",
        "",
        "elif (i == len(pts)-1):",
        "p0 = np.array(pts[-2])",
        "p1 = np.array(pts[-1])",
        "p2 = np.array(pts[0])",
        "",
        "else:",
        "p0 = np.array(pts[i - 1])",
        "p1 = np.array(pts[i])",
        "p2 = np.array(pts[i + 1])",
        "",
        "if i==0 or i==1 or i==len(pts)-1:",
        "dp0 = np.linalg.norm(p0 - p)",
        "dp1 = np.linalg.norm(p1 - p)",
        "dp2 = np.linalg.norm(p2 - p)",
        "",
        "if (i>1) and (i<len(pts)-1):",
        "dp0 = dp1",
        "dp1 = dp2",
        "dp2 = np.linalg.norm(p2 - p)",
        "",
        "if maxSearch:",
        "if (dp1 >= dp2) and (dp1 >= dp0):",
        "localExtremaU.append(kvs[i])",
        "else:  # minS",
        "if (dp1 <= dp2) and (dp1 <= dp0):",
        "# where a point is orthogonal to a planar surface -> sphere radius test, or accept minima",
        "localExtremaU.append(kvs[i])",
        "",
        "localDisp[i] = dp1",
        "",
        "if curvatureTest:",
        "pur, pucc = radiusCentre3points_2(p0, p1, p2)",
        "if (pur == np.inf):",
        "break",
        "else:",
        "# p is on the same side of the surface as the mean curvature",
        "if np.dot(p - p1, pucc - p1)/np.linalg.norm(pucc - p1) > 0:",
        "discreteK[i] = pur",
        "else:",
        "discreteK[i] = -pur",
        "",
        "if curvatureTest:  # discrete grid summing curvatures along U and V axes",
        "localExtremaU = []",
        "",
        "# get local max curvature values",
        "for i in range(1 - closedC(), len(discreteK) - 1 + closedC()):",
        "if (i == 0):",
        "k0 = discreteK[-1]",
        "k1 = discreteK[0]",
        "k2 = discreteK[1]",
        "",
        "elif (i == len(discreteK) - 1):",
        "k0 = discreteK[-2]",
        "k1 = discreteK[-1]",
        "k2 = discreteK[0]",
        "",
        "else:",
        "k0 = discreteK[i - 1]",
        "k1 = discreteK[i]",
        "k2 = discreteK[i + 1]",
        "",
        "if (k0 != np.inf) and (k1 != np.inf) and (k2 != np.inf):",
        "if (np.abs(k1) <= np.abs(k2)) and (np.abs(k1) <= np.abs(k0)):",
        "if (k1 > 0) and maxSearch:",
        "localExtremaU.append(kvs[i])",
        "elif (k1 < 0) and not maxSearch:",
        "# where a point is orthogonal to a planar surface -> sphere radius test, or accept minima",
        "localExtremaU.append(kvs[i])",
        "",
        "extremaU = []",
        "for lu in localExtremaU:",
        "mU = NewtonRaphson(lu)",
        "if mU != np.inf:",
        "extremaU.append(mU)",
        "else:",
        "# Newton-Raphson fail, try hillclimb",
        "mU = subSearchU(curve, lu, eps_bspline)",
        "extremaU.append(mU)",
        "",
        "# filter out identical values",
        "extremaUnique = []",
        "for m in extremaU:",
        "# displacement between any 2 points < eps1",
        "# compare u, v individually to reduce comparison pool",
        "if not any(np.isclose(m, u, eps1).all() for u in extremaUnique):",
        "extremaUnique.append(m)",
        "",
        "if len(extremaU) == 0: #return []",
        "# minima/maxima at curve ends",
        "if all([localDisp[1] < ll for ll in localDisp[2:-2]]): # u = 0",
        "if uv_xyz: return [0.,]",
        "else: return curve.evaluate_single(0.)",
        "elif all([localDisp[-2] > ll for ll in localDisp[1:-1:-3]]): # u = 1",
        "if uv_xyz: return [1.,]",
        "else: return curve.evaluate_single(1.)",
        "else:",
        "print(\"Bspline assumption fail\")",
        "",
        "if (localExtrema and (len(extremaUnique) == 1)) or not localExtrema:  # if there is only one extrema, localextrema is moot",
        "if uv_xyz: return [extremaUnique,] # return single value in list for compatibility",
        "else: return [np.array(curve.evaluate_single(extremaUnique)),]",
        "else:",
        "if localExtrema:",
        "if uv_xyz: return extremaUnique",
        "else: return curve.evaluate_list(extremaUnique)",
        "else: # return single maxima",
        "extremaUniquePoint = curve.evaluate_list(extremaUnique)",
        "dispsExtrema = [np.linalg.norm(np.array(e) - p) for e in extremaUniquePoint]",
        "if maxSearch: # return single value in list for compatibility",
        "if uv_xyz: return [extremaUnique[dispsExtrema.index(max(dispsExtrema))],]",
        "else: return [np.array(extremaUniquePoint[dispsExtrema.index(max(dispsExtrema))]),]",
        "else: # minsearch",
        "if uv_xyz: return [extremaUnique[dispsExtrema.index(min(dispsExtrema))],]",
        "else: return [np.array(extremaUniquePoint[dispsExtrema.index(min(dispsExtrema))]),]",
        "based on Nurbs Book, Piegl & Tiller p.230",
        "same idea to find orthogonal tangent, but at maximum/minimum displacement from a centroid point",
        "revised to test minima segment candidates using 3-point defined circle parameters",
        "def radiusCentre3points2(p1, p2, p3):",
        "# radius + centre from 3 point circle",
        "",
        "#collinear test",
        "coords = np.array([p1, p2, p3])",
        "coords -= coords[0]  # offset for collinear points to intersect the origin",
        "if np.linalg.matrix_rank(coords, tol=None) == 1:",
        "return np.inf, []",
        "",
        "t = p2 - p1",
        "u = p3 - p1",
        "v = p3 - p2",
        "",
        "w = np.cross(t, u)  # triangle normal",
        "wsl = np.linalg.norm(w)",
        "if (wsl < 10e-14):",
        "return False  # triangle area too small",
        "",
        "wsl = np.dot(w, w)",
        "iwsl2 = 1. / (2. * wsl)",
        "tt = np.dot(t, t)",
        "uu = np.dot(u, u)",
        "",
        "circCenter = p1 + (u * tt * (np.dot(u, v)) - t * uu * (np.dot(t, v))) * iwsl2",
        "circRadius = np.sqrt(tt * uu * (np.dot(v, v)) * iwsl2 * 0.5)",
        "# circAxis   = w / np.sqrt(wsl)",
        "",
        "return circRadius, circCenter",
        "eps1 = 0.0001   # Euclidean distance measure",
        "eps2 = 0.0005   # zero cosine measure",
        "eps_bspline = 1E-10",
        "minU = C.knotvector[0]",
        "maxU = C.knotvector[-1]",
        "localDisp = [0] * len(pts)",
        "get discrete curvature values and point displacement",
        "minS",
        "where a point is orthogonal to a planar surface -> sphere radius test, or accept minima",
        "localDisp[i] = dp1",
        "get discrete curvature values and point displacement",
        "p is on the same side of the surface as the mean curvature",
        "get local max curvature values",
        "where a point is orthogonal to a planar surface -> sphere radius test, or accept minima",
        "create simple subdivisions around a minimum point on curve as simple hillclimb search",
        "Newton's method: \t u* = u - f / f'",
        "use product rule to form derivative, f':   f' = C\"(u) * ( C(u) - p ) + C'(u) * C'(u)",
        "d:  ( C(u) - p )",
        "Newton iteration to find orthogonal tangent and is max/min agnostic",
        "f(cu)",
        "C(u) - p",
        "|C(u) - p|",
        "C'(u) * (C(u) - P)",
        "|C'(u)||C(u) - P|",
        "|C'(u) * (C(u) - P)| / |C'(u)||C(u) - P|",
        "c2v = np.dot(e[1], dif) / (np.linalg.norm(e[1]) * np.linalg.norm(dif))",
        "ct = n(cu, e, dif)                           #   u* = u - f / f'",
        "correct for exceeding bounds",
        "[ maxu - ( ct[0] - minu ), ct[1] ]",
        "if closedC(): ct = C.knotvector[-1] - (C.knotvector[0] - ct) # ct = C.knotvector[-1] - (ct - C.knotvector[0]) # NURBS book",
        "if closedC(): ct = C.knotvector[0] + (ct - C.knotvector[-1])",
        "Newton-Raphson fails",
        "numSamples = C.ctrlpts_size * C.degree * CSampleFactor",
        "span = (C.knotvector[-1] - C.knotvector[0]) / (numSamples - 1)",
        "kvs = np.array([C.knotvector[0] + (span * i) for i in range(0, numSamples)])",
        "pts = C.evaluate_list(kvs)",
        "pts, kvs = splineToPolyline(C, curveSampleFactor=delta) todo 1/C.delta?",
        "original version fails on points of equal minimal curvature",
        "2-part selection for global maxima using both displacement and curve inflection",
        "curve inflection determined from local curvature minima - prob doesn't work for self intersecting curves",
        "get set of local minima curvature - use for curve characterisation",
        "from set, find minima/maxima disp from point-of-interest to curve point tangent",
        "curvature approach fails without C2 continuity at minima/maxima?",
        "not much of an issue with STEP spline limitations",
        "",
        "localDisp = [0] * len(pts)",
        "localExtremaU = []",
        "",
        "# get discrete curvature values and point displacement",
        "for i in range(1-closedC(), len(pts) - 1 + closedC()):",
        "if (i == 0):",
        "p0 = np.array(pts[-1])",
        "p1 = np.array(pts[0])",
        "p2 = np.array(pts[1])",
        "",
        "elif (i == len(pts)-1):",
        "p0 = np.array(pts[-2])",
        "p1 = np.array(pts[-1])",
        "p2 = np.array(pts[0])",
        "",
        "else:",
        "p0 = np.array(pts[i - 1])",
        "p1 = np.array(pts[i])",
        "p2 = np.array(pts[i + 1])",
        "",
        "if i==0 or i==1 or i==len(pts)-1:",
        "dp0 = np.linalg.norm(p0 - p)",
        "dp1 = np.linalg.norm(p1 - p)",
        "dp2 = np.linalg.norm(p2 - p)",
        "",
        "if (i>1) and (i<len(pts)-1):",
        "dp0 = dp1",
        "dp1 = dp2",
        "dp2 = np.linalg.norm(p2 - p)",
        "",
        "if maxSearch:",
        "if (dp1 >= dp2) and (dp1 >= dp0):",
        "localExtremaU.append(kvs[i])",
        "else:  # minS",
        "if (dp1 <= dp2) and (dp1 <= dp0):",
        "# where a point is orthogonal to a planar surface -> sphere radius test, or accept minima",
        "localExtremaU.append(kvs[i])",
        "",
        "localDisp[i] = dp1",
        "",
        "if curvatureTest:",
        "pur, pucc = radiusCentre3points_2(p0, p1, p2)",
        "if (pur == np.inf):",
        "break",
        "else:",
        "# p is on the same side of the surface as the mean curvature",
        "if np.dot(p - p1, pucc - p1)/np.linalg.norm(pucc - p1) > 0:",
        "discreteK[i] = pur",
        "else:",
        "discreteK[i] = -pur",
        "discrete grid summing curvatures along U and V axes",
        "localDispTest()",
        "Newton-Raphson fail, try hillclimb",
        "filter out identical values",
        "displacement between any 2 points < eps1",
        "compare u, v individually to reduce comparison pool",
        "if there is only one extrema, localextrema is moot",
        "return single value in list for compatibility",
        "return single maxima",
        "return single value in list for compatibility",
        "minsearch",
        "if len(extremaU) == 0: #return []",
        "# minima/maxima at curve ends",
        "if all([localDisp[1] < ll for ll in localDisp[2:-2]]): # u = 0",
        "if uv_xyz: return [0.,]",
        "else: return C.evaluate_single(0.)",
        "elif all([localDisp[-2] > ll for ll in localDisp[1:-1:-3]]): # u = 1",
        "if uv_xyz: return [1.,]",
        "else: return C.evaluate_single(1.)",
        "else:",
        "print(\"Bspline assumption fail\")",
        "if (localExtrema and (len(extremaUnique) == 1)) or not localExtrema:  # if there is only one extrema, localextrema is moot",
        "if uv_xyz: return [extremaUnique,] # return single value in list for compatibility",
        "else: return [np.array(C.evaluate_single(extremaUnique)),]",
        "else:",
        "if localExtrema:",
        "if uv_xyz: return extremaUnique",
        "else: return C.evaluate_list(extremaUnique)",
        "else: # return single maxima",
        "extremaUniquePoint = C.evaluate_list(extremaUnique)",
        "dispsExtrema = [np.linalg.norm(np.array(e) - p) for e in extremaUniquePoint]",
        "if maxSearch: # return single value in list for compatibility",
        "if uv_xyz: return [extremaUnique[dispsExtrema.index(max(dispsExtrema))],]",
        "else: return [np.array(extremaUniquePoint[dispsExtrema.index(max(dispsExtrema))]),]",
        "else: # minsearch",
        "if uv_xyz: return [extremaUnique[dispsExtrema.index(min(dispsExtrema))],]",
        "else: return [np.array(extremaUniquePoint[dispsExtrema.index(min(dispsExtrema))]),]",
        "(note: if VOR, reverse v1, v2 entries)",
        "test if points are on arc between vertex1 & vertex2",
        "convert aCentreP, p, v1 & v2 to local coordinates with arcAxisDir as z",
        "p may be point or list, returns boolean",
        "if not rotSym, no checks for equal radius (e.g. ellipse)",
        "sanity check that Z-values are identical",
        "if not np.isclose(max(zTest), min(zTest)):",
        "print(\"pointInArc() transform error: \" + str(max(zTest) - min(zTest)))",
        "raise RuntimeError(\"error\")",
        "check if vertex order reversed before calling function",
        "(note: if VOR, reverse v1, v2 entries)",
        "determine the order of a list of cartesian points around a supplied axis",
        "convert aCentreP, p, v1 & v2 to local coordinates with arcAxisDir as z",
        "no requirement for equal radius (e.g. ellipse)",
        "pUV_angle = []",
        "if isinstance(p, list):",
        "for pp in p:",
        "ppUV = np.matmul(rotM, pp - aCentreP)",
        "ppUV_angle = np.arctan2(ppUV[1], ppUV[0])",
        "pUV_angle.append(ppUV_angle)",
        "elif isinstance(p, np.ndarray):",
        "pUV = np.matmul(rotM, p - aCentreP)",
        "pUV_angle.append(np.arctan2(pUV[1], pUV[0]))",
        "if pp is None:",
        "_1=1",
        "# sanity check that Z-values are identical",
        "if isinstance(p, list):",
        "zTest = [pp[2] for pp in pUV]",
        "zTest = zTest + [v1UV[2], v2UV[2]]",
        "else:",
        "zTest = [pUV[2], v1UV[2], v2UV[2]]",
        "",
        "# if not np.isclose(max(zTest), min(zTest)):",
        "planeTestFail = 0",
        "if max(zTest) - min(zTest) > eps_STEP_AP21:",
        "planeTestFail += 1",
        "#print(\"pointInArc() transform error: \" + str(max(zTest) - min(zTest)))",
        "#raise RuntimeError(\"error\")",
        "check if vertex order reversed before calling function",
        "if (v1UV_angle < v2UV_angle): ???",
        "todo is this also projection to surface via normal?",
        "Point on circle (including interior points) furthest/closest to point \"p\"",
        "normAxis = auxDir / np.linalg.norm(normAxis)  # unit normal vector",
        "distance d of point p to the plane is dot product of plane unit normal, normAxis",
        "with the difference vector from the point in the plane P and S: d = (S − P) · u",
        "distance is signed: positive when S is on the side of the plane where u faces and",
        "negative on the other side. zero, S is in the plane",
        "d = (p - plane[0]) * u",
        "point S′ is S projected to the plane, by subtracting d · u from S:",
        "S′ = S − d · u = S − ((S − P) · u) · u",
        "point projected to circle along orthogonal",
        "if point pUV, projected to circle plane, falls outside circle radius, replace with edge point.",
        "centreNormal = False",
        "p lies on normal through circle centrePoint,",
        "nUVmin = centrePoint + radius / (ppCentreDisp * (pUV - centrePoint))",
        "nUVmax = centrePoint - radius / (ppCentreDisp * (pUV - centrePoint))",
        "and not interior:",
        "if ppCentreDisp < eps_STEP_AP21:",
        "return centrePoint, centrePoint",
        "else:",
        "",
        "Robert Nurnberg method, see http://wwwf.imperial.ac.uk/~rn/distance2ellipse.pdf",
        "Move origin to ellipse centre, and rotate point coordinate to local coordinates",
        "based on ellipse major & minor axis.",
        "Assuming direction_ratios of AXIS2_PLACEMENT_3D are normalised",
        "eFeatureAxis = arrayTypeCast(eFeatureAxis)",
        "eLocalXYaxis = arrayTypeCast(eLocalXYaxis)",
        "eCentre = arrayTypeCast(eCentre)",
        "cLocalYaxis = np.cross(eLocalXaxis - eCentre, eNormalAxis - eCentre) # STEP AP21 gives axes wrt local origin",
        "eLocalYaxis = np.cross(eLocalXaxis, eNormalAxis)",
        "eLocalYaxis = eLocalYaxis / np.linalg.norm(eLocalYaxis)  # unit normal vector",
        "todo: ellipse dual min/max",
        "maxima will be +/- eMajorRadius points along major axis",
        "minima +/- eMinorRadius points on minor axis",
        "project to ellipse plane",
        "tolerance = 1E-12",
        "test if p < n, inside ellipse",
        "furthest point on ellipse must be edge point on line that contains ellipse centre and closest point",
        "if interior:",
        "nUVmin = pUV",
        "else:",
        "nUVmin = centrePoint + radius * centreOffset",
        "print('p = Draft.make_point( {:1.8f}, {:1.8f}, {:1.8f})'.format(xyz[0], xyz[0], xyz[2]))",
        "point intersects segment",
        "intersection beyond segment",
        "segment is parallel to plane",
        "direction of intersection line",
        "vector in plane 1 perpendicular to the direction of the intersection line",
        "point on plane 1",
        "if the dot product (cosine of the angle between segment and plane)",
        "is close to zero the line and the normal are almost perpendicular",
        "case 3: no intersection",
        "case 2: one intersection",
        "case 1: two intersections",
        "1.",
        "2.",
        "planePoint = centroidProjAxisPoint for most calls",
        "points within the edge",
        "determine if circle and plane intersect, if so return intersection line/segment (cosine projection?)",
        "no intersection",
        "check projected segment is between arc vertices,",
        "https://web.archive.org/web/20220121145748/http://geomalgorithms.com/index.html",
        "final two boolean values indicate whether point is at or beyond endpoints of segments",
        "def pointSegmentMinDisp(p, a, b):",
        "# https://web.archive.org/web/20220121145748/http://geomalgorithms.com/index.html",
        "s = b - a",
        "w = p - a",
        "ps = np.dot(w, s)",
        "if ps <= 0:",
        "return a, np.linalg.norm(w), True",
        "l2 = np.dot(s, s)",
        "if ps >= l2:",
        "closest = b",
        "vertexEnd = True",
        "else:",
        "closest = a + ps / l2 * s",
        "vertexEnd = False",
        "return closest, np.linalg.norm(p - closest), vertexEnd",
        "def planeMinMaxPoint(p, V, minmax='min'):",
        "import pymesh",
        "def pointTriangleMinDistance(TRI, P):",
        "# return distance between a point and triangle",
        "# SYNTAX",
        "#   dist = pointTriangleDistance(TRI,P)",
        "#   [dist,PP0] = pointTriangleDistance(TRI,P)",
        "#",
        "# DESCRIPTION",
        "#   Calculate the distance of a given point P from a triangle TRI.",
        "#   Point P is a row vector of the form 1x3. The triangle is a matrix",
        "#   formed by three rows of points TRI = [P1;P2;P3] each of size 1x3.",
        "#   dist = pointTriangleDistance(TRI,P) returns the distance of the point P",
        "#   to the triangle TRI.",
        "#   [dist,PP0] = pointTriangleDistance(TRI,P) additionally returns the",
        "#   closest point PP0 to P on the triangle TRI.",
        "#",
        "# Author: Gwolyn Fischer",
        "# Release: 1.0",
        "# Release date: 09/02/02",
        "",
        "# The algorithm is based on",
        "# \"David Eberly, 'Distance Between Point and Triangle in 3D',",
        "# Geometric Tools, LLC, (1999)\"",
        "# http:\\\\www.geometrictools.com/Documentation/DistancePoint3Triangle3.pdf",
        "#",
        "#        ^t",
        "#  \\     |",
        "#   \\reg2|",
        "#    \\   |",
        "#     \\  |",
        "#      \\ |",
        "#       \\|",
        "#        *P2",
        "#        |\\",
        "#        | \\",
        "#  reg3  |  \\ reg1",
        "#        |   \\",
        "#        |reg0\\",
        "#        |     \\",
        "#        |      \\ P1",
        "# -------*-------*------->s",
        "#        |P0      \\",
        "#  reg4  | reg5    \\ reg6",
        "# rewrite triangle in normal form",
        "B = TRI[0, :]",
        "E0 = TRI[1, :] - B",
        "# E0 = E0/np.sqrt(sum(E0.^2)); %normalize vector",
        "E1 = TRI[2, :] - B",
        "# E1 = E1/np.sqrt(sum(E1.^2)); %normalize vector",
        "D = B - P",
        "a = np.dot(E0, E0)",
        "b = np.dot(E0, E1)",
        "c = np.dot(E1, E1)",
        "d = np.dot(E0, D)",
        "e = np.dot(E1, D)",
        "f = np.dot(D, D)",
        "",
        "# print \"{0} {1} {2} \".format(B,E1,E0)",
        "det = a * c - b * b",
        "s = b * e - c * d",
        "t = b * d - a * e",
        "",
        "# Teribble tree of conditionals to determine in which region of the diagram",
        "# shown above the projection of the point into the triangle-plane lies.",
        "if (s + t) <= det:",
        "if s < 0.0:",
        "if t < 0.0:",
        "# region4",
        "if d < 0:",
        "t = 0.0",
        "if -d >= a:",
        "s = 1.0",
        "sqrDistance = a + 2.0 * d + f",
        "else:",
        "s = -d / a",
        "sqrDistance = d * s + f",
        "else:",
        "s = 0.0",
        "if e >= 0.0:",
        "t = 0.0",
        "sqrDistance = f",
        "else:",
        "if -e >= c:",
        "t = 1.0",
        "sqrDistance = c + 2.0 * e + f",
        "else:",
        "t = -e / c",
        "sqrDistance = e * t + f",
        "",
        "# of region 4",
        "else:",
        "# region 3",
        "s = 0",
        "if e >= 0:",
        "t = 0",
        "sqrDistance = f",
        "else:",
        "if -e >= c:",
        "t = 1",
        "sqrDistance = c + 2.0 * e + f",
        "else:",
        "t = -e / c",
        "sqrDistance = e * t + f",
        "# of region 3",
        "else:",
        "if t < 0:",
        "# region 5",
        "t = 0",
        "if d >= 0:",
        "s = 0",
        "sqrDistance = f",
        "else:",
        "if -d >= a:",
        "s = 1",
        "sqrDistance = a + 2.0 * d + f",
        "# GF 20101013 fixed typo d*s ->2*d",
        "else:",
        "s = -d / a",
        "sqrDistance = d * s + f",
        "else:",
        "# region 0",
        "invDet = 1.0 / det",
        "s = s * invDet",
        "t = t * invDet",
        "sqrDistance = (",
        "s * (a * s + b * t + 2.0 * d) + t * (b * s + c * t + 2.0 * e) + f",
        ")",
        "else:",
        "if s < 0.0:",
        "# region 2",
        "tmp0 = b + d",
        "tmp1 = c + e",
        "if tmp1 > tmp0:  # minimum on edge s+t=1",
        "numer = tmp1 - tmp0",
        "denom = a - 2.0 * b + c",
        "if numer >= denom:",
        "s = 1.0",
        "t = 0.0",
        "sqrDistance = a + 2.0 * d + f",
        "# GF 20101014 fixed typo 2*b -> 2*d",
        "else:",
        "s = numer / denom",
        "t = 1 - s",
        "sqrDistance = (",
        "s * (a * s + b * t + 2 * d) + t * (b * s + c * t + 2 * e) + f",
        ")",
        "",
        "else:  # minimum on edge s=0",
        "s = 0.0",
        "if tmp1 <= 0.0:",
        "t = 1",
        "sqrDistance = c + 2.0 * e + f",
        "else:",
        "if e >= 0.0:",
        "t = 0.0",
        "sqrDistance = f",
        "else:",
        "t = -e / c",
        "sqrDistance = e * t + f",
        "# of region 2",
        "else:",
        "if t < 0.0:",
        "# region6",
        "tmp0 = b + e",
        "tmp1 = a + d",
        "if tmp1 > tmp0:",
        "numer = tmp1 - tmp0",
        "denom = a - 2.0 * b + c",
        "if numer >= denom:",
        "t = 1.0",
        "s = 0",
        "sqrDistance = c + 2.0 * e + f",
        "else:",
        "t = numer / denom",
        "s = 1 - t",
        "sqrDistance = (",
        "s * (a * s + b * t + 2.0 * d)",
        "+ t * (b * s + c * t + 2.0 * e)",
        "+ f",
        ")",
        "",
        "else:",
        "t = 0.0",
        "if tmp1 <= 0.0:",
        "s = 1",
        "sqrDistance = a + 2.0 * d + f",
        "else:",
        "if d >= 0.0:",
        "s = 0.0",
        "sqrDistance = f",
        "else:",
        "s = -d / a",
        "sqrDistance = d * s + f",
        "else:",
        "# region 1",
        "numer = c + e - b - d",
        "if numer <= 0:",
        "s = 0.0",
        "t = 1.0",
        "sqrDistance = c + 2.0 * e + f",
        "else:",
        "denom = a - 2.0 * b + c",
        "if numer >= denom:",
        "s = 1.0",
        "t = 0.0",
        "sqrDistance = a + 2.0 * d + f",
        "else:",
        "s = numer / denom",
        "t = 1 - s",
        "sqrDistance = (",
        "s * (a * s + b * t + 2.0 * d)",
        "+ t * (b * s + c * t + 2.0 * e)",
        "+ f",
        ")",
        "",
        "# account for numerical round-off error",
        "if sqrDistance < 0:",
        "sqrDistance = 0",
        "",
        "dist = np.sqrt(sqrDistance)",
        "",
        "PP0 = B + s * E0 + t * E1",
        "return dist, PP0",
        "",
        "disp = []",
        "vertices = []  # np.array([])",
        "#p = arrayTypeCast(p)",
        "for v in V:",
        "#v = arrayTypeCast(v)",
        "vertices.append(v)",
        "if minmax == 'max':",
        "d = np.linalg.norm(v - p)",
        "disp.append(d)",
        "",
        "if minmax == 'max':",
        "maxDisp = max(disp)",
        "maxPoint = vertices[disp.index(maxDisp)]",
        "return maxPoint, maxDisp",
        "",
        "tri = pymesh.triangle()",
        "tri.points = vertices  # np.array(vertices)",
        "tri.split_boundary = False",
        "tri.verbosity = 0",
        "tri.run()  # Execute triangle",
        "minPointIntersect = []",
        "for t in tri.faces:",
        "tt = np.array([vertices[t[0]], vertices[t[1]], vertices[t[2]]])",
        "d, pd = pointTriangleMinDistance(tt, p)",
        "disp.append(d)",
        "minPointIntersect.append(pd)",
        "",
        "minDisp = min(disp)",
        "minPoint = minPointIntersect[disp.index(minDisp)]",
        "return minPoint, minDisp",
        "flatten sublists",
        "in order to establish union of partial ellipse/circle, create box encompassing circle/ellipse",
        "in the case of ellipse, use eMajorRadius",
        "vertex midpoint",
        "midpoint - centroid vector, falls apart if coincident with centre point",
        "midPv = midP - centreP",
        "assert STEPobject[ref2index(pointRefString)].type_name == \"CARTESIAN_POINT\"",
        "R3 = STEPobject[ref2index(pointRefString)].params[1]",
        "process STEP AXIS2_PLACEMENT_3D entity",
        "D = {}",
        "check for name string",
        "not a robust approach as certain values are optional",
        "D['axisPoint'] = axisPoint",
        "D['auxDir'] = auxDir",
        "D['refDir'] = refDir",
        "process STEP AXIS2_PLACEMENT_3D entity",
        "axis: the Direction that defines the second axis of the Axis_placement. (Y or V, not normal)",
        "The value of this attribute need not be specified.",
        "ref_direction: the direction used to determine the direction of the local X axis. (or U)",
        "The value of this attribute need not be specified.",
        "If axis or ref_direction is omitted, these directions are taken from the geometric coordinate system",
        "If both axis and ref_direction are provided then the vector product of axis and ref_direction shall not be a null vector.",
        "relying on order specified",
        "https://www.steptools.com/stds/smrl/data/modules/elemental_geometric_shape/sys/4_info_reqs.htm#elemental_geometric_shape_arm.axis_placement",
        "189 = ADVANCED_FACE( '', ( #409, #410 ), #411, .T. )",
        "409 = FACE_OUTER_BOUND( '', #1293, .T. );",
        "1293 = EDGE_LOOP( '', ( #2202 ) );",
        "2202 = ORIENTED_EDGE( '', *, *, #2631, .F. );",
        "2631 = EDGE_CURVE( '', #2959, #2959, #2960, .F. );",
        "The geometry used in the definition of the face shall be restricted.",
        "The face geometry shall be an elementary surface, swept surface, or b-spline surface;",
        "The geometry of all bounding edges of the face shall be fully defined as edge curves;",
        "The types of curve used to define the geometry of edges shall be restricted to lines,",
        "conics, polylines, surface curves, or b spline curves;",
        "All vertices used in the face definition shall be of type vertex point with geometry defined by a cartesian point;",
        "The use of oriented paths in the definition of the edge loops of the advanced face is prohibited;",
        "If the face geometry is a swept surface then the swept curve used in the definition shall be a line,",
        "conic, polyline, or a b-spline curve;",
        "For any vertex loop used to bound the face, the loop vertex shall be a",
        "vertex whose geometry shall be defined by a cartesian point;",
        "The face bounds shall be defined by either edge loops or vertex loops;",
        "If a surface curve is used as part of a face bound then the associated geometry attribute shall",
        "reference pcurves not surfaces;",
        "If a polyline is used either to define a swept surface or as part of a face bound,",
        "it shall contain at least three points;",
        "Any instance of advanced face which has the geometry of a complete spherical surface shall be bounded by a vertex loop",
        "located at the point where the z axis of the placement coordinate system leaves the surface of the sphere,",
        "(that is, at the North Pole of the sphere).",
        "project ray from localCentroid toward mPoint in order to determine whether this ray intersects the surface defined in AFS",
        "the angle of edge vertices of an intercepted face are calculated with respect to this point and summed",
        "return true if point within surface edges (\"Angle Sum Algorithm\")",
        "project vertex points to a plane defined by mPoint and sNorm",
        "cosine",
        "zero value implies mPoint lies on edge",
        "point is at localCentroid, find normal from provided surface parameters",
        "add offset to everything and try again?",
        "mirror mPoint around surface normal? just use surface normal instead? -> requires earlier calc of axis2Placement3D_2",
        "_1=1",
        "#if not np.isclose(v1, v2).all():",
        "if edge['vertex1ref'] == edge['vertex2ref']: # loop, discard",
        "if edge['typeName'] == 'CIRCLE' or edge['typeName'] == 'B_SPLINE_CURVE_WITH_KNOTS' or edge['typeName'] == 'ELLIPSE':",
        "vertexLoopCount +=1 # should be discarded if point is not within loop?",
        "catch spline and convert to polyline vertices",
        "loop, discard",
        "should be discarded if point is not within loop?",
        "find closest point on spline and ensure that this is not mPoint",
        "nearestSplinePointU = splineCurveMinMaxPointDisp(edge['BsplineKnotCurve'], mPoint, maxSearch=False)",
        "if mPoint[0]==0: # and mPoint[1]== -0.30397087 and mPoint[2]==-16.61759168:",
        "_1=1",
        "has to be ordered correctly",
        "_1=1",
        "account for circle or ellipse arcs, find nearest point on arc to mPoint,",
        "add a point there, effectively converting arc into two segments",
        "loop, discard",
        "should be discarded if point is not within loop?",
        "loop, discard",
        "should be discarded if point is not within loop?",
        "project vertex points to a plane defined by mPoint and sNorm",
        "surfaces that curve > 90deg can give false negative, assume inside/outside test is to detect nearest surface",
        "exception for cylinder, conic, sphere",
        "edges angle sum to zero from 2x loops and seam edge ---------------------needs testing",
        "(len(AFSdata['outerBoundEdgeLoop']) < 4):",
        "only need to determine whether point lies within section of cone axis within cone as circle or ellipse loops at ends signify",
        "fully enclosed surface",
        "vertex angles that sum to zero will still indicate a crossing, for either CW, or ACW direction configuration",
        "if method is uniquely used for closest surface point on a plane encompassing projection and cylinder axis",
        "can then ignore far-side intersection",
        "?? find nearest points on circles/ellipses/bsplines at each curved edge, then test if both points are to one side??",
        "should go to a plane-curve intersection function",
        "define plane through axisPoint, mPoint, normDir",
        "normDir = np.array(AFSdata['ParsedSurface']['normDir'])",
        "determine intersection on mPoint side of plane",
        "test whether vector from mPoint to intersection is parallel with normDir",
        "if np.isclose(np.cross(mPoint - naps, normDir), np.array([0., 0., 0.]), eps_STEP_AP21).all():",
        "binary search over u-interval",
        "1E-10: #==================================================",
        "print(\"insideOutsideSurfaceTest cylinder/conical fail\")",
        "project intersections to plane where axis is normal (normDir), through mPoint",
        "if all points have same sign, all are on same side",
        "if AFS['SurfaceTypeName'] in ['CONICAL_SURFACE',]:",
        "# edges angle sum to zero from 2x loops and seam edge ---------------------needs testing",
        "if (np.abs(edgeTotalAngle) < eps_STEP_AP21) and (vertexLoopCount == 2): # (len(AFSdata['outerBoundEdgeLoop']) < 4):",
        "# only need to determine whether point lies within section of cone axis within cone",
        "return True",
        "else:",
        "return False",
        "full circle",
        "may have to take VOR into account depending on orientation of surface,",
        "e.g. concave or convex spherical surface",
        "assume that minima point is always closest to centroid?",
        "if not edge['VOR']:",
        "ENTITY Line",
        "SUBTYPE OF (Curve);",
        "point : Cartesian_point;",
        "line_direction : Direction;",
        "if ParsedEdge.get('subEdgeType') is not None:",
        "edgeType_ = ParsedEdge['subEdgeType']",
        "else:",
        "todo, if there are multiple minima, return list? store minpoint as list?",
        "if ParsedEdge.get('subEdgeType') is not None:",
        "edgeType_ = ParsedEdge['subEdgeType']",
        "else:",
        "axisDir, refDir guaranteed unit normals?",
        "test if cylinder is rotationally symmetrical, if localCentroid is close to axisDir through axisPoint",
        "rotSymDisp = np.linalg.norm((localCentroid - axisPoint) - np.dot((localCentroid - axisPoint), normDir) * normDir)",
        "why doesn't the below work?-------------------------------------------------------------------------",
        "rotSymDisp = np.linalg.norm(localCentroid - pointProjectAxis(localCentroid, axisPoint, normDir))",
        "# project localCentroid to disc plane",
        "# distance d of point p to the plane is dot product of plane unit normal, normAxis",
        "# with the difference vector from the point in the plane P and S: d = (S − P) · u",
        "# distance is signed: positive when S is on the side of the plane where u faces and",
        "# negative on the other side. zero, S is in the plane",
        "point projected to plane along orthogonal",
        "print(\"rotSymDisp: \" + str(rotSymDisp))",
        "min/max point on arc wrt centroid",
        "v1 always equals v2 for full circle",
        "ParsedEdge['minPoint'] = minPoint",
        "extrema = [maxPoint, minPoint]",
        "drop points not in arc",
        "test whether extrema values already coincide with vertex values,",
        "check u proximity?",
        "centroid orthogonal to centrePoint",
        "case of minPoint equidistant from circle centre - edge case",
        "assign rotSymCentre feature point at centre",
        "first_semi_axis: half the length of the first diameter of the Ellipse.",
        "second_semi_axis: half the length of the second diameter of the Ellipse.",
        "if ParsedEdge.get('subEdgeType') is not None:",
        "edgeType_ = ParsedEdge['subEdgeType']",
        "else:",
        "axisDir, refDir guaranteed unit normals?",
        "test if minPoint, maxPoint is on segment between vertex1 & vertex2",
        "drop points not in arc",
        "test whether extrema values already coincide with vertex values,",
        "check u proximity?",
        "if pointInArc(minPoint, v1, v2, refDir, auxDir, normDir, axisPoint, rotSym=False):",
        "ParsedEdge['minPoint'] = minPoint",
        "ParsedEdge['vertexExtremaMin'] = False",
        "else:  # one of the vertices is a minima",
        "ParsedEdge['vertexExtremaMin'] = True",
        "if ParsedEdge['vertex1centroidDisp'] < ParsedEdge['vertex2centroidDisp']:",
        "ParsedEdge['minPoint'] = ParsedEdge['vertex1']",
        "ParsedEdge['minPointCentroidDisp'] = ParsedEdge['vertex1centroidDisp']",
        "else:",
        "ParsedEdge['minPoint'] = ParsedEdge['vertex2']",
        "ParsedEdge['minPointCentroidDisp'] = ParsedEdge['vertex2centroidDisp']",
        "",
        "if pointInArc(maxPoint, v1, v2, refDir, auxDir, normDir, axisPoint, rotSym=True):",
        "ParsedEdge['maxPoint'] = maxPoint",
        "ParsedEdge['vertexExtremaMax'] = False",
        "else:  # one of the vertices is a maxima",
        "ParsedEdge['vertexExtremaMax'] = True",
        "if ParsedEdge['vertex1centroidDisp'] > ParsedEdge['vertex2centroidDisp']:",
        "ParsedEdge['maxPoint'] = ParsedEdge['vertex1']",
        "ParsedEdge['maxPointCentroidDisp'] = ParsedEdge['vertex1centroidDisp']",
        "else:",
        "ParsedEdge['maxPoint'] = ParsedEdge['vertex2']",
        "ParsedEdge['maxPointCentroidDisp'] = ParsedEdge['vertex2centroidDisp']",
        "if ParsedEdge['vertex1ref'] == ParsedEdge['vertex2ref']:  # full ellipse? untested",
        "if np.linalg.norm(minPoint - v1) < eps_STEP_AP21:",
        "ParsedEdge['vertex1extremaMin'] = True",
        "ParsedEdge['vertex2extremaMin'] = True",
        "ParsedEdge['vertex1extremaMax'] = False",
        "ParsedEdge['vertex2extremaMax'] = False",
        "if np.linalg.norm(maxPoint - v1) < eps_STEP_AP21:",
        "ParsedEdge['vertex1extremaMin'] = False",
        "ParsedEdge['vertex2extremaMin'] = False",
        "ParsedEdge['vertex1extremaMax'] = True",
        "ParsedEdge['vertex2extremaMax'] = True",
        "",
        "else:  # partial ellipse arc",
        "if pointInArc(minPoint, v1, v2, refDir, auxDir, normDir, axisPoint, rotSym=True):",
        "ParsedEdge['minPoint'] = minPoint",
        "ParsedEdge['minPointCentroidDisp'] = np.linalg.norm(minPoint - localCentroid)",
        "if np.linalg.norm(minPoint - v1) < eps_STEP_AP21:",
        "ParsedEdge['vertex1extremaMin'] = True",
        "ParsedEdge['vertex2extremaMin'] = False",
        "if np.linalg.norm(minPoint - v2) < eps_STEP_AP21:",
        "ParsedEdge['vertex1extremaMin'] = False",
        "ParsedEdge['vertex2extremaMin'] = True",
        "",
        "if pointInArc(maxPoint, v1, v2, refDir, auxDir, normDir, axisPoint, rotSym=True):",
        "ParsedEdge['maxPoint'] = maxPoint",
        "ParsedEdge['maxPointCentroidDisp'] = np.linalg.norm(maxPoint - localCentroid)",
        "if np.linalg.norm(maxPoint - v1) < eps_STEP_AP21:",
        "ParsedEdge['vertex1extremaMax'] = True",
        "ParsedEdge['vertex2extremaMax'] = False",
        "if np.linalg.norm(maxPoint - v2) < eps_STEP_AP21:",
        "ParsedEdge['vertex1extremaMax'] = False",
        "ParsedEdge['vertex2extremaMax'] = True",
        "if pointInArc(minPoint, v1, v2, refDir, auxDir, normDir, axisPoint, rotSym=True):",
        "ParsedEdge['minPoint'] = minPoint",
        "ParsedEdge['minPointCentroidDisp'] = np.linalg.norm(minPoint - centroid)",
        "ParsedEdge['vertex1extremaMin'] = False",
        "ParsedEdge['vertex2extremaMin'] = False",
        "else:  # one of the vertices is a minima (only valid for straight line)",
        "if ParsedEdge['vertex1centroidDisp'] < ParsedEdge['vertex2centroidDisp']:",
        "ParsedEdge['minPoint'] = ParsedEdge['vertex1']",
        "ParsedEdge['minPointCentroidDisp'] = ParsedEdge['vertex1centroidDisp']",
        "ParsedEdge['vertex1extremaMin'] = True",
        "ParsedEdge['vertex2extremaMin'] = False",
        "else:",
        "ParsedEdge['minPoint'] = ParsedEdge['vertex2']",
        "ParsedEdge['minPointCentroidDisp'] = ParsedEdge['vertex2centroidDisp']",
        "ParsedEdge['vertex1extremaMin'] = False",
        "ParsedEdge['vertex2extremaMin'] = True",
        "",
        "if pointInArc(maxPoint, v1, v2, refDir, auxDir, normDir, axisPoint, rotSym=True):",
        "ParsedEdge['maxPoint'] = maxPoint",
        "ParsedEdge['maxPointCentroidDisp'] = np.linalg.norm(maxPoint - centroid)",
        "ParsedEdge['vertex1extremaMax'] = True",
        "ParsedEdge['vertex2extremaMax'] = True",
        "else:  # one of the vertices is a maxima (only valid for straight line)",
        "if ParsedEdge['vertex1centroidDisp'] > ParsedEdge['vertex2centroidDisp']:",
        "ParsedEdge['maxPoint'] = ParsedEdge['vertex1']",
        "ParsedEdge['maxPointCentroidDisp'] = ParsedEdge['vertex1centroidDisp']",
        "ParsedEdge['vertex1extremaMax'] = True",
        "ParsedEdge['vertex2extremaMax'] = False",
        "else:",
        "ParsedEdge['maxPoint'] = ParsedEdge['vertex2']",
        "ParsedEdge['maxPointCentroidDisp'] = ParsedEdge['vertex2centroidDisp']",
        "ParsedEdge['vertex1extremaMax'] = False",
        "ParsedEdge['vertex2extremaMax'] = True",
        "ENTITY B_Spline_Curve",
        "SUPERTYPE OF ((ONEOF (Uniform_Curve, B_Spline_Curve_With_Knots, Quasi_Uniform_Curve, Bezier_Curve) ANDOR Rational_B_Spline_Curve))",
        "SUBTYPE OF (Bounded_Curve);",
        "degree : INTEGER;",
        "control_points_list : LIST [2:?] OF Cartesian_Point;",
        "curve_form : B_Spline_Curve_Form;",
        "closed_curve : LOGICAL;",
        "self_intersect : LOGICAL;",
        "ENTITY B_Spline_Curve_With_Knots",
        "SUBTYPE OF (B_Spline_Curve);",
        "knot_multiplicities : LIST [2:?] OF INTEGER;",
        "knots : LIST [2:?] OF Parameter_Value;",
        "knot_spec : Knot_Type;",
        "if ParsedEdge.get('subEdgeType') is not None:",
        "edgeType_ = ParsedEdge['subEdgeType']",
        "else:",
        "check for name string",
        "extract control points",
        "rule for closed periodic curves is :",
        "number of input control points + curve degree = the total number of control points required.",
        "(Reflect.field(Math,\"fabs\")(((vec[i] if i >= 0 and i < len(vec) else None) - rep)) > verb_core_Constants.EPSILON)",
        "NURBS curve is rational with non-unity weights",
        "Creates a rational B_spline curve on the basis <Knots, Multiplicities> of degree <Degree>.",
        "Raises ConstructionError subject to the following conditions 0 < Degree <= MaxDegree.",
        "Weights.Length() == Poles.Length()",
        "Knots.Length() == Mults.Length() >= 2",
        "Knots(i) < Knots(i+1) (Knots are increasing)",
        "1 <= Mults(i) <= Degree",
        "",
        "On a non periodic curve the first and last multiplicities may be Degree+1",
        "(this is even recommended if you want the curve to start and finish on the first and last pole).",
        "On a periodic curve the first and the last multicities must be the same.",
        "on non-periodic curves",
        "Poles.Length() == Sum(Mults(i)) - Degree - 1 >= 2",
        "",
        "on periodic curves",
        "Poles.Length() == Sum(Mults(i)) except the first or last",
        "The knot vector must be non-decreasing and of length (degree + 1) * 2 or greater",
        "[ (degree + 1 copies of the first knot), internal non-decreasing knots, (degree + 1 copies of the last knot) ]",
        "BsplineKnotCurve = BSpline.Curve(normalize_kv=True)",
        "BsplineKnotCurve.degree = curveDegree",
        "BsplineKnotCurve.ctrlpts = [list(c) for c in controlPoints]",
        "BsplineKnotCurve.knotvector = _knotvector",
        "Auto-generate knot vector",
        "BsplineKnotCurve.evaluate()",
        "OpenCascade",
        "Creates a rational B_spline curve on the basis <Knots, Multiplicities> of degree <Degree>.",
        "Raises ConstructionError subject to the following conditions:",
        "0 < Degree <= MaxDegree.",
        "Weights.Length() == Poles.Length()",
        "Knots.Length() == Mults.Length() >= 2",
        "Knots(i) < Knots(i+1) (Knots are increasing)",
        "1 <= Mults(i) <= Degree",
        "",
        "On a non periodic curve the first and last multiplicities may be Degree+1",
        "(this is even recommanded if you want the curve to start and finish on the first and last pole).",
        "On a periodic curve the first and the last multicities must be the same.",
        "on non-periodic curves",
        "Poles.Length() == Sum(Mults(i)) - Degree - 1 >= 2",
        "on periodic curves",
        "Poles.Length() == Sum(Mults(i)) except the first or last",
        "K, the knots sequence of this BSpline curve.",
        "In this sequence, knots with a multiplicity greater than 1 are repeated.",
        "In the case of a non-periodic curve the length of the sequence must be equal to the sum of the NbKnots multiplicities of the knots of the curve (where NbKnots is the number of knots of this BSpline curve). This sum is also equal to : NbPoles + Degree + 1 where NbPoles is the number of poles and Degree the degree of this BSpline curve. In the case of a periodic curve, if there are k periodic knots, the period is Knot(k+1) - Knot(1). The initial sequence is built by writing knots 1 to k+1, which are repeated according to their corresponding multiplicities. If Degree is the degree of the curve, the degree of continuity of the curve at the knot of index 1 (or k+1) is equal to c = Degree + 1 - Mult(1). c knots are then inserted at the beginning and end of the initial sequence:",
        "",
        "the c values of knots preceding the first item Knot(k+1) in the initial sequence are inserted at the beginning; the period is subtracted from these c values;",
        "the c values of knots following the last item Knot(1) in the initial sequence are inserted at the end; the period is added to these c values. The length of the sequence must therefore be equal to: NbPoles + 2*Degree - Mult(1) + 2. Example For a non-periodic BSpline curve of degree 2 where:",
        "the array of knots is: { k1 k2 k3 k4 },",
        "with associated multiplicities: { 3 1 2 3 }, the knot sequence is: K = { k1 k1 k1 k2 k3 k3 k4 k4 k4 } For a periodic BSpline curve of degree 4 , which is \"C1\" continuous at the first knot, and where :",
        "the periodic knots are: { k1 k2 k3 (k4) } (3 periodic knots: the points of parameter k1 and k4 are identical, the period is p = k4 - k1),",
        "with associated multiplicities: { 3 1 2 (3) }, the degree of continuity at knots k1 and k4 is: Degree + 1 - Mult(i) = 2. 2 supplementary knots are added at the beginning and end of the sequence:",
        "at the beginning: the 2 knots preceding k4 minus the period; in this example, this is k3 - p both times;",
        "at the end: the 2 knots following k1 plus the period; in this example, this is k2 + p and k3 + p. The knot sequence is therefore: K = { k3-p k3-p k1 k1 k1 k2 k3 k3 k4 k4 k4 k2+p k3+p } Exceptions Standard_DimensionError if the array K is not of the appropriate length.Returns the knots sequence.",
        "for each spline you have to satisfy the equation: m = n + p + 1, where",
        "m + 1 is the number of the knots (each knot counted separately, no multiplicity)",
        "n + 1 is the number of control points",
        "p is the curve degree",
        "",
        "OCC documentation for Geom_BSplieCurve:",
        "Knot(i+k) = Knot(i) + period",
        "Pole(i+p) = Pole(i)",
        "exclude the repeating control point from description of the spline and the 'redundant' knots.",
        "Going from B-Splines to NURBS means the addition of weights and non-uniform knots.",
        "Weights are straightforward since they correspond directly to points.",
        "As for knots, an unclosed NURBS spline requires n + degree + 1 knots, where n is the number of points.",
        "A closed NURBS curve requires only n + 1 knots. The periodicity is defined by equivalence of the first and last knot,",
        "i.e. knot[0] == knot[-1]",
        "an unclosed NURBS spline requires n + degree + 1 knots, where n is the number of points.",
        "A closed NURBS curve requires only n + 1 knots.",
        "STEP files mostly use NURBS when defining curves.",
        "But the \"b_spline_curve_with_knots\" command allows for uniform b splines too.",
        "It does not discern between the two.",
        "STEP files almost only use \"open b splines\", which means the curve starts and ends at the first and last control points.",
        "So the task was to find the control points in between, which there are n-1 of. But there are only n-3 interpolating points,",
        "so I input the last two equations as the tangents at the start and end.",
        "This is now a linear system of n-1 vector equations, which is easily solved.",
        "constructing closed B-spline curves by wrapping knots.",
        "to construct a closed B-spline curve C(u) of degree p defined by n+1 control points P0, P1, ..., Pn.",
        "The following is the construction procedure:",
        "Add a new control point Pn+1 = P0. Therefore, the number of control points is n+2.",
        "Find an appropriate knot sequence of n+1 knots u0, u1, ..., un. These knots are not necessarily uniform, an advantage over the method discussed above.",
        "Add p+2 knots and wrap around the first p+2 knots: un+1 = u0, un+2 = u1, ..., un+p = up-1, un+p+1 = up, un+p+2 = up+1 as shown in the following diagram. In this way, we have n+p+2 = (n+1) + p + 1 knots",
        "https://github.com/FreeCAD/FreeCAD/blob/69097667df47b2cc86d8688d2dbb545319e33e68/src/Mod/Sketcher/App/Sketch.cpp#L1384",
        "// If periodic, startpoint and endpoint do not play a role in the solver, this can remove",
        "// unnecessary DoF of determining where in the curve the start and the stop should be. However,",
        "// since start and end points are placed above knots, removing them leads to that knot being",
        "// unusable.",
        "// If periodic, startpoint and endpoint do not play a role in the solver, this can remove",
        "// unnecessary DoF of determining where in the curve the start and the stop should be. However,",
        "// since start and end points are placed above knots, removing them leads to that knot being",
        "// unusable.",
        "// WARNING: This is only valid where the multiplicity of the endpoints conforms with a BSpline",
        "// only then the startpoint is the first control point and the endpoint is the last control",
        "// point accordingly, it is never the case for a periodic BSpline. NOTE: For an external",
        "// B-spline (i.e. fixed=true) we must not set the coincident constraints as the points are not",
        "// movable anyway. See #issue 0003176: Sketcher: always over-constrained when referencing",
        "// external B-Spline",
        "https://git.dev.opencascade.org/gitweb/?p=occt.git;a=blob;f=src/BSplCLib/BSplCLib.cxx;h=1414f5008b3b2a79583a0af67e0a05fcd52569cb;hb=HEAD",
        "1917   // index is the first pole of the current curve for insertion schema",
        "1918",
        "1919   if (Periodic) index = -Mults(Mults.Lower());",
        "1920   else          index = -Degree-1;",
        "1922   // on Periodic curves the first knot and the last knot are inserted later",
        "1923   // (they are the same knot)",
        "1924   firstmult = 0;  // multiplicity of the first-last knot for periodic",
        "curvatureTest=True,",
        "curvatureTest=True,",
        "normalise u to [0, 1] - unrequired where normalize_kv=True",
        "knotRange = _knotvector[-1] - _knotvector[0]",
        "maxPointsU = [(mpu - _knotvector[0])/knotRange for mpu in maxPointsU]",
        "minPointsU = [(mpu - _knotvector[0])/knotRange for mpu in minPointsU]",
        "because Newton-Raphson will converge on a tangent, separate max/min values may be identical",
        "if vertex1 centroidDisp is close to u[0],",
        "or vertex2 centroidDisp is close to u[-1],",
        "remove u[0], u[-1]",
        "maximaPoints.insert(0, ParsedEdge['vertex1']) # ParsedEdge['pointFeature']['xyz'][0])",
        "maximaPoints.insert(-1, ParsedEdge['vertex2']) # ParsedEdge['pointFeature']['xyz'][-1])",
        "no point adding maxima & minima fields here",
        "if len(maximaPoints) > 1:",
        "ParsedEdge['maximaPoints'] = maximaPoints",
        "maximaPointsCentroidDisp = [np.linalg.norm(np.array(e) - localCentroid) for e in maximaPoints]",
        "ParsedEdge['maximaPointsCentroidDisp'] = maximaPointsCentroidDisp",
        "maxPoint = maximaPoints[maximaPointsCentroidDisp.index(max(maximaPointsCentroidDisp))]",
        "ParsedEdge['maxPoint'] = maxPoint",
        "ParsedEdge['maxPointCentroidDisp'] = np.linalg.norm(maxPoint - localCentroid)",
        "if len(maximaPoints) == 1:",
        "ParsedEdge['maxPoint'] = maximaPoints[0]",
        "ParsedEdge['maxPointCentroidDisp'] = np.linalg.norm(maxPoint - localCentroid)",
        "ParsedEdge['maximaPointsCentroidDisp'] = None",
        "ParsedEdge['maximaPoints'] = None",
        "else:",
        "ParsedEdge['maximaPointsCentroidDisp'] = None",
        "ParsedEdge['maximaPoints'] = None",
        "ParsedEdge['maxPointCentroidDisp'] = None",
        "ParsedEdge['maxPoint'] = None",
        "if len(minimaPoints) > 1:",
        "ParsedEdge['minimaPoints'] = minimaPoints",
        "minimaPointsCentroidDisp = [np.linalg.norm(np.array(e) - localCentroid) for e in minimaPoints]",
        "ParsedEdge['minimaPointsCentroidDisp'] = minimaPointsCentroidDisp",
        "minPoint = minimaPoints[minimaPointsCentroidDisp.index(min(minimaPointsCentroidDisp))]",
        "ParsedEdge['maxPoint'] = maxPoint",
        "ParsedEdge['maxPointCentroidDisp'] = np.linalg.norm(minPoint - localCentroid)",
        "if len(minimaPoints) == 1:",
        "ParsedEdge['minPoint'] = minimaPoints[0]",
        "ParsedEdge['minPointCentroidDisp'] = np.linalg.norm(minPoint - localCentroid)",
        "ParsedEdge['minimaPointsCentroidDisp'] = None",
        "ParsedEdge['minimaPoints'] = None",
        "else:",
        "ParsedEdge['minimaPointsCentroidDisp'] = None",
        "ParsedEdge['maximaPoints'] = None",
        "ParsedEdge['minPointCentroidDisp'] = None",
        "ParsedEdge['minPoint'] = None",
        "minPointCentroidDisp = np.linalg.norm(minPoint - localCentroid)",
        "ParsedEdge['minPointCentroidDisp'] = minPointCentroidDisp",
        "ParsedEdge['minPoint'] = minPoint",
        "maxPointCentroidDisp = np.linalg.norm(maxPoint - localCentroid)",
        "ParsedEdge['maxPointCentroidDisp'] = maxPointCentroidDisp",
        "ParsedEdge['maxPoint'] = maxPoint",
        "v1 = ParsedEdge['vertex1']",
        "v2 = ParsedEdge['vertex2']",
        "# independent check for vertices,",
        "ParsedEdge['vertex1extremaMin'] = False",
        "ParsedEdge['vertex2extremaMin'] = False",
        "ParsedEdge['vertex1extremaMax'] = False",
        "ParsedEdge['vertex2extremaMax'] = False",
        "",
        "if ParsedEdge['minPointCentroidDisp'] is not None:",
        "if ParsedEdge['vertex1centroidDisp'] < ParsedEdge['minPointCentroidDisp']:",
        "ParsedEdge['minPoint'] = ParsedEdge['vertex1']",
        "ParsedEdge['minPointCentroidDisp'] = ParsedEdge['vertex1centroidDisp']",
        "ParsedEdge['vertex1extremaMin'] = True",
        "",
        "if ParsedEdge['minPointCentroidDisp'] is not None:",
        "if ParsedEdge['vertex2centroidDisp'] < ParsedEdge['minPointCentroidDisp']:",
        "ParsedEdge['minPoint'] = ParsedEdge['vertex2']",
        "ParsedEdge['minPointCentroidDisp'] = ParsedEdge['vertex2centroidDisp']",
        "ParsedEdge['vertex2extremaMin'] = True",
        "",
        "if ParsedEdge['maxPointCentroidDisp'] is not None:",
        "if ParsedEdge['vertex1centroidDisp'] > ParsedEdge['maxPointCentroidDisp']:",
        "ParsedEdge['maxPoint'] = ParsedEdge['vertex1']",
        "ParsedEdge['maxPointCentroidDisp'] = ParsedEdge['vertex1centroidDisp']",
        "ParsedEdge['vertex1extremaMax'] = True",
        "",
        "if ParsedEdge['maxPointCentroidDisp'] is not None:",
        "if ParsedEdge['vertex2centroidDisp'] > ParsedEdge['maxPointCentroidDisp']:",
        "ParsedEdge['maxPoint'] = ParsedEdge['vertex2']",
        "ParsedEdge['maxPointCentroidDisp'] = ParsedEdge['vertex2centroidDisp']",
        "ParsedEdge['vertex2extremaMax'] = True",
        "#BsplineKnotCurve = BSpline.Curve(normalize_kv=False)",
        "BsplineKnotCurve = NURBS.Curve()",
        "BsplineKnotCurve.degree = curveDegree",
        "#BsplineKnotCurve.ctrlpts = [list(c) for c in controlPoints]",
        "#BsplineKnotCurve.knotvector = STEPknotvector",
        "BsplineKnotCurve.set_ctrlpts(compatibility.combine_ctrlpts_weights(controlPoints, weights=None))",
        "detect rotationally symmetric spline surfaces, spline surface cylinder",
        "get the mean point of rings/arcs of control points",
        "test for deviation from mean point",
        "low ctrlptsDelta values suggest rotational symmetry,",
        "rotSymLimit constant --------------------------------------------",
        "def subEdgeParse(edgeInstance_, ParsedEdge, STEP_entities_):",
        "# SEAM_EDGE,",
        "ParsedEdge['subTypeName'] = STEP_entities_[ref2index(edgeInstance_)].type_name",
        "extract data common to all STEP edge instances",
        "if not hasattr(STEP_entities_[ref2index(edgeLoopInstance)].type_name, 'ORIENTED_EDGE'): ----------------------",
        "vertexOrderReversed",
        "edge_geometry: the Curve defining the geometric shape of the edge.",
        "same_sense: a BOOLEAN variable giving the relationship between the topological sense",
        "of the edge and the parametric sense of the curve.",
        "edgeSameSense = 'T' in edgeCurveParams[-1]; ParsedEdge['sameSense'] = edgeSameSense",
        "vertex1centroidDisp = np.linalg.norm(centroid - vertex1)",
        "ParsedEdge['vertex1centroidDisp'] = vertex1centroidDisp",
        "vertex2centroidDisp = np.linalg.norm(centroid - vertex1)",
        "ParsedEdge['vertex2centroidDisp'] = vertex2centroidDisp",
        "vertex2centroidDisp = np.linalg.norm(centroid - vertex2)",
        "ParsedEdge['vertex2centroidDisp'] = vertex2centroidDisp",
        "vertex2centroidDisp = np.linalg.norm(centroid - vertex2)",
        "ParsedEdge['vertex1centroidDisp'] = vertex2centroidDisp",
        "normalise to [0, 1]",
        "a proper object initiation would create extra terms to avoid messy \".get('x') is None\" clauses",
        "while scope is unsettled this is parked here for edge object, presumably surface requires the same",
        "'subTypeName'",
        "'subEdgeType'",
        "'normDir'",
        "'radius'",
        "'axisPoint'",
        "",
        "'rotSymRadius'",
        "'rotSymCentre'",
        "'rotSymMin'",
        "'rotSymMax'",
        "print(\"simpleEdgeParse edge type: \" + ParsedEdge['typeName'])",
        "ENTITY Spherical_surface",
        "SUBTYPE OF (Surface);",
        "position : Axis_placement_3d;",
        "radius : positive_length_measure;",
        "Attribute definitions:",
        "position: an Axis_placement_3d that defines the location and orientation of the surface for the purposes of parameterization.",
        "The centre of the Spherical_surface is at the location",
        "radius: the radius of the Spherical_surface.",
        "The axis is the placement Z axis direction and the ref_direction is an approximation to",
        "the placement X axis direction.= normDir",
        "recalculation of max/min",
        "Z",
        "X",
        "Y",
        "Z",
        "X",
        "not much point",
        "return ParsedSurface",
        "sphere surface maxima & minima exist on a vector between centroid and sphere centre point",
        "minima/maxima = centre point -/+ radius",
        "\"The local z-axis corresponds to the normal of planar and spherical surfaces and to the axis of cylindrical,",
        "conical and toroidal surfaces.\"",
        "Jaider Oussama et al Int. Journal of Engineering Research and Applications www.ijera.com",
        "ISSN : 2248-9622, Vol. 4, Issue 5( Version 6), May 2014, pp.14-25",
        "refDir, auxDir doesn't mean much in stock implementaions.",
        "determine if centroid is coincident with sphere centre",
        "determine if maxPoint/minPoint are inside or outside an edge_loop defined boundary",
        "CCW directionality of edge vertices determines outward surface normal",
        "surface minPoint/maxPoint always orthonormal to localCentroid",
        "sphere sector has at most one maximum and one minimum surface point.",
        "maxima not among edges",
        "maxima not among edges",
        "return ParsedSurface",
        "ENTITY Toroidal_surface",
        "SUBTYPE OF (Surface);",
        "position : Axis_placement_3d;",
        "radius : positive_length_measure;",
        "minor_radius : positive_length_measure;",
        "Attribute definitions:",
        "position: an Axis_placement_3d that defines the location and orientation of the surface.",
        "The centre of the Toroidal_surface is at the location. The plane of the ref_direction and the axis is a",
        "central plane of symmetry of the Toroidal_surface. The normal to this plane is the central axis of the surface.",
        "radius: the distance from the central axis of the Toroidal_surface to the centre of one of the circles",
        "produced by intersecting the Toroidal_surface with a plane containing the central axis.",
        "The surface can be produced by sweeping a circle of radius minor_radius along a circle of radius radius.",
        "minor_radius: the radius of one of the circles produced by intersecting the Toroidal_surface with a plane",
        "containing the central axis.",
        "recalculation of max/min",
        "Z",
        "X",
        "Y",
        "Z",
        "X",
        "return ParsedSurface",
        "localCentroid = np.array([1, 1, 0])",
        "axisPoint = np.array([0, 0, 10])",
        "axisDir = np.array([0, 0, 1])",
        "refDir = np.array([1, 0, 0])",
        "tMajorRadius = 10",
        "tMinorRadius = 1",
        "test if toroid is rotationally symmetrical, if localCentroid is close to normDir through axisPoint",
        "need a precision factor that reflects increasing accuracy arising from iterative calculations of localCentroid --------------------------------------<<<<<<<<<<<<<<<<<",
        "does one find a localCentroid through axis-intersection?",
        "also scale factor affecting numerical precision",
        "also STEP seems to be E-6 decimal places at best",
        "iterativeScaledPrecision = 1e-4  # for testing",
        "ParsedEdge['rotSymFeature']['rotSymRadius'] = radius",
        "ParsedSurface['rotSymCentre'] = axisPoint",
        "create axes for circles based at points of majorMinPoint, majorMaxPoint",
        "minima case, create new axis at majorMinPoint",
        "get min, max of major radius",
        "vector from toroid centre to minima point on majorRadius",
        "vector tangential to major radius",
        "point on minor circle cross-section at minimum disp from localCentroid",
        "ParsedSurface['minPoint'] = minorMinPoint",
        "same for maxima",
        "np.linalg.norm(centroid - tMinorMinPoint) < np.linalg.norm(centroid - tMinorMaxPoint)",
        "ParsedSurface['maxPoint'] = minorMaxPoint",
        "determine if maxPoint/minPoint are inside or outside an edge_loop defined boundary",
        "CCW directionality of edge vertices determines outward surface normal",
        "surface minPoint/maxPoint always orthonormal to localCentroid",
        "maxima is among edges",
        "minima is among edges",
        "return ParsedSurface",
        "ENTITY Cylindrical_surface",
        "SUBTYPE OF (Surface);",
        "position : Axis_placement_3d;",
        "radius : positive_length_measure;",
        "position: an Axis_placement_3d that defines the location and orientation of the surface.",
        "The axis of the Cylindrical_surface passes through the location and is normal to the plane of ref_direction and axis.",
        "radius: the radius of the circular curve of intersection between the surface of the cylinder and a plane",
        "perpendicular to the axis of the Cylindrical_surface.",
        "recalculation of max/min",
        "Z",
        "X",
        "Y",
        "Z # FreeCAD STEP generator reverses normal wrt to cylinder end planes.. ignore?",
        "X",
        "return ParsedSurface",
        "test if cylinder is rotationally symmetrical, if localCentroid is close to axisDir through axisPoint",
        "for creating a minima plane intersection",
        "centroidProjAxisPoint = centroid",
        "maxima is circular edge centre, determined from vertices",
        "minima is orthogonal to centroid",
        "shouldn't there also be a radius measure?? check: not in doctorate schema",
        "todo, update concept where the region between a ridge and groove is a sphere",
        "todo: truth determined via wandering hillclimb point path, or grad",
        "test if any edge crosses cylinder midsection",
        "edges should all have been calculated prior to surface",
        "circle edge cannot be declared groove or ridge prior to discovery of adjacent surfaces",
        "rotationally-symmetric edge must be assigned indeterminate status with centroid & radius",
        "insideOutsideSurfaceTest() doesn't work for objects curved more than 180 degrees",
        "test if any edges intersect a plane through centroid and normal to axis",
        "edges must contain a minimum radius value",
        "minimum value of all cylinder edge must equal radius at (points)/2 = 0 if surface contains minimum radius feature",
        "if edgeMinimaCount == 1: can't be rotational minima if only one point",
        "featureExtrema may also encompass radial symmetric feature,",
        "['xyCentre'] = ['xy']",
        "['centreCentroidDisp']??",
        "['radiusCentroidDisp']",
        "# project centroid to symmetric axis to find rotSymCentre---HUH???",
        "centroidProjAxisPoint = pointProjectAxis(localCentroid, axisPoint, normDir)",
        "ParsedSurface['rotSymCentre'] = centroidProjAxisPoint",
        "# minPointCentroidDisp/maxPointCentroidDisp exist where centroid is on rotSym axis",
        "ParsedSurface['minPointCentroidDisp'] = np.sqrt(np.linalg.norm(centroidProjAxisPoint - localCentroid)**2 + radius**2)",
        "cylinder/conic maxima is a search of greatest disp of vertices from localCentroid",
        "if localCentroid is outside full cylindrical surface, edges contain maxima/minima",
        "circle edges are maxima where circle normal contains local centroid,",
        "cylinder minima -> test for intersection with surface on orthogonal projection from axis to localCentroid",
        "if localCentroid within surface, |centroid - projAxisDir| < cRadius",
        "test:",
        "axisPoint = np.array([1, 0, 0])",
        "localCentroid = np.array([2, 2, 0])",
        "axisDir = np.array([1.5, 0, 0])",
        "cRadius = 1",
        "orthogonal projection of localCentroid to cylinder axis",
        "vCA = localCentroid - axisPoint",
        "vNA = axisPoint - normDir",
        "centroidProjAxisPoint = vNA*np.dot(vCA, vNA)/np.dot(vNA, vNA)",
        "centroidProjAxisPoint = axisPoint + (",
        "np.dot((centroid - axisPoint), normDir) / np.dot(normDir, normDir)) * normDir",
        "can't determine in advance whether rotSymMax or rotSymCentre => requires subsequent comparison to adjacent nodes",
        "minima is among edges",
        "ENTITY Conical_surface",
        "SUBTYPE OF (Surface);",
        "position : Axis_placement_3d;",
        "radius : positive_length_measure;",
        "semi_angle : plane_angle_measure;",
        "position: an Axis_placement_3d that defines the location and orientation of the surface.",
        "The axis of the Conical_surface passes through the location and is normal to the plane of ref_direction and axis.",
        "radius: the radius of the circular curve of intersection between the cone and a plane perpendicular to the",
        "axis of the cone passing through the location. This will have value 0.0 if the location is at the apex of the cone.",
        "semi_angle: the cone semi-angle, this is the angle between the axis of the Conical_surface and the generating line.",
        "note that normal is defined in apex->location direction",
        "note 2 that the radial surface may define the top of a frustum rather than the base, need to check enclosing edges",
        "https://quaoar.su/files/standards/Standard%20-%202003%20-%20ISO%2010303-42.pdf p88",
        "recalculation of max/min",
        "Z",
        "X",
        "Y",
        "Z",
        "X",
        "for the purpose of extracting axisPoint, normDir for inside/outside point detection",
        "return ParsedSurface",
        "test if cone is rotationally symmetrical, if localCentroid is close to axisDir through axisPoint",
        "rotSymDisp = pointProjectAxis(localCentroid, axisPoint, normDir)",
        "find point at cone/triangle apex",
        "circle edge cannot be declared groove or ridge prior to discovery of adjacent surfaces",
        "rotationally-symmetric edge must be assigned indeterminate status with centroid & radius",
        "test whether centroid is on the far side of the apex",
        "ParsedSurface['rotSymCentre'] = apexPoint",
        "ParsedSurface['rotSymRadius'] = 0",
        "get normal to plane containing centroid & cone axis, cross product of (apex - centroid) X (apex - coneLocation)",
        "there is a band around a cone corresponding to a minima",
        "check is band within edges,",
        "ParsedSurface['rotSymRadius'] = np.linalg.norm(coneMinimaCentrePoint - apexPoint) * np.tan(semiAngle)",
        "ParsedSurface['rotSymCentre'] = coneMinimaCentrePoint",
        "else:",
        "",
        "# project centroid to nearest side, i.e.",
        "# construct 2 rays through apex at half angles from cone axis within same plane as centroid",
        "# shortest orthogonal projection to either line is surface minima,",
        "",
        "# project centroid to symmetric axis to find rotSymCentre",
        "",
        "# cylinder/conic maxima is a search of greatest disp of vertices from localCentroid",
        "# if localCentroid is outside full cylindrical/conical surface radius,",
        "# test for intersection with surface on orthogonal projection from axis to localCentroid",
        "# if localCentroid within surface, |centroid - projAxisDir| < cRadius",
        "",
        "# test:",
        "# axisPoint = np.array([1, 0, 0])",
        "# localCentroid = np.array([2, 2, 0])",
        "# axisDir = np.array([1.5, 0, 0])",
        "# cRadius = 1",
        "",
        "# orthogonal projection of localCentroid to cylinder axis",
        "# vCA = localCentroid - axisPoint",
        "# vNA = axisPoint - normDir",
        "# centroidProjAxisPoint = vNA*np.dot(vCA, vNA)/np.dot(vNA, vNA)",
        "",
        "#centroidProjAxisPoint = pointProjectAxis(localCentroid, axisPoint, normDir)-------------------------------------broken??",
        "",
        "centroidProjAxisPoint = axisPoint + ( np.dot((centroid - axisPoint), normDir) / np.dot(normDir, normDir)) * normDir",
        "centroidAxisDir = centroidProjAxisPoint - localCentroid",
        "centroidAxisDisp = np.linalg.norm(centroidAxisDir)",
        "centroidAxisDir = centroidAxisDir / centroidAxisDisp",
        "",
        "coneMinimaCentreDisp = axisPointApexDisp / np.cos(semiAngle)",
        "coneMinimaCentrePoint = apexPoint + (coneMinimaCentreDisp * normDir)",
        "",
        "# calculate cone radius at min",
        "coneMinRadius = np.linalg.norm(apexPoint - coneMinimaCentrePoint) * np.tan(semiAngle)",
        "",
        "smp1 = coneMinimaCentrePoint + (coneMinRadius * -centroidAxisDir)",
        "smp2 = coneMinimaCentrePoint - (coneMinRadius * -centroidAxisDir)",
        "",
        "if np.linalg.norm(localCentroid - smp1) > np.linalg.norm(localCentroid - smp2):",
        "surfaceMinPoint = smp1",
        "else:",
        "surfaceMinPoint = smp2",
        "",
        "if insideOutsideSurfaceTest(localCentroid, surfaceMinPoint, AFS):  # minima is among edges",
        "ParsedSurface['pointFeature']['xyz'].append(surfaceMinPoint)",
        "ParsedSurface['pointFeature']['centroidDisp'].append(np.linalg.norm(surfaceMinPoint - localCentroid))",
        "ENTITY Surface_with_explicit_knots",
        "SUBTYPE OF (B_spline_surface);",
        "u_knot_multiplicities : LIST[2:?] OF INTEGER;",
        "u_knot_values : LIST[2:?] OF parameter_value;",
        "v_knot_multiplicities : LIST[2:?] OF INTEGER;",
        "v_knot_values : LIST[2:?] OF parameter_value;",
        "WHERE",
        "WR1: SIZEOF(u_knot_multiplicities) = SIZEOF(u_knot_values);",
        "WR2: SIZEOF(v_knot_multiplicities) = SIZEOF(v_knot_values);",
        "Attribute definitions:",
        "u_knot_multiplicities: the list of multiplicities for the u_knot_values, these are in the first parametric direction for the surface.",
        "u_knot_values: the list of knot values used to define the B-spline basis functions in the first parametric direction of the surface.",
        "v_knot_multiplicities: the list of multiplicities for the v_knot_values, these are in the second parametric direction for the surface.",
        "v_knot_values: the list of knot values used to define the B-spline basis functions in the second parametric direction of the surface.",
        "u_multiplicities: The multiplicities of the knots in the u parameter direction.",
        "v_multiplicities: The multiplicities of the knots in the v parameter direction.",
        "u_knots: The list of the distinct knots in the u parameter direction.",
        "v_knots: The list of the distinct knots in the v parameter direction.",
        "knot_spec: The description of the knot type.",
        "knot_u_upper: The number of distinct knots in the u parameter direction.",
        "knot_v_upper: The number of distinct knots in the v parameter direction.",
        "SELFnb_spline_surface.u_degree: Algebraic degree of basis functions in u.",
        "SELFnb_spline_surface.v_degree: Algebraic degree of basis functions in v.",
        "SELFnb_spline_surface.control_points_list: This is a list of lists of control points.",
        "SELF\\b_spline_surface.surface_form: Indicator of special surface types. (See 4.3.4.)",
        "SELF\\b_spline_surface.u_closed: Indication of whether the surface is closed in the u direction; this",
        "is for information only.",
        "SELFnb_spline_surface.v_closed: Indication of whether the surface is closed in the v direction; this is",
        "for information only.",
        "SELFnb_spline_surface.self_intersect: Flag to indicate whether, or not, surface is self-intersecting;",
        "this is for information only.",
        "SELFnb_spline_surface.u_upper: Upper index on control points in u direction.",
        "SELFnb_spline_surface.v_upper: Upper index on control points in v direction.",
        "SELFnb_spline_surface.control_points: Array (two-dimensional) of control points defining surface",
        "geometry. This array is constructed from the control points list",
        "u_degree : INTEGER;",
        "v_degree : INTEGER;",
        "control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;",
        "surface_form : b_spline_surface_form;",
        "u_closed : LOGICAL;",
        "v_closed : LOGICAL;",
        "self_intersect : LOGICAL;",
        "check for name string",
        "need to flatten",
        "controPointsListRefs structured as U control points length list of V control points length list",
        "controlPointsRefs = cleanSubRefs(controlPointsRefs)",
        "extract control points",
        "controlPoints = []",
        "for cplU in controlPointsRefs:",
        "cpU = []",
        "for cplV in cplU:",
        "if (STEP_entities_[ref2index(cplV)].type_name == 'CARTESIAN_POINT'):",
        "cpV = CP2point(STEP_entities_, cleanSubRefs(cplV)[0])",
        "cpU.append(cpV)",
        "controlPoints.append(cpU)",
        "construct full U & V knotvectors",
        "p.106 https://quaoar.su/files/standards/Standard%20-%202003%20-%20ISO%2010303-42.pdf",
        "note _knotXvector values not used as Piegel+Tiller algorithms don't always work with explicit knots",
        "BsplineKnotSurface = BSpline.Surface(normalize_kv=True)",
        "BsplineKnotSurface.ctrlpts2d = controlPoints",
        "BsplineKnotSurface.knotvector_u = STEPknotUvector",
        "BsplineKnotSurface.knotvector_v = STEPknotVvector",
        "No compelling reason to set evaluation delta & evaluate surface points as evaluation seems incorrect",
        "BsplineKnotSurface.delta = 0.025  # this seems to be the minima delta under adaptive tesselation",
        "BsplineKnotSurface.evaluate()",
        "return ParsedSurface",
        "local minima/maxima",
        "normalise u,v to [0, 1] - not required with geomdl generated knot vectors",
        "knotUrange = STEPknotUvector[-1] - STEPknotUvector[0]",
        "knotVrange = STEPknotVvector[-1] - STEPknotVvector[0]",
        "maxPointsUV = [((mpu[0] - STEPknotUvector[0])/knotUrange, (mpu[1] - STEPknotVvector[0])/knotVrange ) for mpu in maxPointsUV]",
        "minPointsUV = [((mpu[0] - STEPknotUvector[0])/knotUrange, (mpu[1] - STEPknotVvector[0])/knotVrange ) for mpu in minPointsUV]",
        "create explicit dtype fields to permit sorting via u, then v",
        "because Newton-Raphson will converge on a tangent, separate max/min values may be identical",
        "if vertex1 centroidDisp is close to u[0],",
        "or vertex2 centroidDisp is close to u[-1],",
        "remove u[0], u[-1]",
        "centroidDisp = [np.linalg.norm(mp - localCentroid) for mp in maximaPoints]",
        "vertex1centroidDisp = np.linalg.norm(ParsedEdge['vertex1'] - localCentroid)",
        "vertex2centroidDisp = np.linalg.norm(ParsedEdge['vertex2'] - localCentroid)",
        "if np.abs(vertex1centroidDisp - centroidDisp[0]) < eps_STEP_AP21:",
        "maximaU.pop(0)",
        "maximaPoints.pop(0)",
        "else:",
        "centroidDisp.insert(0, vertex1centroidDisp)",
        "if np.abs(vertex2centroidDisp - centroidDisp[-1]) < eps_STEP_AP21:",
        "maximaU.pop(-1)",
        "maximaPoints.pop(-1)",
        "else:",
        "centroidDisp.append(vertex2centroidDisp)",
        "",
        "#maximaPoints.insert(0, ParsedEdge['vertex1']) # ParsedEdge['pointFeature']['xyz'][0])",
        "#maximaPoints.insert(-1, ParsedEdge['vertex2']) # ParsedEdge['pointFeature']['xyz'][-1])",
        "ParsedEdge['pointFeature']['xyz'] = [ParsedEdge['vertex1'],] + maximaPoints + [ParsedEdge['vertex2'],]",
        "ParsedEdge['pointFeature']['u'] = [0,] + maximaU + [1]",
        "ParsedEdge['pointFeature']['centroidDisp'] = centroidDisp",
        "detect rotationally symmetric spline surfaces, spline surface cylinder",
        "get the median point of rings/arcs of control points",
        "test for deviation from mean point",
        "low rowDelta values suggest rotational symmetry,",
        "similar rowDelta values suggest consistent cross-section (with possible helicity):",
        "consistentCrossSection = np.array(rowDelta).var()",
        "should show up with edge maxima/minima",
        "spinePointDisps = [np.linalg.norm(spinePoints[s] - BsplineKnotSurface.ctrlpts2d[s]) for s in range(0, len(BsplineKnotSurface.ctrlpts2d))]",
        "vv[0] contains the first principal component, i.e. the direction",
        "vector of the 'best fit' line in the least squares sense.",
        "project mean control point rows to derived PCA spine and assess spine axis straightness",
        "test for centroid disp from spine axis, giving minima rotation",
        "rotSymLimit constant --------------------------------------------",
        "ParsedSurface['rotSymFlag'] = 1",
        "ParsedSurface['rotSymFeature']['rotSymCentre'] = ?? centroid minima within",
        "ENTITY Plane",
        "SUBTYPE OF (Surface);",
        "position : Axis_placement_3d;",
        "with a planar surface, closest point is that point closest to orthogonal intersection of ray through",
        "localCentroid with plane of surface",
        "recalculation of max/min",
        "Z",
        "refDir = ParsedSurface['refDir'] # X",
        "auxDir = ParsedSurface['auxDir']  # Y",
        "Z",
        "X",
        "return ParsedSurface",
        "project localCentroid to plane defined by normDir and axisPoint",
        "minima is among edges",
        "replace not append on every calculation",
        "still must test with simple STEP file",
        "stepcode.Part21.ComplexEntity type missing attribute",
        "should prolly assume [0] is FACE_*-----------------<<<<<<",
        "no risk of complex entities from here on in",
        "todo assume 'FACE_INNER_BOUND' or 'HOLE' etc can run the same edge loop from here ----------------------<<<<<<",
        "print(afTypeName)",
        "axis: the Direction that defines the second axis of the Axis_placement. The value of this attribute need not be specified.",
        "ref_direction: the direction used to determine the direction of the local X axis.",
        "The value of this attribute need not be specified. If axis or ref_direction is omitted, these directions are taken from the geometric coordinate system",
        "orientation: a BOOLEAN flag. If TRUE, the topological orientation as used coincides with the orientation,",
        "from start vertex to end vertex, of the edge_definition, if FALSE the vertices are reversed in order.",
        "edge_start: the start vertex of the Oriented_edge. This is derived from the vertices of the edge_definition after taking account of the orientation.",
        "edge_end: the end vertex of the Oriented_edge. This is derived from the vertices of the edge_definition after taking account of the orientation.",
        "extract edge data and convert into useful format",
        "",
        "10 = ADVANCED_BREP_SHAPE_REPRESENTATION('',(#11,#15),#113);",
        "11 = AXIS2_PLACEMENT_3D('',#12,#13,#14);",
        "12 = CARTESIAN_POINT('',(0.,0.,0.));",
        "13 = DIRECTION('',(0.,0.,1.));",
        "14 = DIRECTION('',(1.,0.,-0.));",
        "need to exclude Advanced_brep_shape_representation which seems to contain a [0,0,0] origin point",
        "stepcode.Part21.ComplexEntity type missing attribute",
        "get",
        "_1=1",
        "stepcode.Part21.ComplexEntity type missing attribute",
        "",
        "",
        "continue to ignore local maxima at both radial extents and NURB surface maxima?",
        "for all elements, surfaces and bounding edges, iterate maxima discovery relative to centroid",
        "testing a specific edge loop instance 44CONE 0SPLINE",
        "EdgeLoops = AdvancedFaceSurfaces[0]['EdgeLoopList']",
        "if ParsedEdge['vertex1ref'] == ParsedEdge['vertex2ref']:",
        "_1=1",
        "SEAM_CURVE (not sure if this is worthwhile retaining)",
        "associated geometry in following list does not seem to be defined elsewhere",
        "Attribute\t                Type\t                                        Defined By",
        "name\t                    label (STRING)\t                                representation_item",
        "curve_3d\t                curve (ENTITY)\t                                surface_curve",
        "associated_geometry\t        LIST OF pcurve_or_surface (SELECT)\t            surface_curve",
        "master_representation\t    preferred_surface_curve_representation (ENUM)\tsurface_curve",
        "todo: just create a superTypeName flag?",
        "if edgeRef == '#16':",
        "_1=1",
        "todo: change edgeParams",
        "get associated surfaces, LIST OF pcurve_or_surface",
        "extract surface data from second parameter term",
        "todo:  shouldn't recalculate on every pass?",
        "todo:  create function collateField(surface?) to .. dict data",
        "surfaceRefCollection = []",
        "for AFS2 in AdvancedFaceSurfaces:",
        "surfaceRefCollection.append(AFS2['SurfaceRef'])",
        "if surfaceRef not in surfaceRefCollection:",
        "todo: code for other surface option missing",
        "doesn't seem much point in parsing surface minima until centroid is stable",
        "The standard CSG primitives are the cone, eccentric_cone, cylinder, sphere, torus,",
        "block, right_angular_wedge, ellipsoid, tetrahedron and pyramid.",
        "b_spline_surface,",
        "b_spline_surface_with_knots,",
        "bezier_surface,",
        "conical_surface,",
        "curve_bounded_surface,",
        "cylindrical_surface,",
        "degenerate_toroidal_surface,",
        "offset_surface,",
        "quasi_uniform_surface,",
        "rational_b_spline_surface,",
        "rectangular_composite_surface,",
        "rectangular_trimmed_surface,",
        "spherical_surface,",
        "surface,",
        "surface_of_linear_extrusion,",
        "surface_of_revolution,",
        "surface_replica,",
        "swept_surface,",
        "toroidal_surface,",
        "uniform_surface,",
        "iteratively calculate max/min points and median centroid point",
        "extract max values for all surfaces to add to median vertex calculation for centroid",
        "if AFS['ParsedSurface'].get('axisPoint') is not None:",
        "outermostPoints.append(AFS['ParsedSurface']['axisPoint'])",
        "print('AFS[ParsedSurface][axisPoint]')",
        "print(AFS['ParsedSurface']['axisPoint'])",
        "if edge.get('axisPoint') is not None:",
        "outermostPoints.append(edge['axisPoint'])",
        "print('axisPoint')",
        "print(edge['axisPoint'])",
        "iterate centroid-features relationship",
        "recalculate surfaces & edges max/min points according to new centroid",
        "update surface after edges",
        "doesn't seem much point in parsing surface minima until centroid is stable, possible exception of bspline maxima, minimaFlag ?",
        "for AFS in AdvancedFaceSurfaces:",
        "if AFS['ParsedSurface']['maxPoint'] is not None:",
        "outermostPoints.append(AFS['ParsedSurface']['maxPoint'])",
        "for edge in AFS['outerBoundEdgeLoop']:",
        "outermostPoints.append(edge['maxPoint'])",
        "",
        "centroid = medianPoint(outermostPoints)",
        "todo: search for all edges & surfaces related to point features (maybe symmetrical arcs too) get nearest points",
        "to originating points",
        "note that one can expect C2 continuity in STEP format, meaning that two point maxima will not be adjacent except",
        "where the surface or edge is of a fixed radius from the local centroid.",
        "print('setview()')",
        "getNearestFeatures(sourceRef, parsedFaceSet):",
        "seems there should be sets of associated references with every adjacent feature??",
        "only vertex points have associated Ref",
        "create structures that only represent adjacent features-",
        "max/min @ vertex: return edges w/ second vertex for all edge set, surfaces that touch vertex",
        "max/min @ edge: return vertex1 & 2 plus touching surfaces",
        "max/min @ surface: return surface & its edges & vertices",
        "if bspline surface won't return a maxima at an edge, is this required",
        "# create set of edges to every surface",
        "for afs in AFS:",
        "afs['ParsedSurface']['surfaceEdgeIndex'] = []",
        "for se in afs['outerBoundEdgeLoop']:",
        "afs['ParsedSurface']['surfaceEdgeIndex'].append(se['edgeRef'])",
        "# create set of surface to every edges",
        "for afs in AFS:",
        "for se in afs['outerBoundEdgeLoop']:",
        "se['edgeAdjSurfacesIndex'] = {}",
        "for afs2_index, afs2 in enumerate(AFS):",
        "for te in afs2['outerBoundEdgeLoop']:",
        "if se['edgeRef'] == te['edgeRef']:",
        "if afs2['SurfaceRef'] not in se['edgeAdjSurfacesIndex'].keys():",
        "se['edgeAdjSurfacesIndex'][afs2['SurfaceRef']] = afs2_index",
        "indexDictName = sRef + '_' + ref1 + '_featuresIndex'",
        "se[indexDictName][ref1] = (afs_index, se_index)================================================================",
        "",
        "add adjacent surfaces unnecessary as these are the first field of feature mapping",
        "for tRef in ['vertex1ref', 'vertex2ref']:#, 'edgeRef']:",
        "and ref2 not in edgeSource[indexDictName].keys():",
        "def mapFeatureRefs(sourceFeatureRefs, targetFeatureRefs, AFS):",
        "for afs in AFS:",
        "for edgeSource in afs['outerBoundEdgeLoop']:",
        "for sourceRef in sourceFeatureRefs:",
        "if edgeSource.get(sourceRef):",
        "ref1 = edgeSource[sourceRef]",
        "indexDictName = sourceRef + '_' + ref1 + '_featuresIndex'",
        "edgeSource[indexDictName] = {}",
        "for afs2_index, afs2 in enumerate(AFS):",
        "for edgeTargetIndex, edgeTarget in enumerate(afs2['outerBoundEdgeLoop']):",
        "edgeTargetStrings = [et for et in edgeTarget.values() if type(et) == str]",
        "if ref1 in edgeTargetStrings: #",
        "# add adjacent surfaces unnecessary as these are teh first field of feature mapping",
        "for targetRef in targetFeatureRefs:",
        "if edgeTarget.get(targetRef):",
        "ref2 = edgeTarget[targetRef]",
        "if (ref2 != ref1):# and ref2 not in edgeSource[indexDictName].keys():",
        "edgeSource[indexDictName][ref2] = (afs2_index, edgeTargetIndex)",
        "mapFeatureRefs(['vertex1ref', 'vertex2ref', ], ['vertex1ref', 'vertex2ref', 'edgeRef'], AFS)",
        "mapFeatureRefs(['vertex1ref','vertex2ref',],['vertex1ref','vertex2ref','edgeRef'], AFS)",
        "mapFeatureRefs(['vertex2ref',], ['edgeRef'], AFS)",
        "mapFeatureRefs(['vertex1ref', ], ['vertex2ref'], AFS)",
        "pass",
        "instead of all purpose function, need to find sets of edges at a common vertex",
        "(alongside set of vertices on all edges common to any one vertex)",
        "sets of surfaces at a common vertex (do not exclude common ref (s, e) in search)",
        "intersection of two surface sets to find common surfaces adjacent to common edge",
        "rank rotationally symmetric edges as grooves/spherical/ridges based on adjoining surfaces",
        "namely for the 2 surfaces adjoining an arc/circle, measure the displacement of the surface relative to this axis of rotation",
        "project each point on adjoining surfaces to rotational axis to determine average displacement",
        "Limit to adjoining surfaces to determine the extent of relevant points and edges on each side",
        "(not check edges completely enclose rotational axis)",
        "average the displacement to this axis of vertices & edges",
        "test models: Maltese Cruciform",
        "import FreeCAD as App",
        "import Part",
        "v = App.Vector",
        "doc = App.newDocument()",
        "",
        "p0 = v(0,0,-20)",
        "p1 = v(10,0,-20)",
        "p2 = v(8,0,-10)",
        "p3 = v(5,0,0)",
        "p4 = v(8,0,10)",
        "p5 = v(10,0,20)",
        "p6 = v(0,0,20)",
        "",
        "L0=Part.makePolygon([p0, p1, p2, p3, p4, p5, p6])",
        "S0=L0.revolve(App.Vector(0,0,0),App.Vector(0,0,1),360)",
        "# Part.show(S0, \"Surface\")",
        "",
        "p7 = v(-20,0,0)",
        "p8 = v(-20,10,0)",
        "p9 = v(-10,8,0)",
        "p10 = v(0,5,0)",
        "p11 = v(10,8,0)",
        "p12 = v(20,10,0)",
        "p13 = v(20,0,0)",
        "",
        "L1=Part.makePolygon([p7, p8, p9, p10, p11, p12, p13])",
        "S1=L1.revolve(App.Vector(0,0,0),App.Vector(1,0,0),360)",
        "# Part.show(S1, \"Surface\")",
        "",
        "fusedX = S0.fuse(S1)",
        "Part.show(fusedX, \"Surface\")",
        "rather than searching for all features around a rotSym feature, restrict to rotSym features?",
        "recall that distinction between geometric surfaces is determinined by the most simple shapes permissible.",
        "note that features must be tested to determine they are on the same axis.",
        "multiple data sets created for multiple axes through centroid (e.g. sea-urchin shape, or throwing jacks)",
        "import pickle",
        "p_file = open('AFS_cruciform.pkl', 'wb')",
        "pickle.dump(AdvancedFaceSurfaces, p_file)",
        "p_file.close()",
        "f = open('AFS_cruciform.pkl','rb')",
        "AdvancedFaceSurfaces = pickle.load(f)",
        "get surface rotSymFeatures",
        "get surface rotSymFeatures",
        "get unique axis set (ignore reverse directions)",
        "need to find adjacent rotSym to establish maxima/minima",
        "for sausIndex, saus in enumerate(superAxisUniqueSet):",
        "need to determine which rotSymCentre lie on the same side of centroid",
        "1. find point maxCentroidDisp with max disp from centroid",
        "2. sort all other points relative to maxDispCentroid",
        "define centroid plane, normDir and centroid point, then find dot product",
        "centreDisps = [pointProjectAxis(allRotSymFeatures['rotSymCentre'][s], centroid, normDirSet[sausIndex]) for s in saus]",
        "check neighbours for max/min determination (equality := min)",
        "furthest rotSym centre is always a maxima ? ----------------------------------------------------------",
        "remove duplicates",
        "get individual rotSym max/min values from relative radii",
        "can assume outlying rotSym features are maxima, as face minima are points - adopt as convention?",
        "sas['minima'][0] = False",
        "sas['minima'][-1] = False",
        "for every local minima or maxima feature point, find the surrounding local minima points by way of geometrical features",
        "(i.e. opposing minima on a thin plate don't count; adjacency is not calculated by cartesian distance but surface topography)",
        "create similar dict structure listing local minima/maxima tuple (index1, index2) key and index list of surrounding local maxima/minima",
        "ignore overall minima within a surface and edge boundaries",
        "surface maxima/minima may be associated with related edge maxima/minima (note B-spline surface may have several max/min)",
        "find the minima/maxima associated with every edge",
        "surfaceMinRotSym = []",
        "surfaceMaxRotSym = []",
        "surfaceSphericalRotSym = []",
        "extremaType = 'maxima'",
        "extremaType = 'minima'",
        "vertex1, vertex2",
        "exclude SEAM_CURVE data",
        "unnecessary?",
        "commence with searching local minima around edges associated with AFS surface",
        "for each edge, get 'pointFeatures' fields",
        "this should be checked elsewhere",
        "get localMinima for all vertex and attached edges,",
        "retain extrema value in separate set, [surface]['outerBoundEdgeLoop'][edge]['pointFeature'][index]",
        "for each pointFeature element, get max/min",
        "for vertex1/2 find if relative max/min from adjacent pointFeature element - ignore surfaces for now",
        "u == 0, vertex1, get attached pointFeature",
        "surroundIndex should give address of adjacent edges",
        "test vertexX with immediate neighbours",
        "local min",
        "should capture all local max/min before second vertex",
        "'centroidDisp' find local maxima/minima",
        "CHECK",
        "local max",
        "local min",
        "todo: looking for 'superTypeName', e.g TiltedCylinder.step",
        "extremaType = 'minima'",
        "extremaXYZ = []",
        "vertex1, vertex2",
        "exclude SEAM_CURVE data",
        "unnecessary?",
        "commence with searching local minima around edges associated with AFS surface",
        "for each edge, get 'pointFeatures' fields",
        "this should be checked elsewhere",
        "get localMinima for all vertex and attached edges,",
        "retain extrema value in separate set, [surface]['outerBoundEdgeLoop'][edge]['pointFeature'][index]",
        "conduct championship knockout to find global extrema",
        "for each pointFeature element, get max/min",
        "for vertex1/2 find if relative max/min from adjacent pointFeature element - ignore surfaces for now",
        "pfLocal = edge['pointFeature']",
        "u == 0, vertex1, get attached pointFeature",
        "surroundIndex should give address of adjacent edges",
        "test vertexX with immediate neighbours",
        "local min",
        "should capture all local max/min before second vertex",
        "'centroidDisp' find local maxima/minima",
        "CHECK",
        "local max",
        "vse = edge[vertexXref_surroundIndex[v]][adjacentEdgeRefs[pfsIndex]]",
        "local min",
        "vse = edge[vertexXref_surroundIndex[v]][adjacentEdgeRefs[pfsIndex]]",
        "collate maxima minima extrema within all surfaces, note that local max/min implies that no global hierarchy is required",
        "todo: this should become an initiated class",
        "for AFSindex, AFS in enumerate(AdvancedFaceSurfaces):",
        "def __init__(self):",
        "self.objectHandle = (",
        "\"\"  # pointer or string used to reference model in CAD model-space",
        ")",
        "self.filepath = \"\"",
        "self.name = \"\"",
        "self.generationTime = 0",
        "self.surfaceStatus = \"\"",
        "self.insertionPoint = Point(0.0, 0.0, 0.0)",
        "self.rotation = 0.0",
        "self.rotationAxis = None",
        "self.rotationMatrix = None",
        "self.scale = 1.0",
        "self.featureMaxPoints = []",
        "self.featureMinPoints = []  # arrange as a list of lists representing points",
        "self.surfacePoints = []",
        "self.centroid = None",
        "self.rotSymRidgePoints = []",
        "self.rotSymGroovePoints = []",
        "self.featureMaxCurveDisps = []",
        "self.featureMaxCentres = []",
        "self.featureMinCurveDisps = []",
        "self.featureMinCentres = []",
        "self.featureSphereDisps = []",
        "self.spherePoints = []",
        "self.centrePoints = []",
        "for AFSindex, AFS in enumerate(AdvancedFaceSurfaces):",
        "if AFS['SurfaceTypeName'] == 'SPHERICAL_SURFACE':",
        "# edge and surface point only equidistant from origin if centre coincides with origin",
        "print(\"write code for SPHERICAL_SURFACE\")",
        "break",
        "else:",
        "# commence with searching local minima around edges associated with AFS surface",
        "for edge in AFS['outerBoundEdgeLoop']:",
        "if (edge.get('superTypeNameFlag') is not None):",
        "if edge['superTypeName'] == 'SEAM_CURVE':  # exclude SEAM_CURVE data",
        "print(\"is this code reachable??\")",
        "break",
        "# unnecessary?",
        "",
        "else:",
        "edgeMinima = {}",
        "edgeMinimaCentroidDisp = {}",
        "",
        "# in the instance that a vertex is the edge minima, compare minima associated with adjoining edges & surfaces",
        "# adjEdgeSet, adjSurfaceSet contain the indices of adjacent surface & edges",
        "",
        "if edge['vertex1extremaMin']:",
        "adjSurfaceSet = edge['vertex1SurfacesIndex'].values()",
        "adjEdgeSet = edge['vertex1edgesIndex'].values()",
        "",
        "elif edge['vertex2extremaMin']:",
        "adjSurfaceSet = edge['vertex2SurfacesIndex'].values()",
        "adjEdgeSet = edge['vertex2edgesIndex'].values()",
        "",
        "else:  # minPoint somewhere between vertices on edge todo midpoint=> surfaces adjoining endpoints",
        "adjSurfaceSet = edge['edgeAdjSurfacesIndex'].values()",
        "# adjEdgeSet is union of set of edges at each vertex & remove identity edge",
        "adjEdgeSet = ([edge['vertex1edgesIndex'][i] for i in edge['vertex1edgesIndex'].keys() if i is not edge['edgeRef']] +",
        "[edge['vertex2edgesIndex'][i] for i in edge['vertex2edgesIndex'].keys() if i is not edge['edgeRef']])",
        "",
        "",
        "# vertexX, adjacent surfaces minima",
        "for adjSurfaceIndex in adjSurfaceSet:",
        "adjSurface = AdvancedFaceSurfaces[adjSurfaceIndex]",
        "if adjSurface['ParsedSurface'].get('minimaPoints') is not None:",
        "edgeMinima[adjSurface['SurfaceRef']] = adjSurface['ParsedSurface']['minimaPoints']",
        "edgeMinimaCentroidDisp[adjSurface['SurfaceRef']] = adjSurface['ParsedSurface']['minimaPointsCentroidDisp']",
        "elif adjSurface['ParsedSurface'].get('minPoint') is not None:",
        "edgeMinima[adjSurface['SurfaceRef']] = adjSurface['ParsedSurface']['minPoint']",
        "edgeMinimaCentroidDisp[adjSurface['SurfaceRef']] = adjSurface['ParsedSurface']['minPointCentroidDisp']",
        "",
        "# 'rotSymCentre' is centre of rotationally symmetrical surface feature (e.g. cylinder minimum)",
        "if adjSurface['ParsedSurface']['rotSymFeature'].get('rotSymCentre') is not None:",
        "if adjSurface['ParsedSurface'].get('rotSymMin') is not None:",
        "if adjSurface['ParsedSurface'].get('minPointCentroidDisp') is not None:",
        "edgeMinima[adjSurface['SurfaceRef']] = adjSurface['ParsedSurface']['rotSymFeature']['rotSymCentre']",
        "edgeMinimaCentroidDisp[adjSurface['SurfaceRef']] = adjSurface['ParsedSurface']['minPointCentroidDisp']",
        "else:",
        "print(\"unexpected!\")",
        "",
        "# vertexX, adjacent edges minima, get all relevant minima adjacent to origin vertex/edge/surface",
        "for adjSurfaceEdgeIndex in adjEdgeSet:",
        "adjEdge = AdvancedFaceSurfaces[adjSurfaceEdgeIndex[0]]['outerBoundEdgeLoop'][adjSurfaceEdgeIndex[1]]",
        "if adjEdge.get('minimaPoints') is not None:",
        "edgeMinima[adjEdge['edgeRef']] = adjEdge['minimaPoints']",
        "edgeMinimaCentroidDisp[adjEdge['edgeRef']] = adjEdge['minimaPointsCentroidDisp']",
        "elif adjEdge.get('minPoint') is not None:",
        "edgeMinima[adjEdge['edgeRef']] = adjEdge['minPoint']",
        "edgeMinimaCentroidDisp[adjEdge['edgeRef']] = adjEdge['minPointCentroidDisp']",
        "if adjEdge.get('rotSymMin') is not None:",
        "edgeMinima[adjEdge['edgeRef']] = adjEdge['rotSymCentre']",
        "edgeMinimaCentroidDisp[adjEdge['edgeRef']] = adjEdge['rotSymRadius']",
        "",
        "# test if local minimum relative to surrounding minima",
        "if len(edgeMinimaCentroidDisp) < 1:",
        "deltaMin = 0.0",
        "else:",
        "deltaMin = edge['minPointCentroidDisp'] - min(edgeMinimaCentroidDisp.values())",
        "if (np.abs(deltaMin) * 2 < eps_STEP_AP21) or (deltaMin <= 0):",
        "if edge.get('rotSymCentre') is not None: # rotSym feature",
        "if not array3x1match(edge['rotSymCentre'], surfaceMinRotSym):  # check already exists",
        "surfaceMinRotSym.append(edge['rotSymCentre'])",
        "surfaceMinFeatureCentroidDisp .append(edge['minPointCentroidDisp'])",
        "if edge.get('minimaPoints') is not None:",
        "#",
        "for minp, minpi in enumerate(edge['minimaPoints']):",
        "if not array3x1match(minp, surfaceMinPoint):",
        "surfaceMinPoint.append(minp)",
        "surfaceMinFeatureCentroidDisp.append(edge['minimaPointsCentroidDisp'][minpi])",
        "elif edge.get('minPoint') is not None:",
        "if not array3x1match(edge['minPoint'], surfaceMinPoint):",
        "surfaceMinPoint.append(edge['minPoint'])",
        "surfaceMinFeatureCentroidDisp .append(edge['minPointCentroidDisp'])",
        "edge['localMinima'] = True",
        "else:",
        "edge['localMinima'] = False",
        "",
        "# test minima of surface patch (AFS) against those of immediate surface edges",
        "# note that multiple local surface minima can have an overall minima value",
        "# todo this approach breaks where there are multiple equal minima within a single surface: prepare for list representation",
        "edgeMinima = {}",
        "edgeMinimaCentroidDisp = {}",
        "for edge in AFS['outerBoundEdgeLoop']: # todo 'faceInnerBoundEdgeLoopList'",
        "if edge['minPoint'] is not None:",
        "edgeMinima[edge['edgeRef']] = edge['minPoint']",
        "edgeMinimaCentroidDisp[edge['edgeRef']] = edge['minPointCentroidDisp']",
        "",
        "# test minima of surface patch against those of surface edges",
        "# groove representation here? - 'minPointCentroidDisp' will work, 'minArcPoint' represents arc centre? minFeatureCentroidDisp",
        "if (AFS['ParsedSurface'].get('minPointCentroidDisp') is not None):",
        "if len(edgeMinimaCentroidDisp) < 1:",
        "deltaMin = 0.0",
        "else:",
        "deltaMin = AFS['ParsedSurface']['minPointCentroidDisp'] - min(edgeMinimaCentroidDisp.values())",
        "",
        "if (np.abs(deltaMin) < eps_STEP_AP21) or (deltaMin < 0):",
        "if AFS['ParsedSurface']['minPoint'] is None: # rotSym feature",
        "if len(surfaceMinPoint) > 0:",
        "if len(surfaceMinRotSym) > 0:",
        "if not array3x1match(AFS['ParsedSurface']['rotSymFeature']['rotSymCentre'], surfaceMinRotSym):  # check already exists",
        "surfaceMinRotSym.append(AFS['ParsedSurface']['rotSymFeature']['rotSymCentre'])",
        "surfaceMinFeatureCentroidDisp.append(AFS['ParsedSurface']['minPointCentroidDisp'])",
        "else: # first value",
        "surfaceMinRotSym.append(AFS['ParsedSurface']['rotSymFeature']['rotSymCentre'])",
        "surfaceMinFeatureCentroidDisp.append(AFS['ParsedSurface']['minPointCentroidDisp'])",
        "else:",
        "if surfaceMinPoint is not None:",
        "if not array3x1match(AFS['ParsedSurface']['minPoint'], surfaceMinPoint): # check already exists",
        "surfaceMinPoint.append(AFS['ParsedSurface']['minPoint'])",
        "surfaceMinFeatureCentroidDisp.append(AFS['ParsedSurface']['minPointCentroidDisp'])",
        "else:",
        "surfaceMinPoint.append(AFS['ParsedSurface']['minPoint'])",
        "surfaceMinFeatureCentroidDisp.append(AFS['ParsedSurface']['minPointCentroidDisp'])",
        "AFS['ParsedSurface']['localMinima'] = True",
        "for edge in AFS['outerBoundEdgeLoop']:",
        "edge['localMinima'] = False",
        "# else:",
        "#     AFS['ParsedSurface']['localMinima'] = False",
        "print(surfaceMinPoint)",
        "print(surfaceMinFeatureCentroidDisp )",
        "# repeat for maxima search",
        "for AFSindex, AFS in enumerate(AdvancedFaceSurfaces):",
        "if AFS['SurfaceTypeName'] == 'SPHERICAL_SURFACE':",
        "print(\"write code for SPHERICAL_SURFACE\")",
        "# edge and surface point only equidistant from origin if centre coincides with origin",
        "else:",
        "# commence with searching local minima around edges associated with AFS surface",
        "for edge in AFS['outerBoundEdgeLoop']:",
        "if edge.get('superTypeName'):",
        "if edge['superTypeName'] == 'SEAM_CURVE':  # exclude SEAM_CURVE data",
        "break",
        "",
        "else:",
        "edgeMaxima = {}",
        "edgeMaximaCentroidDisp = {}",
        "",
        "# # in the instance that a vertex is the edge maxima, compare maxima associated with adjoining edges & surfaces",
        "# # adjEdgeSet, adjSurfaceSet contain the indices of adjacent surface & edges",
        "# determine whether maxPoint is vertex or edge; multiple equal maxima, see hill-climbing categorisation",
        "# multiple local maxima suggest saddle points and/or surrounding local minima",
        "",
        "if edge['vertex1extremaMax']:",
        "adjSurfaceSet = edge['vertex1SurfacesIndex'].values()",
        "adjEdgeSet = edge['vertex1edgesIndex'].values()",
        "elif edge['vertex2extremaMax']:",
        "adjSurfaceSet = edge['vertex2SurfacesIndex'].values()",
        "adjEdgeSet = edge['vertex2edgesIndex'].values()",
        "else:  # maxPoint somewhere between vertices on edge",
        "adjSurfaceSet = edge['edgeAdjSurfacesIndex'].values()",
        "# adjEdgeSet is union of set of edges at each vertex",
        "adjEdgeSet = ([edge['vertex1edgesIndex'][i] for i in edge['vertex1edgesIndex'].keys() if i is not edge['edgeRef']] +",
        "[edge['vertex2edgesIndex'][i] for i in edge['vertex2edgesIndex'].keys() if i is not edge['edgeRef']])",
        "",
        "# vertexX, adjacent surfaces maxima",
        "for adjSurfaceIndex in adjSurfaceSet:",
        "adjSurface = AdvancedFaceSurfaces[adjSurfaceIndex]",
        "if adjSurface['ParsedSurface'].get('maximaPoints') is not None:",
        "edgeMaxima[adjSurface['SurfaceRef']] = adjSurface['ParsedSurface']['maximaPoints']",
        "edgeMaximaCentroidDisp[adjSurface['SurfaceRef']] = adjSurface['ParsedSurface']['maximaPointsCentroidDisp']",
        "elif adjSurface['ParsedSurface'].get('maxPoint') is not None:",
        "edgeMaxima[adjSurface['SurfaceRef']] = adjSurface['ParsedSurface']['maxPoint']",
        "edgeMaximaCentroidDisp[adjSurface['SurfaceRef']] = adjSurface['ParsedSurface']['maxPointCentroidDisp'] # todo rename maxFeatureCentroidDisp?",
        "# 'rotSymCentre' is centre to rotationally-symmetric feature, meaning that it's a placeholder for no-point-minima condition",
        "if adjSurface['ParsedSurface'].get('rotSymCentre') is not None:",
        "if adjSurface['ParsedSurface'].get('rotSymMax') is not None:",
        "if adjSurface['ParsedSurface'].get('maxPointCentroidDisp') is not None:",
        "edgeMinimaCentroidDisp[adjSurface['SurfaceRef']] = adjSurface['ParsedSurface']['maxPointCentroidDisp']",
        "else:",
        "print(\"unexpected! - frustum instance\")",
        "",
        "# vertexX, adjacent edges maxima",
        "for adjSurfaceEdgeIndex in adjEdgeSet:",
        "adjEdge = AdvancedFaceSurfaces[adjSurfaceEdgeIndex[0]]['outerBoundEdgeLoop'][adjSurfaceEdgeIndex[1]]",
        "if adjEdge.get('maximaPoints') is not None:",
        "edgeMaxima[adjEdge['edgeRef']] = adjEdge['maximaPoints']",
        "edgeMaximaCentroidDisp[adjEdge['edgeRef']] = adjEdge['maximaPointsCentroidDisp']",
        "elif adjEdge.get('maxPoint') is not None:",
        "edgeMaxima[adjEdge['edgeRef']] = adjEdge['maxPoint']",
        "edgeMaximaCentroidDisp[adjEdge['edgeRef']] = adjEdge['maxPointCentroidDisp']",
        "if adjEdge.get('rotSymMax') is not None:",
        "edgeMinima[adjEdge['edgeRef']] = adjEdge['rotSymCentre']",
        "edgeMinimaCentroidDisp[adjEdge['edgeRef']] = adjEdge['rotSymRadius']",
        "",
        "# test if local maximum relative to surrounding maxima",
        "if len(edgeMaximaCentroidDisp) < 1:",
        "deltaMax = 0.0",
        "else:",
        "deltaMax = edge['maxPointCentroidDisp'] - max(edgeMaximaCentroidDisp.values())",
        "if (np.abs(deltaMax) < eps_STEP_AP21) or (deltaMax > 0): # EPS greater than or equal to",
        "if edge.get('rotSymCentre') is not None: # rotSym feature",
        "if not array3x1match(edge['rotSymCentre'], surfaceMaxRotSym):  # check already exists",
        "surfaceMaxRotSym.append(edge['rotSymCentre'])",
        "surfaceMaxFeatureCentroidDisp.append(edge['maxPointCentroidDisp'])",
        "if edge['maxPoint'] is not None:",
        "if not array3x1match(edge['maxPoint'], surfaceMaxPoint):",
        "surfaceMaxPoint.append(edge['maxPoint'])",
        "surfaceMaxFeatureCentroidDisp.append(edge['maxPointCentroidDisp'])",
        "edge['localMaxima'] = True",
        "else:",
        "edge['localMaxima'] = False",
        "",
        "# test maxima of surface patch (AFS) against those of immediate surface edges",
        "edgeMaxima = {}",
        "edgeMaximaCentroidDisp = {}",
        "for edge in AFS['outerBoundEdgeLoop']:",
        "if edge['maxPoint'] is not None:",
        "edgeMaxima[edge['edgeRef']] = edge['maxPoint']",
        "edgeMaximaCentroidDisp[edge['edgeRef']] = edge['maxPointCentroidDisp']",
        "",
        "# test maxima of surface patch against those of surface edges",
        "#if (AFS['ParsedSurface'].get('maxPointCentroidDisp') is not None) and (len(edgeMaximaCentroidDisp) > 0):",
        "if (AFS['ParsedSurface'].get('maxPointCentroidDisp') is not None):",
        "if len(edgeMaximaCentroidDisp) < 1:",
        "deltaMax = 0.0",
        "else:",
        "deltaMax = AFS['ParsedSurface']['maxPointCentroidDisp'] - min(edgeMaximaCentroidDisp.values())",
        "",
        "if (np.abs(deltaMax) < eps_STEP_AP21) or (deltaMax > 0):",
        "if AFS['ParsedSurface']['maxPoint'] is None: # rotSym feature",
        "if len(surfaceMaxPoint) > 0:",
        "if len(surfaceMaxRotSym) > 0:",
        "if not array3x1match(AFS['ParsedSurface']['rotSymFeature']['rotSymCentre'], surfaceMaxRotSym):  # check already exists",
        "surfaceMaxRotSym.append(AFS['ParsedSurface']['rotSymFeature']['rotSymCentre'])",
        "surfaceMaxFeatureCentroidDisp.append(AFS['ParsedSurface']['maxPointCentroidDisp'])",
        "else: # first value",
        "surfaceMaxRotSym.append(AFS['ParsedSurface']['rotSymFeature']['rotSymCentre'])",
        "surfaceMaxFeatureCentroidDisp.append(AFS['ParsedSurface']['maxPointCentroidDisp'])",
        "else:",
        "if surfaceMaxPoint is not None:",
        "if not array3x1match(AFS['ParsedSurface']['maxPoint'], surfaceMaxPoint): # check already exists",
        "surfaceMaxPoint.append(AFS['ParsedSurface']['maxPoint'])",
        "surfaceMaxFeatureCentroidDisp.append(AFS['ParsedSurface']['maxPointCentroidDisp'])",
        "else:",
        "surfaceMaxPoint.append(AFS['ParsedSurface']['maxPoint'])",
        "surfaceMaxFeatureCentroidDisp.append(AFS['ParsedSurface']['maxPointCentroidDisp'])",
        "AFS['ParsedSurface']['localMaxima'] = True",
        "for edge in AFS['outerBoundEdgeLoop']:",
        "edge['localMaxima'] = False",
        "",
        "else:",
        "if surfaceMaxPoint is not None:",
        "if not array3x1match(AFS['ParsedSurface']['maxPoint'], surfaceMaxPoint): # check already exists",
        "surfaceMaxPoint.append(AFS['ParsedSurface']['maxPoint'])",
        "surfaceMaxFeatureCentroidDisp.append(AFS['ParsedSurface']['maxPointCentroidDisp'])",
        "else:",
        "surfaceMaxPoint.append(AFS['ParsedSurface']['maxPoint'])",
        "surfaceMaxFeatureCentroidDisp.append(AFS['ParsedSurface']['maxPointCentroidDisp'])",
        "AFS['ParsedSurface']['localMaxima'] = True",
        "for edge in AFS['outerBoundEdgeLoop']:",
        "edge['localMaxima'] = False",
        "print('p = Draft.make_point( {:1.8f}, {:1.8f}, {:1.8f})'.format(xyz[0], xyz[0], xyz[2]))",
        "stop here for now",
        "Plane - position - Axis_placement_3d",
        "(detect if plane normal passes through origin)",
        "Conical_surface - position - Axis_placement_3d",
        "- radius - Positive_length_measure",
        "- semi_angle - plane_angle_measure",
        "( is cone axis parallel to ray through origin?,",
        "are cone surfaces orthogonal to ray through origin?)",
        "Cylindrical_surface - position - Axis_placement_3d",
        "- radius - Positive_length_measure",
        "( is cylindrical surface perpendicular to ray through origin?",
        "( if not, extract point from bounding curve)",
        "Spherical_surface - position - Axis_placement_3d",
        "- radius - Positive_length_measure",
        "( point on surface cotangent to centre and origin point)",
        "Swept_surface - swept_curve - Curve",
        "Swept_surface - Extruded_surface - extrusion_axis - Direction",
        "Swept_surface - Surface_of_revolution - axis_direction - Direction",
        "- axis_point - Cartesian_point",
        "Toroidal_surface - position - Axis_placement_3d",
        "- radius - Positive_length_measure",
        "- minor_radius - Positive_length_measure",
        "( if toroid is complete at outer/inner radius, increment rut-symm maxima/minima )",
        "Bounded_surface - B_spline_surface - U_degree - integer",
        "- V_degree - integer",
        "- control_points - Cartesian_point",
        "- U_closed - boolean",
        "- V_closed - boolean",
        "(part of complex_entity listing, need to find footpoint for maxima/minima)",
        "Bounded_surface - B_spline_surface - Rational_B_spline_surface - real",
        "Bounded_surface - B_spline_surface - Surface_with_explicit_knots - U_knot_multiplicities - integer",
        "- U_knot_values - Parameter_value",
        "- V_knot_multiplicities - integer",
        "Bounded_surface - B_spline_surface - Surface_with_implicit_knots - Knot_specification",
        "Bounded_surface - Curve_bounded_surface - basis_surface - Surface",
        "- boundaries - Boundary_curve",
        "- implicit_outer - boolean",
        "Bounded_surface - Rectangular_composite_surface - segments - Surface_patch",
        "- using_surfaces - Surface_patch",
        "Bounded_surface - parent_surface - Surface_patch - u_sense - boolean",
        "- v_sense - boolean",
        "- u_transition - Surface_transition_code",
        "- v_transition - Surface_transition_code",
        "Bounded_surface - Trimmed_surface - u1 - Parameter_value - real",
        "- u2 - Parameter_value - real",
        "- v1 - Parameter_value - real",
        "- v2 - Parameter_value - real",
        "- usense - boolean",
        "- vsense - boolean",
        "Conic - position - Axis_placement",
        "Conic - Circle - Closed_curve (optional) - Closed_composite_curve",
        "- radius - Positive_length_measure",
        "( does circle axis pass thru origin? )",
        "Conic - Ellipse - first_semi_axis - Positive_length_measure",
        "- second_semi_axis - Positive_length_measure",
        "Conic - Hyperbola - semi_axis - Positive_length_measure",
        "- imaginary_semi_axis - Positive_length_measure",
        "Conic - Parabola - focal_distance - Length_measure",
        "Line - point - Cartesian_point",
        "- line_direction - Direction",
        "Bounded_curve - segment_curve - Composite_curve_segment",
        "Bounded_curve - Composite_curve - curve_segment - Composite_curve_segment",
        "Bounded_curve - Composite_curve - using_curves - Composite_curve_segment",
        "Bounded_curve - Closed_composite_curve - Boundary_curve",
        "Bounded_curve - B_spline_curve - degree - integer",
        "- control_points - Cartesian_point",
        "- closed - boolean",
        "Bounded_curve - B_spline_curve - Rational_b_spline_curve - weight_values - real",
        "Bounded_curve - B_spline_curve - Curve_with_explicit_knots - knot_values - Parameter_value",
        "- knot_multiplicities - integer",
        "Bounded_curve - B_spline_curve - Curve_with_implicit_knots - knot_type - Knot_specification",
        "Trimmed_curve - start_point - Cartesian_point",
        "- end_point - Cartesian_point",
        "maxima/minima on edges, but not at vertices => traverse adjoining surfaces and edges until first min/max",
        "maxima/minima at vertices => traverse adjoining surfaces and edges until first min/max",
        "if maxPoint/minPoint at an edge are at an edge vertex, this requires that all surfaces adjacent to this vertex are identified & tested",
        "traverse data and construct a set of minima points, including their nearest minima points",
        "repeat for maxima points",
        "philosophy is to find local minima within surrounding ring of nearest",
        "identify minima/maxima points in hierarchy from local minima maxima points.",
        "for every point in all points, find nearest neighbours and determine maximal disp from centroid",
        "calculate rotSym minima maxima from surrounding vertices",
        "for finding nearest vertices, can use KD-tree, e.g.",
        "from scipy import spatial # numpy < 1.24",
        "A = np.random.random((10,3))*100",
        "pt = [6, 30]  # <-- the point to find",
        "A[spatial.KDTree(A).query(pt)[1]] # <-- the nearest point",
        "distance,index = spatial.KDTree(A).query(pt)",
        "extract all rotationally symmetric features,",
        "test against adjoining surface for groove or ridge distinction",
        "strategy for planar polygonal surfaces is to divide into non-overlapping triangles where corners are polygon vertices",
        "and test for nearest/furthest point on triangle",
        "import and build pymesh locally, see https://github.com/PyMesh/PyMesh/blob/main/README.md",
        "class STEPface(object):",
        "\"\"\"",
        "container class for STEP AP 203 surface",
        "\"\"\"",
        "",
        "def __init__(self, baseRef=\"\"):",
        "self.baseRef = baseRef",
        "self.typeName = '' # 'CYLINDRICAL_SURFACE',",
        "",
        "def addShape(",
        "self,",
        "shapeObject,",
        "shapeName",
        "):",
        "shapeViewObject = self.modelDoc.addObject(\"Part::FeaturePython\", shapeName)",
        "STEP Part21 decomposition:",
        "https://www.mbx-if.org/documents/AP203e2_html/AP203e2.htm",
        "root node, CLOSED_SHELL (OPEN_SHELL), Connected_Face_Set SUPERTYPE OF (ONEOF (Closed_Shell, Open_Shell))",
        "rethink",
        "deconstruct STEP model to find all faces",
        "categorise circles, cylinders and other forms with axes.",
        "extract points from Face_outer_bound (holes in face for minima?)",
        "first pass, find all edge cartesian_points to generate origin based on median",
        "second pass, extract surface maxima from faces,",
        "get all VERTEX, part of EDGE_LOOP",
        "get median barycentre/origin",
        "for all EDGE_LOOP, get VERTEX, find furthest vertex",
        "for all surfaces bound by EDGE_LOOP, calculate if they contain a point normal to an origin-ray",
        "note that for planar regions, maxima/minima is at a polygon point",
        "unless polygon plane is perfectly normal to ray =>",
        "random start, find points closest to initial Desernosphere rays (rethink: more relevant to NURBS surfaces)",
        "get polygon point sets attached to point, find polygon point with max/min disp, repeat",
        "cylinder surface ?? different process, look for entity type",
        "efficient graph node search between interconnecting points?",
        "surface normal - Newell's method for surface normal, cross product == zero, origin on a line parallel to surface normal",
        "for any planar polygon, if 1 point is further from/closer to origin than the others, it is polygon maxima/minima",
        "if 2 points share distance, lacal max/min is at edge.",
        "for any polygon point or edge at min/max find adjacent polygon to point/edge and check for associated points/edges of lesser/greater origin displacement.",
        "(3 points at equivalent disp on valid for symmetric polygon centered and normal to axis thru origin)",
        "for any cylindrical surface, get axis position",
        "find shortest distance from origin cylinder axis, returned point is orthogonal",
        "determine if all cylinder edges are above or below this point",
        "if not, max disp is point + radius",
        "torus, find max/min point on major radius circle, repeat for a minor radius circle at max/min point",
        "ellipsoid, try closest point to an ellipse parallel to major axis?",
        "1. get the median origin from all points",
        "2. find maximum displacement of points from this point, construct ray",
        "3. for every ray find closest cosine angle points",
        "3a. identify closest quadrant through point signs (required to translate model to origin?)",
        "segmentAndPlane( p0 : Point, p1 : Point, v0 : Point, n : Point )",
        "3b. distances from points to ray",
        "4. identify surfaces associated with these (edge) points",
        "5. for each surface, determine if ray is between bounding edge points",
        "(axis1_placement,",
        "axis2_placement_2d,",
        "axis2_placement_3d,",
        "b_spline_curve,",
        "b_spline_curve_with_knots,",
        "b_spline_surface,",
        "b_spline_surface_with_knots,",
        "bezier_curve,",
        "bezier_surface,",
        "boundary_curve,",
        "cartesian_point,",
        "cartesian_transformation_operator_3d,",
        "circle,",
        "composite_curve,",
        "composite_curve_on_surface,",
        "composite_curve_segment,",
        "conic,",
        "conical_surface,",
        "curve,",
        "curve_bounded_surface,",
        "curve_replica,",
        "cylindrical_surface,",
        "degenerate_pcurve,",
        "degenerate_toroidal_surface,",
        "dimension_count,",
        "dimension_of,",
        "direction,",
        "ellipse,",
        "evaluated_degenerate_pcurve,",
        "geometric_representation_context,",
        "geometric_representation_item,",
        "hyperbola,",
        "intersection_curve,",
        "line,",
        "offset_curve_3d,",
        "offset_surface,",
        "outer_boundary_curve,",
        "parabola,",
        "pcurve,",
        "plane,",
        "point,",
        "point_on_curve,",
        "point_on_surface,",
        "point_replica,",
        "polyline,",
        "quasi_uniform_curve,",
        "quasi_uniform_surface,",
        "rational_b_spline_curve,",
        "rational_b_spline_surface,",
        "rectangular_composite_surface,",
        "rectangular_trimmed_surface,",
        "reparametrised_composite_curve_segment,",
        "seam_curve,",
        "spherical_surface,",
        "surface,",
        "surface_curve,",
        "surface_of_linear_extrusion,",
        "surface_of_revolution,",
        "surface_replica,",
        "swept_surface,",
        "toroidal_surface,",
        "trimmed_curve,",
        "uniform_curve,",
        "uniform_surface,",
        "strategy for cylinders & cones (& rotationally-symmetric spheres, surfaces of revolution or ellipsoids), determine curved edges",
        "if rot axis is between origin and surface, maxima lies on a line segment between maxima points on curved edges",
        "if rot axis is beyond surface (concave), minima lies on a line segment between minima points on curved edges",
        "otherwise maxima/minima lie on edges.",
        "given a vertex, edge or surface, return all adjacent vertices",
        "if point is on edge, return edge parallel surfaces & vertex1 + vertex2",
        "point at vertex, return connected edges and all adjoining surfaces",
        "point on surface, return edgeloop for surface (including inner) and all associated vertex",
        "todo: adjoining edges & surfaces part of future surface object method",
        "this process can be abstracted to a search for items in list & subset ['",
        "# find adjoining surfaces to every surface edge",
        "for AFS in AdvancedFaceSurfaces:",
        "for edgeSource in AFS['outerBoundEdgeLoop']:",
        "edgeSource['edgeAdjSurfacesIndex'] = {}",
        "for AFS2index, AFS2 in enumerate(AdvancedFaceSurfaces):",
        "for edgeTarget in AFS2['outerBoundEdgeLoop']:",
        "if edgeSource['edgeRef'] == edgeTarget['edgeRef']:",
        "if AFS2['SurfaceRef'] not in edgeSource['edgeAdjSurfacesIndex'].keys():",
        "edgeSource['edgeAdjSurfacesIndex'][AFS2['SurfaceRef']] = AFS2index",
        "",
        "# find adjoining surfaces to every vertex 1 surface point using STEP reference coincidence",
        "for AFS in AdvancedFaceSurfaces:",
        "for edgeSource in AFS['outerBoundEdgeLoop']:",
        "v1ref = edgeSource['vertex1ref']",
        "edgeSource['vertex1SurfacesIndex'] = {}",
        "for AFS2index, AFS2 in enumerate(AdvancedFaceSurfaces):",
        "for edgeTarget in AFS2['outerBoundEdgeLoop']:",
        "if (v1ref == edgeTarget['vertex1ref']) or (v1ref == edgeTarget['vertex2ref']):",
        "if AFS2index not in edgeSource['vertex1SurfacesIndex'].keys():",
        "edgeSource['vertex1SurfacesIndex'][AFS2['SurfaceRef']] = AFS2index",
        "",
        "# find adjoining surfaces to every vertex 2 surface point",
        "for AFS in AdvancedFaceSurfaces:",
        "for edgeSource in AFS['outerBoundEdgeLoop']:",
        "v2ref = edgeSource['vertex2ref']",
        "edgeSource['vertex2SurfacesIndex'] = {}",
        "for AFS2index, AFS2 in enumerate(AdvancedFaceSurfaces):",
        "for edgeTarget in AFS2['outerBoundEdgeLoop']:",
        "if (v1ref == edgeTarget['vertex1ref']) or (v1ref == edgeTarget['vertex2ref']):",
        "if AFS2index not in edgeSource['vertex2SurfacesIndex'].keys():",
        "edgeSource['vertex2SurfacesIndex'][AFS2['SurfaceRef']] = AFS2index",
        "",
        "# find adjoining edges to every vertex 1 surface point",
        "for AFS in AdvancedFaceSurfaces:",
        "for edgeSource in AFS['outerBoundEdgeLoop']:",
        "v1ref = edgeSource['vertex1ref']",
        "edgeSource['vertex1edgesIndex'] = {}",
        "for AFS2index, AFS2 in enumerate(AdvancedFaceSurfaces):",
        "for edgeTargetIndex, edgeTarget in enumerate(AFS2['outerBoundEdgeLoop']):",
        "if (v1ref == edgeTarget['vertex1ref']) or (v1ref == edgeTarget['vertex2ref']):",
        "if edgeTarget['edgeRef'] not in edgeSource['vertex1edgesIndex'].keys():",
        "edgeSource['vertex1edgesIndex'][edgeTarget['edgeRef']] = (AFS2index, edgeTargetIndex)",
        "",
        "# find adjoining edges to every vertex 2 surface point",
        "for AFS in AdvancedFaceSurfaces:",
        "for edgeSource in AFS['outerBoundEdgeLoop']:",
        "v2ref = edgeSource['vertex2ref']",
        "edgeSource['vertex2edgesIndex'] = {}",
        "for AFS2index, AFS2 in enumerate(AdvancedFaceSurfaces):",
        "for edgeTargetIndex, edgeTarget in enumerate(AFS2['outerBoundEdgeLoop']):",
        "if (v2ref == edgeTarget['vertex1ref']) or (v2ref == edgeTarget['vertex2ref']):",
        "if edgeTarget['edgeRef'] not in edgeSource['vertex2edgesIndex'].keys():",
        "edgeSource['vertex2edgesIndex'][edgeTarget['edgeRef']] = (AFS2index, edgeTargetIndex)",
        "================================================================================",
        "",
        "for AFSindex, AFS in enumerate(AdvancedFaceSurfaces):",
        "# get surface rotSymFeatures",
        "for edge in AFS['outerBoundEdgeLoop']:",
        "if (edge.get('rotSymFeature') is not None):",
        "if (edge['rotSymFeature'].get('rotSymCentre') is not None) and (edge['rotSymFeature'].get('rotSymRadius') is not None):",
        "if type(edge['rotSymFeature']['rotSymCentre']) == list:",
        "for rsf in range(0, len(edge['rotSymFeature']['rotSymCentre'])):",
        "allRotSymFeatures['rotSymCentre'].append(edge['rotSymFeature']['rotSymCentre'][rsf])",
        "allRotSymFeatures['rotSymRadius'].append(edge['rotSymFeature']['rotSymRadius'][rsf])",
        "else:",
        "allRotSymFeatures['rotSymCentre'].append(edge['rotSymFeature']['rotSymCentre'])",
        "allRotSymFeatures['rotSymRadius'].append(edge['rotSymFeature']['rotSymRadius'])",
        "",
        "# get surface rotSymFeatures",
        "if (AFS['ParsedSurface'].get('rotSymFeature') is not None):",
        "if (AFS['ParsedSurface']['rotSymFeature'].get('rotSymCentre') is not None) and (AFS['ParsedSurface']['rotSymFeature'].get('rotSymRadius') is not None):",
        "if type(AFS['ParsedSurface']['rotSymFeature']['rotSymCentre']) == list:",
        "for rsf in range(0, len(AFS['ParsedSurface']['rotSymFeature']['rotSymCentre'])):",
        "allRotSymFeatures['rotSymCentre'].append(AFS['ParsedSurface']['rotSymFeature']['rotSymCentre'][rsf])",
        "allRotSymFeatures['rotSymRadius'].append(AFS['ParsedSurface']['rotSymFeature']['rotSymRadius'][rsf])",
        "else:",
        "allRotSymFeatures['rotSymCentre'].append(AFS['ParsedSurface']['rotSymFeature']['rotSymCentre'])",
        "allRotSymFeatures['rotSymRadius'].append(AFS['ParsedSurface']['rotSymFeature']['rotSymRadius'])",
        "",
        "print(\"need to test w/ multi axis\")",
        "SuperAxisRotSymSet = []",
        "eliminationIndex = [i for i in range(0, len(allRotSymFeatures['rotSymCentre']))]",
        "# create groups of adjacent rotSym features along colinear axes",
        "for ARSFCindex, ARSFC in enumerate(allRotSymFeatures['rotSymCentre'] ):",
        "if (len(eliminationIndex) > 0) and (ARSFCindex in eliminationIndex):",
        "axisRotSymSet = [ARSFCindex,]",
        "SuperAxisRotSymSet.append(axisRotSymSet)",
        "eliminationIndex.pop(eliminationIndex.index(ARSFCindex))",
        "for ARSFC2index, ARSFC2 in enumerate(allRotSymFeatures['rotSymCentre']):",
        "if (len(eliminationIndex) > 0) and (ARSFC2index in eliminationIndex): # check vectors collinear",
        "if np.isclose(np.cross(ARSFC - centroid, ARSFC2 - centroid), eps).all() and (ARSFC2index not in axisRotSymSet):",
        "axisRotSymSet.append(ARSFC2index)",
        "eliminationIndex.pop(eliminationIndex.index(ARSFC2index))",
        "",
        "# eliminate duplicates here",
        "",
        "superAxesSet = []",
        "# need to find adjacent rotSym to establish maxima/minima",
        "for SARSS in SuperAxisRotSymSet:",
        "lobeSet = dict()",
        "# need to determine which rotSymCentre lie on the same side of centroid",
        "# 1. find point maxCentroidDisp with max disp from centroid",
        "# 2. sort all other points relative to maxDispCentroid",
        "",
        "centreDisps = [np.linalg.norm(allRotSymFeatures['rotSymCentre'][s] - centroid) for s in SARSS]",
        "maxCentreDisps = centreDisps.index(max(centreDisps))",
        "axisDisps = [np.linalg.norm(allRotSymFeatures['rotSymCentre'][s] - allRotSymFeatures['rotSymCentre'][maxCentreDisps]) for s in SARSS]",
        "axisDispsSorted = np.argsort(axisDisps)",
        "",
        "SARSS = [SARSS[ads] for ads in axisDispsSorted]",
        "",
        "lobeSet['centreCentroidDisp'] = [centreDisps[s] for s in SARSS]",
        "lobeSet['rotSymCentre'] = [allRotSymFeatures['rotSymCentre'][s] for s in SARSS]",
        "lobeSet['rotSymRadius'] = [allRotSymFeatures['rotSymRadius'][s] for s in SARSS]",
        "# check neighbours for max/min determination (equality := min)",
        "# furthest rotSym centre is always a maxima ? ----------------------------------------------------------",
        "superAxesSet.append(lobeSet)",
        "",
        "",
        "for AFSindex, AFS in enumerate(AdvancedFaceSurfaces):",
        "# commence with searching local minima around edges associated with AFS surface",
        "# no real reason to separate vertices into points closer to localCentroid than arc/circle, and those on the far side.",
        "for edge in AFS['outerBoundEdgeLoop']:",
        "if (edge.get('rotSymFeature') is not None): # only single value in ['rotSymFeature'], no min, max for edges ??---------------------",
        "if (edge['rotSymFeature'].get('rotSymCentre') is not None) and (edge['rotSymFeature'].get('rotSymRadius') is not None):",
        "# recall that it is not required for adjacent surfaces/edges to be radially symmetric",
        "adjSurfaceSet = edge['edgeAdjSurfacesIndex'].values()",
        "# presuming it is not required to identify edges",
        "",
        "# normalise axis normal",
        "rotSymCentroidDisp = np.linalg.norm(edge['rotSymFeature']['rotSymCentre'] - centroid)",
        "if rotSymCentroidDisp > eps:",
        "rotAxisDir = (edge['rotSymFeature']['rotSymCentre'] - centroid) / rotSymCentroidDisp",
        "else:",
        "# if centre to rotSym feature coincides with centroid, get rotAxisDir from other parsed data",
        "if AFS['ParsedSurface'].get('normDir') is not None:",
        "rotAxisDir = AFS['ParsedSurface']['normDir']",
        "else:",
        "print(\"no surface axisDir value, cross()?\")",
        "",
        "# adjacent surfaces minima,  nearPointAxisDisp > rotSymCentroidDisp",
        "# near & far based on disp from centroid",
        "nearPointAxisDisp = []",
        "farPointAxisDisp = []",
        "#ddump=[]",
        "",
        "for adjSurfaceIndex in adjSurfaceSet:",
        "adjSurface = AdvancedFaceSurfaces[adjSurfaceIndex]",
        "for adjSurfaceEdge in adjSurface['outerBoundEdgeLoop']:",
        "if edge['edgeRef'] != adjSurfaceEdge['edgeRef']:",
        "",
        "# project all points, vertex1, vertex2, maxPoint, minPoint to rotational axis",
        "adjSurfaceVertices = adjSurfaceEdge['pointFeature']['xyz']",
        "",
        "for asv in adjSurfaceVertices:",
        "#pAxisProj = pointProjectAxis(asv, centroid, rotAxisDir)",
        "#pAxisProj = rotAxisDir * np.dot((asv - centroid), rotAxisDir) / np.dot(rotAxisDir, rotAxisDir)",
        "",
        "if rotSymCentroidDisp > eps:",
        "pAxisProj = rotAxisDir * np.dot((asv - centroid), rotAxisDir) / np.dot(rotAxisDir, rotAxisDir)",
        "else:",
        "pAxisProj = rotAxisDir * np.dot(asv, rotAxisDir) / np.dot(rotAxisDir, rotAxisDir)",
        "",
        "pAxisDisp = np.linalg.norm(asv - pAxisProj)",
        "#ddump.append(np.dot((asv - edge['rotSymFeature']['rotSymCentre']), rotAxis))",
        "",
        "rotSymEdgeDisp = np.dot((asv - edge['rotSymFeature']['rotSymCentre']), rotAxisDir)",
        "#print(rotSymEdgeDisp)",
        "if rotSymEdgeDisp > eps: # eps_",
        "#if np.linalg.norm(pAxisProj - centroid) > rotSymCentroidDisp:",
        "farPointAxisDisp.append(pAxisDisp)",
        "elif rotSymEdgeDisp < -eps:",
        "nearPointAxisDisp.append(pAxisDisp)",
        "",
        "if len(nearPointAxisDisp)==0 or len(farPointAxisDisp)==0:",
        "# disc at end of object, defined as rotSymMax",
        "edge['rotSymMax'] = True",
        "else:",
        "NPADA = np.average(nearPointAxisDisp)",
        "FPADA = np.average(farPointAxisDisp)",
        "",
        "# conical midpoints",
        "avgRadius = np.abs(NPADA - FPADA)/2 + min([NPADA, FPADA])",
        "if avgRadius > edge['radius']:",
        "# ridge",
        "edge['rotSymMax'] = True",
        "else:",
        "edge['rotSymMin'] = True",
        "# else:",
        "#     edge['rotSymCentre'] = None",
        "#     edge['rotSymRadius'] = None",
        "",
        "# the other class of minima integral to surfaces, e.g. ring minima on cylinders",
        "if (AFS['ParsedSurface'].get('rotSymFeature') is not None):",
        "if (AFS['ParsedSurface']['rotSymFeature'].get('rotSymCentre') is not None) and (AFS['ParsedSurface'].get('rotSymRadius') is not None):",
        "",
        "# normalise axis normal",
        "rotSymCentroidDisp = np.linalg.norm(AFS['ParsedSurface']['rotSymFeature']['rotSymCentre'] - centroid)",
        "if rotSymCentroidDisp > eps:",
        "rotAxisDir = (AFS['ParsedSurface']['rotSymFeature']['rotSymCentre'] - centroid) / rotSymCentroidDisp",
        "else:",
        "# if centre to rotSym feature coincides with centroid, get rotAxisDir from other parsed data",
        "if AFS['ParsedSurface'].get('normDir') is not None:",
        "rotAxisDir = AFS['ParsedSurface']['normDir']",
        "else:",
        "print(\"no surface axisDir value, cross()?\")",
        "",
        "# todo what happens with several rotationally symmetric features within a surface?",
        "# todo list check?",
        "",
        "# adjacent surfaces minima,  nearPointAxisDisp > rotSymCentroidDisp",
        "nearPointAxisDisp = []",
        "farPointAxisDisp = []",
        "",
        "# use edges in surface FaceOuterBoundEdgeLoopList",
        "for adjSurfaceEdge in AFS['outerBoundEdgeLoop']:",
        "# project all points, vertex1, vertex2, maxPoint, minPoint to rotational axis",
        "adjSurfaceVertices = adjSurfaceEdge['pointFeature']['xyz']",
        "for asv in adjSurfaceVertices:",
        "#pAxisProj = pointProjectAxis(asv, centroid, rotAxisDir)",
        "#pAxisProj = rotAxisDir * np.dot((asv - centroid), rotAxisDir) / np.dot(rotAxisDir, rotAxisDir)",
        "#pAxisProj = rotAxisDir * np.dot(asv, rotAxisDir) / np.dot(rotAxisDir, rotAxisDir)",
        "",
        "if rotSymCentroidDisp > eps:",
        "pAxisProj = rotAxisDir * np.dot((asv - centroid), rotAxisDir) / np.dot(rotAxisDir, rotAxisDir)",
        "else:",
        "pAxisProj = rotAxisDir * np.dot(asv, rotAxisDir) / np.dot(rotAxisDir, rotAxisDir)",
        "",
        "pAxisDisp = np.linalg.norm(asv - pAxisProj)",
        "rotSymEdgeDisp = np.dot((asv - AFS['ParsedSurface']['rotSymFeature']['rotSymCentre']), rotAxisDir)",
        "if rotSymEdgeDisp > eps:  # eps_",
        "# if np.linalg.norm(pAxisProj - centroid) > rotSymCentroidDisp:",
        "farPointAxisDisp.append(pAxisDisp)",
        "elif rotSymEdgeDisp < -eps:",
        "nearPointAxisDisp.append(pAxisDisp)",
        "",
        "if len(nearPointAxisDisp) == 0 or len(farPointAxisDisp) == 0:",
        "# disc at end of object, defined as rotSymMax",
        "AFS['ParsedSurface']['rotSymMax'] = True",
        "else:",
        "NPADA = np.average(nearPointAxisDisp)",
        "FPADA = np.average(farPointAxisDisp)",
        "",
        "# conical midpoints",
        "avgRadius = np.abs(NPADA - FPADA) / 2 + min([NPADA, FPADA])",
        "if avgRadius > AFS['ParsedSurface']['rotSymRadius']:",
        "# groove",
        "AFS['ParsedSurface']['rotSymMax'] = True",
        "else:",
        "AFS['ParsedSurface']['rotSymMin'] = True"
    ],
    "docstrings": [
        "\"\"\"\n    Affine transformation matrix from 3x3 rotation matrix and displacement vector.\n    3x3 rotation matrix derived from CCW angle theta around axis\n    From: http://en.wikipedia.org/wiki/Rotation_matrix#Axis_and_angle & transform3d\n\n    :param rotAxis: axis of rotation vector axis emanating from origin\n    :param theta: scalar radian angle of rotation\n    :return: 4x4 matrix representing affine transformation\n    \"\"\"",
        "\"\"\"\n    Return the rotation matrix associated with counterclockwise rotation about the given axis by theta radians.\n\n    :param axis: axis defined as a vector point relative to cartesian origin\n    :param theta: rotation angle in radians\n    :return: rotation matrix\n    \"\"\"",
        "'''test whether a numpy array of 3 elements (a) exists within a list of 3 element arrays'''",
        "\"\"\"\n    Returns centroid determined as the median of cartesian values in an input array of points\n\n    :param pointArray: array of Cartesian points\n    :return: point\n    \"\"\"",
        "\"\"\"\n    Return displacement(s) between input points or list of points\n\n    :param p1: single point\n    :param p2: single or list of points\n    :return: disp value or list of values\n    \"\"\"",
        "'''\n    Use either Newton-Raphson, or a hillclimbing neighbour search to find minimal or maximal distance on a surface, S, from a supplied point, p\n    - not tested with surfaces closed along U & V\n    maxSearch: search for most distant point from p if true, else nearest if false\n    localExtrema: find any local extrema which differs from surrounding sample points, tolerance not sufficiently defined\n    curvatureTest: rather than displacement of sampled points to provide seed locations for N-R/hillclimb search,\n    use a combination of the centres of curvature at any point across U-axis and V-axis to identify C2 inflection point.\n    uv_xyz: return u,v normalised values or cartesian x,y,z values\n    eps1: point coincidence limit, halt N-R on reaching this minima\n    eps2: cosine angle limit, halt N-R on reaching this minima\n    delta: sample interval dividing surface into points\n    '''",
        "* if not closed, don't allow outside of range a-b",
        "* if closed (e.g. circle), allow to move back to beginning",
        "'''\n    project point p to axis defined by point axP and normal axN\n    p: point to project\n    axP: axis point\n    axN: axis normal vector\n    '''",
        "\"\"\"\n    Return intersection point of segment and plane or None if no intersection.\n\n    :param vertex0: segment end point\n    :param vertex1: second segment end point\n    :param planePoint: point on plane\n    :param planeNorm: normal vector defining plane direction (does not need to be normalized)\n    :param precision: constant for STEP numerical float comparison\n    :return: point of segment plane intersection or none\n    \"\"\"",
        "\"\"\"Cintersection of a plane and a circle.\n    plane point\n    plane norm\n    circle point\n    circle norm\n    circle radius\n\n    There are 4 cases of plane-circle intersection:\n\n    1. intersect in 2 points (secant),\n    2. intersect in 1 point (tangent),\n    3. do not intersect, or\n    4. coincide (circle.plane == plane).\n    \"\"\"",
        "\"\"\"\n    flatten parameter sets and extract #d string references\n    \"\"\"",
        "\"\"\"\n    return np.array of STEP AP21 CARTESIAN_POINT, DIRECTION, VECTOR\n    \"\"\"",
        "'''\n    maximaExtrema flag, exit function without expensive minima calculations.\n    Used during centroid iteration\n    '''",
        "\"\"\"get barycentre of all AFS feature points\"\"\"",
        "'''print the instructions to create a FreeCAD model of a list of points'''",
        "\"\"\" given a STEP reference associated with a feature, find all associated objects (edges & surfaces) and return  \"\"\"",
        "'''\n    order rotational features to return unique rotSym features\n    '''",
        "'''\n    order point features to return unique\n    '''",
        "*****SURFACE*****",
        "*****CURVE*****"
    ],
    "functions": [
        "angleAxis2RotMat",
        "rotationMatrix",
        "arrayTypeCast",
        "cart2pol",
        "pol2cart",
        "array3x1match",
        "medianPoint",
        "pointDisp",
        "ref2index",
        "radiusCentre3points_2",
        "rationalSurfaceExtremaParam_5",
        "closedV",
        "closedU",
        "neighbouringUV",
        "localNeighbourSearch",
        "curvatureSearch",
        "localCurvatureExtrema",
        "subSearchUV",
        "NewtonRaphson",
        "n",
        "BsplineCurveExtremaDisp",
        "closedC",
        "localDispTest",
        "localCurvatureTest",
        "subSearchU",
        "NewtonRaphson",
        "n",
        "pointInArc",
        "pointOrderInArc",
        "pointProjectAxis",
        "pointCircleMinMaxDisp",
        "pointEllipseMinMaxDisp",
        "intersectSegmentPlane",
        "intersectPlaneCircle",
        "intersectArcPlane",
        "pointSegmentMinDisp",
        "cleanSubRefs",
        "curveEnclosingRectangle",
        "CP2point",
        "axis2Placement3D",
        "axis2Placement3D_2",
        "splineToPolyline",
        "insideOutsideSurfaceTest",
        "vertexAngle",
        "segmentParse",
        "circleParse",
        "ellipseParse",
        "BsplineCurveWithKnotsParse",
        "edgeSTEPparse",
        "edgeParse",
        "sphereSurfaceParse",
        "toroidSurfaceParse",
        "cylinderSurfaceParse",
        "coneSurfaceParse",
        "BSplineSurfaceWithKnotsParse",
        "planeSurfaceParse_2",
        "surfaceParse",
        "medianOfFeaturePoints",
        "FreeCADpointSyntax",
        "parseAdjacentFeatures",
        "getRotSymFeatures",
        "getPointFeatures",
        "vertexExtremaSearch"
    ],
    "classes": []
}