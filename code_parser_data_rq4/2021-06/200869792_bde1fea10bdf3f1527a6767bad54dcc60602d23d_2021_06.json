{
    "identifiers": [
        "sklearn",
        "cluster",
        "KMeans",
        "SKLModel",
        "lale",
        "docstrings",
        "set_docstrings",
        "lale",
        "operators",
        "make_operator",
        "_hyperparams_schema",
        "_input_fit_schema",
        "_input_transform_schema",
        "_output_transform_schema",
        "_input_predict_schema",
        "_output_predict_schema",
        "make_operator",
        "SKLModel",
        "_combined_schemas",
        "set_docstrings",
        "KMeans"
    ],
    "literals": [
        "\"$schema\"",
        "\"http://json-schema.org/draft-04/schema#\"",
        "\"description\"",
        "\"allOf\"",
        "\"type\"",
        "\"object\"",
        "\"required\"",
        "\"n_clusters\"",
        "\"init\"",
        "\"n_init\"",
        "\"max_iter\"",
        "\"tol\"",
        "\"precompute_distances\"",
        "\"verbose\"",
        "\"random_state\"",
        "\"copy_x\"",
        "\"n_jobs\"",
        "\"algorithm\"",
        "\"relevantToOptimizer\"",
        "\"n_clusters\"",
        "\"init\"",
        "\"n_init\"",
        "\"max_iter\"",
        "\"tol\"",
        "\"precompute_distances\"",
        "\"copy_x\"",
        "\"algorithm\"",
        "\"additionalProperties\"",
        "\"properties\"",
        "\"n_clusters\"",
        "\"type\"",
        "\"integer\"",
        "\"minimumForOptimizer\"",
        "\"maximumForOptimizer\"",
        "\"distribution\"",
        "\"uniform\"",
        "\"default\"",
        "\"description\"",
        "\"The number of clusters to form as well as the number of centroids to generate.\"",
        "\"init\"",
        "\"anyOf\"",
        "\"enum\"",
        "\"k-means++\"",
        "\"random\"",
        "\"laleType\"",
        "\"callable\"",
        "\"forOptimizer\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"number\"",
        "\"forOptimizer\"",
        "\"default\"",
        "\"k-means++\"",
        "\"description\"",
        "\"n_init\"",
        "\"type\"",
        "\"integer\"",
        "\"minimumForOptimizer\"",
        "\"maximumForOptimizer\"",
        "\"distribution\"",
        "\"uniform\"",
        "\"default\"",
        "\"description\"",
        "\"max_iter\"",
        "\"type\"",
        "\"integer\"",
        "\"minimumForOptimizer\"",
        "\"maximumForOptimizer\"",
        "\"distribution\"",
        "\"uniform\"",
        "\"default\"",
        "\"description\"",
        "\"Maximum number of iterations of the k-means algorithm for a single run.\"",
        "\"tol\"",
        "\"type\"",
        "\"number\"",
        "\"minimumForOptimizer\"",
        "\"maximumForOptimizer\"",
        "\"distribution\"",
        "\"loguniform\"",
        "\"default\"",
        "\"description\"",
        "\"Relative tolerance with regards to Frobenius norm of the difference in the cluster centers of two consecutive iterations to declare convergence.\"",
        "\"precompute_distances\"",
        "\"enum\"",
        "\"auto\"",
        "\"default\"",
        "\"auto\"",
        "\"description\"",
        "\"Precompute distances (faster but takes more memory). Deprecated.\"",
        "\"verbose\"",
        "\"type\"",
        "\"integer\"",
        "\"default\"",
        "\"description\"",
        "\"Verbosity mode.\"",
        "\"random_state\"",
        "\"anyOf\"",
        "\"type\"",
        "\"integer\"",
        "\"laleType\"",
        "\"numpy.random.RandomState\"",
        "\"enum\"",
        "\"default\"",
        "\"description\"",
        "\"Determines random number generation for centroid initialization\"",
        "\"copy_x\"",
        "\"type\"",
        "\"boolean\"",
        "\"default\"",
        "\"description\"",
        "\"n_jobs\"",
        "\"anyOf\"",
        "\"type\"",
        "\"integer\"",
        "\"enum\"",
        "\"default\"",
        "\"description\"",
        "\"The number of jobs to use for the computation. Deprecated.\"",
        "\"algorithm\"",
        "\"description\"",
        "\"enum\"",
        "\"auto\"",
        "\"full\"",
        "\"elkan\"",
        "\"default\"",
        "\"auto\"",
        "\"$schema\"",
        "\"http://json-schema.org/draft-04/schema#\"",
        "\"description\"",
        "\"Compute k-means clustering.\"",
        "\"type\"",
        "\"object\"",
        "\"required\"",
        "\"X\"",
        "\"properties\"",
        "\"X\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"number\"",
        "\"description\"",
        "\"Training instances to cluster. Array-like or sparse matrix, shape=(n_samples, n_features)\"",
        "\"y\"",
        "\"description\"",
        "\"not used, present here for API consistency by convention.\"",
        "\"sample_weight\"",
        "\"anyOf\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"number\"",
        "\"enum\"",
        "\"default\"",
        "\"description\"",
        "\"The weights for each observation in X\"",
        "\"$schema\"",
        "\"http://json-schema.org/draft-04/schema#\"",
        "\"description\"",
        "\"Transform X to a cluster-distance space.\"",
        "\"type\"",
        "\"object\"",
        "\"required\"",
        "\"X\"",
        "\"properties\"",
        "\"X\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"number\"",
        "\"description\"",
        "\"New data to transform.\"",
        "\"$schema\"",
        "\"http://json-schema.org/draft-04/schema#\"",
        "\"description\"",
        "\"X transformed in the new space.\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"number\"",
        "\"$schema\"",
        "\"http://json-schema.org/draft-04/schema#\"",
        "\"description\"",
        "\"Predict the closest cluster each sample in X belongs to.\"",
        "\"type\"",
        "\"object\"",
        "\"required\"",
        "\"X\"",
        "\"properties\"",
        "\"X\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"number\"",
        "\"description\"",
        "\"New data to predict.\"",
        "\"sample_weight\"",
        "\"anyOf\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"number\"",
        "\"enum\"",
        "\"default\"",
        "\"description\"",
        "\"The weights for each observation in X\"",
        "\"$schema\"",
        "\"http://json-schema.org/draft-04/schema#\"",
        "\"description\"",
        "\"Index of the cluster each sample belongs to.\"",
        "\"type\"",
        "\"array\"",
        "\"items\"",
        "\"type\"",
        "\"number\"",
        "\"$schema\"",
        "\"http://json-schema.org/draft-04/schema#\"",
        "\"description\"",
        "\"documentation_url\"",
        "\"https://lale.readthedocs.io/en/latest/modules/lale.lib.sklearn.k_means.html\"",
        "\"import_from\"",
        "\"sklearn.cluster\"",
        "\"type\"",
        "\"object\"",
        "\"tags\"",
        "\"pre\"",
        "\"op\"",
        "\"transformer\"",
        "\"clustering\"",
        "\"estimator\"",
        "\"post\"",
        "\"properties\"",
        "\"hyperparams\"",
        "\"input_fit\"",
        "\"input_transform\"",
        "\"output_transform\"",
        "\"input_predict\"",
        "\"output_predict\""
    ],
    "variables": [
        "_hyperparams_schema",
        "_input_fit_schema",
        "_input_transform_schema",
        "_output_transform_schema",
        "_input_predict_schema",
        "_output_predict_schema",
        "_combined_schemas",
        "KMeans"
    ],
    "comments": [
        "Copyright 2019 IBM Corporation",
        "",
        "Licensed under the Apache License, Version 2.0 (the \"License\");",
        "you may not use this file except in compliance with the License.",
        "You may obtain a copy of the License at",
        "",
        "http://www.apache.org/licenses/LICENSE-2.0",
        "",
        "Unless required by applicable law or agreed to in writing, software",
        "distributed under the License is distributed on an \"AS IS\" BASIS,",
        "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
        "See the License for the specific language governing permissions and",
        "limitations under the License."
    ],
    "docstrings": [
        "\"\"\"The k-means problem is solved using either Lloyd's or Elkan's algorithm.\nThe average complexity is given by O(k n T), where n is the number of\nsamples and T is the number of iteration.\nThe worst case complexity is given by O(n^(k+2/p)) with\nn = n_samples, p = n_features. (D. Arthur and S. Vassilvitskii,\n'How slow is the k-means method?' SoCG2006)\nIn practice, the k-means algorithm is very fast (one of the fastest\nclustering algorithms available), but it falls in local minima. That's why\nit can be useful to restart it several times.\nIf the algorithm stops before fully converging (because of ``tol`` or\n``max_iter``), ``labels_`` and ``cluster_centers_`` will not be consistent,\ni.e. the ``cluster_centers_`` will not be the means of the points in each\ncluster. Also, the estimator will reassign ``labels_`` after the last\niteration to make ``labels_`` consistent with ``predict`` on the training\nset.\"\"\"",
        "\"\"\"Method for initialization, defaults to `k-means++`.\n`k-means++` : selects initial cluster centers for k-mean clustering in a smart way to speed up convergence.\nSee section Notes in k_init for more details.\n`random`: choose n_clusters observations (rows) at random from data for the initial centroids.\nIf an array is passed, it should be of shape (n_clusters, n_features) and gives the initial centers.\nIf a callable is passed, it should take arguments X, n_clusters and a random state and return an initialization.\"\"\"",
        "\"\"\"Number of time the k-means algorithm will be run with different centroid seeds.\nThe final results will be the best output of n_init consecutive runs in terms of inertia.\"\"\"",
        "\"\"\"When pre-computing distances it is more numerically accurate to center the data first.\nIf copy_x is True (default), then the original data is not modified.\nIf False, the original data is modified, and put back before the function returns, but small numerical differences may be introduced by subtracting and then adding the data mean.\nNote that if the original data is not C-contiguous, a copy will be made even if copy_x is False.\nIf the original data is sparse, but not in CSR format, a copy will be made even if copy_x is False.\"\"\"",
        "\"\"\"K-means algorithm to use.\nThe classical EM-style algorithm is “full”. The “elkan” variation is more efficient on data with well-defined clusters, by using the triangle inequality.\nHowever it’s more memory intensive due to the allocation of an extra array of shape (n_samples, n_clusters).\nFor now “auto” (kept for backward compatibiliy) chooses “elkan” but it might change in the future for a better heuristic.\"\"\"",
        "\"\"\"`KMeans`_ from scikit-learn.\n\n.. _`KMeans`: https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html\n\"\"\""
    ],
    "functions": [],
    "classes": []
}