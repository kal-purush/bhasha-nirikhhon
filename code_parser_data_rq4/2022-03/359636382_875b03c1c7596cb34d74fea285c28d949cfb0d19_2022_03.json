{
    "identifiers": [
        "org",
        "opensearch",
        "ad",
        "rest",
        "handler",
        "org",
        "opensearch",
        "ad",
        "settings",
        "AnomalyDetectorSettings",
        "CONFIG_BUCKET_MINIMUM_SUCCESS_RATE",
        "org",
        "opensearch",
        "ad",
        "settings",
        "AnomalyDetectorSettings",
        "INTERVAL_BUCKET_MINIMUM_SUCCESS_RATE",
        "org",
        "opensearch",
        "ad",
        "settings",
        "AnomalyDetectorSettings",
        "INTERVAL_RECOMMENDATION_DECREASING_MULTIPLIER",
        "org",
        "opensearch",
        "ad",
        "settings",
        "AnomalyDetectorSettings",
        "INTERVAL_RECOMMENDATION_INCREASING_MULTIPLIER",
        "org",
        "opensearch",
        "ad",
        "settings",
        "AnomalyDetectorSettings",
        "MAX_INTERVAL_REC_LENGTH_IN_MINUTES",
        "org",
        "opensearch",
        "ad",
        "settings",
        "AnomalyDetectorSettings",
        "MAX_TIMES_DECREASING_INTERVAL",
        "org",
        "opensearch",
        "ad",
        "settings",
        "AnomalyDetectorSettings",
        "TOP_VALIDATE_TIMEOUT_IN_MILLIS",
        "java",
        "io",
        "java",
        "time",
        "Clock",
        "java",
        "time",
        "Duration",
        "java",
        "time",
        "Instant",
        "java",
        "time",
        "temporal",
        "ChronoUnit",
        "java",
        "util",
        "Collections",
        "java",
        "util",
        "Comparator",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "Locale",
        "java",
        "util",
        "java",
        "util",
        "Optional",
        "java",
        "util",
        "stream",
        "Collectors",
        "org",
        "apache",
        "logging",
        "log4j",
        "LogManager",
        "org",
        "apache",
        "logging",
        "log4j",
        "Logger",
        "org",
        "opensearch",
        "action",
        "ActionListener",
        "org",
        "opensearch",
        "action",
        "search",
        "SearchRequest",
        "org",
        "opensearch",
        "action",
        "search",
        "SearchResponse",
        "org",
        "opensearch",
        "ad",
        "common",
        "exception",
        "ADValidationException",
        "org",
        "opensearch",
        "ad",
        "common",
        "exception",
        "EndRunException",
        "org",
        "opensearch",
        "ad",
        "constant",
        "CommonErrorMessages",
        "org",
        "opensearch",
        "ad",
        "feature",
        "SearchFeatureDao",
        "org",
        "opensearch",
        "ad",
        "model",
        "AnomalyDetector",
        "org",
        "opensearch",
        "ad",
        "model",
        "DetectorValidationIssueType",
        "org",
        "opensearch",
        "ad",
        "model",
        "IntervalTimeConfiguration",
        "org",
        "opensearch",
        "ad",
        "model",
        "TimeConfiguration",
        "org",
        "opensearch",
        "ad",
        "model",
        "ValidationAspect",
        "org",
        "opensearch",
        "ad",
        "settings",
        "AnomalyDetectorSettings",
        "org",
        "opensearch",
        "ad",
        "transport",
        "ValidateAnomalyDetectorResponse",
        "org",
        "opensearch",
        "ad",
        "util",
        "ParseUtils",
        "org",
        "opensearch",
        "client",
        "Client",
        "org",
        "opensearch",
        "cluster",
        "service",
        "ClusterService",
        "org",
        "opensearch",
        "common",
        "unit",
        "TimeValue",
        "org",
        "opensearch",
        "common",
        "xcontent",
        "NamedXContentRegistry",
        "org",
        "opensearch",
        "index",
        "query",
        "BoolQueryBuilder",
        "org",
        "opensearch",
        "index",
        "query",
        "QueryBuilder",
        "org",
        "opensearch",
        "index",
        "query",
        "QueryBuilders",
        "org",
        "opensearch",
        "index",
        "query",
        "RangeQueryBuilder",
        "org",
        "opensearch",
        "search",
        "aggregations",
        "AggregationBuilder",
        "org",
        "opensearch",
        "search",
        "aggregations",
        "AggregationBuilders",
        "org",
        "opensearch",
        "search",
        "aggregations",
        "Aggregations",
        "org",
        "opensearch",
        "search",
        "aggregations",
        "BucketOrder",
        "org",
        "opensearch",
        "search",
        "aggregations",
        "PipelineAggregatorBuilders",
        "org",
        "opensearch",
        "search",
        "aggregations",
        "bucket",
        "MultiBucketsAggregation",
        "org",
        "opensearch",
        "search",
        "aggregations",
        "bucket",
        "composite",
        "CompositeAggregation",
        "org",
        "opensearch",
        "search",
        "aggregations",
        "bucket",
        "composite",
        "TermsValuesSourceBuilder",
        "org",
        "opensearch",
        "search",
        "aggregations",
        "bucket",
        "histogram",
        "DateHistogramInterval",
        "org",
        "opensearch",
        "search",
        "aggregations",
        "bucket",
        "histogram",
        "Histogram",
        "org",
        "opensearch",
        "search",
        "aggregations",
        "bucket",
        "histogram",
        "LongBounds",
        "org",
        "opensearch",
        "search",
        "aggregations",
        "bucket",
        "terms",
        "Terms",
        "org",
        "opensearch",
        "search",
        "builder",
        "SearchSourceBuilder",
        "org",
        "opensearch",
        "search",
        "sort",
        "FieldSortBuilder",
        "org",
        "opensearch",
        "search",
        "sort",
        "SortOrder",
        "AGG_NAME_TOP",
        "AGGREGATION",
        "anomalyDetector",
        "clusterService",
        "logger",
        "LogManager",
        "getLogger",
        "requestTimeout",
        "handler",
        "client",
        "xContentRegistry",
        "listener",
        "searchFeatureDao",
        "clock",
        "validationType",
        "clusterService",
        "client",
        "listener",
        "anomalyDetector",
        "requestTimeout",
        "xContentRegistry",
        "searchFeatureDao",
        "validationType",
        "clock",
        "clusterService",
        "clusterService",
        "client",
        "client",
        "listener",
        "listener",
        "anomalyDetector",
        "anomalyDetector",
        "requestTimeout",
        "requestTimeout",
        "xContentRegistry",
        "xContentRegistry",
        "searchFeatureDao",
        "searchFeatureDao",
        "validationType",
        "validationType",
        "clock",
        "clock",
        "recommendationListener",
        "ActionListener",
        "wrap",
        "topEntity",
        "getLatestDateForValidation",
        "topEntity",
        "exception",
        "listener",
        "onFailure",
        "exception",
        "logger",
        "error",
        "exception",
        "anomalyDetector",
        "isMultientityDetector",
        "getTopEntity",
        "recommendationListener",
        "recommendationListener",
        "onResponse",
        "Collections",
        "emptyMap",
        "topEntityListener",
        "maxIntervalInMinutes",
        "max",
        "MAX_INTERVAL_REC_LENGTH_IN_MINUTES",
        "anomalyDetector",
        "getDetectorIntervalInMinutes",
        "timeRangeBounds",
        "getTimeRangeBounds",
        "Instant",
        "now",
        "toEpochMilli",
        "maxIntervalInMinutes",
        "ChronoUnit",
        "MINUTES",
        "rangeQuery",
        "anomalyDetector",
        "getTimeField",
        "timeRangeBounds",
        "getMin",
        "to",
        "timeRangeBounds",
        "getMax",
        "bucketAggs",
        "topKeys",
        "anomalyDetector",
        "getCategoryField",
        "size",
        "bucketAggs",
        "AggregationBuilders",
        "terms",
        "AGG_NAME_TOP",
        "field",
        "anomalyDetector",
        "getCategoryField",
        "get",
        "order",
        "BucketOrder",
        "count",
        "bucketAggs",
        "AggregationBuilders",
        "composite",
        "AGG_NAME_TOP",
        "anomalyDetector",
        "getCategoryField",
        "stream",
        "f",
        "f",
        "field",
        "f",
        "collect",
        "Collectors",
        "toList",
        "size",
        "subAggregation",
        "PipelineAggregatorBuilders",
        "bucketSort",
        "Collections",
        "singletonList",
        "order",
        "SortOrder",
        "DESC",
        "size",
        "searchSourceBuilder",
        "query",
        "rangeQuery",
        "aggregation",
        "bucketAggs",
        "trackTotalHits",
        "size",
        "searchRequest",
        "indices",
        "anomalyDetector",
        "getIndices",
        "toArray",
        "source",
        "searchSourceBuilder",
        "client",
        "search",
        "searchRequest",
        "ActionListener",
        "wrap",
        "response",
        "aggs",
        "response",
        "getAggregations",
        "aggs",
        "topEntityListener",
        "onResponse",
        "Collections",
        "emptyMap",
        "anomalyDetector",
        "getCategoryField",
        "size",
        "entities",
        "aggs",
        "get",
        "AGG_NAME_TOP",
        "key",
        "entities",
        "getBuckets",
        "stream",
        "max",
        "Comparator",
        "comparingInt",
        "entry",
        "entry",
        "getDocCount",
        "MultiBucketsAggregation",
        "Bucket",
        "getKeyAsString",
        "orElse",
        "topKeys",
        "put",
        "anomalyDetector",
        "getCategoryField",
        "get",
        "key",
        "compositeAgg",
        "aggs",
        "get",
        "AGG_NAME_TOP",
        "topKeys",
        "putAll",
        "compositeAgg",
        "getBuckets",
        "stream",
        "flatMap",
        "bucket",
        "bucket",
        "getKey",
        "entrySet",
        "stream",
        "collect",
        "Collectors",
        "toMap",
        "e",
        "e",
        "getKey",
        "e",
        "e",
        "getValue",
        "entry",
        "topKeys",
        "entrySet",
        "entry",
        "getValue",
        "topEntityListener",
        "onResponse",
        "Collections",
        "emptyMap",
        "topEntityListener",
        "onResponse",
        "topKeys",
        "topEntityListener",
        "onFailure",
        "topEntity",
        "latestTimeListener",
        "ActionListener",
        "wrap",
        "latest",
        "getSampleRangesForValidationChecks",
        "latest",
        "anomalyDetector",
        "listener",
        "topEntity",
        "exception",
        "listener",
        "onFailure",
        "exception",
        "logger",
        "error",
        "exception",
        "searchFeatureDao",
        "getLatestDataTime",
        "anomalyDetector",
        "latestTimeListener",
        "latestTime",
        "detector",
        "listener",
        "topEntity",
        "latestTime",
        "isPresent",
        "latestTime",
        "get",
        "listener",
        "onFailure",
        "CommonErrorMessages",
        "TIME_FIELD_NOT_ENOUGH_HISTORICAL_DATA",
        "DetectorValidationIssueType",
        "TIMEFIELD_FIELD",
        "ValidationAspect",
        "MODEL",
        "timeRangeEnd",
        "min",
        "Instant",
        "now",
        "toEpochMilli",
        "latestTime",
        "get",
        "getBucketAggregates",
        "timeRangeEnd",
        "listener",
        "topEntity",
        "e",
        "listener",
        "onFailure",
        "detector",
        "getDetectorId",
        "CommonErrorMessages",
        "INVALID_SEARCH_QUERY_MSG",
        "e",
        "latestTime",
        "listener",
        "topEntity",
        "featureFields",
        "ParseUtils",
        "getFeatureFieldNames",
        "anomalyDetector",
        "xContentRegistry",
        "aggregation",
        "getBucketAggregation",
        "latestTime",
        "anomalyDetector",
        "getDetectionInterval",
        "query",
        "QueryBuilders",
        "boolQuery",
        "anomalyDetector",
        "getFilterQuery",
        "anomalyDetector",
        "isMultientityDetector",
        "topEntity",
        "isEmpty",
        "listener",
        "onFailure",
        "CommonErrorMessages",
        "CATEGORY_FIELD_TOO_SPARSE",
        "DetectorValidationIssueType",
        "CATEGORY",
        "ValidationAspect",
        "MODEL",
        "entry",
        "topEntity",
        "entrySet",
        "query",
        "QueryBuilders",
        "termQuery",
        "entry",
        "getKey",
        "entry",
        "getValue",
        "featureField",
        "featureFields",
        "query",
        "QueryBuilders",
        "existsQuery",
        "featureField",
        "searchSourceBuilder",
        "query",
        "query",
        "aggregation",
        "aggregation",
        "size",
        "timeout",
        "requestTimeout",
        "searchRequest",
        "anomalyDetector",
        "getIndices",
        "toArray",
        "source",
        "searchSourceBuilder",
        "intervalListener",
        "ActionListener",
        "wrap",
        "interval",
        "processIntervalRecommendation",
        "interval",
        "latestTime",
        "exception",
        "listener",
        "onFailure",
        "exception",
        "logger",
        "error",
        "exception",
        "client",
        "search",
        "searchRequest",
        "intervalListener",
        "searchRequest",
        "source",
        "anomalyDetector",
        "getDetectionInterval",
        "clock",
        "millis",
        "TOP_VALIDATE_TIMEOUT_IN_MILLIS",
        "latestTime",
        "MAX_TIMES_DECREASING_INTERVAL",
        "buckets",
        "docCountOverOne",
        "entry",
        "buckets",
        "getBuckets",
        "entry",
        "getDocCount",
        "docCountOverOne",
        "docCountOverOne",
        "getNumberOfSamples",
        "intervalListener",
        "searchSourceBuilder",
        "detectorInterval",
        "expirationEpochMs",
        "latestTime",
        "decreasingInterval",
        "numTimesDecreasing",
        "intervalListener",
        "searchSourceBuilder",
        "detectorInterval",
        "expirationEpochMs",
        "latestTime",
        "decreasingInterval",
        "numTimesDecreasing",
        "intervalListener",
        "intervalListener",
        "searchSourceBuilder",
        "searchSourceBuilder",
        "detectorInterval",
        "detectorInterval",
        "expirationEpochMs",
        "expirationEpochMs",
        "latestTime",
        "latestTime",
        "decreasingInterval",
        "decreasingInterval",
        "numTimesDecreasing",
        "numTimesDecreasing",
        "Override",
        "response",
        "aggregate",
        "checkBucketResultErrors",
        "response",
        "aggregate",
        "newIntervalMinute",
        "decreasingInterval",
        "newIntervalMinute",
        "floor",
        "IntervalTimeConfiguration",
        "getIntervalInMinute",
        "detectorInterval",
        "INTERVAL_RECOMMENDATION_DECREASING_MULTIPLIER",
        "newIntervalMinute",
        "ceil",
        "IntervalTimeConfiguration",
        "getIntervalInMinute",
        "detectorInterval",
        "INTERVAL_RECOMMENDATION_INCREASING_MULTIPLIER",
        "fullBucketRate",
        "processBucketAggregationResults",
        "aggregate",
        "fullBucketRate",
        "INTERVAL_BUCKET_MINIMUM_SUCCESS_RATE",
        "intervalListener",
        "onResponse",
        "detectorInterval",
        "expirationEpochMs",
        "clock",
        "millis",
        "listener",
        "onFailure",
        "CommonErrorMessages",
        "TIMEOUT_ON_INTERVAL_REC",
        "DetectorValidationIssueType",
        "TIMEOUT",
        "ValidationAspect",
        "MODEL",
        "logger",
        "info",
        "CommonErrorMessages",
        "TIMEOUT_ON_INTERVAL_REC",
        "newIntervalMinute",
        "MAX_INTERVAL_REC_LENGTH_IN_MINUTES",
        "decreasingInterval",
        "searchWithDifferentInterval",
        "newIntervalMinute",
        "newIntervalMinute",
        "MAX_INTERVAL_REC_LENGTH_IN_MINUTES",
        "decreasingInterval",
        "givenInterval",
        "anomalyDetector",
        "getDetectionInterval",
        "detectorInterval",
        "floor",
        "IntervalTimeConfiguration",
        "getIntervalInMinute",
        "givenInterval",
        "INTERVAL_RECOMMENDATION_DECREASING_MULTIPLIER",
        "ChronoUnit",
        "MINUTES",
        "detectorInterval",
        "getInterval",
        "intervalListener",
        "onResponse",
        "decreasingInterval",
        "numTimesDecreasing",
        "updatedSearchSourceBuilder",
        "getSearchSourceBuilder",
        "searchSourceBuilder",
        "query",
        "getBucketAggregation",
        "latestTime",
        "newIntervalMinute",
        "ChronoUnit",
        "MINUTES",
        "client",
        "search",
        "indices",
        "anomalyDetector",
        "getIndices",
        "toArray",
        "source",
        "updatedSearchSourceBuilder",
        "numTimesDecreasing",
        "newIntervalMinute",
        "numTimesDecreasing",
        "searchWithDifferentInterval",
        "newIntervalMinute",
        "intervalListener",
        "onResponse",
        "e",
        "onFailure",
        "e",
        "newIntervalMinuteValue",
        "detectorInterval",
        "newIntervalMinuteValue",
        "ChronoUnit",
        "MINUTES",
        "updatedSearchSourceBuilder",
        "getSearchSourceBuilder",
        "searchSourceBuilder",
        "query",
        "getBucketAggregation",
        "latestTime",
        "newIntervalMinuteValue",
        "ChronoUnit",
        "MINUTES",
        "client",
        "search",
        "indices",
        "anomalyDetector",
        "getIndices",
        "toArray",
        "source",
        "updatedSearchSourceBuilder",
        "Override",
        "e",
        "logger",
        "error",
        "e",
        "listener",
        "onFailure",
        "CommonErrorMessages",
        "MODEL_VALIDATION_FAILED_UNEXPECTEDLY",
        "DetectorValidationIssueType",
        "AGGREGATION",
        "ValidationAspect",
        "MODEL",
        "interval",
        "latestTime",
        "interval",
        "checkRawDataSparsity",
        "latestTime",
        "interval",
        "equals",
        "anomalyDetector",
        "getDetectionInterval",
        "logger",
        "info",
        "Instant",
        "now",
        "toEpochMilli",
        "latestTime",
        "timeConfigToMilliSec",
        "anomalyDetector",
        "getWindowDelay",
        "sendWindowDelayRec",
        "latestTime",
        "listener",
        "onResponse",
        "listener",
        "onFailure",
        "CommonErrorMessages",
        "DETECTOR_INTERVAL_REC",
        "interval",
        "getInterval",
        "DetectorValidationIssueType",
        "DETECTION_INTERVAL",
        "ValidationAspect",
        "MODEL",
        "interval",
        "latestTime",
        "detectorInterval",
        "AggregationBuilders",
        "dateHistogram",
        "AGGREGATION",
        "field",
        "anomalyDetector",
        "getTimeField",
        "minDocCount",
        "hardBounds",
        "getTimeRangeBounds",
        "latestTime",
        "detectorInterval",
        "fixedInterval",
        "DateHistogramInterval",
        "minutes",
        "IntervalTimeConfiguration",
        "getIntervalInMinute",
        "detectorInterval",
        "query",
        "aggregation",
        "query",
        "query",
        "aggregation",
        "aggregation",
        "size",
        "timeout",
        "requestTimeout",
        "latestTime",
        "aggregation",
        "getBucketAggregation",
        "latestTime",
        "anomalyDetector",
        "getDetectionInterval",
        "searchSourceBuilder",
        "aggregation",
        "aggregation",
        "size",
        "timeout",
        "requestTimeout",
        "searchRequest",
        "anomalyDetector",
        "getIndices",
        "toArray",
        "source",
        "searchSourceBuilder",
        "client",
        "search",
        "searchRequest",
        "ActionListener",
        "wrap",
        "response",
        "processRawDataResults",
        "response",
        "latestTime",
        "listener",
        "onFailure",
        "response",
        "aggs",
        "response",
        "getAggregations",
        "aggs",
        "logger",
        "warn",
        "listener",
        "onFailure",
        "CommonErrorMessages",
        "MODEL_VALIDATION_FAILED_UNEXPECTEDLY",
        "DetectorValidationIssueType",
        "AGGREGATION",
        "ValidationAspect",
        "MODEL",
        "aggregate",
        "aggs",
        "get",
        "AGGREGATION",
        "aggregate",
        "listener",
        "onFailure",
        "aggregate",
        "response",
        "latestTime",
        "aggregate",
        "checkBucketResultErrors",
        "response",
        "aggregate",
        "fullBucketRate",
        "processBucketAggregationResults",
        "aggregate",
        "fullBucketRate",
        "INTERVAL_BUCKET_MINIMUM_SUCCESS_RATE",
        "listener",
        "onFailure",
        "CommonErrorMessages",
        "RAW_DATA_TOO_SPARSE",
        "DetectorValidationIssueType",
        "INDICES",
        "ValidationAspect",
        "MODEL",
        "checkDataFilterSparsity",
        "latestTime",
        "latestTime",
        "aggregation",
        "getBucketAggregation",
        "latestTime",
        "anomalyDetector",
        "getDetectionInterval",
        "query",
        "QueryBuilders",
        "boolQuery",
        "anomalyDetector",
        "getFilterQuery",
        "searchSourceBuilder",
        "getSearchSourceBuilder",
        "query",
        "aggregation",
        "searchRequest",
        "anomalyDetector",
        "getIndices",
        "toArray",
        "source",
        "searchSourceBuilder",
        "client",
        "search",
        "searchRequest",
        "ActionListener",
        "wrap",
        "response",
        "processDataFilterResults",
        "response",
        "latestTime",
        "listener",
        "onFailure",
        "response",
        "latestTime",
        "aggregate",
        "checkBucketResultErrors",
        "response",
        "aggregate",
        "fullBucketRate",
        "processBucketAggregationResults",
        "aggregate",
        "fullBucketRate",
        "CONFIG_BUCKET_MINIMUM_SUCCESS_RATE",
        "listener",
        "onFailure",
        "CommonErrorMessages",
        "FILTER_QUERY_TOO_SPARSE",
        "DetectorValidationIssueType",
        "FILTER_QUERY",
        "ValidationAspect",
        "MODEL",
        "anomalyDetector",
        "isMultientityDetector",
        "getTopEntityForCategoryField",
        "latestTime",
        "checkFeatureQuery",
        "latestTime",
        "ex",
        "logger",
        "error",
        "ex",
        "listener",
        "onFailure",
        "ex",
        "latestTime",
        "getTopEntityListener",
        "ActionListener",
        "wrap",
        "topEntity",
        "checkCategoryFieldSparsity",
        "topEntity",
        "latestTime",
        "exception",
        "listener",
        "onFailure",
        "exception",
        "logger",
        "error",
        "exception",
        "getTopEntity",
        "getTopEntityListener",
        "topEntity",
        "latestTime",
        "query",
        "QueryBuilders",
        "boolQuery",
        "anomalyDetector",
        "getFilterQuery",
        "entry",
        "topEntity",
        "entrySet",
        "query",
        "QueryBuilders",
        "termQuery",
        "entry",
        "getKey",
        "entry",
        "getValue",
        "aggregation",
        "getBucketAggregation",
        "latestTime",
        "anomalyDetector",
        "getDetectionInterval",
        "searchSourceBuilder",
        "getSearchSourceBuilder",
        "query",
        "aggregation",
        "searchRequest",
        "anomalyDetector",
        "getIndices",
        "toArray",
        "source",
        "searchSourceBuilder",
        "client",
        "search",
        "searchRequest",
        "ActionListener",
        "wrap",
        "response",
        "processTopEntityResults",
        "response",
        "latestTime",
        "listener",
        "onFailure",
        "response",
        "latestTime",
        "aggregate",
        "checkBucketResultErrors",
        "response",
        "aggregate",
        "fullBucketRate",
        "processBucketAggregationResults",
        "aggregate",
        "fullBucketRate",
        "CONFIG_BUCKET_MINIMUM_SUCCESS_RATE",
        "listener",
        "onFailure",
        "CommonErrorMessages",
        "CATEGORY_FIELD_TOO_SPARSE",
        "DetectorValidationIssueType",
        "CATEGORY",
        "ValidationAspect",
        "MODEL",
        "checkFeatureQuery",
        "latestTime",
        "ex",
        "logger",
        "error",
        "ex",
        "listener",
        "onFailure",
        "ex",
        "response",
        "latestTime",
        "aggregate",
        "checkBucketResultErrors",
        "response",
        "aggregate",
        "fullBucketRate",
        "processBucketAggregationResults",
        "aggregate",
        "fullBucketRate",
        "CONFIG_BUCKET_MINIMUM_SUCCESS_RATE",
        "listener",
        "onFailure",
        "CommonErrorMessages",
        "FEATURE_QUERY_TOO_SPARSE",
        "DetectorValidationIssueType",
        "FEATURE_ATTRIBUTES",
        "ValidationAspect",
        "MODEL",
        "windowDelayRecommendation",
        "latestTime",
        "latestTime",
        "featureFields",
        "ParseUtils",
        "getFeatureFieldNames",
        "anomalyDetector",
        "xContentRegistry",
        "aggregation",
        "getBucketAggregation",
        "latestTime",
        "anomalyDetector",
        "getDetectionInterval",
        "query",
        "QueryBuilders",
        "boolQuery",
        "anomalyDetector",
        "getFilterQuery",
        "featureField",
        "featureFields",
        "query",
        "QueryBuilders",
        "existsQuery",
        "featureField",
        "searchSourceBuilder",
        "getSearchSourceBuilder",
        "query",
        "aggregation",
        "searchRequest",
        "anomalyDetector",
        "getIndices",
        "toArray",
        "source",
        "searchSourceBuilder",
        "client",
        "search",
        "searchRequest",
        "ActionListener",
        "wrap",
        "response",
        "processFeatureQuery",
        "response",
        "latestTime",
        "listener",
        "onFailure",
        "latestTimeInMillis",
        "minutesSinceLastStamp",
        "ceil",
        "Instant",
        "now",
        "toEpochMilli",
        "latestTimeInMillis",
        "listener",
        "onFailure",
        "format",
        "Locale",
        "ROOT",
        "CommonErrorMessages",
        "WINDOW_DELAY_REC",
        "minutesSinceLastStamp",
        "minutesSinceLastStamp",
        "DetectorValidationIssueType",
        "WINDOW_DELAY",
        "ValidationAspect",
        "MODEL",
        "minutesSinceLastStamp",
        "ChronoUnit",
        "MINUTES",
        "latestTime",
        "Instant",
        "now",
        "toEpochMilli",
        "latestTime",
        "timeConfigToMilliSec",
        "anomalyDetector",
        "getWindowDelay",
        "sendWindowDelayRec",
        "latestTime",
        "listener",
        "onFailure",
        "CommonErrorMessages",
        "RAW_DATA_TOO_SPARSE",
        "DetectorValidationIssueType",
        "INDICES",
        "ValidationAspect",
        "MODEL",
        "endMillis",
        "detectorIntervalInMinutes",
        "detectorInterval",
        "timeConfigToMilliSec",
        "detectorIntervalInMinutes",
        "startMillis",
        "endMillis",
        "getNumberOfSamples",
        "detectorInterval",
        "startMillis",
        "endMillis",
        "interval",
        "anomalyDetector",
        "getDetectorIntervalInMilliseconds",
        "max",
        "Duration",
        "ofHours",
        "AnomalyDetectorSettings",
        "TRAIN_SAMPLE_TIME_RANGE_IN_HOURS",
        "toMillis",
        "interval",
        "AnomalyDetectorSettings",
        "MIN_TRAIN_SAMPLES",
        "config",
        "Optional",
        "ofNullable",
        "config",
        "t",
        "t",
        "toDuration",
        "toMillis",
        "orElse"
    ],
    "literals": [
        "\"top_agg\"",
        "\"agg\"",
        "\"Failed to get top entity for categorical field\"",
        "\"bucketSort\"",
        "\"_count\"",
        "\"Failed to create search request for last data point\"",
        "\"Failed to get interval recommendation\"",
        "\"Failed to recommend new interval\"",
        "\"Using the current interval there is enough dense data \"",
        "\"Unexpected null aggregation.\"",
        "\"Failed to find valid aggregation result\"",
        "\"Failed to get top entity for categorical field\""
    ],
    "variables": [
        "anomalyDetector",
        "clusterService",
        "requestTimeout",
        "client",
        "xContentRegistry",
        "listener",
        "searchFeatureDao",
        "clock",
        "validationType",
        "bucketAggs",
        "intervalListener",
        "searchSourceBuilder",
        "detectorInterval",
        "expirationEpochMs",
        "latestTime",
        "decreasingInterval",
        "numTimesDecreasing",
        "newIntervalMinute"
    ],
    "comments": [
        "TODO: potentially change where this is located",
        "Need to first check if multi entity detector or not before doing any sort of validation.",
        "If detector is HCAD then we will find the top entity and treat as single entity for",
        "validation purposes",
        "For single category HCAD, this method uses bucket aggregation and sort to get the category field",
        "that have the highest document count in order to use that top entity for further validation",
        "For multi-category HCADs we use a composite aggregation to find the top fields for the entity",
        "with the highest doc count.",
        "Look at data back to the lower bound given the max interval we recommend or one given",
        "this would create a flattened stream of map entries",
        "For each entry",
        "maximum amount of times we will try decreasing interval for recommendation",
        "If rate is above success minimum then return interval suggestion.",
        "keep trying higher intervals as new interval is below max, and we aren't decreasing yet",
        "The below block is executed only the first time when new interval is above max and",
        "we aren't decreasing yet, at this point we will start decreasing for the first time",
        "if we are inside the below block",
        "Searching again using an updated interval",
        "In this case decreasingInterval has to be true already, so we will stop",
        "when the next new interval is below or equal to 0, or we have decreased up to max times",
        "this case means all intervals up to max interval recommendation length and down to either",
        "0 or until we tried 10 lower intervals than the one given have been tried",
        "which further means the next step is to go through A/B validation checks",
        "Searching again using an updated interval",
        "if interval suggestion is null that means no interval could be found with all the configurations",
        "applied, our next step then is to check density just with the raw data and then add each configuration",
        "one at a time to try and find root cause of low density",
        "Check if there is a window delay recommendation if everything else is successful and send exception",
        "The rate of buckets with at least 1 doc with given interval is above the success rate",
        "return response with interval recommendation",
        "This would indicate some bug or some opensearch core changes that we are not aware of (we don't keep up-to-date with",
        "the large amounts of changes there). For this reason I'm not throwing a SearchException but instead a validation exception",
        "which will be converted to validation response.",
        "blocks below are executed if data is dense enough with filter query applied.",
        "If HCAD then category fields will be added to bucket aggregation to see if they",
        "are the root cause of the issues and if not the feature queries will be checked for sparsity",
        "Check if there is a better window-delay to recommend and if one was recommended",
        "then send exception and return, otherwise continue to let user know data is too sparse as explained below",
        "This case has been reached if following conditions are met:",
        "1. no interval recommendation was found that leads to a bucket success rate of >= 0.75",
        "2. bucket success rate with the given interval and just raw data is also below 0.75.",
        "3. no single configuration during the following checks reduced the bucket success rate below 0.25",
        "This means the rate with all configs applied or just raw data was below 0.75 but the rate when checking each configuration at",
        "a time was always above 0.25 meaning the best suggestion is to simply ingest more data or change interval since",
        "we have no more insight regarding the root cause of the lower density."
    ],
    "docstrings": [
        "* Copyright OpenSearch Contributors\n * SPDX-License-Identifier: Apache-2.0",
        "* <p>This class executes all validation checks that are not blocking on the 'model' level.\n * This mostly involves checking if the data is generally dense enough to complete model training\n * which is based on if enough buckets in the last x intervals have at least 1 document present.</p>\n * <p>Initially different bucket aggregations are executed with with every configuration applied and with\n * different varying intervals in order to find the best interval for the data. If no interval is found with all\n * configuration applied then each configuration is tested sequentially for sparsity</p>",
        "* Constructor function.\n     *\n     * @param clusterService                  ClusterService\n     * @param client                          ES node client that executes actions on the local node\n     * @param listener                        ES channel used to construct bytes / builder based outputs, and send responses\n     * @param anomalyDetector                 anomaly detector instance\n     * @param requestTimeout                  request time out configuration\n     * @param xContentRegistry                Registry which is used for XContentParser\n     * @param searchFeatureDao                Search feature DAO\n     * @param validationType                  Specified type for validation\n     * @param clock                           clock object to know when to timeout",
        "* ActionListener class to handle execution of multiple bucket aggregations one after the other\n     * Bucket aggregation with different interval lengths are executed one by one to check if the data is dense enough\n     * We only need to execute the next query if the previous one led to data that is too sparse."
    ],
    "functions": [
        "ModelValidationActionHandler",
        "checkIfMultiEntityDetector",
        "getTopEntity",
        "getLatestDateForValidation",
        "getSampleRangesForValidationChecks",
        "getBucketAggregates",
        "processBucketAggregationResults",
        "DetectorIntervalRecommendationListener",
        "onResponse",
        "searchWithDifferentInterval",
        "onFailure",
        "processIntervalRecommendation",
        "AggregationBuilder",
        "getBucketAggregation",
        "SearchSourceBuilder",
        "getSearchSourceBuilder",
        "checkRawDataSparsity",
        "Histogram",
        "checkBucketResultErrors",
        "processRawDataResults",
        "checkDataFilterSparsity",
        "processDataFilterResults",
        "getTopEntityForCategoryField",
        "checkCategoryFieldSparsity",
        "processTopEntityResults",
        "processFeatureQuery",
        "checkFeatureQuery",
        "sendWindowDelayRec",
        "windowDelayRecommendation",
        "LongBounds",
        "getTimeRangeBounds",
        "getNumberOfSamples",
        "timeConfigToMilliSec"
    ],
    "classes": [
        "ModelValidationActionHandler",
        "DetectorIntervalRecommendationListener"
    ]
}