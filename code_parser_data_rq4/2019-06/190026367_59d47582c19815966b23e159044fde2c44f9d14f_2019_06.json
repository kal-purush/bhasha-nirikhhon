{
    "identifiers": [
        "javax",
        "imageio",
        "ImageIO",
        "java",
        "awt",
        "image",
        "BufferedImage",
        "java",
        "io",
        "File",
        "java",
        "io",
        "java",
        "util",
        "java",
        "util",
        "Iterator",
        "java",
        "util",
        "neuronet",
        "isEmpty1",
        "isEmpty2",
        "isEmpty3",
        "whiteString",
        "analyzerString",
        "analyzerWord",
        "analyzerLetter",
        "pict",
        "n",
        "nn",
        "nnn",
        "pix",
        "height",
        "width",
        "analyzerString",
        "analyzerLetter",
        "analyzerWord",
        "pict",
        "height",
        "width",
        "i",
        "i",
        "height",
        "i",
        "j",
        "j",
        "width",
        "j",
        "pix",
        "i",
        "j",
        "whiteString",
        "zoner",
        "pix",
        "height",
        "width",
        "i",
        "whiteString",
        "isEmpty1",
        "whiteString",
        "isEmpty1",
        "i",
        "height",
        "newPict",
        "n",
        "width",
        "q",
        "q",
        "n",
        "q",
        "w",
        "w",
        "width",
        "w",
        "newPict",
        "q",
        "w",
        "pict",
        "q",
        "w",
        "wordFind",
        "newPict",
        "n",
        "width",
        "neuronet",
        "textFormer",
        "isEmpty1",
        "whiteString",
        "analyzerString",
        "analyzerLetter",
        "analyzerWord",
        "n",
        "pict",
        "height",
        "width",
        "pix",
        "pix",
        "height",
        "width",
        "blur",
        "height",
        "width",
        "i",
        "i",
        "height",
        "i",
        "j",
        "j",
        "width",
        "j",
        "pix",
        "i",
        "j",
        "i",
        "j",
        "i",
        "height",
        "j",
        "width",
        "i",
        "j",
        "i",
        "height",
        "j",
        "width",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "i",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "j",
        "width",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "i",
        "height",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "j",
        "width",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "j",
        "width",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "blur",
        "i",
        "j",
        "sumCol",
        "avrCol",
        "avrArr",
        "width",
        "q",
        "q",
        "width",
        "q",
        "w",
        "w",
        "height",
        "w",
        "sumCol",
        "blur",
        "w",
        "q",
        "avrCol",
        "sumCol",
        "height",
        "avrCol",
        "round",
        "avrCol",
        "avrArr",
        "q",
        "avrCol",
        "sumCol",
        "average",
        "sumCol2",
        "e",
        "e",
        "avrArr",
        "length",
        "e",
        "sumCol2",
        "avrArr",
        "e",
        "average",
        "sumCol2",
        "avrArr",
        "length",
        "average",
        "round",
        "average",
        "binaryZone",
        "avrArr",
        "length",
        "a",
        "a",
        "avrArr",
        "length",
        "a",
        "avrArr",
        "a",
        "average",
        "binaryZone",
        "a",
        "binaryZone",
        "a",
        "analyzerString",
        "analyzerWord",
        "analyzerLetter",
        "pict",
        "height",
        "width",
        "i",
        "i",
        "width",
        "i",
        "j",
        "j",
        "height",
        "j",
        "binaryZone",
        "i",
        "whiteString",
        "zoner",
        "pix",
        "height",
        "width",
        "i",
        "whiteString",
        "isEmpty2",
        "whiteString",
        "isEmpty2",
        "i",
        "width",
        "newPict",
        "height",
        "nn",
        "q",
        "q",
        "height",
        "q",
        "w",
        "w",
        "nn",
        "w",
        "newPict",
        "q",
        "w",
        "pict",
        "q",
        "w",
        "letterFind",
        "newPict",
        "height",
        "nn",
        "neuronet",
        "textFormer",
        "isEmpty2",
        "whiteString",
        "analyzerString",
        "analyzerWord",
        "analyzerLetter",
        "nn",
        "pict",
        "height",
        "width",
        "pix",
        "pix",
        "height",
        "width",
        "t",
        "height",
        "interval",
        "round",
        "t",
        "sumCol",
        "avrCol",
        "avrArr",
        "width",
        "q",
        "q",
        "width",
        "q",
        "w",
        "w",
        "height",
        "w",
        "sumCol",
        "pix",
        "w",
        "q",
        "avrCol",
        "sumCol",
        "height",
        "avrCol",
        "round",
        "avrCol",
        "avrArr",
        "q",
        "avrCol",
        "sumCol",
        "average",
        "sumCol2",
        "e",
        "e",
        "avrArr",
        "length",
        "e",
        "sumCol2",
        "avrArr",
        "e",
        "average",
        "sumCol2",
        "avrArr",
        "length",
        "average",
        "round",
        "average",
        "average",
        "average",
        "gran",
        "min",
        "avrArr",
        "index",
        "s",
        "interval",
        "s",
        "avrArr",
        "length",
        "q",
        "s",
        "q",
        "interval",
        "s",
        "q",
        "avrArr",
        "q",
        "min",
        "min",
        "avrArr",
        "q",
        "index",
        "q",
        "gran",
        "add",
        "index",
        "s",
        "index",
        "index",
        "s",
        "min",
        "avrArr",
        "s",
        "q",
        "s",
        "q",
        "avrArr",
        "length",
        "q",
        "avrArr",
        "q",
        "min",
        "min",
        "avrArr",
        "q",
        "index",
        "q",
        "gran",
        "add",
        "index",
        "q",
        "q",
        "gran",
        "size",
        "q",
        "m",
        "gran",
        "get",
        "q",
        "avrArr",
        "m",
        "average",
        "avrArr",
        "m",
        "average",
        "avrArr",
        "m",
        "average",
        "iter",
        "gran",
        "iterator",
        "iter",
        "hasNext",
        "next",
        "iter",
        "next",
        "next",
        "equals",
        "q",
        "iter",
        "remove",
        "t",
        "height",
        "upp",
        "round",
        "t",
        "t",
        "height",
        "mid",
        "round",
        "t",
        "low",
        "height",
        "upp",
        "mid",
        "bool1",
        "bool2",
        "bool3",
        "maxU",
        "maxU_next",
        "maxU_prev",
        "maxM",
        "maxM_next",
        "maxM_prev",
        "maxL",
        "maxL_next",
        "maxL_prev",
        "q",
        "q",
        "width",
        "q",
        "w",
        "w",
        "height",
        "w",
        "w",
        "upp",
        "maxU",
        "pix",
        "w",
        "q",
        "maxU",
        "pix",
        "w",
        "q",
        "maxU_next",
        "pix",
        "w",
        "q",
        "maxU_next",
        "pix",
        "w",
        "q",
        "maxU_prev",
        "pix",
        "w",
        "q",
        "maxU_prev",
        "pix",
        "w",
        "q",
        "w",
        "upp",
        "w",
        "low",
        "maxM",
        "pix",
        "w",
        "q",
        "maxM",
        "pix",
        "w",
        "q",
        "maxM_next",
        "pix",
        "w",
        "q",
        "maxM_next",
        "pix",
        "w",
        "q",
        "maxM_prev",
        "pix",
        "w",
        "q",
        "maxM_prev",
        "pix",
        "w",
        "q",
        "w",
        "low",
        "maxL",
        "pix",
        "w",
        "q",
        "maxL",
        "pix",
        "w",
        "q",
        "maxL_next",
        "pix",
        "w",
        "q",
        "maxL_next",
        "pix",
        "w",
        "q",
        "maxL_prev",
        "pix",
        "w",
        "q",
        "maxL_prev",
        "pix",
        "w",
        "q",
        "maxU",
        "maxU_next",
        "maxM",
        "maxM_next",
        "maxL",
        "maxL_next",
        "maxU",
        "maxU_prev",
        "maxM",
        "maxM_prev",
        "maxL",
        "maxL_prev",
        "bool1",
        "maxU_next",
        "maxM_next",
        "maxU_next",
        "maxL_next",
        "maxU_next",
        "maxU_next",
        "maxL_next",
        "maxM_next",
        "maxU_next",
        "maxL_next",
        "maxU_next",
        "maxL_next",
        "maxU_next",
        "maxM_next",
        "maxM_next",
        "maxL_next",
        "maxU_next",
        "maxM_next",
        "maxU_prev",
        "maxM_prev",
        "maxU_prev",
        "maxL_prev",
        "maxU_prev",
        "maxU_prev",
        "maxL_prev",
        "maxM_prev",
        "maxU_prev",
        "maxL_prev",
        "maxU_prev",
        "maxL_prev",
        "maxU_prev",
        "maxM_prev",
        "maxM_prev",
        "maxL_prev",
        "maxU_prev",
        "maxM_prev",
        "avrArr",
        "q",
        "maxU_next",
        "avrArr",
        "q",
        "maxU_prev",
        "bool2",
        "maxU",
        "maxM",
        "maxU",
        "maxL",
        "maxU",
        "maxU",
        "maxL",
        "maxM",
        "maxU",
        "maxL",
        "maxU",
        "maxL",
        "maxU",
        "maxM",
        "maxM",
        "maxL",
        "maxU",
        "maxM",
        "a_next",
        "abs",
        "maxU",
        "maxU_next",
        "a_prev",
        "abs",
        "maxU",
        "maxU_prev",
        "maxU",
        "a_next",
        "maxU",
        "a_prev",
        "bool3",
        "bool1",
        "bool2",
        "bool3",
        "iter",
        "gran",
        "iterator",
        "iter",
        "hasNext",
        "next",
        "iter",
        "next",
        "next",
        "equals",
        "q",
        "iter",
        "remove",
        "bool1",
        "bool2",
        "bool3",
        "maxU",
        "maxU_next",
        "maxU_prev",
        "maxM",
        "maxM_next",
        "maxM_prev",
        "maxL",
        "maxL_next",
        "maxL_prev",
        "power",
        "height",
        "count",
        "binaryZone",
        "avrArr",
        "length",
        "a",
        "a",
        "avrArr",
        "length",
        "a",
        "gran",
        "contains",
        "a",
        "count",
        "power",
        "binaryZone",
        "a",
        "count",
        "binaryZone",
        "a",
        "count",
        "analyzerString",
        "analyzerWord",
        "analyzerLetter",
        "pict",
        "height",
        "width",
        "i",
        "i",
        "width",
        "i",
        "j",
        "j",
        "height",
        "j",
        "binaryZone",
        "i",
        "whiteString",
        "zoner",
        "pix",
        "height",
        "width",
        "i",
        "whiteString",
        "isEmpty3",
        "whiteString",
        "isEmpty3",
        "i",
        "width",
        "newPict",
        "height",
        "nnn",
        "q",
        "q",
        "height",
        "q",
        "w",
        "w",
        "nnn",
        "w",
        "newPict",
        "q",
        "w",
        "pict",
        "q",
        "w",
        "nnn",
        "imager",
        "newPict",
        "height",
        "nnn",
        "isEmpty3",
        "whiteString",
        "analyzerString",
        "analyzerWord",
        "analyzerLetter",
        "nnn",
        "pict",
        "height",
        "width",
        "pix",
        "pix",
        "height",
        "width",
        "i",
        "analyzerString",
        "j",
        "j",
        "width",
        "j",
        "pict",
        "n",
        "j",
        "pix",
        "i",
        "j",
        "isEmpty1",
        "n",
        "analyzerWord",
        "j",
        "j",
        "height",
        "j",
        "pict",
        "j",
        "nn",
        "pix",
        "j",
        "i",
        "nn",
        "isEmpty2",
        "analyzerLetter",
        "j",
        "j",
        "height",
        "j",
        "pict",
        "j",
        "nnn",
        "pix",
        "j",
        "i",
        "nnn",
        "isEmpty3",
        "sc",
        "pixels",
        "n",
        "w",
        "img",
        "w",
        "n",
        "BufferedImage",
        "TYPE_INT_RGB",
        "sc",
        "f",
        "im",
        "n",
        "w",
        "i",
        "y",
        "y",
        "n",
        "y",
        "x",
        "x",
        "w",
        "x",
        "temp",
        "pixels",
        "y",
        "x",
        "zap",
        "temp",
        "r",
        "zap",
        "g",
        "zap",
        "b",
        "zap",
        "im",
        "i",
        "r",
        "g",
        "b",
        "img",
        "setRGB",
        "x",
        "y",
        "im",
        "i",
        "i",
        "analyzerLetter",
        "neuronet",
        "preporation",
        "img",
        "sc"
    ],
    "literals": [
        "\"src/Save/img\"",
        "\".png\""
    ],
    "variables": [
        "pict",
        "avrCol",
        "average",
        "avrCol",
        "average"
    ],
    "comments": [
        "СЕГМЕНТАТОР_ТЕКСТА",
        "1) получение искателем_строк массива значений для оцифровывания",
        "2) с помощью метода границ искатель_строк делит массив значений изображения на \"строки\", которые определяют реальные строки текста с изображения",
        "3) передача 'строки' в искатель_слов, а после передача в составитель_текста значения '999', определяющее '\\n' (новую строку)",
        "4) искатель_слов через сравнивание среднего значения яркости каждого столбца полученной 'строки' с общим средним значением яркости 'строки' делит массив на 'слова', определяющие реальные слова текста с изображения",
        "5) передача 'слова' в искатель_символов, а после передача в составитель_текста значения '666', определяющее ' ' (пробел между словами)",
        "6) искатель_символов, используя три этапа определения настоящих границ каждого символа, получает 'символы', определяющие реальные символы текста с изображения",
        "7) отправка массива значений 'символа' в метод_создания_изображения",
        "8) создается новое изображения символа",
        "9) передача этого изображения в нейросеть",
        "ДОПОЛНИТЕЛЬНО:",
        "10) выгрузка строк в папку \"Save\", полученных в искателе_строк, в виде изображений (для проверки)",
        "11) выгрузка слов в папку \"Save\", полученных в искателе_слов, в виде изображений (для проверки)",
        "12) выгрузка символов в папку \"Save\", полученных в искателе_символов, в виде изображений (для проверки)",
        "13) возможность сегментатора отправлять полученные изображения вместо нейросети в обучатель_нейросети",
        "булеаны для пустых массивов, в которые сохраняются строки текста (нужны как условие записи искателями полученных ими значений)",
        "нахождение конечной границы строки текста (нужны как условие записи искателями, полученных ими, значений)",
        "флаг работы искателя_строк (нужен для записи значений, полученных им)",
        "флаг работы искателя_слов (нужен для записи значений, полученных им)",
        "флаг работы искателя_символов (нужен для записи значений, полученных им)",
        "временный массив",
        "временные переменные для создания новых изображений (для определения размеров полученного массива на выходе из каждого искателя)",
        "ИСКАТЕЛЬ СТРОК",
        "включение искателя строк",
        "идентифицируем размеры временного массива",
        "порог черного пикселя (находим стартовую границу строки текста)",
        "запись одной строки пикселей",
        "белый символ",
        "находим конечную границу строки текста",
        "идентификация массива для полученной строки",
        "перезапись в новый массив",
        "imager(newPict, n, width); // выгрузка строк как изображений",
        "передача массива в искатель_слов",
        "передача в составитель_текста информации о присутствии '\\n'",
        "устанавливаем значений по умолчанию",
        "ИСКАТЕЛЬ СЛОВ",
        "массив для хранения размытого изображения",
        "размытие изображения (все соседние пиксели у черного пикселя устанавливаются как '1')",
        "условия приграничных пикселей",
        "белые - в '0'",
        "сумма пикселей в одном столбце",
        "среднее значение пикселей в столбце",
        "массив средних значений каждого столбца одной строки",
        "находим средние значения яркости пикселей для каждого столбца в строке",
        "средний порог значений пикселей для полной одной строки",
        "находим среднее значение яркости пикселей для всей строки, которое будет являться порогом для средних значений каждого столбца",
        "здесь храниятся индексы столбцов строки",
        "сравниваем все полученные ранее значения яркости для каждого столбца со средним порогом яркости для всей строки",
        "устанавливаем в '1', где находится слово",
        "включение искателя слов",
        "идентифицируем размеры временного массива",
        "запись нового изображения",
        "исходя из полученных данных предыдущих вычислений, записываем пиксели в новый массив",
        "находим конечную границу слова",
        "идентификация массива для нового слова",
        "перезапись слова",
        "imager(newPict, height, nnn); // выгрузка слов как изображений",
        "передача слова в искатель_символов",
        "передача в составитель_текста информации о присутствии ' '",
        "устанавливаем значения по умолчанию",
        "ИСКАТЕЛЬ СИМВОЛОВ",
        "примерная ширина символа",
        "сумма пикселей в одном столбце",
        "среднее значение пикселей в столбце",
        "массив средних значений каждого столбца одного слова",
        "находим средние значения яркости пикселей для каждого столбца в слове",
        "средний порог значений пикселей для полного одного слова",
        "находим среднее значение яркости пикселей для всего слова",
        "список межсимвольных границ",
        "переменная минимума для нахождения межсимвольных границ",
        "индекс найденных минимумов",
        "переменная для сдвига",
        "находим минимальное среднее (min) значение столбца на отрезке (0, interval)",
        "далее находим на отрезке от (min+1, interval+1)",
        "и так далее до конечной границы слова",
        "таким образом получаем группу предварительных межсимвольных границ",
        "этот цикл нужен для прохода последнего отрезка",
        "первый шаг удаления лишних границ",
        "условие ложной границы",
        "делим изображение слова на три уровня",
        "верхний - 30% от высоты",
        "средний - 40%",
        "нижний - 30%",
        "булеаны для каждого условия удаления последних ложных межсимвольных границ",
        "максимальные среди средних значений яркости для каждого уровня (текущий столбец, следующий, предыдущий)",
        "следующий шаг удаления лишних границ",
        "находим максимальные значения для каждого столбца и соседних ему на каждом уровне",
        "если есть последовательные черные символы, то это ложная граница",
        "нахождения максимума для полных соседних столбцов",
        "если среднее значение текущего столбца меньше максимального соседних, то это ложная граница",
        "нахождение максимума для текущего полного столбца",
        "третье условие для ложных границ",
        "при срабатывании всех трех условий, граница удаляется",
        "обнуляем переменные",
        "записываем в массив финальную группу межсимвольных границ",
        "минимальное расстояние между границами",
        "счетчик расстояний между границами",
        "здесь хранятся индексы столбцов слова",
        "границы не должны быть слишком близко",
        "включение искателя символов",
        "идентифицируем размеры временного массива",
        "запись нового изображения",
        "исходя из полученных данных предыдущих вычислений записываем пиксели в новый массив",
        "записываем конечную границу символа",
        "идентификация массива для нового символа",
        "перезапись символа",
        "используем массивы с шириной больше '3'",
        "создание изображения символа",
        "устанавливаем значения по умолчанию",
        "ЗАПИСЬ СТРОК МАССИВОВ ДЛЯ КАЖДОГО ИСКАТЕЛЯ",
        "для искателя строк",
        "теперь массив не пустой",
        "для искателя слов",
        "теперь массив не пустой",
        "для искателя символов",
        "теперь массив не пустой",
        "счетчик файлов",
        "ПРЕОБРАЗОВАНИЕ ПОЛУЧЕННОГО МАССИВА ИЗ ИСКАТЕЛЯ_СИМВОЛОВ В ИЗОБРАЖЕНИЕ И ОТПРАВКА В НЕЙРОСЕТЬ",
        "массив со значениями пикселей, на основе которого будет создаваться изображение",
        "заполнение массива",
        "кодировка пикселя в тип RGB",
        "если изображение - символ, то передается в нейросеть",
        "передача изображения в нейросеть",
        "neuronet.trainer(img); // передача изображения в обучатель",
        "ImageIO.write(img, \"PNG\", f); // выгрузка изображений"
    ],
    "docstrings": [],
    "functions": [
        "stringFind",
        "wordFind",
        "letterFind",
        "zoner",
        "imager"
    ],
    "classes": [
        "Finder"
    ]
}