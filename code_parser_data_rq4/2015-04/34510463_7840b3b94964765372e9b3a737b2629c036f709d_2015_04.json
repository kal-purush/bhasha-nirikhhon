{
    "identifiers": [
        "http",
        "e",
        "e",
        "e",
        "path",
        "path",
        "method",
        "path",
        "callbacks",
        "options",
        "name",
        "fn",
        "name",
        "fn",
        "path",
        "fn",
        "req",
        "res",
        "next",
        "path",
        "callbacks",
        "name",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "options",
        "name",
        "fn",
        "name",
        "fn",
        "path",
        "fn",
        "req",
        "res",
        "next",
        "path",
        "callbacks",
        "name",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "name",
        "handlers",
        "req",
        "res",
        "next",
        "err",
        "fn",
        "fn",
        "fn",
        "fn",
        "name",
        "name",
        "charset",
        "lang",
        "size",
        "name",
        "defaultValue",
        "name",
        "options",
        "status",
        "body",
        "body",
        "http",
        "code",
        "links",
        "path",
        "path",
        "options",
        "path",
        "fn",
        "path",
        "options",
        "fn",
        "path",
        "path",
        "filename",
        "path",
        "fn",
        "path",
        "filename",
        "fn",
        "obj",
        "filename",
        "field",
        "field",
        "value",
        "field",
        "field",
        "value",
        "field",
        "name",
        "options",
        "name",
        "val",
        "options",
        "name",
        "val",
        "options",
        "name",
        "val",
        "url",
        "url",
        "status",
        "url",
        "url",
        "status",
        "view",
        "options",
        "callback",
        "err",
        "html",
        "view",
        "callback",
        "err",
        "html",
        "req",
        "res",
        "next",
        "route",
        "callback",
        "route",
        "server",
        "callback",
        "server",
        "ext",
        "fn",
        "name",
        "fn",
        "name",
        "fn",
        "setting",
        "val",
        "setting",
        "setting",
        "setting",
        "setting",
        "env",
        "fn",
        "env0",
        "env1",
        "fn",
        "env0",
        "env1",
        "env2",
        "fn",
        "env0",
        "env1",
        "env2",
        "env3",
        "fn",
        "env0",
        "env1",
        "env2",
        "env3",
        "env4",
        "fn",
        "fn",
        "name",
        "options",
        "callback",
        "err",
        "html",
        "name",
        "callback",
        "err",
        "html",
        "port",
        "hostname",
        "backlog",
        "callback",
        "port",
        "hostname",
        "callback",
        "port",
        "callback",
        "path",
        "callback",
        "handle",
        "listeningListener",
        "bodyParser",
        "options",
        "errorHandler",
        "opts",
        "methodOverride",
        "key",
        "cookieParser",
        "secret",
        "session",
        "options",
        "hash",
        "sess",
        "root",
        "options",
        "basicAuth",
        "callback",
        "user",
        "fn",
        "realm",
        "basicAuth",
        "callback",
        "user",
        "realm",
        "basicAuth",
        "user",
        "realm",
        "compress",
        "options",
        "cookieSession",
        "options",
        "csrf",
        "options",
        "directory",
        "root",
        "options",
        "favicon",
        "path",
        "options",
        "json",
        "options",
        "limit",
        "limit",
        "logger",
        "options",
        "logger",
        "options",
        "logger",
        "options",
        "compile",
        "fmt",
        "token",
        "name",
        "fn",
        "format",
        "name",
        "format",
        "name",
        "query",
        "options",
        "responseTime",
        "staticCache",
        "options",
        "timeout",
        "ms",
        "vhost",
        "hostname",
        "server",
        "urlencoded",
        "multipart",
        "e"
    ],
    "literals": [
        "\"express\"",
        "'http'",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string"
    ],
    "variables": [],
    "comments": [
        "Type definitions for Express 3.1",
        "Project: http://expressjs.com",
        "Definitions by: Boris Yankov <https://github.com/borisyankov/>",
        "DefinitelyTyped: https://github.com/borisyankov/DefinitelyTyped",
        "=================== USAGE =================== \n\n    import express = require('express');\n    var app = express();\n\n ===============================================",
        "Merged declaration, e is both a callable function and a namespace",
        "body: { username: string; password: string; remember: boolean; title: string; };",
        "cookies: { string; remember: boolean; };"
    ],
    "docstrings": [
        "* Check if this route matches `path`, if so\n            * populate `.params`.",
        "* Initialize `Route` with the given HTTP `method`, `path`,\n             * and an array of `callbacks` and `options`.\n             *\n             * Options:\n             *\n             *   - `sensitive`    enable case-sensitive routes\n             *   - `strict`       enable strict matching for trailing slashes\n             *\n             * @param method\n             * @param path\n             * @param callbacks\n             * @param options",
        "* Map the given param placeholder `name`(s) to the given callback(s).\n             *\n             * Parameter mapping is used to provide pre-conditions to routes\n             * which use normalized placeholders. For example a _:user_id_ parameter\n             * could automatically load a user's information from the database without\n             * any additional code,\n             *\n             * The callback uses the samesignature as middleware, the only differencing\n             * being that the value of the placeholder is passed, in this case the _id_\n             * of the user. Once the `next()` function is invoked, just like middleware\n             * it will continue on to execute the route, or subsequent parameter functions.\n             *\n             *      app.param('user_id', function(req, res, next, id){\n             *        User.find(id, function(err, user){\n             *          if (err) {\n             *            next(err);\n             *          } else if (user) {\n             *            req.user = user;\n             *            next();\n             *          } else {\n             *            next(new Error('failed to load user'));\n             *          }\n             *        });\n             *      });\n             *\n             * @param name\n             * @param fn",
        "* Special-cased \"all\" method, applying the given route `path`,\n             * middleware, and callback to _every_ HTTP method.\n             *\n             * @param path\n             * @param fn",
        "* Update reset `.cookie.maxAge` to prevent\n             * the cookie from expiring when the\n             * session is still active.\n             *\n             * @return {Session} for chaining\n             * @api public",
        "* Reset `.maxAge` to `.originalMaxAge`.",
        "* Save the session data with optional callback `fn(err)`.",
        "* Re-loads the session data _without_ altering\n             * the maxAge properties. Invokes the callback `fn(err)`,\n             * after which time if no exception has occurred the\n             * `req.session` property will be a new `Session` object,\n             * although representing the same session.",
        "* Destroy `this` session.",
        "* Regenerate this request's session.",
        "* Return request header.\n             *\n             * The `Referrer` header field is special-cased,\n             * both `Referrer` and `Referer` are interchangeable.\n             *\n             * Examples:\n             *\n             *     req.get('Content-Type');\n             *     // => \"text/plain\"\n             *\n             *     req.get('content-type');\n             *     // => \"text/plain\"\n             *\n             *     req.get('Something');\n             *     // => undefined\n             *\n             * Aliased as `req.header()`.\n             *\n             * @param name",
        "* Check if the given `type(s)` is acceptable, returning\n             * the best match when true, otherwise `undefined`, in which\n             * case you should respond with 406 \"Not Acceptable\".\n             *\n             * The `type` value may be a single mime type string\n             * such as \"application/json\", the extension name\n             * such as \"json\", a comma-delimted list such as \"json, html, text/plain\",\n             * or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n             * or array is given the _best_ match, if any is returned.\n             *\n             * Examples:\n             *\n             *     // Accept: text/html\n             *     req.accepts('html');\n             *     // => \"html\"\n             *\n             *     // Accept: text/*, application/json\n             *     req.accepts('html');\n             *     // => \"html\"\n             *     req.accepts('text/html');\n             *     // => \"text/html\"\n             *     req.accepts('json, text');\n             *     // => \"json\"\n             *     req.accepts('application/json');\n             *     // => \"application/json\"\n             *\n             *     // Accept: text/*, application/json\n             *     req.accepts('image/png');\n             *     req.accepts('png');\n             *     // => undefined\n             *\n             *     // Accept: text/*;q=.5, application/json\n             *     req.accepts(['html', 'json']);\n             *     req.accepts('html, json');\n             *     // => \"json\"",
        "* Check if the given `charset` is acceptable,\n             * otherwise you should respond with 406 \"Not Acceptable\".\n             *\n             * @param charset",
        "* Check if the given `lang` is acceptable,\n             * otherwise you should respond with 406 \"Not Acceptable\".\n             *\n             * @param lang",
        "* Parse Range header field,\n             * capping to the given `size`.\n             *\n             * Unspecified ranges such as \"0-\" require\n             * knowledge of your resource length. In\n             * the case of a byte range this is of course\n             * the total number of bytes. If the Range\n             * header field is not given `null` is returned,\n             * `-1` when unsatisfiable, `-2` when syntactically invalid.\n             *\n             * NOTE: remember that ranges are inclusive, so\n             * for example \"Range: users=0-3\" should respond\n             * with 4 users when available, not 3.\n             *\n             * @param size",
        "* Return an array of Accepted media types\n             * ordered from highest quality to lowest.",
        "* Return an array of Accepted languages\n             * ordered from highest quality to lowest.\n             *\n             * Examples:\n             *\n             *     Accept-Language: en;q=.5, en-us\n             *     ['en-us', 'en']",
        "* Return an array of Accepted charsets\n             * ordered from highest quality to lowest.\n             *\n             * Examples:\n             *\n             *     Accept-Charset: iso-8859-5;q=.2, unicode-1-1;q=0.8\n             *     ['unicode-1-1', 'iso-8859-5']",
        "* Return the value of param `name` when present or `defaultValue`.\n             *\n             *  - Checks route placeholders, ex: _/user/:id_\n             *  - Checks body params, ex: id=12, {\"id\":12}\n             *  - Checks query string params, ex: ?id=12\n             *\n             * To utilize request bodies, `req.body`\n             * should be an object. This can be done by using\n             * the `connect.bodyParser()` middleware.\n             *\n             * @param name\n             * @param defaultValue",
        "* Check if the incoming request contains the \"Content-Type\"\n             * header field, and it contains the give mime `type`.\n             *\n             * Examples:\n             *\n             *      // With Content-Type: text/html; charset=utf-8\n             *      req.is('html');\n             *      req.is('text/html');\n             *      req.is('text/*');\n             *      // => true\n             *\n             *      // When Content-Type is application/json\n             *      req.is('json');\n             *      req.is('application/json');\n             *      req.is('application/*');\n             *      // => true\n             *\n             *      req.is('html');\n             *      // => false\n             *\n             * @param type",
        "* Return the protocol string \"http\" or \"https\"\n             * when requested with TLS. When the \"trust proxy\"\n             * setting is enabled the \"X-Forwarded-Proto\" header\n             * field will be trusted. If you're running behind\n             * a reverse proxy that supplies https for you this\n             * may be enabled.",
        "* Short-hand for:\n             *\n             *    req.protocol == 'https'",
        "* Return the remote address, or when\n             * \"trust proxy\" is `true` return\n             * the upstream addr.",
        "* When \"trust proxy\" is `true`, parse\n             * the \"X-Forwarded-For\" ip address list.\n             *\n             * For example if the value were \"client, proxy1, proxy2\"\n             * you would receive the array `[\"client\", \"proxy1\", \"proxy2\"]`\n             * where \"proxy2\" is the furthest down-stream.",
        "* Return basic auth credentials.\n             *\n             * Examples:\n             *\n             *    // http://tobi:hello@example.com\n             *    req.auth\n             *    // => { username: 'tobi', password: 'hello' }",
        "* Return subdomains as an array.\n             *\n             * Subdomains are the dot-separated parts of the host before the main domain of\n             * the app. By default, the domain of the app is assumed to be the last two\n             * parts of the host. This can be changed by setting \"subdomain offset\".\n             *\n             * For example, if the domain is \"tobi.ferrets.example.com\":\n             * If \"subdomain offset\" is not set, req.subdomains is `[\"ferrets\", \"tobi\"]`.\n             * If \"subdomain offset\" is 3, req.subdomains is `[\"tobi\"]`.",
        "* Short-hand for `url.parse(req.url).pathname`.",
        "* Parse the \"Host\" header field hostname.",
        "* Check if the request is fresh, aka\n             * Last-Modified and/or the ETag\n             * still match.",
        "* Check if the request is stale, aka\n             * \"Last-Modified\" and / or the \"ETag\" for the\n             * resource has changed.",
        "* Check if the request was an _XMLHttpRequest_.",
        "* Used to generate an anti-CSRF token.\n             * Placed by the CSRF protection middleware.",
        "* Clear cookie `name`.\n             *\n             * @param name\n             * @param options",
        "* Set status `code`.\n             *\n             * @param code",
        "* Set Link header field with the given `links`.\n             *\n             * Examples:\n             *\n             *    res.links({\n             *      next: 'http://api.example.com/users?page=2',\n             *      last: 'http://api.example.com/users?page=5'\n             *    });\n             *\n             * @param links",
        "* Send a response.\n             *\n             * Examples:\n             *\n             *     res.send(new Buffer('wahoo'));\n             *     res.send({ some: 'json' });\n             *     res.send('<p>some html</p>');\n             *     res.send(404, 'Sorry, cant find that');\n             *     res.send(404);",
        "* Send JSON response.\n             *\n             * Examples:\n             *\n             *     res.json(null);\n             *     res.json({ user: 'tj' });\n             *     res.json(500, 'oh noes!');\n             *     res.json(404, 'I dont have that');",
        "* Send JSON response with JSONP callback support.\n             *\n             * Examples:\n             *\n             *     res.jsonp(null);\n             *     res.jsonp({ user: 'tj' });\n             *     res.jsonp(500, 'oh noes!');\n             *     res.jsonp(404, 'I dont have that');",
        "* Transfer the file at the given `path`.\n             *\n             * Automatically sets the _Content-Type_ response header field.\n             * The callback `fn(err)` is invoked when the transfer is complete\n             * or when an error occurs. Be sure to check `res.sentHeader`\n             * if you wish to attempt responding, as the header and some data\n             * may have already been transferred.\n             *\n             * Options:\n             *\n             *   - `maxAge` defaulting to 0\n             *   - `root`   root directory for relative filenames\n             *\n             * Examples:\n             *\n             *  The following example illustrates how `res.sendfile()` may\n             *  be used as an alternative for the `static()` middleware for\n             *  dynamic situations. The code backing `res.sendfile()` is actually\n             *  the same code, so HTTP cache support etc is identical.\n             *\n             *     app.get('/user/:uid/photos/:file', function(req, res){\n             *       var uid = req.params.uid\n             *         , file = req.params.file;\n             *\n             *       req.user.mayViewFilesFrom(uid, function(yes){\n             *         if (yes) {\n             *           res.sendfile('/uploads/' + uid + '/' + file);\n             *         } else {\n             *           res.send(403, 'Sorry! you cant see that.');\n             *         }\n             *       });\n             *     });",
        "* Transfer the file at the given `path` as an attachment.\n             *\n             * Optionally providing an alternate attachment `filename`,\n             * and optional callback `fn(err)`. The callback is invoked\n             * when the data transfer is complete, or when an error has\n             * ocurred. Be sure to check `res.headerSent` if you plan to respond.\n             *\n             * This method uses `res.sendfile()`.",
        "* Set _Content-Type_ response header with `type` through `mime.lookup()`\n             * when it does not contain \"/\", or set the Content-Type to `type` otherwise.\n             *\n             * Examples:\n             *\n             *     res.type('.html');\n             *     res.type('html');\n             *     res.type('json');\n             *     res.type('application/json');\n             *     res.type('png');\n             *\n             * @param type",
        "* Set _Content-Type_ response header with `type` through `mime.lookup()`\n             * when it does not contain \"/\", or set the Content-Type to `type` otherwise.\n             *\n             * Examples:\n             *\n             *     res.type('.html');\n             *     res.type('html');\n             *     res.type('json');\n             *     res.type('application/json');\n             *     res.type('png');\n             *\n             * @param type",
        "* Respond to the Acceptable formats using an `obj`\n             * of mime-type callbacks.\n             *\n             * This method uses `req.accepted`, an array of\n             * acceptable types ordered by their quality values.\n             * When \"Accept\" is not present the _first_ callback\n             * is invoked, otherwise the first match is used. When\n             * no match is performed the server responds with\n             * 406 \"Not Acceptable\".\n             *\n             * Content-Type is set for you, however if you choose\n             * you may alter this within the callback using `res.type()`\n             * or `res.set('Content-Type', ...)`.\n             *\n             *    res.format({\n             *      'text/plain': function(){\n             *        res.send('hey');\n             *      },\n             *\n             *      'text/html': function(){\n             *        res.send('<p>hey</p>');\n             *      },\n             *\n             *      'appliation/json': function(){\n             *        res.send({ message: 'hey' });\n             *      }\n             *    });\n             *\n             * In addition to canonicalized MIME types you may\n             * also use extnames mapped to these types:\n             *\n             *    res.format({\n             *      text: function(){\n             *        res.send('hey');\n             *      },\n             *\n             *      html: function(){\n             *        res.send('<p>hey</p>');\n             *      },\n             *\n             *      json: function(){\n             *        res.send({ message: 'hey' });\n             *      }\n             *    });\n             *\n             * By default Express passes an `Error`\n             * with a `.status` of 406 to `next(err)`\n             * if a match is not made. If you provide\n             * a `.default` callback it will be invoked\n             * instead.\n             *\n             * @param obj",
        "* Set _Content-Disposition_ header to _attachment_ with optional `filename`.\n             *\n             * @param filename",
        "* Set header `field` to `val`, or pass\n             * an object of header fields.\n             *\n             * Examples:\n             *\n             *    res.set('Foo', ['bar', 'baz']);\n             *    res.set('Accept', 'application/json');\n             *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });\n             *\n             * Aliased as `res.header()`.",
        "* Get value for header `field`.\n             *\n             * @param field",
        "* Clear cookie `name`.\n             *\n             * @param name\n             * @param options",
        "* Set cookie `name` to `val`, with the given `options`.\n             *\n             * Options:\n             *\n             *    - `maxAge`   max-age in milliseconds, converted to `expires`\n             *    - `signed`   sign the cookie\n             *    - `path`     defaults to \"/\"\n             *\n             * Examples:\n             *\n             *    // \"Remember Me\" for 15 minutes\n             *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n             *\n             *    // save as above\n             *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })",
        "* Set the location header to `url`.\n             *\n             * The given `url` can also be the name of a mapped url, for\n             * example by default express supports \"back\" which redirects\n             * to the _Referrer_ or _Referer_ headers or \"/\".\n             *\n             * Examples:\n             *\n             *    res.location('/foo/bar').;\n             *    res.location('http://example.com');\n             *    res.location('../login'); // /blog/post/1 -> /blog/login\n             *\n             * Mounting:\n             *\n             *   When an application is mounted and `res.location()`\n             *   is given a path that does _not_ lead with \"/\" it becomes\n             *   relative to the mount-point. For example if the application\n             *   is mounted at \"/blog\", the following would become \"/blog/login\".\n             *\n             *      res.location('login');\n             *\n             *   While the leading slash would result in a location of \"/login\":\n             *\n             *      res.location('/login');\n             *\n             * @param url",
        "* Redirect to the given `url` with optional response `status`\n             * defaulting to 302.\n             *\n             * The resulting `url` is determined by `res.location()`, so\n             * it will play nicely with mounted apps, relative paths,\n             * `\"back\"` etc.\n             *\n             * Examples:\n             *\n             *    res.redirect('/foo/bar');\n             *    res.redirect('http://example.com');\n             *    res.redirect(301, 'http://example.com');\n             *    res.redirect('http://example.com', 301);\n             *    res.redirect('../login'); // /blog/post/1 -> /blog/login",
        "* Render `view` with the given `options` and optional callback `fn`.\n             * When a callback function is given a response will _not_ be made\n             * automatically, otherwise a response of _200_ and _text/html_ is given.\n             *\n             * Options:\n             *\n             *  - `cache`     boolean hinting to the engine it should cache\n             *  - `filename`  filename of the view being rendered",
        "* Initialize the server.\n             *\n             *   - setup default configuration\n             *   - setup default middleware\n             *   - setup route reflection methods",
        "* Initialize application configuration.",
        "* Proxy `connect#use()` to apply settings to\n             * mounted applications.\n            *",
        "* Register the given template engine callback `fn`\n             * as `ext`.\n             *\n             * By default will `require()` the engine based on the\n             * file extension. For example if you try to render\n             * a \"foo.jade\" file Express will invoke the following internally:\n             *\n             *     app.engine('jade', require('jade').__express);\n             *\n             * For engines that do not provide `.__express` out of the box,\n             * or if you wish to \"map\" a different extension to the template engine\n             * you may use this method. For example mapping the EJS template engine to\n             * \".html\" files:\n             *\n             *     app.engine('html', require('ejs').renderFile);\n             *\n             * In this case EJS provides a `.renderFile()` method with\n             * the same signature that Express expects: `(path, options, callback)`,\n             * though note that it aliases this method as `ejs.__express` internally\n             * so if you're using \".ejs\" extensions you dont need to do anything.\n             *\n             * Some template engines do not follow this convention, the\n             * [Consolidate.js](https://github.com/visionmedia/consolidate.js)\n             * library was created to map all of node's popular template\n             * engines to follow this convention, thus allowing them to\n             * work seamlessly within Express.",
        "* Assign `setting` to `val`, or return `setting`'s value.\n             *\n             *    app.set('foo', 'bar');\n             *    app.get('foo');\n             *    // => \"bar\"\n             *\n             * Mounted servers inherit their parent server's settings.\n             *\n             * @param setting\n             * @param val",
        "* Return the app's absolute pathname\n             * based on the parent(s) that have\n             * mounted it.\n             *\n             * For example if the application was\n             * mounted as \"/admin\", which itself\n             * was mounted as \"/blog\" then the\n             * return value would be \"/blog/admin\".",
        "* Check if `setting` is enabled (truthy).\n             *\n             *    app.enabled('foo')\n             *    // => false\n             *\n             *    app.enable('foo')\n             *    app.enabled('foo')\n             *    // => true",
        "* Check if `setting` is disabled.\n             *\n             *    app.disabled('foo')\n             *    // => true\n             *\n             *    app.enable('foo')\n             *    app.disabled('foo')\n             *    // => false\n             *\n             * @param setting",
        "* Enable `setting`.\n             *\n             * @param setting",
        "* Disable `setting`.\n             *\n             * @param setting",
        "* Configure callback for zero or more envs,\n             * when no `env` is specified that callback will\n             * be invoked for all environments. Any combination\n             * can be used multiple times, in any order desired.\n             *\n             * Examples:\n             *\n             *    app.configure(function(){\n             *      // executed for all envs\n             *    });\n             *\n             *    app.configure('stage', function(){\n             *      // executed staging env\n             *    });\n             *\n             *    app.configure('stage', 'production', function(){\n             *      // executed for stage and production\n             *    });\n             *\n             * Note:\n             *\n             *  These callbacks are invoked immediately, and\n             *  are effectively sugar for the following:\n             *\n             *     var env = process.env.NODE_ENV || 'development';\n             *\n             *      switch (env) {\n             *        case 'development':\n             *          ...\n             *          break;\n             *        case 'stage':\n             *          ...\n             *          break;\n             *        case 'production':\n             *          ...\n             *          break;\n             *      }\n             *\n             * @param env\n             * @param fn",
        "* Render the given view `name` name with `options`\n             * and a callback accepting an error and the\n             * rendered template string.\n             *\n             * Example:\n             *\n             *    app.render('email', { name: 'Tobi' }, function(err, html){\n             *      // ...\n             *    })\n             *\n             * @param name\n             * @param options or fn\n             * @param fn",
        "* Listen for connections.\n             *\n             * A node `http.Server` is returned, with this\n             * application (which is a `Function`) as its\n             * callback. If you wish to create both an HTTP\n             * and HTTPS server you may do so with the \"http\"\n             * and \"https\" modules as shown here:\n             *\n             *    var http = require('http')\n             *      , https = require('https')\n             *      , express = require('express')\n             *      , app = express();\n             *\n             *    http.createServer(app).listen(80);\n             *    https.createServer({ ... }, app).listen(443);",
        "* The app.routes object houses all of the routes defined mapped by the\n             * associated HTTP verb. This object may be used for introspection\n             * capabilities, for example Express uses this internally not only for\n             * routing but to provide default OPTIONS behaviour unless app.options()\n             * is used. Your application or framework may also remove routes by\n             * simply by removing them from this object.",
        "* Framework version.",
        "* Expose mime.",
        "* Create an express application.",
        "* Body parser:\n         * \n         *   Parse request bodies, supports _application/json_,\n         *   _application/x-www-form-urlencoded_, and _multipart/form-data_.\n         *\n         *   This is equivalent to: \n         *\n         *     app.use(connect.json());\n         *     app.use(connect.urlencoded());\n         *     app.use(connect.multipart());\n         *\n         * Examples:\n         *\n         *      connect()\n         *        .use(connect.bodyParser())\n         *        .use(function(req, res) {\n         *          res.end('viewing user ' + req.body.user.name);\n         *        });\n         *\n         *      $ curl -d 'user[name]=tj' http://local/\n         *      $ curl -d '{\"user\":{\"name\":\"tj\"}}' -H \"Content-Type: application/json\" http://local/\n         *\n         *  View [json](json.html), [urlencoded](urlencoded.html), and [multipart](multipart.html) for more info.\n         *\n         * @param options",
        "* Error handler:\n         *\n         * Development error handler, providing stack traces\n         * and error message responses for requests accepting text, html,\n         * or json.\n         *\n         * Text:\n         *\n         *   By default, and when _text/plain_ is accepted a simple stack trace\n         *   or error message will be returned.\n         *\n         * JSON:\n         *\n         *   When _application/json_ is accepted, connect will respond with\n         *   an object in the form of `{ \"error\": error }`.\n         *\n         * HTML:\n         *\n         *   When accepted connect will output a nice html stack trace.",
        "* Method Override:\n         * \n         * Provides faux HTTP method support.\n         * \n         * Pass an optional `key` to use when checking for\n         * a method override, othewise defaults to _\\_method_.\n         * The original method is available via `req.originalMethod`.\n         *\n         * @param key",
        "* Cookie parser:\n         *\n         * Parse _Cookie_ header and populate `req.cookies`\n         * with an object keyed by the cookie names. Optionally\n         * you may enabled signed cookie support by passing\n         * a `secret` string, which assigns `req.secret` so\n         * it may be used by other middleware.\n         *\n         * Examples:\n         *\n         *     connect()\n         *       .use(connect.cookieParser('optional secret string'))\n         *       .use(function(req, res, next){\n         *         res.end(JSON.stringify(req.cookies));\n         *       })\n         *\n         * @param secret",
        "* Session:\n         * \n         *   Setup session store with the given `options`.\n         *\n         *   Session data is _not_ saved in the cookie itself, however\n         *   cookies are used, so we must use the [cookieParser()](cookieParser.html)\n         *   middleware _before_ `session()`.\n         *\n         * Examples:\n         *\n         *     connect()\n         *       .use(connect.cookieParser())\n         *       .use(connect.session({ secret: 'keyboard cat', key: 'sid', cookie: { secure: true }}))\n         *\n         * Options:\n         *\n         *   - `key` cookie name defaulting to `connect.sid`\n         *   - `store` session store instance\n         *   - `secret` session cookie is signed with this secret to prevent tampering\n         *   - `cookie` session cookie settings, defaulting to `{ path: '/', httpOnly: true, maxAge: null }`\n         *   - `proxy` trust the reverse proxy when setting secure cookies (via \"x-forwarded-proto\")\n         *\n         * Cookie option:\n         *\n         *  By default `cookie.maxAge` is `null`, meaning no \"expires\" parameter is set\n         *  so the cookie becomes a browser-session cookie. When the user closes the \n         *  browser the cookie (and session) will be removed.\n         *\n         * ## req.session\n         *\n         *  To store or access session data, simply use the request property `req.session`,\n         *  which is (generally) serialized as JSON by the store, so nested objects \n         *  are typically fine. For example below is a user-specific view counter:\n         *\n         *       connect()\n         *         .use(connect.favicon())\n         *         .use(connect.cookieParser())\n         *         .use(connect.session({ secret: 'keyboard cat', cookie: { maxAge: 60000 }}))\n         *         .use(function(req, res, next){\n         *           var sess = req.session;\n         *           if (sess.views) {\n         *             res.setHeader('Content-Type', 'text/html');\n         *             res.write('<p>views: ' + sess.views + '</p>');\n         *             res.write('<p>expires in: ' + (sess.cookie.maxAge / 1000) + 's</p>');\n         *             res.end();\n         *             sess.views++;\n         *           } else {\n         *             sess.views = 1;\n         *             res.end('welcome to the session demo. refresh!');\n         *           }\n         *         }\n         *       )).listen(3000);\n         *\n         * ## Session#regenerate()\n         *\n         *  To regenerate the session simply invoke the method, once complete\n         *  a new SID and `Session` instance will be initialized at `req.session`.\n         *\n         *      req.session.regenerate(function(err){\n         *        // will have a new session here\n         *      });\n         *\n         * ## Session#destroy()\n         *\n         *  Destroys the session, removing `req.session`, will be re-generated next request.\n         *\n         *      req.session.destroy(function(err){\n         *        // cannot access session here\n         *      });\n         * \n         * ## Session#reload()\n         *\n         *  Reloads the session data.\n         *\n         *      req.session.reload(function(err){\n         *        // session updated\n         *      });\n         *\n         * ## Session#save()\n         *\n         *  Save the session.\n         *\n         *      req.session.save(function(err){\n         *        // session saved\n         *      });\n         *\n         * ## Session#touch()\n         *\n         *   Updates the `.maxAge` property. Typically this is\n         *   not necessary to call, as the session middleware does this for you.\n         *\n         * ## Session#cookie\n         *\n         *  Each session has a unique cookie object accompany it. This allows\n         *  you to alter the session cookie per visitor. For example we can\n         *  set `req.session.cookie.expires` to `false` to enable the cookie\n         *  to remain for only the duration of the user-agent.\n         *\n         * ## Session#maxAge\n         *\n         *  Alternatively `req.session.cookie.maxAge` will return the time\n         *  remaining in milliseconds, which we may also re-assign a new value\n         *  to adjust the `.expires` property appropriately. The following\n         *  are essentially equivalent\n         *\n         *     var hour = 3600000;\n         *     req.session.cookie.expires = new Date(Date.now() + hour);\n         *     req.session.cookie.maxAge = hour;\n         *\n         * For example when `maxAge` is set to `60000` (one minute), and 30 seconds\n         * has elapsed it will return `30000` until the current request has completed,\n         * at which time `req.session.touch()` is called to reset `req.session.maxAge`\n         * to its original value.\n         *\n         *     req.session.cookie.maxAge;\n         *     // => 30000\n         *\n         * Session Store Implementation:\n         *\n         * Every session store _must_ implement the following methods\n         *\n         *    - `.get(sid, callback)`\n         *    - `.set(sid, session, callback)`\n         *    - `.destroy(sid, callback)`\n         *\n         * Recommended methods include, but are not limited to:\n         *\n         *    - `.length(callback)`\n         *    - `.clear(callback)`\n         *\n         * For an example implementation view the [connect-redis](http://github.com/visionmedia/connect-redis) repo.\n         *\n         * @param options",
        "* Hash the given `sess` object omitting changes\n         * to `.cookie`.\n         *\n         * @param sess",
        "* Static:\n         *\n         *   Static file server with the given `root` path.\n         *\n         * Examples:\n         *\n         *     var oneDay = 86400000;\n         *\n         *     connect()\n         *       .use(connect.static(__dirname + '/public'))\n         *\n         *     connect()\n         *       .use(connect.static(__dirname + '/public', { maxAge: oneDay }))\n         *\n         * Options:\n         *\n         *    - `maxAge`     Browser cache maxAge in milliseconds. defaults to 0\n         *    - `hidden`     Allow transfer of hidden files. defaults to false\n         *    - `redirect`   Redirect to trailing \"/\" when the pathname is a dir. defaults to true\n         *\n         * @param root\n         * @param options",
        "* Basic Auth:\n         *\n         * Enfore basic authentication by providing a `callback(user, pass)`,\n         * which must return `true` in order to gain access. Alternatively an async\n         * method is provided as well, invoking `callback(user, pass, callback)`. Populates\n         * `req.user`. The final alternative is simply passing username / password\n         * strings.\n         *\n         *  Simple username and password\n         *\n         *     connect(connect.basicAuth('username', 'password'));\n         *\n         *  Callback verification\n         *\n         *     connect()\n         *       .use(connect.basicAuth(function(user, pass){\n         *         return 'tj' == user & 'wahoo' == pass;\n         *       }))\n         *\n         *  Async callback verification, accepting `fn(err, user)`.\n         *\n         *     connect()\n         *       .use(connect.basicAuth(function(user, pass, fn){\n         *         User.authenticate({ user: user, pass: pass }, fn);\n         *       }))\n         *\n         * @param callback or username\n         * @param realm",
        "* Compress:\n         *\n         * Compress response data with gzip/deflate.\n         *\n         * Filter:\n         *\n         *  A `filter` callback function may be passed to\n         *  replace the default logic of:\n         *\n         *     exports.filter = function(req, res){\n         *       return /json|text|javascript/.test(res.getHeader('Content-Type'));\n         *     };\n         *\n         * Options:\n         *\n         *  All remaining options are passed to the gzip/deflate\n         *  creation functions. Consult node's docs for additional details.\n         *\n         *   - `chunkSize` (default: 16*1024)\n         *   - `windowBits`\n         *   - `level`: 0-9 where 0 is no compression, and 9 is slow but best compression\n         *   - `memLevel`: 1-9 low is slower but uses less memory, high is fast but uses more\n         *   - `strategy`: compression strategy\n         *\n         * @param options",
        "* Cookie Session:\n         *\n         *   Cookie session middleware.\n         *\n         *      var app = connect();\n         *      app.use(connect.cookieParser());\n         *      app.use(connect.cookieSession({ secret: 'tobo!', cookie: { maxAge: 60 * 60 * 1000 }}));\n         *\n         * Options:\n         *\n         *   - `key` cookie name defaulting to `connect.sess`\n         *   - `secret` prevents cookie tampering\n         *   - `cookie` session cookie settings, defaulting to `{ path: '/', httpOnly: true, maxAge: null }`\n         *   - `proxy` trust the reverse proxy when setting secure cookies (via \"x-forwarded-proto\")\n         *\n         * Clearing sessions:\n         *\n         *  To clear the session simply set its value to `null`,\n         *  `cookieSession()` will then respond with a 1970 Set-Cookie.\n         *\n         *     req.session = null;\n         *\n         * @param options",
        "* Anti CSRF:\n         *\n         * CSRF protection middleware.\n         *\n         * This middleware adds a `req.csrfToken()` function to make a token\n         * which should be added to requests which mutate\n         * state, within a hidden form field, query-string etc. This\n         * token is validated against the visitor's session.\n         *\n         * The default `value` function checks `req.body` generated\n         * by the `bodyParser()` middleware, `req.query` generated\n         * by `query()`, and the \"X-CSRF-Token\" header field.\n         *\n         * This middleware requires session support, thus should be added\n         * somewhere _below_ `session()` and `cookieParser()`.\n         *\n         * Options:\n         *\n         *    - `value` a function accepting the request, returning the token\n         *\n         * @param options",
        "* Directory:\n         *\n         * Serve directory listings with the given `root` path.\n         *\n         * Options:\n         *\n         *  - `hidden` display hidden (dot) files. Defaults to false.\n         *  - `icons`  display icons. Defaults to false.\n         *  - `filter` Apply this filter function to files. Defaults to false.\n         *\n         * @param root\n         * @param options",
        "* Favicon:\n         *\n         * By default serves the connect favicon, or the favicon\n         * located by the given `path`.\n         *\n         * Options:\n         *\n         *   - `maxAge`  cache-control max-age directive, defaulting to 1 day\n         *\n         * Examples:\n         *\n         *   Serve default favicon:\n         *\n         *     connect()\n         *       .use(connect.favicon())\n         *\n         *   Serve favicon before logging for brevity:\n         *\n         *     connect()\n         *       .use(connect.favicon())\n         *       .use(connect.logger('dev'))\n         *\n         *   Serve custom favicon:\n         *\n         *     connect()\n         *       .use(connect.favicon('public/favicon.ico))\n         *\n         * @param path\n         * @param options",
        "* JSON:\n         *\n         * Parse JSON request bodies, providing the\n         * parsed object as `req.body`.\n         *\n         * Options:\n         *\n         *   - `strict`  when `false` anything `JSON.parse()` accepts will be parsed\n         *   - `reviver`  used as the second \"reviver\" argument for JSON.parse\n         *   - `limit`  byte limit disabled by default\n         *\n         * @param options",
        "* Limit:\n         *\n         *   Limit request bodies to the given size in `bytes`.\n         *\n         *   A string representation of the bytesize may also be passed,\n         *   for example \"5mb\", \"200kb\", \"1gb\", etc.\n         *\n         *     connect()\n         *       .use(connect.limit('5.5mb'))\n         *       .use(handleImageUpload)",
        "* Logger:\n         *\n         * Log requests with the given `options` or a `format` string.\n         *\n         * Options:\n         *\n         *   - `format`  Format string, see below for tokens\n         *   - `stream`  Output stream, defaults to _stdout_\n         *   - `buffer`  Buffer duration, defaults to 1000ms when _true_\n         *   - `immediate`  Write log line on request instead of response (for response times)\n         *\n         * Tokens:\n         *\n         *   - `:req[header]` ex: `:req[Accept]`\n         *   - `:res[header]` ex: `:res[Content-Length]`\n         *   - `:http-version`\n         *   - `:response-time`\n         *   - `:remote-addr`\n         *   - `:date`\n         *   - `:method`\n         *   - `:url`\n         *   - `:referrer`\n         *   - `:user-agent`\n         *   - `:status`\n         *\n         * Formats:\n         *\n         *   Pre-defined formats that ship with connect:\n         *\n         *    - `default` ':remote-addr - - [:date] \":method :url HTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\"'\n         *    - `short` ':remote-addr - :method :url HTTP/:http-version :status :res[content-length] - :response-time ms'\n         *    - `tiny`  ':method :url :status :res[content-length] - :response-time ms'\n         *    - `dev` concise output colored by response status for development use\n         *\n         * Examples:\n         *\n         *      connect.logger() // default\n         *      connect.logger('short')\n         *      connect.logger('tiny')\n         *      connect.logger({ immediate: true, format: 'dev' })\n         *      connect.logger(':method :url - :referrer')\n         *      connect.logger(':req[content-type] -> :res[content-type]')\n         *      connect.logger(function(tokens, req, res){ return 'some format string' })\n         *\n         * Defining Tokens:\n         *\n         *   To define a token, simply invoke `connect.logger.token()` with the\n         *   name and a callback function. The value returned is then available\n         *   as \":type\" in this case.\n         *\n         *      connect.logger.token('type', function(req, res){ return req.headers['content-type']; })\n         *\n         * Defining Formats:\n         *\n         *   All default formats are defined this way, however it's public API as well:\n         *\n         *       connect.logger.format('name', 'string or function')",
        "* Compile `fmt` into a function.\n         *\n         * @param fmt",
        "* Define a token function with the given `name`,\n         * and callback `fn(req, res)`.\n         *\n         * @param name\n         * @param fn",
        "* Define a `fmt` with the given `name`.",
        "* Query:\n         *\n         * Automatically parse the query-string when available,\n         * populating the `req.query` object.\n         *\n         * Examples:\n         *\n         *     connect()\n         *       .use(connect.query())\n         *       .use(function(req, res){\n         *         res.end(JSON.stringify(req.query));\n         *       });\n         *\n         *  The `options` passed are provided to qs.parse function.",
        "* Reponse time:\n         *\n         * Adds the `X-Response-Time` header displaying the response\n         * duration in milliseconds.",
        "* Static cache:\n         *\n         * Enables a memory cache layer on top of\n         * the `static()` middleware, serving popular\n         * static files.\n         *\n         * By default a maximum of 128 objects are\n         * held in cache, with a max of 256k each,\n         * totalling ~32mb.\n         *\n         * A Least-Recently-Used (LRU) cache algo\n         * is implemented through the `Cache` object,\n         * simply rotating cache objects as they are\n         * hit. This means that increasingly popular\n         * objects maintain their positions while\n         * others get shoved out of the stack and\n         * garbage collected.\n         *\n         * Benchmarks:\n         *\n         *     static(): 2700 rps\n         *     node-static: 5300 rps\n         *     static() + staticCache(): 7500 rps\n         *\n         * Options:\n         *\n         *   - `maxObjects`  max cache objects [128]\n         *   - `maxLength`  max cache object length 256kb",
        "* Timeout:\n         *\n         * Times out the request in `ms`, defaulting to `5000`. The\n         * method `req.clearTimeout()` is added to revert this behaviour\n         * programmatically within your application's middleware, routes, etc.\n         *\n         * The timeout error is passed to `next()` so that you may customize\n         * the response behaviour. This error has the `.timeout` property as\n         * well as `.status == 408`.",
        "* Vhost:\n         * \n         *   Setup vhost for the given `hostname` and `server`.\n         *\n         *     connect()\n         *       .use(connect.vhost('foo.com', fooApp))\n         *       .use(connect.vhost('bar.com', barApp))\n         *       .use(connect.vhost('*.com', mainApp))\n         *\n         *  The `server` may be a Connect server or\n         *  a regular Node `http.Server`. \n         *\n         * @param hostname\n         * @param server"
    ],
    "functions": [],
    "classes": [
        "Route",
        "Router"
    ]
}