{
    "identifiers": [
        "quiny",
        "java",
        "lang",
        "reflect",
        "java",
        "util",
        "java",
        "util",
        "Collection",
        "java",
        "util",
        "java",
        "util",
        "Iterator",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "BinaryOperator",
        "java",
        "util",
        "Consumer",
        "java",
        "util",
        "java",
        "util",
        "IntFunction",
        "java",
        "util",
        "Predicate",
        "data",
        "action",
        "mapper",
        "maxSize",
        "p",
        "generator"
    ],
    "literals": [],
    "variables": [],
    "comments": [],
    "docstrings": [
        "* Copyright (c) 2016, Miguel Gamboa\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.",
        "* <p>\n * {@code Queryable<T>} is a concise and functional implementation\n * of an equivalent API to the {@link java.util.stream.Stream}, which\n * preserves the internal iteration approach, the laziness behavior\n * and the fluent idiom.\n * This solution answers the question: How can I implement a lazy iterator\n * in Java 8?\n * </p>\n *\n * <p>\n * To achieve a short implementation, the {@code Queryable<T>} suppressed\n * the partitioning feature, which means that {@code Queryable<T>} does NOT\n * support parallel processing.\n * </p>\n *\n * <p>\n * The following example illustrates a use case of {@code Queryable<T>}\n * that is equivalent to the use of {@link java.util.stream.Stream}.\n * You can replace the {@code Queryable.of(dataSrc)} call with {@code\n * dataSrc.stream()} and you will get the same result.\n * </p>\n *\n * <pre>{@code\n *     Collection<String> dataSrc = ...  // something\n *     Queryable.of(dataSrc)             // <=> dataSrc.stream()\n *         .filter(w -> !w.startsWith(\"-\"))\n *         .distinct()\n *         .map(String::length)\n *         .limit(5)\n *         .forEach(System.out::println);\n * }</pre>\n *\n * @author Miguel Gamboa\n *         created on 21-04-2016"
    ],
    "functions": [
        "of",
        "forEach",
        "limit",
        "distinct",
        "toArray"
    ],
    "classes": [
        "Queryable"
    ]
}