{
    "identifiers": [
        "width",
        "height",
        "d",
        "w",
        "h",
        "x",
        "y",
        "w",
        "h",
        "x",
        "y",
        "w",
        "h",
        "r",
        "x",
        "y",
        "w",
        "h",
        "w",
        "h",
        "x",
        "y",
        "r",
        "x",
        "y",
        "x",
        "original",
        "original",
        "layout",
        "ctx",
        "x",
        "y",
        "w",
        "h",
        "w",
        "h",
        "w",
        "h",
        "x",
        "y",
        "w",
        "h",
        "layoutInfo",
        "children",
        "e",
        "constraint",
        "d",
        "BaseLayout",
        "e",
        "e",
        "e",
        "e",
        "e",
        "layoutInfo",
        "e",
        "constraint",
        "BaseLayout",
        "layoutInfo",
        "BaseLayout",
        "layout"
    ],
    "literals": [
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string"
    ],
    "variables": [],
    "comments": [],
    "docstrings": [
        "* License: see license.txt file.",
        "* Point x coordinate.\n     * @member Point#x\n     * @type {number}",
        "* Point y coordinate.\n     * @member Point#y\n     * @type {number}",
        "* @interface BaseLayoutInitializer\n * @classdesc\n *\n * Initializer object for a common layout.\n *",
        "* type of the layout, currently: 'element', 'border', 'grid'\n     * @member BaseLayoutInitializer#type\n     * @type {string}",
        "* Layout element name\n     * @member BaseLayoutInitializer#name\n     * @type {string=}",
        "* Preferred width. Has Unit notation, so values like '10px' or '20%' are valid.\n     * @member BaseLayoutInitializer#preferredWidth\n     * @type {string=}",
        "* Preferred height. Has Unit notation, so values like '10px' or '20%' are valid.\n     * @member BaseLayoutInitializer#preferredHeight\n     * @type {string=}",
        "* Element insets.\n     * An array of four strings representing insets for: left, top, right, bottom respectively.\n     * Unit notation.\n     * @member BaseLayoutInitializer#insets\n     * @type {Array<string>=}",
        "* Element gap.\n     * An array of two strings representing element separation for horizontal and vertical respectively.\n     * Unit notation.\n     * @member BaseLayoutInitializer#gap\n     * @type {Array<string>=}",
        "* Array of other layout initializer objects.\n     * @member BaseLayoutInitializer#elements\n     * @type {Array<BaseLayoutInitializer>} any layout initializer.",
        "* @interface GridLayoutInitializer\n * @extends BaseLayoutInitializer\n * @classdesc\n *\n * Initializer object for a grid layout\n *",
        "* Set the grid to grow in columns every number of rows.\n     * @member GridLayoutInitializer#rows\n     * @type {number=}",
        "* Set the grid to grow in rows every number of columns.\n     * @member GridLayoutInitializer#columns\n     * @type {number=}",
        "* @interface BorderLayoutInitializer\n * @extends BaseLayoutInitializer\n * @classdesc\n *\n * Initializer for a border layout",
        "* Left element initializer.\n     * @member BorderLayoutInitializer#left\n     * @type {BaseLayoutInitializer=}",
        "* Right element initializer.\n     * @member BorderLayoutInitializer#right\n     * @type {BaseLayoutInitializer=}",
        "* Top element initializer.\n     * @member BorderLayoutInitializer#top\n     * @type {BaseLayoutInitializer=}",
        "* Bottom element initializer.\n     * @member BorderLayoutInitializer#bottom\n     * @type {BaseLayoutInitializer=}",
        "* Center element initializer.\n     * @member BorderLayoutInitializer#center\n     * @type {BaseLayoutInitializer=}",
        "* @class Unit\n * @classdesc\n *\n * This class encapsulates a value in a given unit.\n * Currently, it could be a number, or a percentage value.\n * If the value is a percentage, a call to <code>getValue</code> needs a reference value.",
        "* Unit value.\n     * @member Unit#_orgValue\n     * @type {number}\n     * @private",
        "* Unit type. Either px, %, or nothing.\n     * @member Unit#_orgType\n     * @type {string}\n     * @private",
        "* Create a new Unit object instance.\n     * @method Unit#constructor\n     * @param original {string=} Unit value. if not set, the unit it set to 0.",
        "* Set the unit value. For example '2%', '100px', '100'\n     * @method Unit#setValue\n     * @param original {string}",
        "* Get the unit value.\n     * If the unit type is percentage, and no reference value is supplied, zero will be returned as value.\n     * @method Unit#getValue\n     * @param ref {number=} percentage reference value.\n     * @returns {number}",
        "* @class Insets\n * @classdesc\n *\n * This class describes a layout element internal padding.\n * It is descibed as independent inset values for top, bottom, left and right.\n * These values are Unit objects, so can be described as percentage values. The relative values are relative to\n * the Layout element assigned dimension, so its calculation is deferred to the proper layout stage.",
        "* Layout element left inset Unit.\n     * @member Insets#left\n     * @type {Unit}",
        "* Layout element top inset Unit.\n     * @member Insets#top\n     * @type {Unit}",
        "* Layout element right inset Unit.\n     * @member Insets#right\n     * @type {Unit}",
        "* Layout element bottom inset Unit.\n     * @member Insets#bottom\n     * @type {Unit}",
        "* @class Gap\n * @classdesc\n *\n * This object describes the separation values between two adjacent layout elements.\n * For example, for a grid, describes the Units to separate the grid elements.",
        "* Horizontal gap Unit.\n     * @member Gap#horizontal\n     * @type {Unit}",
        "* Vertical gap Unit.\n     * @member Gap#vertical\n     * @type {Unit}",
        "* @class Layout\n * @classdesc\n *\n * This object is the base for all other layout objects.\n * The layout will assign bounds (position and size) for all the layout elements it contains.\n * Layouts will apply different space partitioning rules to conform elements to available space.\n * Layout elements can be nested. for example, a grid cell can contain another grid of elements.\n * <p>\n * Each layout element will have its bounds modified by an <code>Insets</code> object which will reduce the\n * available element bounds.\n * Some layout types, like <code>GridLayout</code> or <code>BorderLayout</code> will be able to apply a gap\n * to separate the contained elements.\n * <p>\n * A layout element can define a preferred size (either in units or percentage) to layout with. This value is\n * needed for layout types that don't impose a size constraint. For example, a GridLayout will set each element's\n * bounds with a fixed rule, that is, dividing the space evenly. But others, like a BorderLayout won't, so you\n * must hint how much space each element is expected to take.\n * <p>\n *     Layouts are defined declaratively and a Node or any other object, does not need to know anything about\n *     the layout itself.\n * <p>\n * The BaseLayout object assumes no children when laying out. Other extending objects will modify this behavior.",
        "* Resulting bounds after applying the layout rules.\n     * @member BaseLayout#_bounds\n     * @type {Rectangle}\n     * @private",
        "* The layout insets. Insets will reduce the bounds area by setting a padding for the element.\n     * @member BaseLayout#_insets\n     * @type {Insets}\n     * @private",
        "* Separation between each layout elements. Not all layout will use this value.\n     * @member BaseLayout#_gap\n     * @type {Gap}\n     * @private",
        "* Array of elements to lay out. Since layouts are nestable, children are layout instances as well.\n     * @member BaseLayout#_children\n     * @type {Array<BaseLayout>}\n     * @private",
        "* Layout preferred width Unit hint.\n     * @member BaseLayout#_preferredWidth\n     * @type {Unit}\n     * @private",
        "* Layout preferred height Unit hint.\n     * @member BaseLayout#_preferredHeight\n     * @type {Unit}\n     * @private",
        "* Optional layout identifier.\n     * This is useful so that a node tag or name can be matched against this layout element.\n     * @member BaseLayout#_name\n     * @type {string}\n     * @private",
        "* Create a new BaseLayout object instance.\n     * Do not create directly, only by subclasses.\n     * @method BaseLayout#constructor",
        "* Parse a layout initializer object to get a layout element object.\n     * @param layout {string|BaseLayoutInitializer} a layout initializer object, or a string.\n     *   If a string is set, a BaseLayout object will be used.",
        "* Helper method to visually see the layout result.\n     * @method BaseLayout#paint\n     * @param ctx {CanvasRenderingContext2D}",
        "* Set the layout bounds.\n     * @method BaseLayout#setBounds\n     * @param x {number}\n     * @param y {number}\n     * @param w {number}\n     * @param h {number}",
        "* Set the layout size.\n     * @method BaseLayout#setSize\n     * @param w {number}\n     * @param h {number}",
        "* Set the layout preferred size Unit hints.\n     * @param w {number|string}\n     * @param h {number|string}",
        "* Get the element preferredSize.\n     * The size units are evaluated, so if they are percentage, the value is recalculated now again.\n     * @method BaseLayout#getPreferredSize\n     * @returns {Dimension}",
        "* Recursively evaluate the layout elements and get the resulting preferred size.\n     * This does not take into account the size constraints, will get the desired size.\n     * In this object, the implementation returns the result of the preferredSize Unit hints + Insets.\n     * @method BaseLayout#getPreferredLayoutSize\n     * @returns {Dimension}",
        "* Evaluate the layout with the current size constraints. The root layout element bounds will be used\n     * as size constraint.\n     * @method BaseLayout#doLayout",
        "* Set size constraints and evaluate the layout.\n     * The result will be all layout elements have assigned a bounds.\n     * @method BaseLayout#layout\n     * @param x {number}\n     * @param y {number}\n     * @param w {number}\n     * @param h {number}",
        "* Parse a layout definition object.\n     * This will get all the common layout properties: insets, gap, preferred size and elements.\n     * @method BaseLayout#parse\n     * @param layoutInfo {BaseLayoutInitializer}\n     * @returns {BaseLayout}",
        "* Parse the elements block from the layout initializer object.\n     * @method BaseLayout#parseElements\n     * @param children {Array<object>}",
        "* Add an element layout to this layout object.\n     * @param e {BaseLayout}\n     * @param constraint {string=} a constraint to add an element. For example, BorderLayout requires a position hint\n     *      to add an element.",
        "* Helper method to add the Inset object value to a Dimension.\n     * @method BaseLayout#adjustWithInsets\n     * @param d",
        "* @class BorderLayout\n * @extends BaseLayout\n * @classdesc\n *\n * A BorderLayout object divides the available space in up to 5 different regions as follows:\n * <pre>\n *\n *     +----------------------------+\n *     |            TOP             |\n *     +------+-------------+-------+\n *     | LEFT |             | RIGHT |\n *     |      |             |       |\n *     |      |             |       |\n *     |      |   CENTER    |       |\n *     |      |             |       |\n *     |      |             |       |\n *     |      |             |       |\n *     +------+-------------+-------+\n *     |           BOTTOM           |\n *     +----------------------------+\n * </pre>\n *\n * <p>\n *     Since all bounds are dynamically calculated, elements added to a BorderLayout (at any nesting level) must\n *     have preferred size hints.\n * <p>\n *     The gap values will be empty filler values between every elements. Horizontal between left-center center-right\n *     and vertical betweeen top and bottom and all the others.\n * <p>\n *     All Elements are optional to define.\n * <p>\n *     The center element will get the remaining space after laying out all the other elements.\n *     The left, right and center elements will get the remaining height after evaluating top and then\n *     bottom elements.\n * <p>\n *     top, left, right, bottom and center can be, at the same time, other layouts.\n *",
        "* Left layout element.\n     * @member BorderLayout#_left\n     * @type {BaseLayout}\n     * @private",
        "* Right layout element.\n     * @member BorderLayout#_right\n     * @type {BaseLayout}\n     * @private",
        "* Top layout element.\n     * @member BorderLayout#_top\n     * @type {BaseLayout}\n     * @private",
        "* Bottom layout element.\n     * @member BorderLayout#_bottom\n     * @type {BaseLayout}\n     * @private",
        "* Center layout element.\n     * @member BorderLayout#_center\n     * @type {BaseLayout}\n     * @private",
        "* Build a new BorderLayout object instance\n     * @method BorderLayout#constructor",
        "* Get the preferred layout size after recursively applying the layout. The size will be the preferred size,\n     * not the actual size.\n     * @method BorderLayout#getPreferredLayoutSize\n     * @returns {Dimension}",
        "* Set the left layout element.\n     * @method BorderLayout#left\n     * @param e {BaseLayout}\n     * @returns {BorderLayout}",
        "* Set the right layout element.\n     * @method BorderLayout#right\n     * @param e {BaseLayout}\n     * @returns {BorderLayout}",
        "* Set the top layout element.\n     * @method BorderLayout#top\n     * @param e {BaseLayout}\n     * @returns {BorderLayout}",
        "* Set the bottom layout element.\n     * @method BorderLayout#bottom\n     * @param e {BaseLayout}\n     * @returns {BorderLayout}",
        "* Set the center layout element.\n     * @method BorderLayout#center\n     * @param e {BaseLayout}\n     * @returns {BorderLayout}",
        "* Parse the BorderLayout.\n     * @method BorderLayout#parse\n     * @param layoutInfo {BorderLayoutInitializer}\n     * @returns {BorderLayout}",
        "* Add an element to the layout. Since this layout only allows for 5 specific elements, an adding constraint\n     * must be used.\n     * @method BorderLayout#addElement\n     * @param e {BaseLayout}\n     * @param constraint {string} must exist. a value from 'top','bottom','left','right' or 'center'.",
        "* Do the actual lay out process. Elements will fit into the previously set element bounds.\n     * @method BorderLayout#doLayout",
        "* @class GridLayout\n * @extends BaseLayout\n * @classdesc\n *\n * A grid layout lays elements out either in rows or columns. If rows are specified, the lay out will keep the fixed\n * number of rows and grow on the number of columns or vice versa, like as follows:\n *\n * <pre>\n *\n *     3 rows                        3 columns\n *\n *     +------------+-----...        +----------+----------+----------+\n *     |  row1      |                |   col1   |   col2   |   col3   |\n *     +------------+-----...        +----------+----------+----------+\n *     |  row2      |                |          |          |          |\n *     +------------+-----...        .          .          .          .\n *     |  row3      |                .          .          .          .\n *     +------------+-----...\n * </pre>\n *",
        "* Lay out in rows or columns.\n     * @member GridLayout#_layoutRows\n     * @type {boolean}\n     * @private",
        "* Elements to layout before adding a row or column.\n     * @member GridLayout#_numElements\n     * @type {number}\n     * @private",
        "* Calculated number of rows for the current added elements.\n     * @member GridLayout#_rows\n     * @type {number}\n     * @private",
        "* Calculated number of columns for the current added elements.\n     * @member GridLayout#_columns\n     * @type {number}\n     * @private",
        "* Create a new GridLayout object instance.\n     * @method GridLayout#constructor",
        "* Parse the grid info.\n     * @method GridLayout#parse\n     * @param layoutInfo {GridLayoutInitializer}\n     * @returns {GridLayout}",
        "* Get the preferred layout elements size. The preferred size will be the adjusted to the biggest element's\n     * preferred size, adding the gap for each of the layout elements.\n     * Finally, the insets will be added to the size.\n     * @method GridLayout#getPreferredLayoutSize\n     * @returns {Dimension}",
        "* Do the actual elements lay out. The size of each element will be constrained to the element's bound.\n     * @method GridLayout#doLayout",
        "* @class LayerLayout\n * @extends BaseLayout\n * @classdesc\n *\n * A LayerLayout stacks elements one on top of the other making their bounds the same.\n * The layout does not work on z-index, simply makes them to take over the same area.\n *",
        "* Build a new LayerLayout\n     * @method LayerLayout#constructor",
        "* @method LayerLayout#getPreferredLayoutSize\n     * @returns {Dimension}",
        "* @method LayerLayout#doLayout"
    ],
    "functions": [],
    "classes": [
        "Dimension",
        "Rectangle",
        "Unit",
        "Insets",
        "Gap",
        "BaseLayout",
        "BorderLayout",
        "GridLayout",
        "LayerLayout",
        "ll"
    ]
}