{
    "identifiers": [
        "time",
        "time",
        "time_now",
        "limit_function",
        "limit_function",
        "values",
        "time_now",
        "previous_time",
        "now",
        "values",
        "limit_function",
        "previous_value",
        "previous_time",
        "value",
        "now",
        "previous_value",
        "value",
        "previous_values",
        "values",
        "updated_values",
        "now",
        "updated_values",
        "staticmethod",
        "rate_per_second",
        "previous_value",
        "previous_time",
        "new_value",
        "new_time",
        "new_time",
        "previous_time",
        "abs",
        "previous_value",
        "new_value",
        "value_delta",
        "time_delta",
        "requested_rate",
        "rate_per_second",
        "new_value",
        "previous_value",
        "new_value",
        "previous_value",
        "rate_per_second",
        "requested_rate",
        "limit_function"
    ],
    "literals": [],
    "variables": [
        "previous_values",
        "previous_time",
        "limit_function",
        "now",
        "previous_time",
        "previous_values",
        "updated_values",
        "previous_values",
        "previous_time",
        "time_delta",
        "value_delta",
        "requested_rate"
    ],
    "comments": [],
    "docstrings": [
        "\"\"\"\n    Utility class to provide time-based rate limiting.\n    \"\"\"",
        "\"\"\"\n        Create a new rate limit object, this can be used to enforce maximum rates of change in a set of values, these\n        are generally expressed in rate per second, but could use any arbitrary function. For a default application the\n        provided function which can handle rate per second should be sufficient, but the ability to provide a custom\n        function allows for e.g. permitting larger rates when decreasing. This can be used in conjunction with the motor\n        power functions to provide a degree of traction control (we can't actually detect slipping in wheels, we just\n        don't have sufficient information), by limiting the maximum requested power rate change over time.\n\n        :param limit_function:\n            A function of old_value * old_time * new_value * new_time which will return a potentially limited new value\n            given a requested value, historical value and timepoints for both.\n        \"\"\"",
        "\"\"\"\n        Take a list of values, update the internal state of the RateLimit and return a modified list of values which are\n        restricted by the configured limit function.\n\n        :param float[] values:\n            Values to attempt to apply\n        :return:\n            New values to apply, modified by the configured limit function\n        \"\"\"",
        "\"\"\"\n        Create and return a new limit function which will lock the maximum delta applied to the specified rate per\n        second.\n\n        :param float rate_per_second:\n            Largest allowed delta per second\n        :return:\n            A function which can be used in the :class:`triangula.dynamics.RateLimit` constructor and which will enforce\n            a fixed maximum absolute rate of change across successive values such that no value in the supplied vector\n            will vary at a higher rate than provided.\n        \"\"\""
    ],
    "functions": [
        "limit_and_return",
        "fixed_rate_limit_function",
        "limit_function"
    ],
    "classes": [
        "RateLimit"
    ]
}