{
    "identifiers": [
        "waterbutler",
        "constants",
        "IDENTIFIER_PATHS",
        "waterbutler",
        "core",
        "path",
        "WaterButlerPath",
        "logging",
        "logging",
        "getLogger",
        "resource",
        "provider",
        "metadata",
        "path",
        "path",
        "metadata",
        "resource",
        "provider",
        "metadata",
        "path",
        "WaterButlerPath",
        "from_metadata",
        "metadata",
        "resource",
        "resource",
        "metadata",
        "payload",
        "update",
        "provider",
        "NAME",
        "path",
        "kind",
        "path",
        "identifier_path",
        "provider",
        "NAME",
        "IDENTIFIER_PATHS",
        "path",
        "raw_path",
        "path",
        "name",
        "path",
        "materialized_path",
        "payload",
        "update",
        "metadata",
        "serialized",
        "payload",
        "property",
        "provider",
        "auth"
    ],
    "literals": [
        "\"Log payload needs either a path or metadata.\"",
        "'nid'",
        "'resource'",
        "'provider'",
        "'kind'",
        "'path'",
        "'/'",
        "'name'",
        "'materialized'"
    ],
    "variables": [
        "logger",
        "resource",
        "provider",
        "metadata",
        "path",
        "payload"
    ],
    "comments": [],
    "docstrings": [
        "\"\"\"Simple wrapper class to abstract the object being logged.  Expects the parent resource,\n    provider, and either a metadata or WaterButlerPath object.\n    \"\"\"",
        "\"\"\"Turn this LogPayload into something decent for mixed company.\n\n        A serialized LogPayload will always have the following keys::\n\n            {\n              'kind': 'file', // 'file' or 'folder'\n              'materialized': '/foo/bar/baz', // 'full human-readable path'\n              'name': 'baz', // just the file or folder basename\n              'nid': 'mst3k',  // same thing as 'resource', kept for backcompat\n              'path': '/foo/bar/baz', // path of the file, differs from materialized if provider uses IDs\n              'provider': 'osfstorage', // the provider being connected to\n              'resource': 'mst3k', // the parent entity controlling access to the provider\n            }\n\n        If a metadata object is available it will also contain the `etag` and `extra` properties.\n        Metadata is `None` when the operation is a DELETE, or when constructing a source payload\n        for a move/copy operation.\n        \"\"\"",
        "\"\"\"The auth object for the entity.  Contains the callback_url.\"\"\""
    ],
    "functions": [
        "serialize",
        "auth"
    ],
    "classes": [
        "LogPayload"
    ]
}