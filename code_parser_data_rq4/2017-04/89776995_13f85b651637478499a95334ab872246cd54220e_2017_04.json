{
    "identifiers": [
        "structures",
        "Vertex",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "structures",
        "Graph",
        "graph",
        "answer",
        "graph",
        "graph",
        "graph",
        "u",
        "graph",
        "vertices",
        "u",
        "u",
        "rb",
        "equals",
        "u",
        "rb",
        "BFS_VISIT",
        "u",
        "u",
        "queue",
        "queue",
        "add",
        "u",
        "queue",
        "isEmpty",
        "curr",
        "queue",
        "poll",
        "v",
        "curr",
        "adjVerts",
        "v",
        "v",
        "rb",
        "equals",
        "v",
        "parent",
        "curr",
        "curr",
        "rb",
        "equals",
        "v",
        "rb",
        "curr",
        "rb",
        "equals",
        "v",
        "rb",
        "queue",
        "add",
        "v",
        "v",
        "v",
        "rb",
        "equals",
        "curr",
        "rb",
        "curr",
        "parent",
        "root",
        "v",
        "root",
        "backList",
        "backTrack",
        "curr",
        "v",
        "backList2",
        "backTrack",
        "v",
        "curr",
        "backList",
        "backList2",
        "answer",
        "setupAnswer",
        "backList",
        "backList2",
        "curr",
        "target",
        "back",
        "curr",
        "back",
        "add",
        "curr",
        "root",
        "curr",
        "root",
        "target",
        "root",
        "curr",
        "curr",
        "parent",
        "back",
        "backList",
        "backList2",
        "finalList",
        "i",
        "i",
        "backList",
        "size",
        "i",
        "ele",
        "backList",
        "get",
        "i",
        "backList2",
        "contains",
        "ele",
        "finalList",
        "add",
        "ele",
        "j",
        "backList2",
        "size",
        "j",
        "j",
        "curr2",
        "backList2",
        "get",
        "j",
        "backList",
        "contains",
        "curr2",
        "finalList",
        "add",
        "curr2",
        "finalList",
        "finalList",
        "add",
        "ele",
        "answer"
    ],
    "literals": [
        "\"\"",
        "\"RED\"",
        "\"\"",
        "\"RED\"",
        "\"BLUE\"",
        "\"BLUE\"",
        "\"RED\""
    ],
    "variables": [
        "graph",
        "answer"
    ],
    "comments": [
        "Graph object representing the graph",
        "If graph is not 2-Colorable, the violating cycle is stored here",
        "Initializes the engine",
        "Step one of the BFS",
        "For every vertex in the graph",
        "If it is unvisited",
        "Initialize the color as red",
        "Call BFS Visit",
        "Initializes the queue",
        "If an adjacent vertex is unvisited",
        "Set the parent of the adjacent vertex to the current vertex",
        "Sets the color of the adjacent vertex to color opposite to that of current vertex",
        "Checks if we're going in circles or not",
        "Backtracks from the current node and will eventually reach node 1 or the other node with the same color",
        "Backtracks from the violating node until node 1 or the current adjacent node",
        "List representing the final cycle",
        "Loop through the first path",
        "Current element",
        "Conditional will first trigger upon first instance of common element",
        "Adds that first common element to the final cycle",
        "Adds the non-common elements in reversed order to guarantee that it's a cycle",
        "Sends away the odd cycle"
    ],
    "docstrings": [
        "* \tThis is a slight modification of BFS as needed for this assignment\n * \tInstead of using WHITE, GRAY and BLACK as coloring, we use RED and BLUE as coloring\n *  \tand \"\" if a node is unvisited\n *",
        "* \tIf an adjacent vertex is visited and that vertex has a color equal to that of the current vertex\n\t\t\t\t * \tIf this conditional is ever satisfied, the current graph is not 2-Colorable",
        "* \tIf neither of the lists resulting from the backtracking is null\n\t\t\t\t\t\t * \tpasses the lists to setupAnswer to find the odd cycle\n\t\t\t\t\t\t *",
        "* \tGiven a root node and a target vertex\n\t * \ttravels backwards through the parent of the current node until it reaches vertex 1 or the target vertex\n\t * \tReturns a list of Integers denoting the path this backtracking took",
        "* \tTakes in two lists that represent paths resulting from backtracking as parameters\n\t * \tSuppose that we have two paths in the form of Integer lists\n\t * \t\tA: 8 -> 7 -> 6 -> 5 -> 4 -> 3 -> 2 -> 1\n\t * \t\tB: 14 -> 13 -> 12 -> 11 -> 10 -> 4 -> 3 -> 2 -> 2\n\t * \tThe path we need to return consists of the elements they do not share AND\n\t * \tthe first element they have in common so this method finds:\n\t * \t\t8 -> 7 -> 6 -> 5 -> 4 -> 14 -> 13 -> 12 -> 11 -> 10"
    ],
    "functions": [
        "BFSEngine",
        "BFS",
        "BFS_VISIT",
        "backTrack",
        "setupAnswer",
        "getAnswer"
    ],
    "classes": [
        "BFSEngine"
    ]
}