{
    "identifiers": [
        "Collections",
        "Generic",
        "IO",
        "args",
        "ReadLine",
        "Split",
        "Convert",
        "ToInt32",
        "temp_input",
        "ReadLine",
        "Split",
        "ConvertAll",
        "arr_temp",
        "Int32",
        "Parse",
        "coinAmountArray",
        "Length",
        "numberOfCoinAmounts",
        "amount",
        "n",
        "numberOfCoinAmounts",
        "n",
        "numberOfSolutionsAtValue",
        "n",
        "n",
        "amount",
        "n",
        "numberOfSolutionsAtValue",
        "n",
        "currCoinIndex",
        "numberOfCoinAmounts",
        "currCoinIndex",
        "currAmount",
        "amount",
        "currAmount",
        "currAmount",
        "coinAmountArray",
        "currCoinIndex",
        "valueAfterDec",
        "numberOfSolutionsAtValue",
        "currCoinIndex",
        "currAmount",
        "numberOfSolutionsAtValue",
        "currCoinIndex",
        "valueAfterDec",
        "numberOfSolutionsAtValue",
        "currCoinIndex",
        "currAmount",
        "numberOfSolutionsAtValue",
        "currCoinIndex",
        "currAmount",
        "numberOfSolutionsAtValue",
        "currCoinIndex",
        "currAmount",
        "WriteLine",
        "numberOfSolutionsAtValue",
        "numberOfCoinAmounts",
        "amount"
    ],
    "literals": [],
    "variables": [
        "temp_input",
        "amount",
        "arr_temp",
        "coinAmountArray",
        "numberOfCoinAmounts",
        "numberOfSolutionsAtValue",
        "n",
        "n",
        "currCoinIndex",
        "currAmount",
        "valueAfterDec"
    ],
    "comments": [
        "………. ,*˜*, ……. ,•°*•, Spencer MK Smith ,•*°•, …… ,*˜*, .……… \n\t„*˜……“• •“………'·,¸¸,‘•°. HackerRank .°•',¸¸,·'……..“• •“……˜*„\n\t“‹„¸¸„ •°`'·.,¸¸,.·‘…Coin Change Problem…'·.,¸¸,.·'´°•„¸¸„›“\n\n\tThis dynamic programming challenge of moderate difficulty can be found here: https://www.hackerrank.com/challenges/coin-change\n\n\tAt first I came to a solution very quickly to this problem, but my solution had a flaw: If the amount we were looking for was 5,\n\tit would consider both coin choices of 2,3 and 3,2 as a solution, but these should only be counted as one solution.  Based on this\n\tflaw, I needed to rethink my whole solution into what I have now.\n\t\n\tThis solution could easily be modified to use recursion, but I opted to use a bottom-up dynamic programming solution instead of\n\tthe recursive method, either way, the logic is the same.  To begin, we are given a number of coin values and an amount.  We are to\n\tfigure out how many different ways we can use the coin values to construct the amount.  To do this, we first figure out how many ways\n\twe can construct the amount = 1 only using the 1st coin given, then the amount = 2 with only the 1st coin, all of the way to the amount.\n\tThen, we do the same thing but also looking at the second coin.  Each of these values use each other to create themselves.  The values are\n\tstored in a 2D array called numberOfSolutionsAtValue with index values [number of coin values + 1, amount + 1].  Let's look at an example:\n\t\n\tSay the given coin amounts are 2,3,5,6 and the amount we want to look at is 5.  We first construct an array with index [number of coin values + 1, amount + 1]\n\tor, [5,6]:\n\t_______\tAmounts\t\t\t\t\t\t\t\t\t\t\t\t\t\t_______ Amounts\n\t|000000  First, we fill in the base cases.  These are that\t\t\t|100000\n\t|000000  that is 1 way to construct the amount 0 for any\t\t\t|100000\n\t|000000  coin amounts.  And, that given no coins and a positive -->\t|100000\n\t|000000  amount, no amount can be constructed.  This forms the \t\t|100000\n\t|000000\t array to look like this\t\t\t\t\t\t\t\t\t|100000\ncoinIndex\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcoinIndex\n\n\tNow that we have the base case values in, we start to look at the actual values, we start with the first row and go right, looking at each value.\n\tLooking at the amount = 1, and coinIndex = 1.  Keep in mind that coinAmount[1] = 2, because 2 is the first coin value given.  So, how many ways can\n\twe construct the amount = 1, using a coin with value = 2?  That isn't possible, so that value stays 0, what about amount = 2?  There would be 1 way.\n\tBut, it gets very complex very easily as we get to higher values, and so we need to start using the values that we create earlier in the process to \n\tdiscover the new values.  Take the amount = 5, with a coinIndex = 3, this means that at first we only look at coin value = 5.  There are a number of things we need\n\tto consider, first, consider that we use the coin that we're looking at with a value of 5, we can use this coin and this coin only.  Or, we could ignore the coin\n\twe're looking at and use another coin.  We need to take both tracks into consideration.  And so, the value at index [3][5] is the addition of these two values:\n\t\tnumberOfSolutionsAtValue[3][5 - coinUsed] = numberOfSolutionsAtValue[3][0] = 1\n\t\tnumberOfSolutionsAtValue[3 - 1][5] = numberOfSolutionsAtValue[2][5] (look at coinValue[2] = 3 and how many ways we can construct 5)\n\t\t\n\tOnce we iterate through the whole 2D array, discovering every value, we simply print the value at the bottom right of the array, which is the number of ways\n\tthat we can construct the amount given, using all of the coin values given.  After all of the iteration, the following matrix is created:\n\t\n\t_______Amount\n\t|100000\t\t\tNOTE: There is 0 ways to construct an amount of\n\t|101010\t\t\t\t  1 with any of the coins given, so those values are all 0\n\t|101111\n\t|101112\n\t|101112 <-- Answer = 2\ncoinIndex\n\n\t\n\tI urge you, before going further, to write out this sample problem on a piece of paper and iterate through it programmatically like your algorithm will\n\tbe so that you can understand it better.",
        "Read first line of input and get the amount from it",
        "Read second line of input, create an array of different coin amounts and get the number of coins we have",
        "NOTE: long data type needs to be used because some test cases have extremely large values",
        "Base case, there is 1 way to construct an amount of 0 regardless of what coins we look at",
        "Base case, there is 0 ways to construct a positive amount with no coins",
        "Populate the rest of the values in te 2D array",
        "Loop through every coins value available",
        "Loop through every amount up to the one given",
        "Value after decrementing the current coin value that we're looking at",
        "If it is possible to use the coin we're looking at, this value will be greater than 0",
        "If the coin value we're looking at is too large, only look at using smaller coins",
        "The answer resides at the last value in the 2D array"
    ],
    "docstrings": [],
    "functions": [
        "Main"
    ],
    "classes": [
        "Solution"
    ]
}