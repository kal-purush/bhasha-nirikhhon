{
    "identifiers": [
        "ws4py",
        "websocket",
        "Heartbeat",
        "WebSocket",
        "_WebSocket",
        "waitress",
        "channel",
        "HTTPChannel",
        "_WebSocket",
        "sock",
        "protocols",
        "extensions",
        "environ",
        "heartbeat_freq",
        "_WebSocket",
        "sock",
        "protocols",
        "extensions",
        "environ",
        "heartbeat_freq",
        "heartbeat_freq",
        "Heartbeat",
        "heartbeat_freq",
        "data",
        "terminated",
        "sock",
        "RuntimeError",
        "sock",
        "write_soon",
        "data",
        "sock",
        "heartbeat_freq",
        "hb",
        "start",
        "code",
        "reason",
        "heartbeat_freq",
        "hb",
        "stop",
        "WebSocket",
        "message",
        "send",
        "message",
        "data",
        "message",
        "is_binary",
        "HTTPChannel",
        "server",
        "sock",
        "addr",
        "adj",
        "HTTPChannel",
        "server",
        "sock",
        "addr",
        "adj",
        "websocket",
        "websocket",
        "websocket",
        "opened",
        "websocket",
        "data",
        "_websocket",
        "_websocket",
        "process",
        "data",
        "HTTPChannel",
        "received",
        "data",
        "HTTPChannel",
        "handle_close",
        "_websocket",
        "_websocket",
        "terminate"
    ],
    "literals": [
        "'WebSocket'",
        "'EchoWebSocket'",
        "\"Cannot send on a terminated websocket\""
    ],
    "variables": [
        "__doc__",
        "__all__",
        "hb",
        "will_close",
        "_websocket",
        "_websocket"
    ],
    "comments": [
        "-*- coding: utf-8 -*-"
    ],
    "docstrings": [
        "\"\"\"\nSupport for ws4py in waitress\n\"\"\"",
        "\"\"\"\n        Make it clear this won't be used as\n        IO runs off asyncore.loop() in server\n        \"\"\"",
        "\"\"\"\n        Make it clear this won't be used as\n        IO runs off asyncore.loop() in server\n        \"\"\"",
        "\"\"\"\n        self.sock must be an instance of waitress' WSHTTPChannel\n        so use WSHTTPChannel.write_soon() to queue data to be sent\n        \"\"\"",
        "\"\"\"\n        Close the underlying transport\n        \"\"\"",
        "\"\"\"\n        Called by the server when the upgrade handshake has succeeded.\n        If overriding in subclass, please call this as follows ...\n        WebSocket.opened(self)\n        \"\"\"",
        "\"\"\"\n        Called when the websocket stream and connection are finally closed.\n        If overriding in subclass, please call this as follows ...\n        WebSocket.closed(self, code, reason)\n        \"\"\"",
        "\"\"\"\n        Automatically sends back the provided ``message`` to\n        its originating endpoint.\n        \"\"\"",
        "\"\"\"\n    Support switching from HTTPChannel to WebSocket\n    \"\"\"",
        "\"\"\"\n        Override HTTPChannel.__init__ just to initialise _websocket\n        \"\"\"",
        "\"\"\"\n        Called from WSGITask when handshake is successful\n        \"\"\"",
        "\"\"\"\n        If not a websocket, behave as a normal HTTPChannel\n        If a websocket, then process received data as such\n        \"\"\"",
        "\"\"\"\n        Override HTTPChannel.handle_close() just to\n        to call websocket's terminate() so it can clean up\n        \"\"\""
    ],
    "functions": [
        "once",
        "run",
        "_write",
        "close_connection",
        "opened",
        "closed",
        "received_message",
        "websocket_opened",
        "received",
        "handle_close"
    ],
    "classes": [
        "WebSocket",
        "EchoWebSocket",
        "WSHTTPChannel"
    ]
}