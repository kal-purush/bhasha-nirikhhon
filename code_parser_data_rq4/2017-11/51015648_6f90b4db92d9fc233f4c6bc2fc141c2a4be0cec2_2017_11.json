{
    "identifiers": [
        "reactor",
        "cache",
        "java",
        "util",
        "java",
        "util",
        "BiFunction",
        "java",
        "util",
        "reactor",
        "core",
        "publisher",
        "Mono",
        "reactor",
        "core",
        "publisher",
        "Signal",
        "reactor",
        "util",
        "annotation",
        "NonNull",
        "NonNull",
        "NonNull",
        "cm",
        "NonNull",
        "key",
        "o",
        "Mono",
        "justOrEmpty",
        "cm",
        "get",
        "key",
        "switchIfEmpty",
        "o",
        "materialize",
        "doOnNext",
        "value",
        "cm",
        "put",
        "key",
        "value",
        "dematerialize",
        "NonNull",
        "NonNull",
        "cr",
        "NonNull",
        "key",
        "o",
        "cw",
        "cr",
        "apply",
        "key",
        "switchIfEmpty",
        "o",
        "materialize",
        "flatMap",
        "value",
        "cw",
        "apply",
        "key",
        "value",
        "dematerialize",
        "FunctionalInterface",
        "MonoCacheReader",
        "FunctionalInterface",
        "MonoCacheWriter",
        "FunctionalInterface",
        "MonoCacheBuilderCacheMiss",
        "other",
        "FunctionalInterface",
        "MonoCacheBuilderCacheWriter",
        "writer",
        "FunctionalInterface",
        "MonoCacheBuilderMapMiss",
        "other"
    ],
    "literals": [],
    "variables": [],
    "comments": [],
    "docstrings": [
        "* Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.",
        "* Cache helper that may be used with any cache vendors that has a Map wrapper support.\n * <p> Example usage:\n * <pre><code>\n *    LoadingCache<Integer, Object> graphs = Caffeine.newBuilder()\n *                                       .maximumSize(10_000)\n *                                       .expireAfterWrite(5, TimeUnit.MINUTES)\n *                                       .refreshAfterWrite(1, TimeUnit.MINUTES)\n *                                       .build(key -> createExpensiveGraph(key));\n *\n *    keyStream.concatMap(key -> Cache.lookupMono(graphs.asMap(), key)\n *                                    .onCacheMissResume(repository.findOneById(key))\n * </code></pre>\n * </p>\n *\n * @author Oleh Dokuka\n * @author Simon Basl√©",
        "* Restore a {@link Mono<Value>} from the cache-map given a provided key. If no value\n\t * is in the cache, it will be calculated from the original source which is set up in\n\t * the next step. Note that if the source completes empty, this result will be cached\n\t * and all subsequent requests with the same key will return {@link Mono#empty()). The\n\t * behaviour is similar for erroring sources, except cache hits would then return\n\t * {@link Mono#error(Throwable)}.\n\t *\n\t * @param cache {@link Map} wrapper of a cache\n\t * @param key mapped key\n\t * @param <Key> Key Type\n\t * @param <Value> Value Type\n\t *\n\t * @return Lazy \"{@link MonoCacheBuilderMapMiss}\"",
        "* Restore a {@link Mono<Value>} from the {@link MonoCacheReader} given a provided\n\t * key. If no value is in the cache, it will be calculated from the original source\n\t * which is set up in the next step. Note that if the source completes empty, this\n\t * result will be cached and all subsequent requests with the same key will return\n\t * {@link Mono#empty()). The behaviour is similar for erroring sources, except cache\n\t * hits would then return {@link Mono#error(Throwable)}.\n\t *\n\t * @param cache {@link Map} wrapper of a cache\n\t * @param key mapped key\n\t * @param <Key> Key Type\n\t * @param <Value> Value Type\n\t *\n\t * @return Lazy \"{@link MonoCacheBuilderCacheMiss}\"",
        "* Functional interface that gives ability to lookup for cached result from the Cache\n\t * source. <p> Example adapter around {@link Map} usage:\n\t * <pre><code>\n\t * Map<Integer, Signal<? extends String>> cache = new HashMap<>();\n\t * Function<Integer, Mono<String>> flatMap = key -> CacheHelper\n\t *                                                   .lookupMono(reader(cache), key)\n\t *                                                   .onCacheMissResume(source)\n\t *                                                   .andWriteWith(writer(cache));\n\t *\n\t *\n\t * private static <Key, Value> CacheHelper.MonoCacheReader<Key, Value> reader(Map<Key, ? extends Signal<? extends Value>> cache) {\n\t *    return key -> Mono.justOrEmpty(cache.get(key));\n\t * }\n\t *\n\t * private static <Key, Value> CacheHelper.MonoCacheWriter<Key, Value> writer(Map<Key, ? super Signal<? extends Value>> cache) {\n\t *    return (key, value) -> {\n\t *        cache.put(key, value);\n\t *        return Mono.just(value);\n\t *    };\n\t * }\n\t * </code></pre>\n\t * </p>\n\t *\n\t * @param <Key> Key Type\n\t * @param <Value> Value Type",
        "* Functional interface that gives ability to write results from the original source\n\t * to Cache-storage.\n\t * <p> Example adapter around {@link Map} usage:\n\t * <pre><code>\n\t * Map<Integer, Signal<? extends String>> cache = new HashMap<>();\n\t * Function<Integer, Mono<String>> flatMap = key -> CacheHelper\n\t *                                                   .lookupMono(reader(cache), key)\n\t *                                                   .onCacheMissResume(source)\n\t *                                                   .andWriteWith(writer(cache));\n\t *\n\t *\n\t * private static <Key, Value> CacheHelper.MonoCacheReader<Key, Value> reader(Map<Key, ? extends Signal<? extends Value>> cache) {\n\t *    return key -> Mono.justOrEmpty(cache.get(key));\n\t * }\n\t *\n\t * private static <Key, Value> CacheHelper.MonoCacheWriter<Key, Value> writer(Map<Key, ? super Signal<? extends Value>> cache) {\n\t *    return (key, value) -> {\n\t *        cache.put(key, value);\n\t *        return Mono.just(value);\n\t *    };\n\t * }\n\t * </code></pre>\n\t * </p>\n\t *\n\t * @param <Key> Key Type\n\t * @param <Value> Value Type",
        "* Builder that setup original source\n\t *\n\t * @param <Key> Key type\n\t * @param <Value> Value type",
        "* Setup original source\n\t\t *\n\t\t * @param other original source\n\t\t *\n\t\t * @return lazy {@link MonoCacheBuilderCacheWriter}",
        "* Builder that setup {@link MonoCacheWriter}\n\t *\n\t * @param <Key> Key type\n\t * @param <Value> Value type",
        "* Setup {@link MonoCacheWriter}\n\t\t *\n\t\t * @param writer {@link MonoCacheWriter} instance\n\t\t *\n\t\t * @return {@link Mono}",
        "* Cache builder that adapt {@link Map} as the Cache source and skip building steps\n\t * such as specified by {@link MonoCacheBuilderCacheWriter}\n\t *\n\t * <p> Example usage:\n\t * <pre><code>\n\t *    LoadingCache<Integer, Object> graphs = Caffeine.newBuilder()\n\t *                                       .maximumSize(10_000)\n\t *                                       .expireAfterWrite(5, TimeUnit.MINUTES)\n\t *                                       .refreshAfterWrite(1, TimeUnit.MINUTES)\n\t *                                       .build(key -> createExpensiveGraph(key));\n\t *\n\t *    keyStream.concatMap(key -> Cache.lookupMono(graphs.asMap(), key)\n\t *                                    .onCacheMissResume(repository.findOneById(key))\n\t * </code></pre>\n\t * </p>\n\t *\n\t * @param <Value> type",
        "* Setup original source\n\t\t *\n\t\t * @param other original source\n\t\t *\n\t\t * @return direct {@link Mono}"
    ],
    "functions": [
        "lookupMono",
        "lookupMono",
        "onCacheMissResume",
        "andWriteWith",
        "onCacheMissResume"
    ],
    "classes": [
        "CacheHelper"
    ]
}