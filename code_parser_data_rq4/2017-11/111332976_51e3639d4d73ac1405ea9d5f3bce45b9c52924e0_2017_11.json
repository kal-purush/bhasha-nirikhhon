{
    "identifiers": [
        "sys",
        "subprocess",
        "json",
        "socket",
        "threading",
        "time",
        "sys",
        "i3Exception",
        "MessageTypeError",
        "msg",
        "i3Exception",
        "EventTypeError",
        "msg",
        "i3Exception",
        "i3Exception",
        "socket_path",
        "socket_path",
        "ConnectionError",
        "msg",
        "msg_type",
        "msg_type",
        "ValueError",
        "index",
        "index",
        "len",
        "MSG_TYPES",
        "index",
        "msg_type",
        "lower",
        "msg_type",
        "MSG_TYPES",
        "MSG_TYPES",
        "index",
        "msg_type",
        "MessageTypeError",
        "msg_type",
        "event_type",
        "event_type",
        "ValueError",
        "index",
        "index",
        "len",
        "EVENT_TYPES",
        "EVENT_TYPES",
        "index",
        "event_type",
        "lower",
        "event_type",
        "EVENT_TYPES",
        "event_type",
        "EventTypeError",
        "event_type",
        "path",
        "timeout",
        "chunk_size",
        "magic_string",
        "path",
        "get_socket_path",
        "path",
        "timeout",
        "timeout",
        "chunk_size",
        "chunk_size",
        "magic_string",
        "magic_string",
        "initialize",
        "connect",
        "len",
        "magic_string",
        "encode",
        "calcsize",
        "struct_header",
        "socket",
        "socket",
        "socket",
        "AF_UNIX",
        "socket",
        "SOCK_STREAM",
        "socket",
        "settimeout",
        "timeout",
        "path",
        "connected",
        "initialize",
        "path",
        "path",
        "socket",
        "connect",
        "path",
        "socket",
        "error",
        "ConnectionError",
        "path",
        "msg_type",
        "payload",
        "send",
        "msg_type",
        "payload",
        "receive",
        "event_type",
        "parse_event_type",
        "event_type",
        "event_type",
        "payload",
        "append",
        "json",
        "dumps",
        "payload",
        "get",
        "payload",
        "msg_type",
        "payload",
        "pack",
        "msg_type",
        "payload",
        "socket",
        "sendall",
        "message",
        "socket",
        "recv",
        "chunk_size",
        "unpack_header",
        "data",
        "struct_header_size",
        "msg_length",
        "len",
        "data",
        "msg_size",
        "data",
        "socket",
        "recv",
        "msg_length",
        "buffer",
        "data",
        "unpack",
        "data",
        "socket",
        "timeout",
        "msg_type",
        "payload",
        "magic_string",
        "len",
        "payload",
        "encode",
        "parse_msg_type",
        "msg_type",
        "pack",
        "msg_length",
        "decode",
        "pack",
        "msg_type",
        "decode",
        "msg_magic",
        "msg_length",
        "msg_type",
        "payload",
        "message",
        "encode",
        "data",
        "len",
        "data",
        "unpack_header",
        "data",
        "struct_header_size",
        "msg_length",
        "data_size",
        "msg_size",
        "data",
        "struct_header_size",
        "msg_size",
        "decode",
        "json",
        "loads",
        "payload",
        "data",
        "msg_size",
        "payload",
        "data",
        "data",
        "unpack",
        "struct_header",
        "data",
        "struct_header_size",
        "property",
        "get",
        "socket",
        "error",
        "socket",
        "close",
        "threading",
        "callback",
        "event_type",
        "event_socket",
        "data_socket",
        "callable",
        "callback",
        "parse_event_type",
        "event_type",
        "callback",
        "event_type",
        "event_socket",
        "Socket",
        "event_socket",
        "event_socket",
        "subscribe",
        "event_type",
        "data_socket",
        "Socket",
        "data_socket",
        "threading",
        "start",
        "listen",
        "socket",
        "error",
        "close",
        "subscribed",
        "event_socket",
        "receive",
        "type_translation",
        "event_type",
        "data_socket",
        "get",
        "msg_type",
        "callback",
        "data",
        "close",
        "event_socket",
        "close",
        "data_socket",
        "default_socket",
        "data_socket",
        "close",
        "cmd",
        "subprocess",
        "check_output",
        "cmd",
        "subprocess",
        "CalledProcessError",
        "error",
        "error",
        "output",
        "output",
        "decode",
        "output",
        "strip",
        "socket",
        "__socket__",
        "socket",
        "isinstance",
        "socket",
        "Socket",
        "socket",
        "__socket__",
        "Socket",
        "__socket__",
        "message",
        "default_socket",
        "get",
        "message",
        "response",
        "message",
        "args",
        "crit",
        "args2",
        "crit2",
        "join",
        "message",
        "args",
        "args2",
        "crit",
        "criteria",
        "update",
        "crit2",
        "criteria",
        "container",
        "criteria",
        "msg_full",
        "msg",
        "msg_full",
        "success",
        "response",
        "isinstance",
        "response",
        "i3Exception",
        "response",
        "response",
        "message",
        "event_type",
        "callback",
        "callback",
        "data",
        "subscription",
        "data",
        "data",
        "default_socket",
        "Subscription",
        "callback",
        "event_type",
        "data_socket",
        "socket",
        "time",
        "sleep",
        "KeyboardInterrupt",
        "subscription",
        "close",
        "__call_cmd__",
        "cmd",
        "output",
        "response",
        "isinstance",
        "response",
        "response",
        "response",
        "MessageError",
        "response",
        "response",
        "isinstance",
        "response",
        "index",
        "item",
        "response",
        "success",
        "item",
        "isinstance",
        "item",
        "i3Exception",
        "item",
        "item",
        "response",
        "criteria",
        "key",
        "val",
        "key",
        "val",
        "criteria",
        "items",
        "join",
        "criteria",
        "con_id",
        "tree",
        "node",
        "child",
        "node",
        "child",
        "con_id",
        "tree",
        "has_child",
        "parents",
        "len",
        "parents",
        "parents",
        "tree",
        "conditions",
        "tree",
        "msg",
        "isinstance",
        "tree",
        "tree",
        "tree",
        "tree",
        "KeyError",
        "IndexError",
        "key",
        "value",
        "conditions",
        "items",
        "key",
        "tree",
        "tree",
        "key",
        "value",
        "tree",
        "nodes",
        "nodes",
        "tree",
        "node",
        "tree",
        "nodes",
        "matches",
        "node",
        "conditions",
        "matches",
        "ModuleType",
        "name",
        "getattr",
        "__module__",
        "name",
        "AttributeError",
        "name",
        "lower",
        "__module__",
        "MSG_TYPES",
        "__module__",
        "__function__",
        "name",
        "__module__",
        "__function__",
        "message",
        "name",
        "sys",
        "modules",
        "i3",
        "sys",
        "modules"
    ],
    "literals": [
        "'Jure Ziberna'",
        "'0.6.5'",
        "'2012-06-20'",
        "'GNU GPL 3'",
        "'command'",
        "'get_workspaces'",
        "'subscribe'",
        "'get_outputs'",
        "'get_tree'",
        "'get_marks'",
        "'get_bar_config'",
        "'workspace'",
        "'output'",
        "\"Message type '%s' isn't available\"",
        "\"Event type '%s' isn't available\"",
        "\"Could not connect to socket at '%s'\"",
        "'i3-ipc'",
        "b''",
        "'<%dsII'",
        "'utf-8'",
        "''",
        "'subscribe'",
        "''",
        "'utf-8'",
        "'I'",
        "'utf-8'",
        "'I'",
        "'utf-8'",
        "'%s%s%s%s'",
        "'utf-8'",
        "'utf-8'",
        "'command'",
        "'workspace'",
        "'get_workspaces'",
        "'output'",
        "'get_outputs'",
        "'Callback must be callable'",
        "'change'",
        "'change'",
        "'utf-8'",
        "''",
        "''",
        "' '",
        "'%s %s'",
        "'Message sender (type: %s, message: %s)'",
        "'changed:'",
        "'change'",
        "'data:\\n'",
        "''",
        "'i3'",
        "'--get-socketpath'",
        "'success'",
        "'error'",
        "'error'",
        "'success'",
        "'%s=\"%s\"'",
        "'[%s]'",
        "' '",
        "'nodes'",
        "'id'",
        "'get_tree'",
        "'list'",
        "'nodes'",
        "'floating_nodes'",
        "'list'",
        "'command'"
    ],
    "variables": [
        "ModuleType",
        "__author__",
        "__version__",
        "__date__",
        "__license__",
        "MSG_TYPES",
        "EVENT_TYPES",
        "msg",
        "msg",
        "msg",
        "index",
        "index",
        "msg_type",
        "index",
        "index",
        "event_type",
        "magic_string",
        "chunk_size",
        "timeout",
        "buffer",
        "path",
        "path",
        "timeout",
        "chunk_size",
        "magic_string",
        "struct_header",
        "struct_header_size",
        "socket",
        "path",
        "event_type",
        "payload",
        "payload",
        "message",
        "data",
        "msg_magic",
        "msg_length",
        "msg_type",
        "msg_size",
        "data",
        "msg_magic",
        "msg_length",
        "msg_type",
        "msg_length",
        "msg_type",
        "message",
        "data_size",
        "msg_magic",
        "msg_length",
        "msg_type",
        "msg_size",
        "payload",
        "payload",
        "buffer",
        "buffer",
        "subscribed",
        "type_translation",
        "event_type",
        "callback",
        "event_type",
        "event_socket",
        "event_socket",
        "data_socket",
        "data_socket",
        "subscribed",
        "msg_type",
        "data",
        "data",
        "subscribed",
        "output",
        "output",
        "output",
        "__socket__",
        "__socket__",
        "__socket__",
        "response",
        "msg_full",
        "criteria",
        "msg_full",
        "response",
        "response",
        "__doc__",
        "socket",
        "subscription",
        "cmd",
        "output",
        "item",
        "response",
        "index",
        "criteria",
        "parents",
        "tree",
        "tree",
        "matches",
        "__module__"
    ],
    "comments": [
        "======================================================================",
        "i3 (Python module for communicating with i3 window manager)",
        "Copyright (C) 2012  Jure Ziberna",
        "",
        "This program is free software: you can redistribute it and/or modify",
        "it under the terms of the GNU General Public License as published by",
        "the Free Software Foundation, either version 3 of the License, or",
        "(at your option) any later version.",
        "",
        "This program is distributed in the hope that it will be useful,",
        "but WITHOUT ANY WARRANTY; without even the implied warranty of",
        "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
        "GNU General Public License for more details.",
        "",
        "You should have received a copy of the GNU General Public License",
        "along with this program.  If not, see <http://www.gnu.org/licenses/>.",
        "======================================================================",
        "safety string for i3-ipc",
        "in bytes",
        "in seconds",
        "byte string",
        "Socket initialization and connection",
        "Struct format initialization, length of magic string is in bytes",
        "Create JSON payload from given event type and event",
        "Continuously send the bytes from the message",
        "Keep receiving data until the whole message gets through",
        "Get the byte count instead of number of characters",
        "\"struct.pack\" returns byte string, decoding it for concatenation",
        "Encoding the message back to byte string",
        "Message shouldn't be any longer than the data",
        "Variable initialization",
        "Socket initialization",
        "Thread initialization",
        "skip an iteration if event is None",
        "byte string decoding",
        "force newline",
        "Turn the module into an i3 object"
    ],
    "docstrings": [
        "\"\"\"\n    Raised when message type isn't available. See i3.MSG_TYPES.\n    \"\"\"",
        "\"\"\"\n    Raised when even type isn't available. See i3.EVENT_TYPES.\n    \"\"\"",
        "\"\"\"\n    Raised when a message to i3 is unsuccessful.\n    That is, when it contains 'success': false in its JSON formatted response.\n    \"\"\"",
        "\"\"\"\n    Raised when a socket couldn't connect to the window manager.\n    \"\"\"",
        "\"\"\"\n    Returns an i3-ipc code of the message type. Raises an exception if\n    the given message type isn't available.\n    \"\"\"",
        "\"\"\"\n    Returns an i3-ipc string of the event_type. Raises an exception if\n    the given event type isn't available.\n    \"\"\"",
        "\"\"\"\n    Socket for communicating with the i3 window manager.\n    Optional arguments:\n    - path of the i3 socket. Path is retrieved from i3-wm itself via\n      \"i3.get_socket_path()\" if not provided.\n    - timeout in seconds\n    - chunk_size in bytes\n    - magic_string as a safety string for i3-ipc. Set to 'i3-ipc' by default.\n    \"\"\"",
        "\"\"\"\n        Initializes the socket.\n        \"\"\"",
        "\"\"\"\n        Connects the socket to socket path if not already connected.\n        \"\"\"",
        "\"\"\"\n        Convenience method, calls \"socket.send(msg_type, payload)\" and\n        returns data from \"socket.receive()\".\n        \"\"\"",
        "\"\"\"\n        Subscribes to an event. Returns data on first occurrence.\n        \"\"\"",
        "\"\"\"\n        Sends the given message type with given message by packing them\n        and continuously sending bytes from the packed message.\n        \"\"\"",
        "\"\"\"\n        Tries to receive a data. Unpacks the received byte string if\n        successful. Returns None on failure.\n        \"\"\"",
        "\"\"\"\n        Packs the given message type and payload. Turns the resulting\n        message into a byte string.\n        \"\"\"",
        "\"\"\"\n        Unpacks the given byte string and parses the result from JSON.\n        Returns None on failure and saves data into \"self.buffer\".\n        \"\"\"",
        "\"\"\"\n        Unpacks the header of given byte string.\n        \"\"\"",
        "\"\"\"\n        Returns True if connected and False if not.\n        \"\"\"",
        "\"\"\"\n        Closes the socket connection.\n        \"\"\"",
        "\"\"\"\n    Creates a new subscription and runs a listener loop. Calls the\n    callback on event.\n    Example parameters:\n    callback = lambda event, data, subscription: print(data)\n    event_type = 'workspace'\n    event = 'focus'\n    event_socket = <i3.Socket object>\n    data_socket = <i3.Socket object>\n    \"\"\"",
        "\"\"\"\n        Wrapper method for the listen method -- handles exceptions.\n        The method is run by the underlying \"threading.Thread\" object.\n        \"\"\"",
        "\"\"\"\n        Runs a listener loop until self.subscribed is set to False.\n        Calls the given callback method with data and the object itself.\n        If event matches the given one, then matching data is retrieved.\n        Otherwise, the event itself is sent to the callback.\n        In that case 'change' key contains the thing that was changed.\n        \"\"\"",
        "\"\"\"\n        Ends subscription loop by setting self.subscribed to False and\n        closing both sockets.\n        \"\"\"",
        "\"\"\"\n    Returns output (stdout or stderr) of the given command args.\n    \"\"\"",
        "\"\"\"\n    Returns i3.Socket object, which was initiliazed once with default values\n    if no argument is given.\n    Otherwise sets the default socket to the given socket.\n    \"\"\"",
        "\"\"\"\n    Takes a message type and a message itself.\n    Talks to the i3 via socket and returns the response from the socket.\n    \"\"\"",
        "\"\"\"\n    Accepts a message type, a message. Takes optional args and keyword\n    args which are present in all future calls of the resulting function.\n    Returns a function, which takes arguments and container criteria.\n    If message type was 'command', the function returns success value.\n    \"\"\"",
        "\"\"\"\n    Accepts an event_type and event itself.\n    Creates a new subscription, prints data on every event until\n    KeyboardInterrupt is raised.\n    \"\"\"",
        "\"\"\"\n    Gets the socket path via i3 command.\n    \"\"\"",
        "\"\"\"\n    Convenience method for filtering success values of a response.\n    Each success dictionary is replaces with boolean value.\n    i3.MessageError is returned if error key is found in any of the\n    success dictionaries.\n    \"\"\"",
        "\"\"\"\n    Turns keyword arguments into a formatted container criteria.\n    \"\"\"",
        "\"\"\"\n    Searches for a parent of a node/container, given the container id.\n    Returns None if no container with given id exists (or if the\n    container is already a root node).\n    \"\"\"",
        "\"\"\"\n    Filters a tree based on given conditions. For example, to get a list of\n    unfocused windows (leaf nodes) in the current tree:\n      i3.filter(nodes=[], focused=False)\n    The return value is always a list of matched items, even if there's\n    only one item that matches.\n    The user function should take a single node. The function doesn't have\n    to do any dict key or index checking (this is handled by i3.filter\n    internally).\n    \"\"\"",
        "\"\"\"\n    i3.py is a Python module for communicating with the i3 window manager.\n    \"\"\"",
        "\"\"\"\n        Turns a nonexistent attribute into a function.\n        Returns the resulting function.\n        \"\"\""
    ],
    "functions": [
        "parse_msg_type",
        "parse_event_type",
        "initialize",
        "connect",
        "get",
        "subscribe",
        "send",
        "receive",
        "pack",
        "unpack",
        "unpack_header",
        "connected",
        "close",
        "run",
        "listen",
        "close",
        "__call_cmd__",
        "default_socket",
        "msg",
        "__function__",
        "subscribe",
        "callback",
        "get_socket_path",
        "success",
        "container",
        "parent",
        "has_child",
        "__getattr__"
    ],
    "classes": [
        "i3Exception",
        "MessageTypeError",
        "EventTypeError",
        "MessageError",
        "ConnectionError",
        "Socket",
        "Subscription",
        "i3"
    ]
}