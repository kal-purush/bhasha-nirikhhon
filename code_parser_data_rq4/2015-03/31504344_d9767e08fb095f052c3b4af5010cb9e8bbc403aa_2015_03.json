{
    "identifiers": [
        "require",
        "require",
        "require",
        "require",
        "require",
        "BASE_URL",
        "verbose",
        "util",
        "arguments",
        "require",
        "verbose",
        "argv",
        "printAllEvents",
        "argv",
        "result",
        "whisper",
        "err",
        "err",
        "err",
        "err",
        "currentPage",
        "parseEventsOnPage",
        "currentPage",
        "eventsOnPage",
        "eventsOnPage",
        "eventsOnPage",
        "JSON_INDENT_SPACES",
        "printAllEvents",
        "currentPage",
        "pageIndex",
        "whisper",
        "pageIndex",
        "request",
        "SEARCH_URL",
        "pageIndex",
        "body",
        "body",
        "cheerio",
        "body",
        "$",
        "idx",
        "article",
        "parseArticle",
        "cheerio",
        "article",
        "whisper",
        "eventPromises",
        "pageIndex",
        "eventPromises",
        "article$",
        "article$",
        "eventLink$",
        "BASE_URL",
        "eventLink$",
        "article$",
        "date$",
        "date$",
        "date$",
        "date$",
        "article$",
        "article$",
        "idx",
        "el",
        "cheerio",
        "el",
        "artists",
        "artists",
        "article$",
        "venueLink$",
        "BASE_URL",
        "venueLink$",
        "venueLink$",
        "venueUrl",
        "venueUrl",
        "venueAddresses",
        "venueAddresses",
        "venueUrl",
        "whisper",
        "venueUrl",
        "request",
        "venueUrl",
        "venueBody",
        "cheerio",
        "venueBody",
        "$",
        "address",
        "address",
        "address",
        "venueAddresses",
        "venueUrl",
        "address",
        "address",
        "address",
        "main"
    ],
    "literals": [
        "'yargs'",
        "'util'",
        "'request-promise'",
        "'bluebird'",
        "'cheerio'",
        "'http://www.seetickets.com'",
        "'/search'",
        "'yargs'",
        "'Usage: $0 [-v] [-h] [-t type]'",
        "'h'",
        "'h'",
        "'help'",
        "'verbose'",
        "'v'",
        "'Increase verbosity'",
        "'v'",
        "'verbose'",
        "'t'",
        "'comedy'",
        "'t'",
        "'type'",
        "'t'",
        "'Event type to retrieve'",
        "'parsed all events'",
        "'Issue parsing events %s'",
        "'parsing %s events on page %s'",
        "''",
        "'There were no results for your search.'",
        "'article'",
        "'%s events on page %s'",
        "'a'",
        "'href'",
        "'.date-wrap'",
        "'.weekday'",
        "'.day'",
        "'p'",
        "'.result-text >p'",
        "' '",
        "'.supports a'",
        "'p a'",
        "'href'",
        "'requesting venue data for %s: %s'",
        "'poopy'",
        "'.location'",
        "''"
    ],
    "variables": [
        "yargs",
        "util",
        "request",
        "cheerio",
        "JSON_INDENT_SPACES",
        "BASE_URL",
        "SEARCH_URL",
        "RESULTS_PER_PAGE",
        "verbose",
        "argv",
        "$",
        "eventPromises",
        "venueAddresses",
        "eventLink$",
        "date$",
        "artists",
        "venueLink$",
        "venueUrl",
        "$",
        "address"
    ],
    "comments": [
        "Why I don't use semi-colons in JavaScript: http://mislav.uniqpath.com/2010/05/semicolons/",
        "formatting of output",
        "Attempting to change the pageSize query string leads to changes to the text indicating",
        "the desired number of results but the list of events always contains 30 elements",
        "whisper is used for logging status updates when --verbose is used, it writes output to",
        "stderr so that stdout can be used for parsing the json generated from the page",
        "this strategy streams json after each page has been parsed, if I were",
        "to use FRP (bacon.js/rx) then a higher granularity of streaming could be",
        "achieved (with greater concurrency) but I went for an approach that",
        "won't scare off those not used to functional programming.",
        "if the previous page had results then extend the promise with results from",
        "the next page",
        "no more results left",
        "cache of venue address data by relative url to venue",
        "some events span multiple dates and don't list a specific date field",
        "not everything has a venue... e.g. glasgow international comedy venue lists \"many\"",
        "not every venue has a listed address",
        "add cache entry even when there is no address to avoid duplicate requests",
        "live long and prosper"
    ],
    "docstrings": [
        "* Print all pages on after the other.\n * @returns {Promise} Resolves when all events on all pages have been parsed.",
        "* Parse events for given event type and page.\n * @return {Promise} Resolves when all event data for the page has been retrieved.",
        "* Parse the given article, returning a promise as an additional request may have to be\n * made to retrieve the venue address data.\n * @return {Promise} Resolves with given event data."
    ],
    "functions": [
        "whisper",
        "main",
        "printAllEvents",
        "parseEventsOnPage",
        "parseArticle"
    ],
    "classes": []
}