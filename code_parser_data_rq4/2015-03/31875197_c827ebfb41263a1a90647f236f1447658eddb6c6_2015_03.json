{
    "identifiers": [
        "ynab",
        "initialValues",
        "initialValues",
        "EmberBaseObject",
        "EmberBaseObject",
        "EmberBaseObject",
        "className",
        "className",
        "className",
        "className",
        "className",
        "initialValues",
        "initialValues",
        "Ember",
        "curPrototype",
        "curPrototype",
        "nextPrototype",
        "retVal",
        "curPrototype",
        "curPrototype",
        "nextPrototype",
        "retVal",
        "retVal",
        "retVal",
        "prototypeChain",
        "staticMethodToCall",
        "x",
        "prototypeChain",
        "x",
        "prototypeChain",
        "x",
        "currentPrototype",
        "classConstructor",
        "classConstructor",
        "staticMethodToCall",
        "staticMethod",
        "staticMethod",
        "staticMethod",
        "staticMethod",
        "currentPrototype",
        "prototypeChain",
        "EmberBaseObject",
        "prototypeChain",
        "Ember",
        "allPrototypes",
        "firstPrototype",
        "typescriptConstructor",
        "firstPrototype",
        "firstPrototype",
        "typescriptConstructor",
        "Ember",
        "Ember",
        "className",
        "className",
        "Ember",
        "className",
        "x",
        "allPrototypes",
        "x",
        "allPrototypes",
        "x",
        "currentPrototype",
        "Ember",
        "currentPrototype",
        "currentPrototype",
        "initialValues",
        "EmberBaseObject",
        "Ember",
        "emberClass",
        "EmberBaseObject",
        "retVal",
        "EmberBaseObject",
        "retVal",
        "initialValues",
        "retVal",
        "metaValues",
        "obj",
        "Ember",
        "keyName",
        "keyName",
        "SETTER_FUNCTION",
        "value",
        "Ember",
        "keyName",
        "obj",
        "value",
        "keyName",
        "GETTER_FUNCTION",
        "obj",
        "meta",
        "meta",
        "keyName",
        "obj",
        "keyName",
        "descriptor",
        "descriptor",
        "descriptor",
        "descriptor",
        "descriptor",
        "descriptor",
        "descriptor",
        "descriptor",
        "possibleDesc",
        "possibleDesc",
        "possibleDesc",
        "isDescriptor",
        "keyName",
        "configurable",
        "isWritable",
        "hasValue",
        "keyName",
        "obj",
        "metaValues",
        "keyName",
        "obj",
        "keyName",
        "obj",
        "keyName",
        "obj",
        "keyName",
        "getSetterFunction",
        "keyName",
        "getGetterFunction",
        "keyName",
        "keyName",
        "obj",
        "obj",
        "Ember",
        "obj",
        "meta",
        "meta",
        "values",
        "meta",
        "watching",
        "_",
        "watching",
        "value",
        "keyName",
        "EmberBaseObject",
        "values",
        "obj",
        "keyName",
        "successful",
        "obj",
        "keyName",
        "objToInitialize",
        "prop",
        "val",
        "initialValues",
        "initialValues",
        "tempProp",
        "initialValues",
        "initialValues",
        "tempProp",
        "objToInitialize",
        "tempProp",
        "initialValues",
        "tempProp",
        "propName",
        "value",
        "propName",
        "value",
        "value",
        "EmberBaseObject",
        "prototype",
        "prototype",
        "propName",
        "propName",
        "value",
        "Ember",
        "keyName",
        "keyName",
        "decrement",
        "Ember",
        "args",
        "keyName",
        "defaultValue",
        "key",
        "keyName",
        "increment",
        "keyName",
        "Ember",
        "keyName",
        "Ember",
        "keyName",
        "Ember",
        "key",
        "target",
        "method",
        "Ember",
        "hash",
        "Ember",
        "keyName"
    ],
    "literals": [
        "'use strict'",
        "string",
        "\"name\"",
        "\"ClassName\"",
        "This class must be constructed using '${className}.createInstance()'. You can't just call 'new ${className}()' on it.",
        "string",
        "\"emberPrototypeConstructor\"",
        "\"undefined\"",
        "\"init\"",
        "\"undefined\"",
        "\"You cannot define an 'init' method on this object. Use a normal typescript constructor instead.\"",
        "\"init\"",
        "string",
        "\"name\"",
        "\"__originalEmberCreate\"",
        "\"__originalEmberCreate\"",
        "string",
        "string",
        "You must use the 'set()' method to set the '${keyName}' property (of ${obj}) to '${value}'.",
        "string",
        "'__ember_meta__'",
        "'value'",
        "'object'",
        "\"isDescriptor for \"",
        "\"Property '\"",
        "\"' doesn't exist on \"",
        "\". Are you observing a property that isn't defined?\"",
        "'__ember_meta__'",
        "\"values\"",
        "\"watching\"",
        "string",
        "Could not set up the mandatory setter for ${obj} : ${keyName}",
        "string",
        "\"undefined\"",
        "string",
        "'get'",
        "'set'",
        "string",
        "\"If you are in this 'get' method, you've done something wrong. You probably forgot to use the static 'create' method.\"",
        "string",
        "\"If you are in this 'set' method, you've done something wrong. You probably forgot to use the static 'create' method.\"",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string"
    ],
    "variables": [
        "className",
        "retVal",
        "curPrototype",
        "nextPrototype",
        "x",
        "currentPrototype",
        "classConstructor",
        "staticMethod",
        "allPrototypes",
        "firstPrototype",
        "typescriptConstructor",
        "className",
        "x",
        "currentPrototype",
        "emberClass",
        "retVal",
        "meta",
        "descriptor",
        "configurable",
        "isWritable",
        "hasValue",
        "possibleDesc",
        "isDescriptor",
        "meta",
        "values",
        "watching",
        "successful",
        "prototype"
    ],
    "comments": [
        "<reference path='typings/ember/ember.d.ts' />",
        "<reference path='typings/lodash/lodash.d.ts' />",
        "Nothing to do here really",
        "Let's just make sure that they are not just calling 'new MyClass()' but are using the EmberBaseObject methods instead",
        "First, we prop it back up to where it was so that we don't prevent EVERY object from being created from now on",
        "Not all browsers (IE) support the name property",
        "asdfsdf",
        "This is protected so that derived classes can override createInstance and make use of this method if they really want to.",
        "You probably just want to be calling createInstance though.",
        "Note: There will be a different _emberClass variable for each type on which you call \"getEmberClass\"",
        "So, if you call BaseClass.getEmberClass() you'll get a different class than if you call DerivedClass.getEmberClass()",
        "This is a sentinal to determine whether we're calling this object's constructor directly or are using the 'create' method as we should",
        "Gets all of the prototypes in the inheritance chain, starting with the base class (excluding the default Object prototype)",
        "and ending with the most derived class",
        "We keep pushing prototypes onto the result until our next prototype is null",
        "That means we've reached the \"Object\" prototype, so it's not necessary to put on the chain",
        "We start with our base prototype and call that one first. Then we go to our next class.",
        "That means we walk from base classes down to derived classes.",
        "That way, derived prototype functions/properties will correctly override the base properties of the same name",
        "We use the constructor for the \"this\" parameter",
        "That way, if you're in SomeClass::emberPrototypeConstructor",
        "The \"this\" will be SomeClass and not something else.",
        "In a static method, \"this\" is the class on which we are calling \"getEmberClass\"",
        "So if you call MyClass.getEmberClass, \"this\" will be \"MyClass\", and",
        "MyClass._emberClass is different than SomeOtherClass._emberClass",
        "All Typescript types have a prototype field we can reference",
        "Ember will call the init function on an object",
        "So, we need to make sure that this object has an \"init\" function",
        "That will call the typescript constructor, if there is one",
        "Have they already defined an \"init\" method? Let's make sure we don't override it",
        "To set this object's name in Ember, we have two options:",
        "1: Use namespaces. We could add each of these classes to a namespace like EmberObjects",
        "Then, we'd call Ember.processNamespace on the namespace",
        "However, that does a linear search through the namespace each time you process it,",
        "so I'd rather not do that with every object we create.",
        "",
        "2: Just fake it and do what Ember would do.",
        "That's what the below does. It sets the toString method to be the className, and also",
        "sets a magic class[Ember.NAME_KEY].",
        "Ember appears to use these to get the name of the object at runtime.",
        "To see where I copied this code, have a look at the `processNamespace` method in Ember.",
        "`name` is an ES6 feature. It might very well not exist, but if you're debugging in a modern",
        "browser, this is still helpful.",
        "We walk from our deepest prototype up to our top prototype",
        "That means we walk from base classes down to derived classes",
        "That way, derived prototype functions/properties will correctly override the base properties of",
        "the same name",
        "TODO: This copy is probably overly cautious. It used to be necessary when I was maniupulating",
        "this particular prototype here, but I am no longer.",
        "We have to create the object in Ember and THEN initialize it",
        "That's because the way Ember does the initialization interferes with the way the Typescript",
        "constructors work. If we rely only upon Ember to do the initialization, we miss out on the ability",
        "for the TypeScript object to do the initialization",
        "We always add one to this right before we construct, and then the constructor removes 1 from it",
        "If we ever remove more than we add, we know that at some point, someone has called 'new' on this",
        "object instead of using the `createInstance` method.",
        "This is basically a copy-paste from Ember 1.10",
        "In normal Ember object creation, this function runs early on in object creation time.",
        "However, when Ember is creating our Typescript objects, it doesn't get a chance to define",
        "properties that typescript initializes.",
        "If Ember is using mandatory setters, we need to set up MandatorySetters on our object",
        "(We used to just turn mandatory setters off, but that is no longer an option because the Ember",
        "team compiles that setting in)",
        "Here we need to define the getter function for this property so that it knows to return meta.values[key] instead of the underlying value",
        "this x in Y deopts, so keeping it in this function is better;",
        "More details about the above:",
        "In Ember's set function, it first looks to make sure that obj[key] != the new value we're setting it to",
        "But if we haven't defined a getter for obj[key], it will look directly at the object's property value instead",
        "of looking at meta.values. (meta.values are where the mandatory-setter system shadows all property values)",
        "So, imagine you had an observed property called \"stringProp\" with a value of \"foo\"",
        "That value is actually stored in meta.values[\"stringProp\"], although obj[\"stringProp\"] will still happen to have a value",
        "obj[\"stringProp\"] is what the set method will accidentally look at when determining if it can early-out of the set function",
        "So, imagine you're trying to set obj[\"stringProp\"] back to null, and obj[\"stringProp\"] happens to still be null,",
        "but meta.values[\"stringProp\"] isn't.",
        "Ember will conclude there is nothing to do, and your set won't actually happen!",
        "If we're in development mode, we need to work around a bug in Ember's mandatory-setter,",
        "As I reported here: https://github.com/emberjs/ember.js/issues/10252",
        "Basically, if we're watching properties that are only defined in Typescript,",
        "and have never had `.set` called for them, Ember will return `undefined` for their value because",
        "their values haven't been shadowed in meta.values yet",
        "In addition, there is a separate issue (see below)",
        "These values are only there if we are in Ember debug mode, and have mandatory setters on",
        "If you don't use lodash or underscore, you can make this a simpler \"for in\" loop instead",
        "We use lodash, and it's \"faster\", so this is what we do:",
        "If we had a normal Ember object, we would have defined these properties in the prototype,",
        "and Ember would have already defined this property's getters and setters to prevent writing directly to it.",
        "(Because of mandatory-setter)",
        "But even if we could convince ember to create these setters/getters for us, we wouldn't want to.",
        "That's because Typescript constructors just call set directly on the properties, and having a mandatory setter",
        "function for those properties would prevent that from happening",
        "So we now create these getter/setters ourselves AFTER the Typescript has run",
        "I think this is bad if this doesn't happen, so we're going to freak out",
        "I have commented out for now since not everyone will want this",
        "private unknownProperty(propName: string, value: any): any {\n\n            // If we're here, it's because a \"get\" just returned a value of \"undefined\"\n            // There are only two ways that can happen:\n            // 1) We are trying to \"get\" a value that we haven't assigned a value yet,\n            // 2) We misspelled the name of the value we're trying to get\n            // Either way, this is a great way to make sure that we are not making a dumb mistake\n            // So, we warn about it\n\n            // isTruthy is called a lot on objects by handleBars/Ember, and it's not worthy of a warning\n            if (propName !== \"isTruthy\")\n                ynab.utilities.ConsoleUtilities.warning(`An unknown property is being get : '${this}.${propName}. The property name is either misspelled, or you forgot to give it a default value in the Typescript class.`);\n\n            return undefined;\n        }",
        "If we're here, it's because we're trying to set a property that doesn't exist on the object",
        "This is a great way to make sure that we are not making a dumb mistake",
        "So, we warn about it",
        "ynab.utilities.ConsoleUtilities.warning(`An unknown property is being set : '${this}.${propName}' The property name is either misspelled, or you forgot to give it a default value in the Typescript class.\\n` +",
        "'It will be defined as normal, but you should fix this.');",
        "Get rid of the \"fake\" get and set methods defined below",
        "The get and set methods tell the Typescript compiler that instances of this class will indeed have these methods at runtime.",
        "They are also there to catch us if we just create this object with `new` instead of using `create`",
        "The following method will be replaced at runtime by Ember.Object.get",
        "The following method will be replaced at runtime by Ember.Object.set",
        "Other methods that will be available on this instance at runtime",
        "(Taken from ember.d.ts in the DefinitelyTyped project)",
        "There are two potential signatures for getProperties, and I'm not sure how to declare this",
        "overloaded signature when declaring methods like this.",
        "public getProperties:(keys: string[])=> {};"
    ],
    "docstrings": [
        "* EmberBaseObject is a base class that you can inherit from in Typescript.\n     * It provides your derived class with a _static_ method \"create\", from which you can create\n     * instances of your class.\n     * Note: Using the normal constructor for your class is not supported, and will throw an exceotion.\n     *\n     * Sometimes you will need to modify your class prototype before the first instance is created\n     * To do that, create a static function called `emberPrototypeConstructor`, like so:\n     *\n     * export class MyClass {\n     *    protected static emberPrototypeConstructor() {\n     *       var classPrototype:MyClass = (<typeof MyClass>this).prototype;\n     *       // You are now free to modify the functions defined on this prototype.\n     *       // Say you want to modify a method defined on the prototype to be a computed property:\n     *       classPrototype.myComputedProperty = <any>classPrototype.myComputedProperty.property(\"dependentProperty\").readOnly();\n     *       }\n     * }\n     *\n     * More examples can be found in the project readme.",
        "* You can optionally pass in a type to explicitly show that this Type is going to be returned\n         * for example:\n         * var instance:MyDerivedClass = MyDerivedClass.createEmberInstance<MyDerivedClass>();",
        "* Called by Ember when a property is requested that is unknown to Ember\n         * Used to warn that this is most likely a mistake.\n         * The most common way that this happens is declaring a property in Typescript without initializing it.\n         * Wrong: public val : number;\n         * Right: public val : number = 5;\n         *\n         * @param propName\n         * @returns {undefined}",
        "* Called by Ember when a property is set that is unknown to Ember\n         * Used to warn that this is most likely a mistake.\n         * The most common way that this happens is declaring a property in Typescript without initializing it.\n         * Wrong: public val : number;\n         * Right: public val : number = 5;\n         *\n         * @param propName\n         * @returns {undefined}"
    ],
    "functions": [
        "createInstance",
        "createAsEmberObject",
        "getAllPrototypesFromBaseToMostDerived",
        "callStaticMethodOnAllPrototypeObjects",
        "callAllEmberPrototypeConstructorsInInheritanceChain",
        "getEmberClass",
        "handleMandatorySetter",
        "getSetterFunction",
        "getGetterFunction",
        "createMandatorySettersForObject",
        "initializeObjectWithValues",
        "setUnknownProperty",
        "emberPrototypeConstructor",
        "get"
    ],
    "classes": [
        "EmberBaseObject"
    ]
}