{
    "identifiers": [
        "fs",
        "length",
        "length",
        "length",
        "buffer",
        "length",
        "length",
        "length",
        "length",
        "length",
        "buffer",
        "length",
        "length",
        "length",
        "bytesSkipped",
        "BufferedBufferReader",
        "input",
        "encoding",
        "Buffer",
        "input",
        "encoding",
        "Buffer",
        "fd",
        "file_position",
        "filepath",
        "fs",
        "filepath",
        "BufferedFileReader",
        "fd",
        "fs",
        "buffer",
        "offset",
        "length",
        "position",
        "fs",
        "buffer",
        "offset",
        "length",
        "position",
        "length",
        "length",
        "BufferedFileReader",
        "EOF",
        "length",
        "Buffer",
        "length",
        "buffer",
        "length",
        "bytesRead",
        "Buffer",
        "buffer",
        "bytesRead",
        "bytesRead",
        "length",
        "length",
        "length",
        "length",
        "length",
        "length",
        "length",
        "buffer",
        "length",
        "length",
        "length",
        "length",
        "bytesSkipped",
        "match",
        "default_rules",
        "state_rules",
        "index",
        "state",
        "state",
        "rule",
        "rules",
        "i",
        "i",
        "input",
        "rule",
        "match",
        "Buffer",
        "match",
        "byteLength",
        "rule",
        "match",
        "input",
        "state",
        "result",
        "result",
        "result"
    ],
    "literals": [
        "'fs'",
        "string",
        "string",
        "string",
        "string",
        "'r'",
        "string",
        "string",
        "string",
        "'utf8'",
        "'utf8'",
        "Invalid language; could not find a match in input \"${input}\" while in state \"${state}\""
    ],
    "variables": [
        "buffer",
        "bytesSkipped",
        "fd",
        "EOF",
        "buffer",
        "bytesRead",
        "buffer",
        "bytesSkipped",
        "input",
        "state",
        "rules",
        "i",
        "rule",
        "match",
        "byteLength",
        "result"
    ],
    "comments": [
        "<reference path=\"type_declarations/DefinitelyTyped/node/node.d.ts\" />",
        "export module lexing {",
        "#############################################################################",
        "READERS",
        "Reads a single byte.",
        "Reads a series of bytes.",
        "Skip over the next `length` characters, returning the number of skipped\n  characters (which may be < `length` iff EOF has been reached).",
        "we cannot skip more than `this.buffer.length` bytes",
        "#############################################################################",
        "FILE READERS",
        "Provide buffered (and Buffer-friendly) access to a file.",
        "when reading more data, pull in chunks of `BLOCK_SIZE` bytes.",
        "Calls fs.readSync on the underlying file descriptor with pretty much the same\n  argument signature.\n\n  Returns `bytesRead`, the number of bytes that were read into the given Buffer.\n\n  Node.js documentation for fs.read() / fs.readSync():\n  > position is an integer specifying where to begin reading from in the file.\n  > If position is null, data will be read from the current file position.",
        "Ensure that the available buffer is at least `length` bytes long.\n\n  This may return without the condition being met of this.buffer.length >= length,\n  if the end of the underlying file has been reached.",
        "all the action happens only if we need more bytes than are in the buffer",
        "exit regardless",
        "Read data from the underlying file and append it to the buffer.\n\n  Returns false iff EOF has been reached, otherwise returns true.",
        "always read from the reader's current position",
        "and update it accordingly",
        "use the Buffer.concat totalLength argument to slice the fresh buffer if needed",
        "Skip over the next `length` characters, returning the number of skipped\n  characters (which may be < `length` iff EOF has been reached).",
        "we cannot skip more than `this.buffer.length` bytes",
        "#############################################################################",
        "LEXERS",
        "Reset the Lexer back to its initial state.",
        "Returns the next available pair from the input reader (usually [token, data]).\n\n  If the matching rule's action returns null, this will return null.",
        "TODO: abstract out the peekBuffer + toString, back into the reader?",
        "optimize string conversion",
        "Returns the next available non-null token / symbol output from the input\n  reader (usually a token_data: [string, any] tuple).\n\n  This will never return null.",
        "}"
    ],
    "docstrings": [],
    "functions": [
        "peekByte",
        "peekBuffer",
        "readByte",
        "readBuffer",
        "skip",
        "toString",
        "open",
        "close",
        "read",
        "ensureLength",
        "fillBuffer",
        "peekByte",
        "peekBuffer",
        "readByte",
        "readBuffer",
        "skip",
        "reset",
        "read",
        "next"
    ],
    "classes": [
        "BufferedBufferReader",
        "BufferedStringReader",
        "BufferedFileReader",
        "BufferedLexer"
    ]
}