{
    "identifiers": [
        "asyncio",
        "asyncio",
        "queues",
        "QueueEmpty",
        "asyncio",
        "tasks",
        "copy",
        "datetime",
        "functools",
        "wraps",
        "itertools",
        "json",
        "decoder",
        "JSONDecodeError",
        "logging",
        "traceback",
        "typing",
        "Callable",
        "Optional",
        "Union",
        "httpx",
        "pydantic",
        "reasoner_pydantic",
        "Response",
        "ReasonerResponse",
        "uuid",
        "trapi",
        "BatchingError",
        "get_curies",
        "remove_curies",
        "filter_by_curie_mapping",
        "utils",
        "get_keys_with_value",
        "log_request",
        "log_response",
        "logging",
        "getLogger",
        "pydantic",
        "main",
        "BaseModel",
        "pydantic",
        "AnyHttpUrl",
        "datetime",
        "timedelta",
        "fcn",
        "wraps",
        "fcn",
        "args",
        "kwargs",
        "fcn",
        "args",
        "kwargs",
        "err",
        "traceback",
        "print_exc",
        "wrapper",
        "arg",
        "args",
        "kwargs",
        "arg",
        "id",
        "url",
        "request_qty",
        "request_duration",
        "args",
        "max_batch_size",
        "Optional",
        "timeout",
        "preproc",
        "Callable",
        "anull",
        "postproc",
        "Callable",
        "anull",
        "logger",
        "logging",
        "Logger",
        "kwargs",
        "id",
        "Optional",
        "asyncio",
        "PriorityQueue",
        "itertools",
        "count",
        "url",
        "request_qty",
        "datetime",
        "timedelta",
        "seconds",
        "request_duration",
        "timeout",
        "max_batch_size",
        "preproc",
        "postproc",
        "logger",
        "logging",
        "getLogger",
        "logger",
        "log_errors",
        "request_qty",
        "request_duration",
        "request_qty",
        "datetime",
        "datetime",
        "utcnow",
        "interval",
        "request_id",
        "payload",
        "response_queue",
        "request_queue",
        "get",
        "request_id",
        "priority",
        "request_id",
        "payload",
        "request_id",
        "response_queue",
        "max_batch_size",
        "len",
        "request_value_mapping",
        "max_batch_size",
        "request_id",
        "payload",
        "response_queue",
        "request_queue",
        "get_nowait",
        "QueueEmpty",
        "priority",
        "payload",
        "response_queue",
        "LOGGER",
        "debug",
        "len",
        "request_value_mapping",
        "id",
        "request_id",
        "get_curies",
        "request_value",
        "request_id",
        "request_value",
        "request_value_mapping",
        "items",
        "request_id",
        "remove_curies",
        "request",
        "request_id",
        "request",
        "request_value_mapping",
        "items",
        "next",
        "iter",
        "stripped_qgraphs",
        "values",
        "get_keys_with_value",
        "stripped_qgraphs",
        "first_value",
        "request_id",
        "request_value_mapping",
        "request_id",
        "batch_request_ids",
        "request_queue",
        "put",
        "priorities",
        "request_id",
        "request_id",
        "request_value_mapping",
        "request_id",
        "response_queues",
        "request_id",
        "k",
        "v",
        "k",
        "v",
        "request_value_mapping",
        "items",
        "k",
        "batch_request_ids",
        "k",
        "v",
        "k",
        "v",
        "request_curie_mapping",
        "items",
        "k",
        "batch_request_ids",
        "copy",
        "deepcopy",
        "next",
        "iter",
        "request_value_mapping",
        "values",
        "qnode",
        "merged_request_value",
        "values",
        "qnode",
        "pop",
        "curie_mapping",
        "request_curie_mapping",
        "values",
        "node_id",
        "node_curies",
        "curie_mapping",
        "items",
        "merged_request_value",
        "node_id",
        "node",
        "node",
        "extend",
        "node_curies",
        "qnode",
        "merged_request_value",
        "values",
        "qnode",
        "get",
        "qnode",
        "logger",
        "info",
        "format",
        "id",
        "id",
        "subrequests",
        "len",
        "request_curie_mapping",
        "curies",
        "join",
        "len",
        "qnode",
        "get",
        "qnode",
        "merged_request_value",
        "values",
        "logger",
        "id",
        "preproc",
        "merged_request_value",
        "logger",
        "httpx",
        "AsyncClient",
        "client",
        "client",
        "post",
        "url",
        "json",
        "merged_request_value",
        "timeout",
        "timeout",
        "response",
        "status_code",
        "request_duration",
        "request_qty",
        "datetime",
        "datetime",
        "utcnow",
        "interval",
        "request_id",
        "request_value_mapping",
        "request_queue",
        "put",
        "priorities",
        "request_id",
        "request_id",
        "request_value_mapping",
        "request_id",
        "response_queues",
        "request_id",
        "response",
        "raise_for_status",
        "ReasonerResponse",
        "parse_obj",
        "response",
        "json",
        "postproc",
        "response",
        "response",
        "message",
        "get",
        "logger",
        "info",
        "id",
        "len",
        "results",
        "request_id",
        "curie_mapping",
        "request_curie_mapping",
        "items",
        "filter_by_curie_mapping",
        "message",
        "curie_mapping",
        "kp_id",
        "id",
        "request_value_mapping",
        "request_id",
        "kgraph",
        "results",
        "BatchingError",
        "err",
        "err",
        "asyncio",
        "exceptions",
        "TimeoutError",
        "httpx",
        "RequestError",
        "httpx",
        "HTTPStatusError",
        "JSONDecodeError",
        "pydantic",
        "ValidationError",
        "e",
        "request_id",
        "curie_mapping",
        "request_curie_mapping",
        "items",
        "request_value_mapping",
        "request_id",
        "isinstance",
        "e",
        "asyncio",
        "TimeoutError",
        "logger",
        "warning",
        "id",
        "e",
        "merged_request_value",
        "isinstance",
        "e",
        "httpx",
        "ReadTimeout",
        "logger",
        "warning",
        "id",
        "e",
        "log_request",
        "e",
        "request",
        "isinstance",
        "e",
        "httpx",
        "RequestError",
        "logger",
        "warning",
        "id",
        "e",
        "log_request",
        "e",
        "request",
        "isinstance",
        "e",
        "httpx",
        "HTTPStatusError",
        "logger",
        "warning",
        "id",
        "e",
        "log_request",
        "e",
        "request",
        "log_response",
        "e",
        "response",
        "isinstance",
        "e",
        "JSONDecodeError",
        "logger",
        "warning",
        "id",
        "e",
        "request",
        "e",
        "response",
        "text",
        "e",
        "isinstance",
        "e",
        "pydantic",
        "ValidationError",
        "logger",
        "warning",
        "id",
        "e",
        "logger",
        "warning",
        "id",
        "e",
        "request_id",
        "response_value",
        "response_values",
        "items",
        "response_queues",
        "request_id",
        "put",
        "response_value",
        "request_qty",
        "tat",
        "datetime",
        "datetime",
        "utcnow",
        "total_seconds",
        "time_remaining_seconds",
        "LOGGER",
        "debug",
        "time_remaining_seconds",
        "asyncio",
        "sleep",
        "time_remaining_seconds",
        "datetime",
        "datetime",
        "utcnow",
        "interval",
        "asyncio",
        "get_event_loop",
        "loop",
        "create_task",
        "process_batch",
        "args",
        "worker",
        "task",
        "cancel",
        "task",
        "asyncio",
        "CancelledError",
        "LOGGER",
        "debug",
        "task",
        "query",
        "priority",
        "timeout",
        "Optional",
        "worker",
        "RuntimeError",
        "uuid",
        "uuid1",
        "asyncio",
        "request_queue",
        "put",
        "priority",
        "next",
        "counter",
        "request_id",
        "query",
        "response_queue",
        "Union",
        "asyncio",
        "wait_for",
        "response_queue",
        "get",
        "timeout",
        "timeout",
        "isinstance",
        "output",
        "output",
        "output",
        "args",
        "kwargs",
        "ThrottledServer",
        "kp_id",
        "kp_info",
        "kp_id",
        "servers",
        "DuplicateError",
        "kp_id",
        "servers",
        "ThrottledServer",
        "kp_id",
        "kp_info",
        "servers",
        "kp_id",
        "__aenter__",
        "kp_id",
        "servers",
        "pop",
        "kp_id",
        "__aexit__",
        "kp_id",
        "query",
        "servers",
        "kp_id",
        "query",
        "query"
    ],
    "literals": [
        "f\"Processing batch of size {len(request_value_mapping)} for KP {self.id}\"",
        "\"message\"",
        "\"query_graph\"",
        "\"message\"",
        "\"query_graph\"",
        "\"message\"",
        "\"query_graph\"",
        "\"nodes\"",
        "\"ids\"",
        "\"message\"",
        "\"query_graph\"",
        "\"nodes\"",
        "\"ids\"",
        "\"ids\"",
        "\"ids\"",
        "\"message\"",
        "\"query_graph\"",
        "\"nodes\"",
        "\"ids\"",
        "\"ids\"",
        "\"ids\"",
        "\"[{id}] Sending request made of {subrequests} subrequests ({curies} curies)\"",
        "\" x \"",
        "\"ids\"",
        "\"message\"",
        "\"query_graph\"",
        "\"nodes\"",
        "\"message\"",
        "\"results\"",
        "f\"[{self.id}] Received response with {len(results)} results\"",
        "\"message\"",
        "\"query_graph\"",
        "\"message\"",
        "\"query_graph\"",
        "\"knowledge_graph\"",
        "\"results\"",
        "\"message\"",
        "\"message\"",
        "\"message\"",
        "f\"{self.id} took >60 seconds to respond\"",
        "\"error\"",
        "\"request\"",
        "\"message\"",
        "f\"{self.id} took >60 seconds to respond\"",
        "\"error\"",
        "\"request\"",
        "\"message\"",
        "f\"Request Error contacting {self.id}\"",
        "\"error\"",
        "\"request\"",
        "\"message\"",
        "f\"Response Error contacting {self.id}\"",
        "\"error\"",
        "\"request\"",
        "\"response\"",
        "\"message\"",
        "f\"Received bad JSON data from {self.id}\"",
        "\"request\"",
        "\"response\"",
        "\"error\"",
        "\"message\"",
        "f\"Received non-TRAPI compliant response from {self.id}\"",
        "\"error\"",
        "\"message\"",
        "f\"Something went wrong while querying {self.id}\"",
        "\"error\"",
        "f\"Waiting {time_remaining_seconds} seconds\"",
        "f\"Task cancelled: {task}\"",
        "\"Cannot send a request until a worker is running - enter the context\"",
        "f\"{kp_id} already exists\""
    ],
    "variables": [
        "LOGGER",
        "url",
        "request_qty",
        "request_duration",
        "id",
        "worker",
        "request_queue",
        "counter",
        "url",
        "request_qty",
        "request_duration",
        "timeout",
        "max_batch_size",
        "preproc",
        "postproc",
        "logger",
        "logger",
        "interval",
        "tat",
        "priority",
        "priorities",
        "request_value_mapping",
        "response_queues",
        "priority",
        "priorities",
        "request_id",
        "request_value_mapping",
        "request_id",
        "response_queues",
        "request_id",
        "request_curie_mapping",
        "stripped_qgraphs",
        "first_value",
        "batch_request_ids",
        "request_value_mapping",
        "request_curie_mapping",
        "merged_request_value",
        "node",
        "node",
        "qnode",
        "response_values",
        "context",
        "merged_request_value",
        "response",
        "interval",
        "tat",
        "response",
        "response",
        "message",
        "results",
        "kgraph",
        "results",
        "response_values",
        "request_id",
        "response_values",
        "request_id",
        "response_values",
        "request_id",
        "time_remaining_seconds",
        "tat",
        "loop",
        "worker",
        "task",
        "worker",
        "request_id",
        "response_queue",
        "output",
        "servers",
        "kp_id"
    ],
    "comments": [
        "Initialize the TAT",
        "",
        "TAT = Theoretical Arrival Time",
        "When the next request should be sent",
        "to adhere to the rate limit.",
        "",
        "This is an implementation of the GCRA algorithm",
        "More information can be found here:",
        "https://dev.to/astagi/rate-limiting-using-python-and-redis-58gk",
        "Get everything in the stream or wait for something to show up",
        "Extract a curie mapping from each request",
        "Find requests that are the same (those that we can merge)",
        "This disregards non-matching IDs because the IDs have been",
        "removed with the extract_curie method",
        "Re-queue the un-selected requests",
        "Filter curie mapping to only include matching requests",
        "Pull first value from request_value_mapping",
        "to use as a template for our merged request",
        "Remove qnode ids",
        "Update merged request using curie mapping",
        "Make request",
        "reset TAT",
        "re-queue requests",
        "try again later",
        "Parse with reasoner_pydantic to validate",
        "Split using the request_curie_mapping",
        "the response is probably malformed",
        "Log error",
        "Log error with response",
        "Log error with response",
        "Write finished value to DB",
        "if request_qty == 0 we don't enforce the rate limit",
        "Wait for TAT",
        "Update TAT",
        "lowest goes first",
        "Queue query for processing",
        "Wait for response"
    ],
    "docstrings": [
        "\"\"\"Server routes\"\"\"",
        "\"\"\"Do nothing, asynchronously.\"\"\"",
        "\"\"\"Throttled server.\"\"\"",
        "\"\"\"Initialize.\"\"\"",
        "\"\"\"Set up a subscriber to process batching\"\"\"",
        "\"\"\"Set KP info and start processing task.\"\"\"",
        "\"\"\"Cancel KP processing task.\"\"\"",
        "\"\"\" Queue up a query for batching and return when completed \"\"\"",
        "\"\"\"Duplicate KP.\"\"\"",
        "\"\"\"TRAPI Throttle.\"\"\"",
        "\"\"\"Initialize.\"\"\"",
        "\"\"\"Set KP info and start processing task.\"\"\"",
        "\"\"\"Cancel KP processing task.\"\"\"",
        "\"\"\" Queue up a query for batching and return when completed \"\"\""
    ],
    "functions": [
        "log_errors",
        "wrapper",
        "anull",
        "process_batch",
        "__aenter__",
        "__aexit__",
        "query",
        "register_kp",
        "unregister_kp",
        "query"
    ],
    "classes": [
        "KPInformation",
        "ThrottledServer",
        "DuplicateError",
        "Throttle"
    ]
}