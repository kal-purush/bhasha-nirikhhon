{
    "identifiers": [
        "dataclasses",
        "dataclass",
        "dataclass",
        "key",
        "key",
        "node",
        "node",
        "node",
        "height",
        "node",
        "node",
        "get_height",
        "node",
        "left",
        "get_height",
        "node",
        "right",
        "root",
        "root",
        "left",
        "new_root",
        "right",
        "root",
        "r_t",
        "max",
        "get_height",
        "root",
        "left",
        "get_height",
        "root",
        "right",
        "max",
        "get_height",
        "new_root",
        "left",
        "get_height",
        "new_root",
        "right",
        "new_root",
        "key",
        "new_root",
        "left",
        "new_root",
        "right",
        "new_root",
        "root",
        "root",
        "right",
        "new_root",
        "left",
        "root",
        "l_t",
        "max",
        "get_height",
        "root",
        "left",
        "get_height",
        "root",
        "right",
        "max",
        "get_height",
        "new_root",
        "left",
        "get_height",
        "new_root",
        "right",
        "new_root",
        "key",
        "new_root",
        "left",
        "key",
        "new_root",
        "right",
        "key",
        "new_root",
        "root_node",
        "node",
        "root_node",
        "node",
        "node",
        "key",
        "root_node",
        "key",
        "insert",
        "root_node",
        "left",
        "node",
        "insert",
        "root_node",
        "right",
        "node",
        "max",
        "get_height",
        "root_node",
        "left",
        "get_height",
        "root_node",
        "right",
        "balancing_factor",
        "root_node",
        "bf",
        "node",
        "key",
        "root_node",
        "left",
        "key",
        "Print",
        "rightRotate",
        "root_node",
        "leftRotate",
        "root_node",
        "left",
        "rightRotate",
        "root_node",
        "bf",
        "node",
        "key",
        "root_node",
        "right",
        "key",
        "leftRotate",
        "root_node",
        "rightRotate",
        "root_node",
        "right",
        "leftRotate",
        "root_node",
        "root_node",
        "start_node",
        "start_node",
        "inorder_travs",
        "start_node",
        "left",
        "start_node",
        "key",
        "inorder_travs",
        "start_node",
        "right",
        "root",
        "root",
        "Postorder_travs",
        "root",
        "left",
        "Postorder_travs",
        "root",
        "right",
        "root",
        "key",
        "root",
        "root",
        "root",
        "key",
        "preorder_travs",
        "root",
        "left",
        "preorder_travs",
        "root",
        "right",
        "root",
        "node",
        "AVL",
        "Tree",
        "insert",
        "root",
        "TreeNode",
        "Tree",
        "insert",
        "root",
        "TreeNode",
        "Tree",
        "insert",
        "root",
        "TreeNode",
        "Tree",
        "insert",
        "root",
        "TreeNode",
        "Tree",
        "insert",
        "root",
        "TreeNode",
        "Tree",
        "insert",
        "root",
        "TreeNode",
        "Tree",
        "preorder_travs",
        "root"
    ],
    "literals": [
        "\"inside right rotate\"",
        "\"new_root key = \"",
        "\"new_root left = \"",
        "\"new_root right = \"",
        "\"inside left rotate\"",
        "\"new_root key = \"",
        "\"new_root left = \"",
        "\"new_root right = \"",
        "\"performing right rotate\"",
        "\"performing left right rorate\"",
        "\"performing left rotate rr\"",
        "\"performing right left rotatae rr\"",
        "\"inserting -- \"",
        "\"inserting -- \"",
        "\"inserting -- \""
    ],
    "variables": [
        "left",
        "right",
        "key",
        "height",
        "key",
        "left",
        "right",
        "height",
        "new_root",
        "r_t",
        "new_root",
        "right",
        "root",
        "left",
        "root",
        "height",
        "new_root",
        "height",
        "new_root",
        "l_t",
        "new_root",
        "left",
        "root",
        "right",
        "root",
        "height",
        "new_root",
        "height",
        "root_node",
        "left",
        "root_node",
        "right",
        "root_node",
        "height",
        "bf",
        "root_node",
        "left",
        "root_node",
        "right",
        "A",
        "B",
        "root",
        "Tree",
        "root",
        "root",
        "root",
        "root",
        "root",
        "root"
    ],
    "comments": [
        "!/usr/bin/env python",
        "coding: utf-8",
        "In[3]:",
        "In[157]:",
        "r_t = left/'new node'( going to be root node)'s right child",
        "now swap, make left as root by moveing root to left.right ( this is why we store r_t so that we dont lose left.right actual value)",
        "move left.right's older value ( before swap) to the swapped curRoot nodes right left child which is now free ( earlier it was 'new node')",
        "r_t = left/'new node'( going to be root node)'s left child",
        "now swap, make rihgt as root by moveing root to right's.left ( this is why we store l_t so that we dont lose right.left's actual value)",
        "move left.right's older value ( before swap) to the swapped curRoot nodes right left child which is now free ( earlier it was 'new node')",
        "check if node is present in left subtree or right subtree",
        "get the balancing factor of the root node and check if it >1 or <1. if true, the tree is imbalnced with the current",
        "root node and balance and move up the treebalancing upper root nodes if they are imbalanced",
        "imbalance due to either LL or LR",
        "if the node exists, then left, root, right",
        "if the node exists then left, right, root",
        "if the node exists then left, right, root",
        "In[158]:",
        "for i in range(0, len(B)):",
        "print(\"inserting --\", B[i])",
        "root = Tree.insert(root, TreeNode(B[i]))",
        "print(\"root = \", root)",
        "print(\"root = \", root.key)",
        "print(\"root = \", root.key)",
        "print(\"root = \", root.key)",
        "print(\"root = \", root.key)",
        "print(\"root = \", root.key)",
        "print(\"root = \", root.key)",
        "print(root.key)",
        "print(root.left.key)",
        "print(root.right.key)",
        "print((root.right).right.key)",
        "In[ ]:",
        "In[ ]:"
    ],
    "docstrings": [
        "\"\"\"\n        Since this RR rotate, we have imbalance in currRoot :  curRoot -- > left -- child_left\n        Now to do RR, we need move 'left' to curRoot and curRoot to left.right and left.right to curRoot.left\n        \"\"\"",
        "\"\"\"\n        Since this LL rotate, we have imbalance in currRoot :  curRoot -- > right -- right's_Right_Child\n        Now to do LL, we need move 'right' to curRoot and curRoot to right's.right and right's.right to curRoot.left\n        \"\"\"",
        "\"\"\"\n        insert a node to the binary tree\n        arguments:\n        root_node - top most node to travese the tree and find the position to insert the node\n        node - node to be inserted \n        \n        \"\"\"",
        "\"\"\"\n                if bf of root.left >=0 then it means that root's left child has a left subtree or a left leaf node because of \n                which root's left child's height ! =0  (h!=0) and hence we get subtree/tree with curRoot --> left --> left(inserted)\n                LL imbalance\n                \"\"\"",
        "\"\"\"\n                if bf of root_node.left<=0 then it means root's left child has no left subtree or left leaf. Therefore tree is\n                curRoot --> left --> right, Therefore this is left right imbllance\n                \"\"\"",
        "\"\"\"\n                if bf of root.right >=0 then it means that root's right child has a left subtree or a right leaf node because of \n                which root's right child's height ! =0  (h!=0) and hence we get subtree/tree with curRoot --> right --> right(inserted)\n                RR imbalance\n                \"\"\"",
        "\"\"\"\n                if bf of root_node.right<=0 then it means root's right child has no left subtree or right leaf. Therefore tree is\n                curRoot --> right --> left, Therefore this is left right imbalance\n                \"\"\""
    ],
    "functions": [
        "get_height",
        "balancing_factor",
        "rightRotate",
        "leftRotate",
        "insert",
        "inorder_travs",
        "Postorder_travs",
        "preorder_travs"
    ],
    "classes": [
        "node",
        "TreeNode",
        "AVL"
    ]
}