{
    "identifiers": [
        "software",
        "amazon",
        "smithy",
        "codegen",
        "core",
        "java",
        "util",
        "Collections",
        "java",
        "util",
        "LinkedHashMap",
        "java",
        "util",
        "LinkedHashSet",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "TreeMap",
        "software",
        "amazon",
        "smithy",
        "model",
        "Model",
        "software",
        "amazon",
        "smithy",
        "model",
        "knowledge",
        "KnowledgeIndex",
        "software",
        "amazon",
        "smithy",
        "model",
        "knowledge",
        "NeighborProviderIndex",
        "software",
        "amazon",
        "smithy",
        "model",
        "loader",
        "Prelude",
        "software",
        "amazon",
        "smithy",
        "model",
        "neighbor",
        "NeighborProvider",
        "software",
        "amazon",
        "smithy",
        "model",
        "neighbor",
        "Relationship",
        "software",
        "amazon",
        "smithy",
        "model",
        "neighbor",
        "RelationshipDirection",
        "software",
        "amazon",
        "smithy",
        "model",
        "selector",
        "PathFinder",
        "software",
        "amazon",
        "smithy",
        "model",
        "shapes",
        "Shape",
        "software",
        "amazon",
        "smithy",
        "model",
        "shapes",
        "ShapeId",
        "software",
        "amazon",
        "smithy",
        "model",
        "shapes",
        "SimpleShape",
        "software",
        "amazon",
        "smithy",
        "model",
        "shapes",
        "ToShapeId",
        "software",
        "amazon",
        "smithy",
        "utils",
        "FunctionalUtils",
        "shapes",
        "recursiveShapes",
        "model",
        "computeRecursiveShapes",
        "model",
        "provider",
        "NeighborProviderIndex",
        "of",
        "model",
        "getProvider",
        "model",
        "shapes",
        "FunctionalUtils",
        "Prelude",
        "isPreludeShape",
        "shape",
        "recursiveShapes",
        "containsKey",
        "shape",
        "sorted",
        "forEach",
        "shape",
        "visitShape",
        "provider",
        "shape",
        "model",
        "finder",
        "PathFinder",
        "create",
        "model",
        "edgesToShapePaths",
        "shape",
        "model",
        "toSet",
        "Prelude",
        "isPreludeShape",
        "shape",
        "shape",
        "paths",
        "finder",
        "search",
        "shape",
        "shape",
        "paths",
        "isEmpty",
        "edgeCount",
        "path",
        "paths",
        "edgeCount",
        "path",
        "size",
        "edgesToShapePaths",
        "computeIfAbsent",
        "edgeCount",
        "s",
        "put",
        "shape",
        "Collections",
        "unmodifiableList",
        "paths",
        "entry",
        "edgesToShapePaths",
        "entrySet",
        "recursiveShapes",
        "putAll",
        "entry",
        "getValue",
        "provider",
        "shape",
        "rel",
        "provider",
        "getNeighbors",
        "shape",
        "rel",
        "getRelationshipType",
        "getDirection",
        "RelationshipDirection",
        "DIRECTED",
        "rel",
        "getNeighborShapeId",
        "equals",
        "shape",
        "getId",
        "rel",
        "getNeighborShape",
        "isPresent",
        "visitShape",
        "provider",
        "rel",
        "getNeighborShape",
        "get",
        "shapes",
        "add",
        "shape",
        "model",
        "model",
        "getKnowledge",
        "TopologicalIndex",
        "Collections",
        "unmodifiableSet",
        "shapes",
        "Collections",
        "unmodifiableSet",
        "recursiveShapes",
        "keySet",
        "shape",
        "getRecursiveClosure",
        "shape",
        "isEmpty",
        "shape",
        "shape",
        "recursiveShapes",
        "getOrDefault",
        "shape",
        "Collections",
        "emptyList",
        "id",
        "shape",
        "toShapeId",
        "entry",
        "recursiveShapes",
        "entrySet",
        "entry",
        "getKey",
        "getId",
        "equals",
        "id",
        "entry",
        "getValue",
        "Collections",
        "emptyList"
    ],
    "literals": [],
    "variables": [],
    "comments": [
        "A reverse-topological sort can't be performed on recursive shapes,",
        "so instead, recursive shapes are explored first and removed from",
        "the topological sort.",
        "Next, the model is explored using a DFS so that targets of shapes",
        "are ordered before the shape itself.",
        "Note that while we do not scan the prelude here, shapes from",
        "the prelude are pull into the ordered result if referenced.",
        "Sort here to provide a deterministic result.",
        "PathFinder is used to find all paths from U -> U.",
        "The order of recursive shapes is first by the number of edges",
        "(the degree of recursion), and then alphabetically by shape ID.",
        "Find all paths from the shape back to itself.",
        "Visit members before visiting containers. Note that no 'visited'",
        "set is needed since only non-recursive shapes are traversed.",
        "If given an ID, we need to scan the recursive shapes to look for a matching ID."
    ],
    "docstrings": [
        "* Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\").\n * You may not use this file except in compliance with the License.\n * A copy of the License is located at\n *\n *  http://aws.amazon.com/apache2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing\n * permissions and limitations under the License.",
        "* Creates a reverse-topological ordering of shapes.\n *\n * <p>This kind of reverse topological ordering is useful for languages\n * like C++ that need to define shapes before they can be referenced.\n * Only non-recursive shapes are reverse-topologically ordered using\n * {@link #getOrderedShapes()}. However, recursive shapes are queryable\n * through {@link #getRecursiveShapes()}. When this returned {@code Set} is\n * iterated, recursive shapes are ordered by their degree of recursion (the\n * number of edges across all recursive closures), and then by shape ID\n * when multiple shapes have the same degree of recursion.\n *\n * <p>The recursion closures of a shape can be queried using\n * {@link #getRecursiveClosure(ToShapeId)}. This method returns a list of\n * paths from the shape back to itself. This list can be useful for code\n * generation to generate different code based on if a recursive path\n * passes through particular types of shapes.",
        "* Creates a new {@code TopologicalIndex}.\n     *\n     * @param model Model to create the index from.\n     * @return The created (or previously cached) {@code TopologicalIndex}.",
        "* Gets all reverse-topologically ordered shapes, including members.\n     *\n     * <p>When the returned {@code Set} is iterated, shapes are returned in\n     * reverse-topological. Note that the returned set does not contain\n     * recursive shapes.\n     *\n     * @return Non-recursive shapes in a reverse-topological ordered {@code Set}.",
        "* Gets all shapes that have edges that are part of a recursive closure,\n     * including container shapes (list/set/map/structure/union) and members.\n     *\n     * <p>When iterated, the returned {@code Set} is ordered from fewest number\n     * of edges to the most number of edges in the recursive closures, and then\n     * alphabetically by shape ID when there are multiple entries with\n     * the same number of edges.\n     *\n     * @return All shapes that are part of a recursive closure.",
        "* Checks if the given shape has edges with recursive references.\n     *\n     * @param shape Shape to check.\n     * @return True if the shape has recursive edges.",
        "* Gets the recursive closure of a given shape represented as\n     * {@link PathFinder.Path} objects.\n     *\n     * @param shape Shape to get the recursive closures of.\n     * @return The closures of the shape, or an empty {@code List} if the shape is not recursive."
    ],
    "functions": [
        "TopologicalIndex",
        "computeRecursiveShapes",
        "visitShape",
        "TopologicalIndex",
        "of",
        "getOrderedShapes",
        "getRecursiveShapes",
        "isRecursive",
        "getRecursiveClosure"
    ],
    "classes": [
        "TopologicalIndex"
    ]
}