{
    "identifiers": [
        "pyaudio",
        "array",
        "audioop",
        "RPi",
        "GPIO",
        "GPIO",
        "unpack",
        "colorsys",
        "hsv_to_rgb",
        "time",
        "time",
        "numpy",
        "np",
        "pyaudio",
        "paInt16",
        "rpin",
        "gpin",
        "bpin",
        "rpin",
        "gpin",
        "bpin",
        "GPIO",
        "setup",
        "rpin",
        "GPIO",
        "OUT",
        "GPIO",
        "setup",
        "gpin",
        "GPIO",
        "OUT",
        "GPIO",
        "setup",
        "bpin",
        "GPIO",
        "OUT",
        "GPIO",
        "PWM",
        "rpin",
        "GPIO",
        "PWM",
        "gpin",
        "GPIO",
        "PWM",
        "bpin",
        "rpwm",
        "start",
        "gpwm",
        "start",
        "bpwm",
        "start",
        "r",
        "g",
        "b",
        "rpwm",
        "ChangeDutyCycle",
        "r",
        "gpwm",
        "ChangeDutyCycle",
        "g",
        "bpwm",
        "ChangeDutyCycle",
        "b",
        "h",
        "s",
        "v",
        "h",
        "rgb",
        "hsv_to_rgb",
        "h",
        "s",
        "v",
        "GPIO",
        "setmode",
        "GPIO",
        "BCM",
        "Letter",
        "Letter",
        "Letter",
        "time",
        "stream",
        "read",
        "CHUNK",
        "stream",
        "stop_stream",
        "z",
        "hsv",
        "b",
        "hsv",
        "t",
        "hsv",
        "stream",
        "start_stream",
        "stream",
        "stop_stream",
        "stream",
        "close"
    ],
    "literals": [
        "\"Exit\""
    ],
    "variables": [
        "CHUNK",
        "FORMAT",
        "CHANNELS",
        "RATE",
        "RECORD_SECONDS",
        "rpin",
        "gpin",
        "bpin",
        "rpwm",
        "gpwm",
        "bpwm",
        "z",
        "b",
        "t",
        "amplitudes",
        "start",
        "data",
        "KeyboardInterrupt"
    ],
    "comments": [],
    "docstrings": [
        "\"\"\"\ndef calculate_levels(data, chunk, sample_rate):\n  # convert raw data to nmpy array\n  data = unpack(\"%dh\" % (len(data)/2), data)\n  data = np.array(data, dtype='h')\n  # apply FFT - real data so rfft\n  fourier = np.fft.rfft(data)\n  # remove last element in array to make it same size as chunk\n  fourier = np.delete(fourier, len(fourier) - 1)\n  # find amplitude\n  power = np.log10(np.abs(fourier)) ** 2\n  # arrange array into 3 rows\n  power = np.reshape(power, (8, chunk/16))\n  matrix = np.average(power, axis=1)\n  return matrix\n\np = pyaudio.PyAudio()\n\nstream = p.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK)\n\"\"\"",
        "\"\"\"\n    matrix = calculate_levels(data, CHUNK, RATE)\n    rms = audioop.rms(data, 2) / 3500.0\n    rms = min(1.0, rms)\n    amplitudes.append(matrix[3])\n    matrix = [ (x / 32.0) % 1 for x in matrix ]\n    dt = time() - start\n    hz = (dt / 5.0) % 1\n    hb = (dt / 5.0 + 0.3) % 1\n    ht = (dt / 5.0 + 0.6) % 1\n    avg = sum(matrix) / len(matrix)\n    wavg = matrix[1] * 0.3 + matrix[2] * 0.3 + matrix[3] * 0.1 + matrix[4] * 0.05 + matrix[5] * 0.05 + matrix[6] * 0.05\n    z.hsv(hz + matrix[1], 1.0, rms)\n    b.hsv(hz + matrix[3], 1.0, rms)\n    t.hsv(hz + matrix[6], 1.0, rms)\n    \"\"\"",
        "\"\"\"\n\np.terminate()\n\nprint\nprint 'Min:', min(amplitudes)\nprint 'Max:', max(amplitudes)\nprint 'Avg:', sum(amplitudes) / len(amplitudes)\n\"\"\""
    ],
    "functions": [
        "rgb",
        "hsv"
    ],
    "classes": [
        "Letter"
    ]
}