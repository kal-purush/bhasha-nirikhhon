{
    "identifiers": [
        "Server",
        "ListenOptions",
        "EventEmitter",
        "Router",
        "RequestParamHandler",
        "RequestHandler",
        "PathParams",
        "app",
        "ext",
        "fn",
        "setting",
        "val",
        "name",
        "path",
        "handlers",
        "name",
        "handler",
        "callback",
        "name",
        "matcher",
        "setting",
        "setting",
        "setting",
        "setting",
        "name",
        "locals",
        "local",
        "callback",
        "err",
        "html",
        "name",
        "callback",
        "err",
        "html",
        "port",
        "hostname",
        "backlog",
        "listeningListener",
        "port",
        "hostname",
        "listeningListener",
        "port",
        "backlog",
        "listeningListener",
        "port",
        "listeningListener",
        "path",
        "backlog",
        "listeningListener",
        "path",
        "listeningListener",
        "handle",
        "backlog",
        "listeningListener",
        "handle",
        "listeningListener",
        "options",
        "listeningListener",
        "app",
        "app"
    ],
    "literals": [
        "'http'",
        "'net'",
        "'events'",
        "'./router/index'",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string"
    ],
    "variables": [
        "app"
    ],
    "comments": [
        "need to duplicate this here from the Router because of the overload"
    ],
    "docstrings": [
        "* Contains one or more path patterns on which a sub-app was mounted.",
        "* Has properties that are local variables within the application.\n         * Once set, the value of app.locals properties persist throughout the life of the application,\n         * in contrast with res.locals properties that are valid only for the lifetime of the request.\n         * You can access local variables in templates rendered within the application.\n         * This is useful for providing helper functions to templates, as well as application-level data.\n         * Local variables are available in middleware via req.app.locals (see req.app)",
        "* Initialize the server.\n         *\n         *   - setup default configuration\n         *   - setup default middleware\n         *   - setup route reflection methods",
        "* Initialize application configuration.",
        "* Register the given template engine callback `fn`\n         * as `ext`.\n         *\n         * By default will `require()` the engine based on the\n         * file extension. For example if you try to render\n         * a \"foo.jade\" file Express will invoke the following internally:\n         *\n         *     app.engine('jade', require('jade').__express);\n         *\n         * For engines that do not provide `.__express` out of the box,\n         * or if you wish to \"map\" a different extension to the template engine\n         * you may use this method. For example mapping the EJS template engine to\n         * \".html\" files:\n         *\n         *     app.engine('html', require('ejs').renderFile);\n         *\n         * In this case EJS provides a `.renderFile()` method with\n         * the same signature that Express expects: `(path, options, callback)`,\n         * though note that it aliases this method as `ejs.__express` internally\n         * so if you're using \".ejs\" extensions you dont need to do anything.\n         *\n         * Some template engines do not follow this convention, the\n         * [Consolidate.js](https://github.com/visionmedia/consolidate.js)\n         * library was created to map all of node's popular template\n         * engines to follow this convention, thus allowing them to\n         * work seamlessly within Express.",
        "* Assign `setting` to `val`, or return `setting`'s value.\n         *\n         *    app.set('foo', 'bar');\n         *    app.get('foo');\n         *    // => \"bar\"\n         *    app.set('foo', ['bar', 'baz']);\n         *    app.get('foo');\n         *    // => [\"bar\", \"baz\"]\n         *\n         * Mounted servers inherit their parent server's settings.",
        "* Add callback triggers to route parameters, where name is the name of the parameter or an array of them,\n         * and callback is the callback function. The parameters of the callback function are the request object,\n         * the response object, the next middleware, the value of the parameter and the name of the parameter,\n         * in that order.\n         * If name is an array, the callback trigger is registered for each parameter declared in it,\n         * in the order in which they are declared. Furthermore, for each declared parameter except the last one,\n         * a call to next inside the callback will call the callback for the next declared parameter.\n         * For the last parameter, a call to next will call the next middleware in place for the route currently\n         * being processed, just like it would if name were just a string.\n         * For example, when :user is present in a route path, you may map user loading logic to automatically\n         * provide req.user to the route, or perform validations on the parameter input.",
        "* @deprecated",
        "* Return the app's absolute pathname\n         * based on the parent(s) that have\n         * mounted it.\n         *\n         * For example if the application was\n         * mounted as \"/admin\", which itself\n         * was mounted as \"/blog\" then the\n         * return value would be \"/blog/admin\".",
        "* Check if `setting` is enabled (truthy).\n         *\n         *    app.enabled('foo')\n         *    // => false\n         *\n         *    app.enable('foo')\n         *    app.enabled('foo')\n         *    // => true",
        "* Check if `setting` is disabled.\n         *\n         *    app.disabled('foo')\n         *    // => true\n         *\n         *    app.enable('foo')\n         *    app.disabled('foo')\n         *    // => false",
        "* Enable `setting`.",
        "* Disable `setting`.",
        "* Render the given view `name` name with `options`\n         * and a callback accepting an error and the\n         * rendered template string.\n         *\n         * Example:\n         *\n         *    app.render('email', { name: 'Tobi' }, function(err, html){\n         *      // ...\n         *    })",
        "* Listen for connections.\n         *\n         * A node `http.Server` is returned, with this\n         * application (which is a `Function`) as its\n         * callback. If you wish to create both an HTTP\n         * and HTTPS server you may do so with the \"http\"\n         * and \"https\" modules as shown here:\n         *\n         *    var http = require('http')\n         *      , https = require('https')\n         *      , express = require('express')\n         *      , app = express();\n         *\n         *    http.createServer(app).listen(80);\n         *    https.createServer({ ... }, app).listen(443);"
    ],
    "functions": [],
    "classes": []
}