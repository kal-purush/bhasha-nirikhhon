{
    "identifiers": [
        "com",
        "vertx",
        "s3",
        "client",
        "unit",
        "io",
        "vertx",
        "rxjava",
        "core",
        "Vertx",
        "io",
        "vertx",
        "rxjava",
        "core",
        "buffer",
        "Buffer",
        "io",
        "vertx",
        "rxjava",
        "core",
        "streams",
        "ReadStream",
        "java",
        "io",
        "java",
        "io",
        "InputStream",
        "java",
        "util",
        "concurrent",
        "BlockingQueue",
        "java",
        "util",
        "concurrent",
        "LinkedBlockingQueue",
        "java",
        "util",
        "concurrent",
        "TimeUnit",
        "java",
        "util",
        "concurrent",
        "atomic",
        "AtomicBoolean",
        "vertx",
        "readStreamFinished",
        "readStreamPaused",
        "MAX_QUEUE",
        "queue",
        "inputStream",
        "vertxBuffer",
        "counter",
        "bufCounter",
        "vertx",
        "inputStream",
        "InnderReadInputStream",
        "getInstance",
        "vertx",
        "inputStream",
        "vertx",
        "inputStream",
        "vertx",
        "vertx",
        "vertxBuffer",
        "Buffer",
        "buffer",
        "readStreamPaused",
        "readStreamFinished",
        "queue",
        "MAX_QUEUE",
        "inputStream",
        "inputStream",
        "stop",
        "inputStream",
        "handler",
        "handleBuffer",
        "bufCounter",
        "handleBuffer",
        "length",
        "bufCounter",
        "bufCounter",
        "counter",
        "queue",
        "size",
        "MAX_QUEUE",
        "stop",
        "vertxBuffer",
        "appendByte",
        "handleBuffer",
        "getByte",
        "bufCounter",
        "queue",
        "offer",
        "handleBuffer",
        "getByte",
        "bufCounter",
        "inputStream",
        "endHandler",
        "endHandle",
        "readStreamFinished",
        "inputStream",
        "resume",
        "readStreamPaused",
        "inputStream",
        "pause",
        "readStreamPaused",
        "Override",
        "b",
        "readStreamFinished",
        "get",
        "queue",
        "isEmpty",
        "b",
        "queue",
        "poll",
        "TimeUnit",
        "MILLISECONDS",
        "vertxBuffer",
        "vertxBuffer",
        "length",
        "MAX_QUEUE",
        "i",
        "i",
        "vertxBuffer",
        "length",
        "i",
        "queue",
        "offer",
        "vertxBuffer",
        "getByte",
        "i",
        "i",
        "i",
        "MAX_QUEUE",
        "i",
        "queue",
        "offer",
        "vertxBuffer",
        "getByte",
        "i",
        "temp",
        "Buffer",
        "buffer",
        "i",
        "MAX_QUEUE",
        "i",
        "vertxBuffer",
        "length",
        "i",
        "temp",
        "appendByte",
        "vertxBuffer",
        "getByte",
        "i",
        "vertxBuffer",
        "temp",
        "readStreamPaused",
        "get",
        "start",
        "b",
        "queue",
        "poll",
        "TimeUnit",
        "MILLISECONDS",
        "queue",
        "isEmpty",
        "b",
        "queue",
        "poll",
        "TimeUnit",
        "MILLISECONDS",
        "vertxBuffer",
        "vertxBuffer",
        "length",
        "MAX_QUEUE",
        "i",
        "i",
        "vertxBuffer",
        "length",
        "i",
        "queue",
        "offer",
        "vertxBuffer",
        "getByte",
        "i",
        "i",
        "i",
        "MAX_QUEUE",
        "i",
        "queue",
        "offer",
        "vertxBuffer",
        "getByte",
        "i",
        "temp",
        "Buffer",
        "buffer",
        "i",
        "MAX_QUEUE",
        "i",
        "vertxBuffer",
        "length",
        "i",
        "temp",
        "appendByte",
        "vertxBuffer",
        "getByte",
        "i",
        "vertxBuffer",
        "temp",
        "readStreamPaused",
        "get",
        "start",
        "b",
        "queue",
        "poll",
        "TimeUnit",
        "MILLISECONDS",
        "e",
        "e",
        "printStackTrace",
        "b",
        "b",
        "intValue",
        "Override",
        "b",
        "read",
        "b",
        "b",
        "length",
        "Override",
        "b",
        "off",
        "len",
        "read",
        "off",
        "b",
        "off",
        "len",
        "len",
        "b",
        "length",
        "off",
        "len",
        "c",
        "read",
        "c",
        "b",
        "off",
        "c",
        "i",
        "i",
        "len",
        "i",
        "c",
        "read",
        "c",
        "b",
        "off",
        "i",
        "c",
        "read",
        "i",
        "i",
        "Override",
        "Override",
        "stop",
        "close",
        "INSTANCE",
        "vertx",
        "inputstream",
        "INSTANCE",
        "INSTANCE",
        "vertx",
        "inputstream",
        "INSTANCE"
    ],
    "literals": [],
    "variables": [
        "vertx",
        "readStreamFinished",
        "readStreamPaused",
        "queue",
        "inputStream",
        "vertxBuffer",
        "INSTANCE"
    ],
    "comments": [
        "private static final int MAX_QUEUE = 32768;",
        "if (queue.remainingCapacity() >= handleBuffer.length()) {",
        "This Should never happen because we are checking the full chunk will fit the queue",
        "} else {",
        "stop();",
        "vertxBuffer = handleBuffer;",
        "}",
        "Stream overrides to copy the data",
        "Not finished and queue not empty - poll queue",
        "not finished and queue empty copy buffer to queue, reset buffer and restart stream",
        "finished and queue not empty - poll queue",
        "finished and queue empty copy buffer to queue, reset buffer and restart stream"
    ],
    "docstrings": [
        "* Created by bruno on 04-11-2015.",
        "* for each buffer chunk handled check if the entire chunk will fit in the queue\n         * if it doesn't stop the stream and save the chunk in memory temporarily so that read()\n         * can process it when it runs out of queue entries and resume the stream\n         *\n         * TODO - change this to check queue size on each byte"
    ],
    "functions": [
        "ReadInputStream",
        "getInstance",
        "ReadInputStream",
        "ReadInputStream",
        "start",
        "ReadInputStream",
        "stop",
        "read",
        "read",
        "read",
        "available",
        "close",
        "ReadInputStream",
        "getInstance"
    ],
    "classes": [
        "ReadInputStream",
        "InnderReadInputStream"
    ]
}