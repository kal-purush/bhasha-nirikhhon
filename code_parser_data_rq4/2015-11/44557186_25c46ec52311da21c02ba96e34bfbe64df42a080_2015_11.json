{
    "identifiers": [],
    "literals": [],
    "variables": [],
    "comments": [
        "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing Microsoft.Xna.Framework;\nusing Microsoft.Xna.Framework.Graphics;\nusing Microsoft.Xna.Framework.Input;\nusing System.Threading;\n\nnamespace COSC438GameDesignNewREV\n{\n    public class PlayerCollision\n    {\n        private Game1 gameObj;\n        private Physics physicsEngine;\n        public PlayerCollision(Game1 gameObj)\n        {\n            this.gameObj = gameObj;\n            this.physicsEngine = gameObj.PhysicsEngine;\n        }\n        public bool SweepCollisionVertical()\n        {\n            //Need to implement sweeping detection to fix collision graph offsets              \n            int checkX = gameObj.currPlayerPositionFunc.X;\n            int checkY = gameObj.currPlayerPositionFunc.Y + (int)physicsEngine.Velocity.Y;\n            Rectangle checkPlayerNewState = new Rectangle(checkX, checkY - gameObj.ActivePlayer.Height + physicsEngine.YOffSet, 40, 40);\n            if (CollisionDetection(checkPlayerNewState))\n            {\n                return true;\n            }\n            return false;\n        }\n        public bool SweepCollisionHorizontal()\n        {\n            //Need to implement sweeping detection to fix collision graph offsets              \n            int checkX = gameObj.currPlayerPositionFunc.X + (int)physicsEngine.Velocity.X;\n            int checkY = gameObj.currPlayerPositionFunc.Y;\n            Rectangle checkPlayerNewState = new Rectangle(checkX, checkY - gameObj.ActivePlayer.Height + physicsEngine.YOffset, 40, 40);\n            if (CollisionDetection(checkPlayerNewState))\n            {\n                return true;\n            }\n            return false;\n        }\n        //Standard game collision detection algorithm, citation at top of file.\n        public bool CollisionDetection(Rectangle checkPlayerNewState)\n        {\n            //Collision for platform tiles require movement from top collisions\n            foreach (PlatFormTile tile in gameObj.PhysicsEngine.GenMaps[physicsEngine.ACTIVELEVELFunc].PlatFormTile)\n            {\n                //Right side collison with offsets at maximum velocity\n                if (checkPlayerNewState.Left >= tile.Box.Left && checkPlayerNewState.Left <= tile.Box.Right && checkPlayerNewState.Top <= tile.Box.Bottom - (gameObj.ActivePlayer.Height / 2 - 10) && checkPlayerNewState.Bottom >= tile.Box.Top + (gameObj.ActivePlayer.Width / 4))\n                {\n                    //  Console.WriteLine(\"Right Collision\");    \n                    gameObj.currPlayerPositionFunc.X = tile.Box.Right + 2;\n                    return true;\n                }\n                //Left side collisions with offsets\n                if (checkPlayerNewState.Right <= tile.Box.Right && checkPlayerNewState.Right >= tile.Box.Left && checkPlayerNewState.Top <= tile.Box.Bottom - (gameObj.ActivePlayer.Height / 2 - 10) && checkPlayerNewState.Bottom >= tile.Box.Top + (gameObj.ActivePlayer.Width / 4))\n                {\n                    // Console.WriteLine(\"Left Collision\");\n                    gameObj.currPlayerPositionFunc.X = tile.Box.Left - 2 - gameObj.activePlayerFunc.Width;\n                    return true;\n                }\n                //Top\n                if (checkPlayerNewState.Bottom >= tile.Box.Top && checkPlayerNewState.Bottom <= tile.Box.Top + (gameObj.ActivePlayer.Height / 2) + 1 && checkPlayerNewState.Right >= tile.Box.Left + (gameObj.ActivePlayer.Height / 10 - 1) && checkPlayerNewState.Left <= tile.Box.Right - (gameObj.ActivePlayer.Height / 10 - 1))\n                {\n                    // Console.WriteLine(\"Top Collision\");\n                    physicsEngine.Jumpstate = false;\n                    physicsEngine.SetVelocity(-1, 0);\n                    gameObj.currPlayerPositionFunc.Y = tile.Box.Top - 1;\n                    return true;\n                }\n                //Bottom\n                if (checkPlayerNewState.Top <= tile.Box.Bottom + gameObj.ActivePlayer.Height - physicsEngine.YOffSet - 2 && checkPlayerNewState.Top >= tile.Box.Bottom - 1 && checkPlayerNewState.Right >= tile.Box.Left + (gameObj.ActivePlayer.Height / 10 - 1) && checkPlayerNewState.Left <= tile.Box.Right - (gameObj.ActivePlayer.Height / 10 - 1))\n                {\n                    // Console.WriteLine(\"Bot Collision\");                       \n                    physicsEngine.SetVelocity(-1, 1);\n                    gameObj.currPlayerPositionFunc.Y = tile.Box.Bottom + gameObj.ActivePlayer.Height + 2;\n                    return true;\n                }\n            }\n            foreach (ItemTile tile in gameObj.GenMaps[physicsEngine.ACTIVELEVELFunc].ItemTile)\n            {\n                //Right side collison with offsets at maximum velocity\n                if (checkPlayerNewState.Left >= tile.Box.Left && checkPlayerNewState.Left <= tile.Box.Right && checkPlayerNewState.Top <= tile.Box.Bottom - (gameObj.ActivePlayer.Height / 2 - 10) && checkPlayerNewState.Bottom >= tile.Box.Top + (gameObj.ActivePlayer.Width / 4))\n                {\n                    gameObj.InventoryContainer[tile.ItemKey].Collected = true;\n                    tile.Collected = true;\n                }\n                //Left side collisions with offsets\n                if (checkPlayerNewState.Right <= tile.Box.Right && checkPlayerNewState.Right >= tile.Box.Left && checkPlayerNewState.Top <= tile.Box.Bottom - (gameObj.ActivePlayer.Height / 2 - 10) && checkPlayerNewState.Bottom >= tile.Box.Top + (gameObj.ActivePlayer.Width / 4))\n                {\n                    gameObj.InventoryContainer[tile.ItemKey].Collected = true;\n                    tile.Collected = true;\n                }\n                //Top\n                if (checkPlayerNewState.Bottom >= tile.Box.Top && checkPlayerNewState.Bottom <= tile.Box.Top + (gameObj.ActivePlayer.Height / 2) + 1 && checkPlayerNewState.Right >= tile.Box.Left + (gameObj.ActivePlayer.Height / 10 - 1) && checkPlayerNewState.Left <= tile.Box.Right - (gameObj.ActivePlayer.Height / 10 - 1))\n                {\n                    gameObj.InventoryContainer[tile.ItemKey].Collected = true;\n                    tile.Collected = true;\n                }\n                //Bottom\n                if (checkPlayerNewState.Top <= tile.Box.Bottom + gameObj.ActivePlayer.Height - physicsEngine.YOffSet - 2 && checkPlayerNewState.Top >= tile.Box.Bottom - 1 && checkPlayerNewState.Right >= tile.Box.Left + (gameObj.ActivePlayer.Height / 10 - 1) && checkPlayerNewState.Left <= tile.Box.Right - (gameObj.ActivePlayer.Height / 10 - 1))\n                {\n                    gameObj.InventoryContainer[tile.ItemKey].Collected = true;\n                    tile.Collected = true;\n                }\n            }\n            return false;\n        }\n        public bool ladderCollision(Rectangle player)\n        {\n            foreach (LadderTile tile in gameObj.GenMaps[physicsEngine.ACTIVELEVELFunc].LadderTile)\n            {\n                if (tile.Box.Intersects(player))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n}"
    ],
    "docstrings": [],
    "functions": [],
    "classes": []
}