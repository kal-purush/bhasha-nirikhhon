{
    "identifiers": [
        "_pytest",
        "config",
        "get_config",
        "unit_testing",
        "unit_testing",
        "CountError",
        "count_letter_frequency",
        "clf",
        "pytest",
        "pytest",
        "fixture",
        "open",
        "f",
        "f",
        "read",
        "get_content",
        "clf",
        "get_content",
        "isinstance",
        "actual",
        "expected",
        "get_content",
        "clf",
        "get_content",
        "expected",
        "actual",
        "get_content",
        "pytest",
        "raises",
        "CountError",
        "cr",
        "clf",
        "get_content",
        "cr",
        "match",
        "pytest",
        "mark",
        "skipif",
        "get_content",
        "reason",
        "pytest",
        "raises",
        "CountError",
        "cr",
        "clf",
        "cr",
        "match",
        "pytest",
        "mark",
        "skip",
        "slef",
        "get_content",
        "clf",
        "get_content",
        "expected",
        "actual",
        "pytest",
        "mark",
        "xfail",
        "get_content",
        "clf",
        "get_content",
        "expected",
        "actual"
    ],
    "literals": [
        "'./assets/test.txt'",
        "'a'",
        "'a'",
        "'f'",
        "'Letter cannot be found in the content.'",
        "''",
        "'Content is empty'",
        "''",
        "'f'",
        "'Letter cannot be found in the content.'",
        "\"in progress\"",
        "'a'",
        "'Frequency is above 100'",
        "'z'"
    ],
    "variables": [
        "expected",
        "actual",
        "expected",
        "actual",
        "expected",
        "actual",
        "expected",
        "actual"
    ],
    "comments": [
        "we can also use yeild if we are following the setup, assertion, teardown workflow. Setup is done before yield, and teardown is after yeild",
        "Here the context manager is actually handeling all of these together, it opens the file, reads its content, closes the file",
        "test return type",
        "test returned values",
        "test exceptions",
        "skip the test if the condition passed to skipif evaluates to True. Here, I am skipping the test if the content is not empty (not ideal but you get the idea :))",
        "skip a test especially while something is in development",
        "mark as xfail, which means that before the actual implementation, it is expected that this test will fail since this test is considered as a false alarm, so we are telling pytest that this test is expected to fail"
    ],
    "docstrings": [],
    "functions": [
        "get_content",
        "test_count_letter_returns_an_integer_if_letter_exists",
        "test_count_letter_returns_correct_count",
        "test_count_frequency_raises_a_CountError_exception_if_letter_is_not_found_in_content",
        "test_count_frequency_raises_a_CountError_exception_if_content_is_empty",
        "test_count_frequency_returns_True_if_the_letter_is_the_most_frequent",
        "test_count_frequency_returns_correct_message_if_frequency_is_higher_than_100"
    ],
    "classes": [
        "TestCountLetterFrequency"
    ]
}