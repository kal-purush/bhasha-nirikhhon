{
    "identifiers": [
        "numpy",
        "np",
        "this_utils",
        "boxes_nms",
        "boxes_filter",
        "search_expansion",
        "min_search_wh",
        "pad_pixels",
        "search_expansion",
        "min_search_wh",
        "pad_pixels",
        "active_ids",
        "max_entangle_length",
        "max_dormant_frames",
        "active_ids",
        "max_dormant_frames",
        "max_entangle_length",
        "track_id",
        "last_active",
        "_dormant_ids",
        "items",
        "_frame_idx",
        "last_active",
        "_max_dormant_frames",
        "_dormant_ids",
        "pop",
        "track_id",
        "_kill_ids",
        "add",
        "track_id",
        "_cache",
        "pop",
        "track_id",
        "value",
        "_frame_idx",
        "value",
        "_max_id",
        "new_id",
        "_active_ids",
        "add",
        "new_id",
        "new_id",
        "_active_ids",
        "_dormant_ids",
        "keys",
        "track_utils",
        "track_pool",
        "TrackHead",
        "track_utils",
        "track_pool",
        "features",
        "track",
        "extract_cache",
        "_get_track_targets",
        "track",
        "active_tracks",
        "bbox",
        "len",
        "active_tracks",
        "bbox",
        "copy",
        "np",
        "array",
        "copy",
        "deepcopy",
        "active_tracks",
        "track_utils",
        "pad_pixels",
        "track_utils",
        "pad_pixels",
        "template_features",
        "sr",
        "active_tracks",
        "extract_cache",
        "features",
        "active_tracks",
        "_update_memory_with_dormant_track",
        "track_memory",
        "track_pool",
        "update_cache",
        "track_memory",
        "track_memory",
        "track_memory",
        "track_pool",
        "get_cache",
        "cache",
        "track_memory",
        "track_memory",
        "dormant_id",
        "track_pool",
        "get_dormant_ids",
        "dormant_id",
        "cache",
        "dormant_caches",
        "append",
        "cache",
        "dormant_id",
        "x",
        "x",
        "dormant_caches",
        "track_memory",
        "track_memory",
        "track_memory",
        "track_memory",
        "torch",
        "cat",
        "buffer_feat",
        "cached_features",
        "cat_boxlist",
        "track_memory",
        "x",
        "x",
        "dormant_caches",
        "cat_boxlist",
        "track_memory",
        "x",
        "x",
        "dormant_caches",
        "features",
        "sr",
        "boxes",
        "target",
        "len",
        "target",
        "bbox",
        "target",
        "track_pool",
        "get_active_ids",
        "target",
        "ids",
        "tolist",
        "np",
        "zeros",
        "len",
        "ids",
        "dtype",
        "np",
        "_i",
        "_id",
        "ids",
        "_id",
        "active_ids",
        "idxs",
        "nonzero",
        "boxes_filter",
        "target",
        "idxs",
        "track_pool",
        "track_thresh",
        "start_track_thresh",
        "resume_track_thresh",
        "track_pool",
        "track_thresh",
        "start_track_thresh",
        "resume_track_thresh",
        "detection",
        "boxes_nms",
        "detection",
        "nms_thresh",
        "detection",
        "ids",
        "detection",
        "scores",
        "_scores",
        "_scores",
        "_scores",
        "_scores",
        "_scores",
        "_scores",
        "detection",
        "_ids",
        "_scores",
        "boxes",
        "len",
        "boxes",
        "bbox",
        "boxes",
        "track_pool",
        "boxes",
        "ids",
        "boxes",
        "scores",
        "track_pool",
        "get_active_ids",
        "track_pool",
        "get_dormant_ids",
        "np",
        "array",
        "x",
        "active_ids",
        "x",
        "all_ids",
        "all_scores",
        "active_mask",
        "all_scores",
        "all_scores",
        "shape",
        "get_nms_boxes",
        "boxes",
        "nms_detection",
        "combined_detection",
        "ids",
        "combined_detection",
        "scores",
        "_ids",
        "_scores",
        "start_thresh",
        "nonzero",
        "_ids",
        "_scores",
        "track_thresh",
        "_ids",
        "_ids",
        "tolist",
        "all_ids",
        "all_ids",
        "tolist",
        "all_track_ids",
        "nms_track_ids",
        "_ids",
        "inactive_idxs",
        "tolist",
        "nms_removed_ids",
        "np",
        "array",
        "x",
        "dormant_ids",
        "x",
        "_ids",
        "_ids",
        "dormant_mask",
        "_scores",
        "resume_track_thresh",
        "_id",
        "resume_ids",
        "tolist",
        "track_pool",
        "resume_track",
        "_id",
        "_idx",
        "start_idxs",
        "track_pool",
        "start_track",
        "track_pool",
        "get_active_ids",
        "_id",
        "inactive_ids",
        "_id",
        "active_ids",
        "track_pool",
        "suspend_track",
        "_id",
        "track_pool",
        "expire_tracks",
        "track_pool",
        "increment_frame",
        "combined_detection",
        "bbox",
        "combined_detection",
        "bbox",
        "shape",
        "combined_detection",
        "TrackUtils",
        "search_expansion",
        "min_search_wh",
        "pad_pixels",
        "TrackPool",
        "max_dormant_frames",
        "TrackHead",
        "track_utils",
        "track_pool",
        "TrackSolver",
        "track_pool"
    ],
    "literals": [
        "\"active_tracks---\"",
        "\"Unexpected cache state\"",
        "\"all_scores------\"",
        "\"all_scores------\"",
        "\"combined_detection---\"",
        "\"combined_detection---\""
    ],
    "variables": [
        "search_expansion",
        "min_search_wh",
        "pad_pixels",
        "_active_ids",
        "_dormant_ids",
        "_kill_ids",
        "_max_id",
        "_embedding",
        "_cache",
        "_frame_idx",
        "_max_dormant_frames",
        "_max_entangle_length",
        "new_id",
        "_max_id",
        "_active_ids",
        "_kill_ids",
        "_dormant_ids",
        "_embedding",
        "_cache",
        "_max_id",
        "_frame_idx",
        "feature_extractor",
        "track_utils",
        "track_pool",
        "active_tracks",
        "template_features",
        "sr",
        "sr",
        "size",
        "track_memory",
        "track_memory",
        "track_memory",
        "cache",
        "dormant_caches",
        "cached_features",
        "track_memory",
        "buffer_feat",
        "buffer_feat",
        "features",
        "sr",
        "boxes",
        "active_ids",
        "ids",
        "idxs",
        "idxs",
        "_i",
        "idxs",
        "track_pool",
        "track_thresh",
        "start_thresh",
        "resume_track_thresh",
        "detection",
        "_ids",
        "_scores",
        "_scores",
        "_scores",
        "track_pool",
        "all_ids",
        "all_scores",
        "active_ids",
        "dormant_ids",
        "active_mask",
        "nms_detection",
        "nms_ids",
        "nms_scores",
        "combined_detection",
        "_ids",
        "_scores",
        "start_idxs",
        "inactive_idxs",
        "nms_track_ids",
        "all_track_ids",
        "nms_removed_ids",
        "inactive_ids",
        "dormant_mask",
        "resume_ids",
        "_ids",
        "_idx",
        "active_ids",
        "_ids",
        "inactive_idxs",
        "track_utils",
        "track_pool",
        "track_head",
        "track_solver"
    ],
    "comments": [
        "@staticmethod",
        "def swap_pairs(entity_list):",
        "assert len(entity_list) % 2 == 0",
        "# Take the targets of the other frame (in a tracking pair) as input during training, thus swap order",
        "for xx in range(0, len(entity_list), 2):",
        "entity_list[xx], entity_list[xx + 1] = entity_list[xx + 1], entity_list[xx]",
        "return entity_list",
        "",
        "@staticmethod",
        "def shuffle_feature(f):",
        "\"\"\"",
        "odd-even order swap of the feature tensor in the batch dimension",
        "\"\"\"",
        "",
        "def shuffle_feature_tensor(x):",
        "batch_size = x.shape[0]",
        "assert batch_size % 2 == 0",
        "",
        "# get channel swap order [1, 0, 3, 2, ...]",
        "odd_idx = range(1, batch_size, 2)",
        "even_idx = range(0, batch_size, 2)",
        "idxs = np.arange(0, batch_size)",
        "idxs[even_idx] = idxs[even_idx] + 1",
        "idxs[odd_idx] = idxs[odd_idx] - 1",
        "idxs = torch.tensor(idxs)",
        "",
        "return x[idxs]",
        "",
        "if isinstance(f, tuple):",
        "shuffle_f = []",
        "for i, _f in enumerate(f):",
        "shuffle_f.append(shuffle_feature_tensor(_f))",
        "shuffle_f = tuple(shuffle_f)",
        "else:",
        "shuffle_f = shuffle_feature_tensor(f)",
        "",
        "return shuffle_f",
        "",
        "def extend_bbox(self, in_box: [BoxList]):",
        "\"\"\"",
        "Extend the bounding box to define the search region",
        ":param in_box: a set of bounding boxes in previous frame",
        ":param min_wh: the miniumun width/height of the search region",
        "\"\"\"",
        "for i, _track in enumerate(in_box):",
        "bbox_w = _track.bbox[:, 2] - _track.bbox[:, 0] + 1",
        "bbox_h = _track.bbox[:, 3] - _track.bbox[:, 1] + 1",
        "w_ext = bbox_w * (self.search_expansion / 2.)",
        "h_ext = bbox_h * (self.search_expansion / 2.)",
        "",
        "# todo: need to check the equation later",
        "min_w_ext = (self.min_search_wh - bbox_w) / (self.search_expansion * 2.)",
        "min_h_ext = (self.min_search_wh - bbox_h) / (self.search_expansion * 2.)",
        "",
        "w_ext = torch.max(min_w_ext, w_ext)",
        "h_ext = torch.max(min_h_ext, h_ext)",
        "in_box[i].bbox[:, 0] -= w_ext",
        "in_box[i].bbox[:, 1] -= h_ext",
        "in_box[i].bbox[:, 2] += w_ext",
        "in_box[i].bbox[:, 3] += h_ext",
        "# in_box[i].clip_to_image()",
        "return in_box",
        "",
        "def pad_feature(self, f):",
        "\"\"\"",
        "Pad the feature maps with 0",
        ":param f: [torch.tensor] or torch.tensor",
        "\"\"\"",
        "",
        "if isinstance(f, (list, tuple)):",
        "pad_f = []",
        "for i, _f in enumerate(f):",
        "# todo fix this hack, should read from cfg file",
        "pad_pixels = int(self.pad_pixels / ((2 ** i) * 4))",
        "x = F.pad(_f, [pad_pixels, pad_pixels, pad_pixels, pad_pixels],",
        "mode='constant', value=0)",
        "pad_f.append(x)",
        "pad_f = tuple(pad_f)",
        "else:",
        "pad_f = F.pad(f, [self.pad_pixels, self.pad_pixels,",
        "self.pad_pixels, self.pad_pixels],",
        "mode='constant', value=0)",
        "",
        "return pad_f",
        "",
        "def update_boxes_in_pad_images(self, boxlists: [BoxList]):",
        "\"\"\"",
        "Update the coordinates of bounding boxes in the padded image",
        "\"\"\"",
        "",
        "pad_width = self.pad_pixels",
        "pad_height = self.pad_pixels",
        "",
        "pad_boxes = []",
        "for _boxlist in boxlists:",
        "im_width, im_height = _boxlist.size",
        "new_width = int(im_width + pad_width * 2)",
        "new_height = int(im_height + pad_height * 2)",
        "",
        "assert (_boxlist.mode == 'xyxy')",
        "xmin, ymin, xmax, ymax = _boxlist.bbox.split(1, dim=-1)",
        "new_xmin = xmin + pad_width",
        "new_ymin = ymin + pad_height",
        "new_xmax = xmax + pad_width",
        "new_ymax = ymax + pad_height",
        "bbox = torch.cat((new_xmin, new_ymin, new_xmax, new_ymax), dim=-1)",
        "bbox = BoxList(bbox, [new_width, new_height], mode='xyxy')",
        "for _field in _boxlist.fields():",
        "bbox.add_field(_field, _boxlist.get_field(_field))",
        "pad_boxes.append(bbox)",
        "",
        "return pad_boxes",
        "track ids that are killed up to previous frames",
        "track ids that are killed in current frame",
        "no need for feature extraction of search region if",
        "the tracker is tracktor, or no trackable instances",
        "differentiate active tracks from dormant tracks with scores",
        "active tracks, (3 >= score > 2, id >= 0),",
        "dormant tracks, (2 >= score > 1, id >= 0),",
        "By doing this, dormant tracks will be merged to active tracks during nms,",
        "if they highly overlap",
        "start track ids",
        "inactive track ids",
        "active tracks that are removed by nms",
        "resume dormant mask, if needed",
        "make sure that the ids for inactive tracks in current frame are meaningless (< 0)"
    ],
    "docstrings": [
        "\"\"\"\n    A class that includes utility functions unique to track branch\n    \"\"\"",
        "\"\"\"\n        :param search_expansion: expansion ratio (of the search region)\n        w.r.t the size of tracking targets\n        :param min_search_wh: minimal size (width and height) of the search region\n        :param pad_pixels: the padding pixels that are neccessary to keep the\n        feature map pf search region and that of template target in the same scale\n        \"\"\"",
        "\"\"\"\n    A class to manage the track id distribution (initiate/kill a track)\n    \"\"\"",
        "\"\"\"\n        Expire the suspended tracks after they are inactive\n        for a consecutive self._max_dormant_frames frames\n        \"\"\"",
        "\"\"\"\n        Return a new track id, when starting a new track\n        \"\"\"",
        "\"\"\"\n        The solver is to merge predictions from detection branch as well as from track branch.\n        The goal is to assign an unique track id to bounding boxes that are deemed tracked\n        :param boxes: it includes three set of distinctive prediction:\n        prediction propagated from active tracks, (2 >= score > 1, id >= 0),\n        prediction propagated from dormant tracks, (2 >= score > 1, id >= 0),\n        prediction from detection (1 > score > 0, id = -1).\n        :return:\n        \"\"\""
    ],
    "functions": [
        "expire_tracks",
        "increment_frame",
        "start_track",
        "get_active_ids",
        "get_dormant_ids",
        "reset",
        "get_track_memory",
        "_update_memory_with_dormant_track",
        "_get_track_targets",
        "get_nms_boxes",
        "solve"
    ],
    "classes": [
        "TrackUtils",
        "TrackPool",
        "TrackHead",
        "TrackSolver"
    ]
}