{
    "identifiers": [
        "build",
        "buildfarm",
        "common",
        "oshi",
        "SystemInfo",
        "oshi",
        "hardware",
        "CentralProcessor",
        "oshi",
        "hardware",
        "HardwareAbstractionLayer",
        "PROCESSOR_DERIVE",
        "JAVA_RUNTIME",
        "OSHI",
        "max",
        "get",
        "PROCESSOR_DERIVE",
        "JAVA_RUNTIME",
        "get",
        "PROCESSOR_DERIVE",
        "OSHI",
        "strategy",
        "strategy",
        "JAVA_RUNTIME",
        "getViaJavaRuntime",
        "OSHI",
        "getViaOSHI",
        "getViaJavaRuntime",
        "Runtime",
        "getRuntime",
        "availableProcessors",
        "systemInfo",
        "hardwareAbstractionLayer",
        "systemInfo",
        "getHardware",
        "centralProcessor",
        "hardwareAbstractionLayer",
        "getProcessor",
        "centralProcessor",
        "getLogicalProcessorCount"
    ],
    "literals": [],
    "variables": [],
    "comments": [
        "Copyright 2023 The Bazel Authors. All rights reserved.",
        "",
        "Licensed under the Apache License, Version 2.0 (the \"License\");",
        "you may not use this file except in compliance with the License.",
        "You may obtain a copy of the License at",
        "",
        "http://www.apache.org/licenses/LICENSE-2.0",
        "",
        "Unless required by applicable law or agreed to in writing, software",
        "distributed under the License is distributed on an \"AS IS\" BASIS,",
        "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
        "See the License for the specific language governing permissions and",
        "limitations under the License.",
        "Have buildfarm choose the best value."
    ],
    "docstrings": [
        "* @class SystemProcessors\n * @brief Abstraction for getting information about the system processors.\n * @details We've found that using java's Runtime.getRuntime().availableProcessors() utility does\n *     not always accurately reflect the amount of processors available. In some cases it returns 1\n *     due to containerization or virtualization. For example, if you are using k8s with containerd\n *     you might see this method give back 1 based on your particular deployment. There are other\n *     implementations such as OSHI that use JNA to acquire the native operating system and hardware\n *     information which is often more suitable for buildfarm. In order to provide consistency in\n *     deriving configuration values, and allocating thread pools, it's best to source the processor\n *     count from the same place. This abstracts implementation on how we derive processor count\n *     based on config and environment.",
        "* @field PROCESSOR_DERIVE\n   * @brief Strategies for getting total processor counts.\n   * @details Can be chosen in user configuration.",
        "* @brief Get the number of logical processors on the system.\n   * @details Buildfarm will choose the best implementation.\n   * @return Number of logical processors on the system.",
        "* @brief Get the number of logical processors on the system.\n   * @details Implementation decided by configuration.\n   * @return Number of logical processors on the system.",
        "* @brief Get the number of logical processors on the system through java runtime.\n   * @details specific implementation.\n   * @return Number of logical processors on the system.",
        "* @brief Get the number of logical processors on the system through OSHI.\n   * @details specific implementation.\n   * @return Number of logical processors on the system."
    ],
    "functions": [
        "get",
        "get",
        "getViaJavaRuntime",
        "getViaOSHI"
    ],
    "classes": [
        "SystemProcessors"
    ]
}