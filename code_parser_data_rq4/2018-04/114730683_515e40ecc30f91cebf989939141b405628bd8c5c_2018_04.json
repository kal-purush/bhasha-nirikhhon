{
    "identifiers": [
        "Threading",
        "Tasks",
        "InpaintService",
        "Activities",
        "Microsoft",
        "Azure",
        "WebJobs",
        "Zavolokas",
        "ImageProcessing",
        "Inpainting",
        "InpaintService",
        "FunctionName",
        "Name",
        "OrchestrationTrigger",
        "DurableOrchestrationContext",
        "ctx",
        "ctx",
        "GetInput",
        "NnfInputData",
        "input",
        "LevelIndex",
        "input",
        "InpaintIterationIndex",
        "input",
        "ExcludeInpaintArea",
        "levelIndex",
        "inpaintIterationIndex",
        "input",
        "IterationIndex",
        "inpaintIterationIndex",
        "levelIndex",
        "inpaintIterationIndex",
        "ctx",
        "CallActivityAsync",
        "NnfRandomInitActivity",
        "Name",
        "input",
        "ctx",
        "CallSubOrchestratorAsync",
        "BuildNnfFunction",
        "Name",
        "input",
        "ctx",
        "CallActivityAsync",
        "InpaintingResult",
        "ImageInpaintActivity",
        "Name",
        "input"
    ],
    "literals": [
        "\"InpaintLevelIteration\""
    ],
    "variables": [
        "Name",
        "input",
        "levelIndex",
        "inpaintIterationIndex",
        "inpaintResult"
    ],
    "comments": [
        "Obtain pixels area.",
        "Pixels area defines which pixels are allowed to be used",
        "for the patches distance calculation. We must avoid pixels",
        "that we want to inpaint. That is why before the area is not",
        "inpainted - we should exclude this area.",
        "skip building NNF for the first iteration in the level",
        "unless it is top level (for the top one we haven't built NNF yet)",
        "in order to find best matches for the inpainted area,",
        "we build NNF for this imageLab as a dest and a source",
        "but excluding the inpainted area from the source area",
        "(our mapping already takes care of it)",
        "input.K = input.K > minK ? input.K - kStep : input.K;",
        "if the change is smaller then a treshold, we quit",
        "if (inpaintResult.ChangedPixelsPercent < changedPixelsPercentTreshold) break;",
        "if (levelIndex == pyramid.LevelsAmount - 1) break;"
    ],
    "docstrings": [],
    "functions": [
        "InpaintLevelIteration"
    ],
    "classes": [
        "InpaintLevelIterationFunction"
    ]
}