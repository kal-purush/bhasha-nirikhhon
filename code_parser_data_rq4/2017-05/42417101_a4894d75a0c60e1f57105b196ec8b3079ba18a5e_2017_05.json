{
    "identifiers": [
        "camelCase",
        "forOwn",
        "isObject",
        "forEach",
        "defaults",
        "forIn",
        "dedent",
        "Dict",
        "Constructor",
        "DenaliObject",
        "Resolver",
        "assign",
        "mapValues",
        "DenaliObject",
        "root",
        "process",
        "root",
        "Resolver",
        "root",
        "root",
        "resolver",
        "resolver",
        "name",
        "value",
        "options",
        "name",
        "value",
        "options",
        "name",
        "options",
        "name",
        "options",
        "parseName",
        "name",
        "fullName",
        "fullName",
        "assign",
        "currentOptions",
        "options",
        "name",
        "option",
        "parseName",
        "name",
        "fullName",
        "defaults",
        "defaults",
        "options",
        "typeOptions",
        "DEFAULT_CONTAINER_OPTIONS",
        "option",
        "combinedOptions",
        "combinedOptions",
        "option",
        "name",
        "lookupOptions",
        "parseName",
        "name",
        "parsedName",
        "forEach",
        "resolver",
        "resolver",
        "parsedName",
        "lookupOptions",
        "parsedName",
        "parsedName",
        "parsedName",
        "parsedName",
        "parsedName",
        "parsedName",
        "parsedName",
        "parsedName",
        "modulePath",
        "resolver",
        "resolver",
        "modulePath",
        "assign",
        "resolverResultsets",
        "mapValues",
        "mergedResultset",
        "rawResolvedObject",
        "modulePath",
        "modulePath",
        "name",
        "name",
        "name",
        "camelCase",
        "modulePath"
    ],
    "literals": [
        "'lodash'",
        "'dedent-js'",
        "'../utils/types'",
        "'./object'",
        "'./resolver'",
        "'lodash'",
        "string",
        "string",
        "string",
        "string",
        "string",
        "'string'",
        "string",
        "string",
        "'app'",
        "'orm-adapter'",
        "'serializer'",
        "'service'",
        "string",
        "string",
        "string",
        "string",
        "No such ${ parsedName.type } found: '${ parsedName.moduleName }'",
        "'singleton'",
        "'containerize'",
        "'singleton'",
        "string",
        "string",
        "string",
        "${ type }:${ modulePath }",
        "string",
        "string",
        "string",
        "':'"
    ],
    "variables": [
        "DEFAULT_CONTAINER_OPTIONS",
        "currentOptions",
        "options",
        "typeOptions",
        "combinedOptions",
        "parsedName",
        "resolverResultsets",
        "mergedResultset",
        "modulePath"
    ],
    "comments": [
        "Find the member with the top level resolver",
        "Break loop if we found something",
        "Handle a bad lookup",
        "Allow failed lookups (opt-in)",
        "Make the singleton if needed",
        "Inject container references",
        "Freeze the actual containered value to avoid allowing mutations. If `object` here is the",
        "direct result of a require() call, then any mutations to it will be shared with other",
        "containers that require() it (i.e. when running concurrent tests). If it's a singleton,",
        "this isn't necessary since each container gets it's own instance. But if it's not, then we",
        "freeze it to prevent mutations which can lead to extremely difficult to trace bugs."
    ],
    "docstrings": [
        "* The Container houses all the various classes that makeup a Denali app's\n *\n * runtime. It holds references to the modules themselves, as well as managing lookup logic (i.e.\n * some types of classes fall back to a generic \"application\" class if a more specific one is not\n * found.\n *\n * @package runtime\n * @since 0.1.0",
        "* An internal cache of lookups and their resolved values",
        "* Optional resolvers to use as a fallback if the default resolver is unable to resolve a lookup.\n   * Usually these are the resolvers for child addons, but you could also use a fallback resolver\n   * to support an alternative directory structure for your app. NOTE: this is NOT recommended, and\n   * may break compatibility with poorly designed addons as well as certainly CLI features.",
        "* Holds options for how to handle constructing member objects",
        "* Add a fallback resolver to the bottom of the fallback queue.\n   *\n   * @since 0.1.0",
        "* Register a value under the given `fullName` for later use.\n   *\n   * @since 0.1.0",
        "* Set options for how the given member will be constructed. Options passed in are merged with any\n   * existing options - they do not replace them entirely.\n   *\n   * @since 0.1.0",
        "* Get the given option for the given member of the container\n   *\n   * @since 0.1.0",
        "* Lookup a value in the container. Uses type specific lookup logic if available.\n   *\n   * @since 0.1.0",
        "* Lookup all modules of a specific type in the container. Returns an object of all the modules\n   * keyed by their module path (i.e. `role:employees/manager` would be found under\n   * `lookupAll('role')['employees/manager']`",
        "* For a given type, returns the names of all the available modules under that\n   * type. Primarily used for debugging purposes (i.e. to show available modules\n   * when a lookup of that type fails).",
        "* Take the supplied name which can come in several forms, and normalize it."
    ],
    "functions": [
        "addResolver",
        "register",
        "registerOptions",
        "optionFor",
        "lookup",
        "lookupAll",
        "availableForType",
        "parseName"
    ],
    "classes": [
        "Container"
    ]
}