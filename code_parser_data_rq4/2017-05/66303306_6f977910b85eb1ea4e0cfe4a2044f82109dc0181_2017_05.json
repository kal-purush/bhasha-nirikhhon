{
    "identifiers": [
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "eval",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "AndCondition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "ComparisonCondition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "Condition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "ConditionVisitor",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "Conditions",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "ConstantCondition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "ContainsCondition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "EqualCondition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "InCondition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "IntrinsicCondition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "IsCondition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "LikeCondition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "MapCondition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "NotCondition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "OrCondition",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "condition",
        "State",
        "com",
        "bazaarvoice",
        "emodb",
        "sor",
        "delta",
        "eval",
        "Intrinsics",
        "com",
        "google",
        "common",
        "collect",
        "Sets",
        "java",
        "util",
        "com",
        "google",
        "common",
        "Preconditions",
        "checkNotNull",
        "ParameterOrder",
        "CONSTANT",
        "LIKE",
        "COMPARISON",
        "IS",
        "EQUAL",
        "IN",
        "CONTAINS",
        "MAP",
        "INTRINSIC",
        "left",
        "right",
        "checkAreDistinct",
        "checkNotNull",
        "left",
        "checkNotNull",
        "right",
        "left",
        "right",
        "left",
        "visit",
        "right",
        "Override",
        "left",
        "right",
        "left",
        "getValue",
        "visitor",
        "left",
        "Override",
        "right",
        "right",
        "getValue",
        "right",
        "visit",
        "visitor",
        "ParameterOrder",
        "CONSTANT",
        "Override",
        "left",
        "right",
        "visitor",
        "left",
        "Override",
        "right",
        "right",
        "getState",
        "State",
        "DEFINED",
        "right",
        "getState",
        "State",
        "STRING",
        "Override",
        "right",
        "right",
        "getValue",
        "_left",
        "matches",
        "right",
        "getValue",
        "Override",
        "right",
        "value",
        "right",
        "getValues",
        "value",
        "_left",
        "matches",
        "value",
        "Override",
        "right",
        "right",
        "getValue",
        "prefix",
        "_left",
        "getPrefix",
        "prefix",
        "comparisonValue",
        "right",
        "getValue",
        "prefix",
        "length",
        "comparisonValue",
        "length",
        "ConditionEvaluator",
        "eval",
        "right",
        "prefix",
        "Override",
        "right",
        "_left",
        "overlaps",
        "right",
        "right",
        "visit",
        "visitor",
        "ParameterOrder",
        "LIKE",
        "Override",
        "left",
        "right",
        "visitor",
        "left",
        "Override",
        "right",
        "_left",
        "overlaps",
        "right",
        "Override",
        "right",
        "value",
        "right",
        "getValues",
        "checkAreDistinct",
        "_left",
        "Conditions",
        "equal",
        "value",
        "right",
        "visit",
        "visitor",
        "ParameterOrder",
        "COMPARISON",
        "Override",
        "left",
        "right",
        "visitor",
        "left",
        "Override",
        "right",
        "value",
        "right",
        "getValues",
        "checkAreDistinct",
        "_left",
        "Conditions",
        "equal",
        "value",
        "right",
        "visit",
        "visitor",
        "ParameterOrder",
        "IS",
        "Override",
        "left",
        "right",
        "visitor",
        "left",
        "Override",
        "right",
        "value",
        "_left",
        "getValues",
        "checkAreDistinct",
        "right",
        "Conditions",
        "equal",
        "value",
        "right",
        "visit",
        "visitor",
        "ParameterOrder",
        "IN",
        "Override",
        "left",
        "right",
        "visitor",
        "left",
        "Override",
        "right",
        "_left",
        "getName",
        "equals",
        "right",
        "getName",
        "checkAreDistinct",
        "_left",
        "getCondition",
        "right",
        "getCondition",
        "right",
        "visit",
        "visitor",
        "ParameterOrder",
        "INTRINSIC",
        "Override",
        "left",
        "right",
        "visitor",
        "left",
        "Override",
        "right",
        "_left",
        "overlaps",
        "right",
        "right",
        "visit",
        "visitor",
        "ParameterOrder",
        "CONTAINS",
        "Override",
        "left",
        "right",
        "visitor",
        "left",
        "Override",
        "right",
        "leftMap",
        "_left",
        "getEntries",
        "rightMap",
        "right",
        "getEntries",
        "key",
        "Sets",
        "intersection",
        "leftMap",
        "keySet",
        "rightMap",
        "keySet",
        "checkAreDistinct",
        "leftMap",
        "get",
        "key",
        "rightMap",
        "get",
        "key",
        "right",
        "visit",
        "visitor",
        "ParameterOrder",
        "MAP",
        "Override",
        "left",
        "right",
        "right",
        "visit",
        "left",
        "ParameterOrder",
        "EQUAL",
        "Override",
        "left",
        "right",
        "Override",
        "left",
        "right",
        "Override",
        "left",
        "right",
        "_left",
        "left",
        "_left",
        "left",
        "leftOrder",
        "rightType",
        "rightType",
        "compareTo",
        "leftOrder",
        "right",
        "SubsetEvaluator",
        "isSubset",
        "_left",
        "right",
        "SubsetEvaluator",
        "isSubset",
        "right",
        "_left",
        "Override",
        "right",
        "leftOrder",
        "swapParameters",
        "leftOrder",
        "ParameterOrder",
        "CONSTANT",
        "checkAreDistinct",
        "right",
        "_left",
        "visit",
        "right",
        "right",
        "defaultDistinctCheck",
        "right",
        "Override",
        "right",
        "leftOrder",
        "swapParameters",
        "leftOrder",
        "ParameterOrder",
        "LIKE",
        "checkAreDistinct",
        "right",
        "_left",
        "visit",
        "right",
        "right",
        "defaultDistinctCheck",
        "right",
        "Override",
        "right",
        "leftOrder",
        "swapParameters",
        "leftOrder",
        "ParameterOrder",
        "COMPARISON",
        "checkAreDistinct",
        "right",
        "_left",
        "visit",
        "right",
        "right",
        "defaultDistinctCheck",
        "right",
        "Override",
        "right",
        "leftOrder",
        "swapParameters",
        "leftOrder",
        "ParameterOrder",
        "EQUAL",
        "checkAreDistinct",
        "right",
        "_left",
        "visit",
        "right",
        "right",
        "defaultDistinctCheck",
        "right",
        "Override",
        "right",
        "leftOrder",
        "swapParameters",
        "leftOrder",
        "ParameterOrder",
        "IN",
        "checkAreDistinct",
        "right",
        "_left",
        "visit",
        "right",
        "right",
        "defaultDistinctCheck",
        "right",
        "Override",
        "right",
        "leftOrder",
        "swapParameters",
        "leftOrder",
        "ParameterOrder",
        "INTRINSIC",
        "checkAreDistinct",
        "right",
        "_left",
        "visit",
        "right",
        "right",
        "defaultDistinctCheck",
        "right",
        "Override",
        "right",
        "leftOrder",
        "swapParameters",
        "leftOrder",
        "ParameterOrder",
        "IS",
        "checkAreDistinct",
        "right",
        "_left",
        "visit",
        "right",
        "right",
        "defaultDistinctCheck",
        "right",
        "Override",
        "right",
        "leftOrder",
        "swapParameters",
        "leftOrder",
        "ParameterOrder",
        "CONTAINS",
        "checkAreDistinct",
        "right",
        "_left",
        "visit",
        "right",
        "right",
        "defaultDistinctCheck",
        "right",
        "Override",
        "right",
        "leftOrder",
        "swapParameters",
        "leftOrder",
        "ParameterOrder",
        "MAP",
        "checkAreDistinct",
        "right",
        "_left",
        "visit",
        "right",
        "right",
        "defaultDistinctCheck",
        "right",
        "Override",
        "right",
        "leftOrder",
        "Override",
        "right",
        "leftOrder",
        "Override",
        "right",
        "leftOrder"
    ],
    "literals": [
        "\"left\"",
        "\"right\""
    ],
    "variables": [
        "_left"
    ],
    "comments": [
        "alwaysFalse() is always distinct from any other condition since it never returns true",
        "We've already established that _left.getValue() == true, so by the same logic as above",
        "they are only distinct if right == alwaysFalse()",
        "\"Like\" conditions are true only for strings, so it is distinct if the \"is\" condition cannot match strings.",
        "\"Like\" conditions are true only for strings, so it is distinct if the \"equal\" condition does not",
        "contain a string constant which matches the \"like\" condition.",
        "The conditions are distinct if the \"in\" condition contains no values the match the \"like\" condition.",
        "Numeric comparisons such as gt(10) are always distinct from a \"like\" condition which only matches strings.",
        "If the condition has a prefix then it can be used for comparison.",
        "The condition is something like \"*abc\", so it cannot be distinct from a comparison.",
        "The two are distinct if the \"like\" conditions prefix can never overlap with the comparison.",
        "For example, like(\"ba*\") is distinct from ge(\"be\") but not gt(\"b\"), since \"bat\" would satisfy both.",
        "If any value in the \"in\" condition matches then they are not distinct",
        "If any value in the \"in\" condition matches then they are not distinct",
        "If any value in the \"in\" condition matches then they are not distinct",
        "The two are distinct only if they match on intrinsic type and the conditions are distinct.",
        "Two maps can only be distinct if at least one key is guaranteed to be distinct from the other",
        "There are no overrides necessary for an equality condition; all special cases are handled by other overrides",
        "whose order in ParameterOrder will evaluate them in favor of this method."
    ],
    "docstrings": [
        "* Partial implementation of a condition evaluator to determine if two conditions are distinct.  This is true if for all\n * input values at most one of the conditions returns true from {@link ConditionEvaluator#eval(Condition, Object, Intrinsics)}.\n *\n * This evaluator is only used internally by {@link SubsetEvaluator} for the specific case where it is trying to\n * determine if, for two conditions c1 and c2, <code>c1</code> is a subset of <code>not(c2)</code>.  As previously\n * stated this is only a partial implementation and may not return correct values if either the left or right input\n * to {@link #areDistinct(Condition, Condition)} is a {@link NotCondition}, {@link AndCondition}, or {@link OrCondition}.\n * There are two reasons why these implementations are not provided:\n *\n * <ol>\n *     <li>\n *         The implementation for these conditions is complicated and requires condition evaluation capabilities currently\n *         not available.  For example, <code>and(ge(0),le(20))</code> is not distinct with <code>and(ge(10),le(30))</code>\n *         but there is no current ability to combine the two conditions into a single ranged condition.\n *     </li>\n *     <li>\n *         Implementations for these conditions are not necessary because they will never be called from SubsetEvaluator.\n *     </li>\n * </ol>\n *\n * Proof for the second reason above:\n *\n * The only circumstance this evaluator is used is if the right condition in the subset check is a \"not\" condition\n * and is handled by {@link SubsetEvaluator.LeftResolvedVisitor#visit(NotCondition, Void)}.  That method only checks\n * whether two conditions are distinct if neither the left nor the right's nested condition have an inverse.  \"Not\", \"and\", and\n * \"or\" conditions all have inverses as implemented by {@link InverseEvaluator#visit(NotCondition, Void)},\n * {@link InverseEvaluator#visit(AndCondition, Void)}, and {@link InverseEvaluator#visit(OrCondition, Void)},\n * respectively.  Therefore, SubsetEvaluator will never make a distinct check for any conditions where either the\n * left or right parameter is a \"not\", \"and\", or \"or\" condition.  This implementation returns false in all of those\n * cases as a conservative default, although as proven here those calls are never actually made.",
        "* For two conditions c1 and c2, <code>areDistinct(c1, c2)</code> == <code>areDistinct(c2, c1)</code>.\n     * Rather than implementing every possible combination of left and right condition type, resulting in a good deal\n     * of code duplication, this enumeration is used to control which methods actually need to be implemented.  Any call\n     * made where the right parameter's order is greater than the left's parameter order calls back to the method with the\n     * parameters swapped.\n     *\n     * For example, a call to <code>visit(IsCondition, LikeCondition)</code> is automatically forwarded to\n     * <code>visit(LikeCondition, IsCondition)</code> since <code>ParameterOrder.LIKE <= ParameterOrder.IS</code>.",
        "* Future:  Build an actual implementation.  Currently this call is never made and is here only to satisfy\n     * the {@link ConditionVisitor} interface.",
        "* Future:  Build an actual implementation.  Currently this call is never made and is here only to satisfy\n     * the {@link ConditionVisitor} interface.",
        "* Future:  Build an actual implementation.  Currently this call is never made and is here only to satisfy\n     * the {@link ConditionVisitor} interface.",
        "* Visitor used to provide typed evaluation of both the left and right conditions.  Default behavior for all\n     * combinations of conditions is:\n     *\n     * !left.subset(right) && !right.subset(left)\n     *\n     * For the cases where this is insufficient the subclass should override.",
        "* Check for whether, based on the left and right parameter type, the order should be reversed to\n         * satisfy requiring only a single implementation.",
        "* Returns the default distinct check which works most commonly, where neither left nor right are\n         * a subset of the other.",
        "* Future:  Build an actual implementation.  Currently this call is never made and is here only to satisfy\n         * the {@link ConditionVisitor} interface.",
        "* Future:  Build an actual implementation.  Currently this call is never made and is here only to satisfy\n         * the {@link ConditionVisitor} interface.",
        "* Future:  Build an actual implementation.  Currently this call is never made and is here only to satisfy\n         * the {@link ConditionVisitor} interface."
    ],
    "functions": [
        "areDistinct",
        "checkAreDistinct",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "LeftResolvedVisitor",
        "swapParameters",
        "defaultDistinctCheck",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit",
        "visit"
    ],
    "classes": [
        "DistinctEvaluator",
        "LeftResolvedVisitor"
    ]
}