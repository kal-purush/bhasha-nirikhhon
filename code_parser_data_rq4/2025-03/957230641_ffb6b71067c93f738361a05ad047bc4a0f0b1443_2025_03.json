{
    "identifiers": [
        "collections",
        "OrderedDict",
        "key",
        "val",
        "next",
        "prev",
        "key",
        "val",
        "next",
        "prev",
        "capacity",
        "capacity",
        "node",
        "node",
        "head",
        "new_lru_node",
        "new_lru_node",
        "head",
        "head",
        "new_lru_node",
        "new_lru_node",
        "node",
        "node",
        "target_node",
        "head",
        "target_node",
        "prev",
        "target_node",
        "next",
        "target_node",
        "next",
        "target_node",
        "prev",
        "head",
        "next",
        "head",
        "head",
        "target_node",
        "tail",
        "tail",
        "prev",
        "tail",
        "tail",
        "node",
        "remove_dll_node",
        "node",
        "add_dll_node",
        "node",
        "tail",
        "least_used_node",
        "hashmap",
        "least_used_node",
        "key",
        "remove_dll_node",
        "least_used_node",
        "length",
        "key",
        "val",
        "key",
        "hashmap",
        "length",
        "capacity",
        "evict_cache",
        "LRUNode",
        "key",
        "val",
        "add_dll_node",
        "new_lru_node",
        "hashmap",
        "new_lru_node",
        "length",
        "hashmap",
        "get",
        "key",
        "val",
        "move_to_head",
        "existing_node",
        "key",
        "key",
        "hashmap",
        "hashmap",
        "get",
        "key",
        "put",
        "key",
        "retrieved_node",
        "val",
        "retrieved_node",
        "val",
        "head",
        "current",
        "current",
        "key",
        "current",
        "val",
        "current",
        "next",
        "LRUCache",
        "cache",
        "put",
        "cache",
        "put",
        "cache",
        "put",
        "cache",
        "get",
        "cache",
        "put",
        "cache",
        "capacity",
        "OrderedDict",
        "capacity",
        "key",
        "key",
        "cache",
        "cache",
        "move_to_end",
        "key",
        "cache",
        "key",
        "key",
        "value",
        "key",
        "cache",
        "cache",
        "move_to_end",
        "key",
        "cache",
        "value",
        "len",
        "cache",
        "capacity",
        "cache",
        "popitem",
        "last",
        "cache",
        "value"
    ],
    "literals": [
        "''",
        "f\"key {current.key}: value {current.val}\"",
        "\"__main__\"",
        "\"a\"",
        "\"b\"",
        "\"c\"",
        "\"b\"",
        "\"d\""
    ],
    "variables": [
        "key",
        "val",
        "next",
        "prev",
        "hashmap",
        "head",
        "tail",
        "capacity",
        "length",
        "new_lru_node",
        "head",
        "tail",
        "new_lru_node",
        "next",
        "prev",
        "head",
        "new_lru_node",
        "prev",
        "target_node",
        "next",
        "prev",
        "head",
        "prev",
        "tail",
        "next",
        "least_used_node",
        "new_lru_node",
        "key",
        "existing_node",
        "existing_node",
        "val",
        "retrieved_node",
        "current",
        "current",
        "cache",
        "cache",
        "capacity",
        "key",
        "key"
    ],
    "comments": [
        "most recently used",
        "least recently used",
        "remove the target node from the list (DLL 'remove')",
        "wire node before target node to one after 'forwards'",
        "wire node after target node to one before 'backwards'",
        "if target node is head",
        "edge case: if there's only one node left",
        "handle case if the target node is the tail",
        "--Cache eviciton--: check if DLL is at capacity remove from dll and map",
        "add node to head of DLL and add to hashmap (DLL 'push_front')",
        "add node to head of DLL",
        "retrieve target node from reference in hashmap",
        "update value",
        "make MRU",
        "using OrderedDict:",
        "the 'end' is the most recently used side",
        "the 'end' is the most recently used side",
        "reached capacity so evict,last=false gets you the least recently used side"
    ],
    "docstrings": [
        "\"\"\"\nLRU Cache v2\n\nA cache that keeps track of most recentely and least recently used data as \nits 'heuristic' for cache eviction. \n\nIt leverages the strengths of two data structures working together. Using the O(1) features of a \ndoubly linked list (insertion and removal at ends) with the O(1) feature of a hashtable lookup to \nrandomly access nodes on the linked list. \n\nThe nitty gritty:\n\n- While doing an insert (or PUT) we insert the element in the head of the list and record it in the hashmap. \n-\n- If element is found (GET) , we move the node to the head of the list .\n-\n- When the list is full we discard the tail and update the corresponding hashmap entry as well.\n\n\n\"\"\"",
        "** this is the core logic of the cache ***"
    ],
    "functions": [
        "add_dll_node",
        "remove_dll_node",
        "move_to_head",
        "evict_cache",
        "put",
        "get",
        "get",
        "put"
    ],
    "classes": [
        "LRUNode",
        "LRUCache",
        "LRUCache2"
    ]
}