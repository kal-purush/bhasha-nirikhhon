{
    "identifiers": [
        "Microsoft",
        "CodeAnalysis",
        "Microsoft",
        "CodeAnalysis",
        "CSharp",
        "Microsoft",
        "CodeAnalysis",
        "CSharp",
        "Syntax",
        "Microsoft",
        "CodeAnalysis",
        "Diagnostics",
        "Collections",
        "Immutable",
        "Linq",
        "Microsoft",
        "Macios",
        "Bindings",
        "Analyzer",
        "DiagnosticAnalyzer",
        "LanguageNames",
        "CSharp",
        "DiagnosticAnalyzer",
        "LocalizableResourceString",
        "nameof",
        "Resources",
        "RBI0014Title",
        "Resources",
        "ResourceManager",
        "Resources",
        "LocalizableResourceString",
        "nameof",
        "Resources",
        "RBI0014MessageFormat",
        "Resources",
        "ResourceManager",
        "Resources",
        "DiagnosticSeverity",
        "isEnabledByDefault",
        "description",
        "LocalizableResourceString",
        "nameof",
        "Resources",
        "RBI0014Description",
        "Resources",
        "ResourceManager",
        "Resources",
        "ImmutableArray",
        "DiagnosticDescriptor",
        "ImmutableArray",
        "Create",
        "RBI0014",
        "AnalysisContext",
        "context",
        "context",
        "ConfigureGeneratedCodeAnalysis",
        "GeneratedCodeAnalysisFlags",
        "context",
        "EnableConcurrentExecution",
        "context",
        "RegisterSyntaxNodeAction",
        "AnalyzeNode",
        "SyntaxKind",
        "SimpleMemberAccessExpression",
        "ITypeSymbol",
        "typeSymbol",
        "typeSymbol",
        "TypeKind",
        "TypeKind",
        "TypeParameter",
        "ITypeParameterSymbol",
        "typeSymbol",
        "ConstraintTypes",
        "Any",
        "IsINativeObject",
        "t",
        "typeSymbol",
        "TypeKind",
        "TypeKind",
        "Interface",
        "typeSymbol",
        "ToDisplayString",
        "typeSymbol",
        "AllInterfaces",
        "Any",
        "i",
        "ToDisplayString",
        "MemberAccessExpressionSyntax",
        "memberAccess",
        "memberAccess",
        "Name",
        "Identifier",
        "Text",
        "name",
        "IMethodSymbol",
        "methodSymbol",
        "methodSymbol",
        "Name",
        "name",
        "IMethodSymbol",
        "methodSymbol",
        "methodSymbol",
        "MethodKind",
        "MethodKind",
        "Constructor",
        "methodSymbol",
        "ContainingType",
        "methodSymbol",
        "ReturnType",
        "SyntaxNodeAnalysisContext",
        "context",
        "context",
        "Node",
        "MemberAccessExpressionSyntax",
        "memberAccess",
        "IsHandleAccessor",
        "memberAccess",
        "memberAccess",
        "Expression",
        "context",
        "SemanticModel",
        "GetSymbolInfo",
        "expressionToCheck",
        "symbol",
        "symbol",
        "IParameterSymbol",
        "IsThis",
        "symbol",
        "IMethodSymbol",
        "methodSymbol",
        "IsINativeObject",
        "GetRealReturnType",
        "methodSymbol",
        "methodSymbol",
        "Name",
        "Diagnostic",
        "Create",
        "RBI0014",
        "memberAccess",
        "GetLocation",
        "symbol",
        "Name",
        "context",
        "ReportDiagnostic",
        "diagnostic",
        "symbol",
        "ILocalSymbol",
        "localSymbol",
        "varType",
        "localSymbol",
        "Type",
        "localSymbol",
        "IsUsing",
        "symbol",
        "IParameterSymbol",
        "parameterSymbol",
        "varType",
        "parameterSymbol",
        "Type",
        "IsINativeObject",
        "varType",
        "varType",
        "ContainingNamespace",
        "Name",
        "varType",
        "Name",
        "memberAccess",
        "Parent",
        "BinaryExpressionSyntax",
        "binaryParent",
        "binaryParent",
        "Kind",
        "SyntaxKind",
        "EqualsExpression",
        "SyntaxKind",
        "NotEqualsExpression",
        "memberAccess",
        "Parent",
        "FirstAncestorOrSelf",
        "UsingStatementSyntax",
        "usingStatement",
        "usingStatement",
        "Expression",
        "context",
        "SemanticModel",
        "GetSymbolInfo",
        "usingStatement",
        "Expression",
        "resourceSymbol",
        "SymbolEqualityComparer",
        "Default",
        "Equals",
        "resourceSymbol",
        "symbol",
        "usingStatement",
        "usingStatement",
        "Parent",
        "FirstAncestorOrSelf",
        "UsingStatementSyntax",
        "memberAccess",
        "FirstAncestorOrSelf",
        "BlockSyntax",
        "block",
        "memberAccess",
        "FirstAncestorOrSelf",
        "ConstructorDeclarationSyntax",
        "Body",
        "Statements",
        "statements",
        "statements",
        "Count",
        "context",
        "SemanticModel",
        "AnalyzeDataFlow",
        "statements",
        "First",
        "statements",
        "Last",
        "df",
        "accessedAfter",
        "df",
        "ReadInside",
        "Contains",
        "symbol",
        "accessedAfter",
        "memberAccess",
        "FirstAncestorOrSelf",
        "StatementSyntax",
        "statement",
        "block",
        "Statements",
        "IndexOf",
        "statement",
        "index",
        "index",
        "block",
        "Statements",
        "Count",
        "context",
        "SemanticModel",
        "AnalyzeDataFlow",
        "block",
        "Statements",
        "index",
        "block",
        "Statements",
        "Last",
        "df",
        "accessedAfter",
        "df",
        "ReadInside",
        "Contains",
        "symbol",
        "accessedAfter",
        "Diagnostic",
        "Create",
        "RBI0014",
        "memberAccess",
        "GetLocation",
        "symbol",
        "Name",
        "context",
        "ReportDiagnostic",
        "diagnostic"
    ],
    "literals": [
        "\"RBI0014\"",
        "\"Usage\"",
        "\"ObjCRuntime.INativeObject\"",
        "\"ObjCRuntime.INativeObject\"",
        "\"Handle\"",
        "\"GetHandle\"",
        "\"GetNonNullHandle\"",
        "\"GetCheckedHandle\"",
        "\"DangerousAutorelease\"",
        "\"GetConstant\"",
        "\"DangerousAutorelease\"",
        "\"GetConstant\"",
        "\"ObjCRuntime\"",
        "\"Class\"",
        "\"Selector\""
    ],
    "variables": [
        "DiagnosticDescriptor",
        "RBI0014",
        "SupportedDiagnostics",
        "name",
        "name",
        "ExpressionSyntax",
        "expressionToCheck",
        "symbol",
        "diagnostic",
        "ITypeSymbol",
        "varType",
        "usingStatement",
        "resourceSymbol",
        "accessedAfter",
        "block",
        "df",
        "statement",
        "index",
        "df",
        "diagnostic"
    ],
    "comments": [
        "Analyzer to ensure that native objects are kept alive for the duration of accessing them by their Handle.",
        "</summary>",
        "<remarks>",
        "Common pattern used in the manual bindings is to call a native method and pass objects using their",
        "handle like this:",
        "<code>",
        "var x = nw_framer_create_options (protocolDefinition.Handle);",
        "</code>",
        "If <c>protocolDefinition</c> is a local variable or method argument that is no longer accessed after",
        "the call then the .NET runtime may consider it eligible for garbage collection. Such garbage collection",
        "could run the object finalizer and render the <c>Handle</c> invalid while the native call is still in",
        "progress. In order to avoid this race condition the bindings have to keep the <c>protocolDefinition</c>",
        "variable alive for the garbage collector. This can be done by either accessing the same variable",
        "later in the method, or explicitly calling <c>GC.KeepAlive (protocolDefinition);</c>. This analyzer",
        "detects cases where such access is not performed and issues an error.",
        "",
        "Current shortcommings of the analyzer include:",
        "<list type=\"bullet\">",
        "<item><description>Handles stored inside an array are not tracked</description></item>",
        "<item><description>Only nearest scope is considered when checking if the variable is kept alive</description></item>",
        "</list>",
        "</remarks>",
        "White-list couple of methods that return one of the input parameters or a static",
        "object.",
        "Ignore methods that return a handle that is guaranteed to stay",
        "alive.",
        "Calling Handle directly on a value returned from method is wrong because",
        "the object is immediately collectible.",
        "Ignore variables that are wrapped in using block",
        "Exclude Class and Selector types, they are implicitly kept alive",
        "Skip over this.Handle == other.Handle checks",
        "Ignore variables that are wrapped in `using (existingVariable)` block. These are",
        "not excluded by the `localSymbol.IsUsing` condition above.",
        "We are not in a block. This can happen when handles are accessed in calls in constructor",
        "parameters, or if we are in an expression body. For constructors we have to check the",
        "method body for GC.KeepAlive or other references.",
        "We end up here for empty constructor bodies or bodies written as an",
        "expression. Assume that expressions don't access the variable and",
        "produce an error.",
        "Search just the immediate containing block for variable access"
    ],
    "docstrings": [
        "<summary>"
    ],
    "functions": [
        "Initialize",
        "IsINativeObject",
        "IsHandleAccessor",
        "IsSafeMethod",
        "ITypeSymbol",
        "GetRealReturnType",
        "AnalyzeNode"
    ],
    "classes": [
        "NativeObjectHandleAnalyzer"
    ]
}