{
    "identifiers": [
        "pennylane",
        "qml",
        "numpy",
        "np",
        "jax",
        "numpy",
        "jnp",
        "jax",
        "jax",
        "config",
        "update",
        "matplotlib",
        "pyplot",
        "plt",
        "datetime",
        "datetime",
        "qml",
        "PauliX",
        "qml",
        "PauliY",
        "qml",
        "PauliZ",
        "jnp",
        "pi",
        "nu",
        "p",
        "t",
        "jnp",
        "pi",
        "jnp",
        "sin",
        "nu",
        "t",
        "p",
        "wrapped",
        "omega",
        "qml",
        "PauliZ",
        "H",
        "amp",
        "omega",
        "qml",
        "PauliY",
        "jax",
        "jit",
        "qml",
        "qnode",
        "qml",
        "device",
        "wires",
        "t",
        "qml",
        "evolve",
        "H",
        "t",
        "return_intermediate",
        "qml",
        "expval",
        "op",
        "op",
        "X",
        "Y",
        "Z",
        "jnp",
        "linspace",
        "trajectory",
        "ts",
        "trajectory",
        "jnp",
        "pi",
        "ts",
        "plt",
        "figure",
        "fig",
        "add_subplot",
        "projection",
        "ax",
        "plot",
        "res0",
        "label",
        "ax",
        "plot",
        "res1",
        "label",
        "ax",
        "legend",
        "nu",
        "p",
        "t",
        "p",
        "jnp",
        "sin",
        "nu",
        "t",
        "p",
        "wrapped",
        "omega",
        "qml",
        "PauliZ",
        "H1",
        "amp",
        "omega",
        "Y",
        "jax",
        "jit",
        "qml",
        "qnode",
        "qml",
        "device",
        "wires",
        "Omega0",
        "phi",
        "qml",
        "evolve",
        "H1",
        "Omega0",
        "phi",
        "qml",
        "expval",
        "op",
        "op",
        "X",
        "Y",
        "Z",
        "jnp",
        "linspace",
        "jax",
        "vmap",
        "trajectory",
        "Omegas",
        "jax",
        "vmap",
        "trajectory",
        "Omegas",
        "jnp",
        "pi",
        "plt",
        "figure",
        "fig",
        "add_subplot",
        "projection",
        "ax",
        "plot",
        "res0",
        "label",
        "ax",
        "plot",
        "res1",
        "label",
        "ax",
        "legend",
        "qml",
        "device",
        "wires",
        "wire",
        "qml",
        "device",
        "device_arn",
        "wires",
        "shots",
        "dev_lucy",
        "pulse_settings",
        "wire",
        "qml",
        "pulse",
        "transmon_interaction",
        "qubit_freq",
        "qubit_freq",
        "connections",
        "coupling",
        "wires",
        "wire",
        "qml",
        "pulse",
        "transmon_drive",
        "amplitude",
        "qml",
        "pulse",
        "constant",
        "phase",
        "qml",
        "pulse",
        "constant",
        "freq",
        "qubit_freq",
        "wires",
        "wire",
        "duration",
        "qml",
        "evolve",
        "H0",
        "Hd0",
        "t",
        "duration",
        "qml",
        "expval",
        "qml",
        "PauliZ",
        "wire",
        "jax",
        "jit",
        "qml",
        "QNode",
        "circuit",
        "dev_sim",
        "qml",
        "QNode",
        "circuit",
        "dev_lucy",
        "scipy",
        "optimize",
        "curve_fit",
        "x",
        "y",
        "initial_guess",
        "np",
        "linspace",
        "np",
        "min",
        "x",
        "np",
        "max",
        "x",
        "x",
        "A",
        "omega",
        "phi",
        "A",
        "np",
        "sin",
        "omega",
        "x",
        "phi",
        "curve_fit",
        "sinusoidal_func",
        "np",
        "array",
        "x",
        "np",
        "array",
        "y",
        "maxfev",
        "p0",
        "initial_guess",
        "sinusoidal_func",
        "x_fit",
        "x_fit",
        "y_fit",
        "np",
        "linspace",
        "t0",
        "t1",
        "num_ts",
        "jnp",
        "array",
        "amp0",
        "phi0",
        "qnode_lucy",
        "t",
        "t",
        "x_lucy",
        "fint_sine",
        "x_lucy",
        "y_lucy",
        "plt",
        "plot",
        "x_lucy",
        "y_lucy",
        "label",
        "plt",
        "plot",
        "x_lucy_fit",
        "y_lucy_fit",
        "color",
        "label",
        "coeffs_fit_lucy",
        "coeffs_fit_lucy",
        "coeffs_fit_lucy",
        "alpha",
        "jnp",
        "array",
        "amp0",
        "phi0",
        "jnp",
        "linspace",
        "jax",
        "vmap",
        "qnode_sim",
        "params_sim",
        "x_sim",
        "fint_sine",
        "x_sim",
        "y_sim",
        "np",
        "pi",
        "plt",
        "plot",
        "x_sim",
        "y_sim",
        "label",
        "plt",
        "plot",
        "x_fit",
        "y_fit",
        "color",
        "label",
        "coeffs_fit_sim",
        "coeffs_fit_sim",
        "coeffs_fit_sim",
        "alpha",
        "plt",
        "legend",
        "plt",
        "ylabel",
        "plt",
        "xlabel",
        "plt",
        "show",
        "np",
        "abs",
        "coeffs_fit_lucy",
        "coeffs_fit_sim",
        "attenuation",
        "plt",
        "plot",
        "x_lucy",
        "y_lucy",
        "label",
        "plt",
        "plot",
        "x_lucy_fit",
        "y_lucy_fit",
        "color",
        "label",
        "coeffs_fit_lucy",
        "coeffs_fit_lucy",
        "coeffs_fit_lucy",
        "alpha",
        "jnp",
        "array",
        "attenuation",
        "amp0",
        "phi0",
        "jnp",
        "linspace",
        "jax",
        "vmap",
        "qnode_sim",
        "params_sim",
        "x_sim",
        "fint_sine",
        "x_sim",
        "y_sim",
        "np",
        "pi",
        "plt",
        "plot",
        "x_sim",
        "y_sim",
        "label",
        "plt",
        "plot",
        "x_fit",
        "y_fit",
        "color",
        "label",
        "coeffs_fit_sim",
        "coeffs_fit_sim",
        "coeffs_fit_sim",
        "alpha",
        "plt",
        "legend",
        "plt",
        "ylabel",
        "plt",
        "xlabel",
        "plt",
        "show",
        "p",
        "t",
        "attenuation",
        "p",
        "qml",
        "pulse",
        "transmon_drive",
        "amplitude",
        "qml",
        "pulse",
        "constant",
        "qubit_freq",
        "wires",
        "wire",
        "jax",
        "jit",
        "qml",
        "qnode",
        "dev_sim",
        "duration",
        "qml",
        "evolve",
        "H0",
        "Hd_attenuated",
        "t",
        "duration",
        "atol",
        "qml",
        "expval",
        "qml",
        "PauliX",
        "wire",
        "qml",
        "expval",
        "qml",
        "PauliY",
        "wire",
        "qml",
        "expval",
        "qml",
        "PauliZ",
        "wire",
        "qml",
        "qnode",
        "dev_lucy",
        "duration",
        "qml",
        "evolve",
        "H0",
        "Hd0",
        "t",
        "duration",
        "qml",
        "expval",
        "qml",
        "PauliX",
        "wire",
        "qml",
        "expval",
        "qml",
        "PauliY",
        "wire",
        "qml",
        "expval",
        "qml",
        "PauliZ",
        "wire",
        "np",
        "pi",
        "np",
        "pi",
        "np",
        "linspace",
        "phi0",
        "phi1",
        "n_phis",
        "qnode_lucy",
        "amp0",
        "phi",
        "phi",
        "x_lucy",
        "plt",
        "subplots",
        "ncols",
        "figsize",
        "axs",
        "ax",
        "plot",
        "x_lucy",
        "y_lucy",
        "label",
        "ax",
        "plot",
        "x_lucy",
        "y_lucy",
        "label",
        "ax",
        "plot",
        "x_lucy",
        "y_lucy",
        "label",
        "ax",
        "plot",
        "x_lucy",
        "np",
        "sum",
        "y_lucy",
        "axis",
        "label",
        "ax",
        "set_xlabel",
        "ax",
        "set_title",
        "wire",
        "ax",
        "set_ylim",
        "x_lucy",
        "jnp",
        "array",
        "amp0",
        "phi",
        "phi",
        "x_sim",
        "np",
        "array",
        "jax",
        "vmap",
        "qnode_sim",
        "params_sim",
        "axs",
        "ax",
        "plot",
        "x_sim",
        "y_sim",
        "label",
        "ax",
        "plot",
        "x_sim",
        "y_sim",
        "label",
        "ax",
        "plot",
        "x_sim",
        "y_sim",
        "label",
        "ax",
        "plot",
        "x_sim",
        "np",
        "sum",
        "y_sim",
        "axis",
        "label",
        "ax",
        "set_xlabel",
        "ax",
        "set_title",
        "ax",
        "legend",
        "ax",
        "set_ylim"
    ],
    "literals": [
        "r\"\"\"Pulse programming on OQC Lucy in PennyLane\n==============================================\n\n.. meta::\n    :property=\"og:description\": Perform hardware-level pulse gates on superconducting qubits in PennyLane\n    :property=\"og:image\": https://pennylane.ai/qml/_images/thumbnail_intro_oqc_pulse.png\n\n.. related::\n   ahs_aquila Pulse programming on Rydberg atom hardware\n   tutorial_pulse_programming101 Differentiable pulse programming with qubits in PennyLane\n\n*Author: Korbinian Kottmann â€” Posted: 30 October 2023.*\n\nPulse-level access to quantum computers offers many interesting new avenues in\nquantum optimal control, variational quantum algorithms and device-aware algorithm design.\nWe now have the possibility to run hardware-level circuits combined with standard gates on a\nphysical device in ``PennyLane`` via ``AWS Braket`` on OQC's Lucy quantum computer. In this demo, \nwe explain the underlying physical principles of driving transmon qubits and show how to perform custom pulse gates on hardware through PennyLane.\n\n.. figure:: ../demonstrations/oqc_pulse/thumbnail_intro_oqc_pulse.png\n    :align: center\n    :width: 70%\n    :alt: Illustration of how single-qubit rotations are realized by Z-precession and Rabi oscillation\n    :target: javascript:void(0);\n\n\n\nIntroduction\n------------\n\nAdditionally to accessing `neutral atom quantum computers by Quera through PennyLane and AWS <ahs_aquila>`_, we now \nhave the possibility to access `Lucy` by Oxford Quantum Computing (OQC), an 8-qubit superconducting quantum computer with a ring-like connectivity.\nThrough the `PennyLane-Braket plugin <https://amazon-braket-pennylane-plugin-python.readthedocs.io/en/latest/>`_,\nwe are able to design custom pulse gates that control the physical qubits at the lowest hardware level.\nA neat feature is the ability to combine `digital` gates like :math:`\\text{CNOT}, H, R_x, R_y, R_z` with `pulse` gates.\nThis ability allows us to differentiate parametrized pulse gates natively on hardware via our recently introduced \n`ODEgen` method [#Kottmann]_, which we will discuss in detail in a future demo.\n\nIn this demo, we are going to explore the physical principles for hardware level control of transmon qubits and run custom pulse gates on \nOQC Lucy via the `pennylane-braket plugin <https://amazon-braket-pennylane-plugin-python.readthedocs.io/en/latest/>`__.\nFor a general introduction to pulse programming, see our `recent demo on it <tutorial_pulse_programming101>`_.\n\n.. note::\n\n    To access remote services on Amazon Braket, you first need to\n    `create an account on AWS <https://aws.amazon.com/braket/getting-started/>`__ and follow the\n    `setup instructions <https://github.com/aws/amazon-braket-sdk-python>`__ for accessing Braket from Python.\n    You also need to install the `pennylane-braket plugin <https://amazon-braket-pennylane-plugin-python.readthedocs.io/en/latest/>`__.\n\n\nTransmon Physics\n----------------\n\nIn this section, we are going to give an intuitive intro to the physical principles behind the control of superconducting transmon qubits.\n\nOxford Quantum Circuit's Lucy is a quantum computer with 8 superconducting transmon qubits based on the Coaxmon design [#Rahamim]_.\nIn order to control a transmon qubit, it is driven by a microwave pulse. The interaction between the transmon and the pulse can be\nmodeled by the Hamiltonian\n\n.. math:: H(t) = - \\frac{\\omega_q}{2} Z_q + \\Omega_q(t) \\sin(\\nu_q t + \\phi_q) Y_q\n\nwhere operators :math:`\\{X_q, Y_q, Z_q\\}` refer to the single-qubit Pauli operators acting on qubit :math:`q`, :math:`\\omega_q` is the qubit frequency, :math:`\\Omega_q(t)` is the drive amplitude,  :math:`\\nu_q` denotes the drive frequency, and :math:`\\phi_q` is the phase of the pulse.\nAll of these parameters are given or set for each qubit :math:`q =0, 1, .., 7` on the device.\nSince we are going to focus on driving one single qubit, we are going to drop the subscript :math:`q` from here on.\nWe refer to section IV D in reference [#Krantz]_ for a good derivation and review from first principles.\n\nWe now want to understand the action of driving a qubit with this Hamiltonian.\nThe first term leads to a constant precession around the Z-axis on the Bloch sphere, whereas the second term introduces\nthe so-called Rabi oscillation between :math:`|0\\rangle` and :math:`|1\\rangle`.\nThis can be seen by the following simple simulation:\nWe evolve the state in the Bloch sphere from :math:`|0\\rangle` with a constant pulse of :math:`\\Omega(t) = 2 \\pi \\text{ GHz}`\nfor :math:`1 \\text{ ns}`. We choose :math:`\\omega = 5 \\times 2\\pi \\text{ GHz}` as the drive and qubit frequency (i.e. we are at resonance :math:`\\omega - \\nu = 0`).\n\"\"\"",
        "\"jax_enable_x64\"",
        "\"default.qubit\"",
        "\"jax\"",
        "'3d'",
        "\"-\"",
        "\"$\\\\phi=0$\"",
        "\"-\"",
        "\"$\\\\phi=\\\\pi/2$\"",
        "\"default.qubit\"",
        "\"jax\"",
        "'3d'",
        "\"-\"",
        "\"$\\\\Phi=0$\"",
        "\"-\"",
        "\"$\\\\Phi=\\\\pi/2$\"",
        "\"default.qubit\"",
        "\"braket.aws.qubit\"",
        "\"arn:aws:braket:eu-west-2::device/qpu/oqc/Lucy\"",
        "\"qubit_freq\"",
        "\"jax\"",
        "\"jax\"",
        "\"x:\"",
        "\"data\"",
        "\"-\"",
        "\"tab:blue\"",
        "f\"{coeffs_fit_lucy[0]:.3f} sin({coeffs_fit_lucy[1]:.3f} t + {coeffs_fit_lucy[2]:.3f})\"",
        "\"x-\"",
        "\"sim\"",
        "\"-\"",
        "\"tab:orange\"",
        "f\"{coeffs_fit_sim[0]:.3f} sin({coeffs_fit_sim[1]:.3f} t + {coeffs_fit_sim[2]:.3f})\"",
        "\"<Z>\"",
        "\"t1\"",
        "\"x:\"",
        "\"data\"",
        "\"-\"",
        "\"tab:blue\"",
        "f\"{coeffs_fit_lucy[0]:.3f} sin({coeffs_fit_lucy[1]:.3f} t + {coeffs_fit_lucy[2]:.3f})\"",
        "\"x-\"",
        "\"sim\"",
        "\"-\"",
        "\"tab:orange\"",
        "f\"{coeffs_fit_sim[0]:.3f} sin({coeffs_fit_sim[1]:.3f} t + {coeffs_fit_sim[2]:.3f})\"",
        "\"<Z>\"",
        "\"t1\"",
        "\"jax\"",
        "\"jax\"",
        "\"x-\"",
        "\"$\\\\langle X \\\\rangle$\"",
        "\"x-\"",
        "\"$\\\\langle Y \\\\rangle$\"",
        "\"x-\"",
        "\"$\\\\langle Z \\\\rangle$\"",
        "\":\"",
        "\"$\\\\langle X \\\\rangle^2 + \\\\langle Y \\\\rangle^2 + \\\\langle Z \\\\rangle^2$\"",
        "\"$\\\\phi$\"",
        "f\"OQC Lucy qubit {wire}\"",
        "\"x-\"",
        "\"$\\\\langle X \\\\rangle$\"",
        "\"x-\"",
        "\"$\\\\langle Y \\\\rangle$\"",
        "\"x-\"",
        "\"$\\\\langle Z \\\\rangle$\"",
        "\":\"",
        "\"$\\\\langle X \\\\rangle^2 + \\\\langle Y \\\\rangle^2 + \\\\langle Z \\\\rangle^2$\"",
        "\"$\\\\phi$\"",
        "\"Simulation\""
    ],
    "variables": [
        "X",
        "Y",
        "Z",
        "omega",
        "H",
        "ts",
        "res0",
        "res1",
        "fig",
        "ax",
        "H1",
        "Omegas",
        "res0",
        "res1",
        "fig",
        "ax",
        "wire",
        "dev_sim",
        "dev_lucy",
        "qubit_freq",
        "H0",
        "Hd0",
        "qnode_sim",
        "qnode_lucy",
        "x_fit",
        "_",
        "y_fit",
        "t0",
        "t1",
        "num_ts",
        "phi0",
        "amp0",
        "x_lucy",
        "y_lucy",
        "x_lucy_fit",
        "y_lucy_fit",
        "coeffs_fit_lucy",
        "params_sim",
        "x_sim",
        "y_sim",
        "x_fit",
        "y_fit",
        "coeffs_fit_sim",
        "attenuation",
        "params_sim",
        "x_sim",
        "y_sim",
        "x_fit",
        "y_fit",
        "coeffs_fit_sim",
        "Hd_attenuated",
        "phi0",
        "phi1",
        "n_phis",
        "amp0",
        "x_lucy",
        "y_lucy",
        "fig",
        "axs",
        "ax",
        "x_sim",
        "params_sim",
        "y_sim",
        "ax"
    ],
    "comments": [
        "To generate a time-dependent ``ParametrizedHamiltonian``, we multiply a ``callable``",
        "and an ``Operator``.",
        "Due to PennyLane convention, the callable has to have the signature (p, t).",
        "Here, the only parameter that we control is the phase ``p`` in the sinusodial.",
        "We generate a qnode that evolves the qubit state according to the time-dependent",
        "Hamiltonian H.",
        "By setting ``return_intermediate=True``, we can output all intermediate time steps.",
        "We compute the time series for 10000 samples for the phase equal to 0 and pi/2, respectively.",
        "We plot the evolution in the Bloch sphere.",
        "",
        "",
        ".. figure:: ../demonstrations/oqc_pulse/qubit_rotation.png",
        ":align: center",
        ":width: 70%",
        ":alt: single-qubit rotations with different phases leading to different effective rotation axes",
        ":target: javascript:void(0);",
        "",
        "Driving a transmon qubits leads to a spiral movement on the Bloch sphere in the lab frame. It results from a constant Z-axis precession together with the Rabi oscillation from the drive on resonance.",
        "",
        "We can see that for a fixed time, we land on different longitudes on the Bloch sphere for different phases :math:`\\phi`.",
        "This means that we can control the rotation axis of the logical gate by setting the phase :math:`\\phi`",
        "of the drive. Another way of seeing this is by fixing the pulse duration and looking at the",
        "final state for different amplitudes and two phases shifted by :math:`\\pi/2`.",
        "We change the ``callable`` of the time-dependent Hamiltonian and",
        "now can control both amplitude (p[0]) and phase (p[1]).",
        "This time we compute the full evolution until the final time after 20ns",
        "return_intermediate=False is the default, so we dont have to set it explicitly.",
        "We use ``jax.vmap`` to efficiently evaluate the ``trajectory`` function for all amplitudes",
        "``Omegas``. We repeat that procedure for the phase equal to 0 and pi/2 again.",
        "",
        "",
        ".. figure:: ../demonstrations/oqc_pulse/qubit_rotation2.png",
        ":align: center",
        ":width: 70%",
        ":alt: single-qubit rotations with different phases leading to different effective rotation axes",
        ":target: javascript:void(0);",
        "",
        "Results on the Bloch sphere after driving with different amplitudes and phases. Setting the phase :math:`\\phi` leads to different rotation axes.",
        "",
        "",
        "",
        "So far, we have looked at transmon physics in the so-called lab frame. Another common way of understanding transmon physics",
        "is via the Hamiltonian expressed in the `qubit frame,` which rotates at the qubit frequency.",
        "We can change frames via the unitary transformation",
        ":math:`R = e^{-i \\frac{\\omega}{2}Z}` that leads to the transformed Hamiltonian :math:`\\tilde{H}(t) = i R R^\\dagger + R H R^\\dagger`.",
        "In the rotating wave approximation (RWA) and on resonance (:math:`\\omega = \\nu`), this yields",
        "",
        ".. math:: \\tilde{H}(t) = - \\frac{1}{2} \\Omega(t) (\\cos(\\phi) X + \\sin(\\phi) Y).",
        "",
        "This is another way of seeing how setting the phase :math:`\\phi` controls the rotation axis of the qubit.",
        "In particular, we see how :math:`\\phi = 0` (:math:`\\pi/2`) leads to a :math:`X` (:math:`Y`) rotation.",
        "For a detailed derivation of the qubit frame Hamiltonian above, see reference [#Krantz]_, section IV, D1 (eq. (79) onwards).",
        "",
        "Rabi Oscillation Calibration",
        "----------------------------",
        "",
        "We now want to drive a qubit on OQC's Lucy by sending custom pulses via PennyLane.",
        "For better comparability with classical simulations, we calibrate the attenuation :math:`\\xi` between the device voltage output :math:`V_0`",
        "and the actual voltage :math:`V_\\text{device} = \\xi V_0` that the the superconducting qubit receives.",
        "The attenuation :math:`\\xi` accounts for all losses between the arbitrary waveform generator (AWG) that outputs the signal in",
        "the lab at room temperature and all wires that lead to the cooled down chip in a cryostat.",
        "",
        "We start by setting up the real device and a simulation device and perform all measurements on qubit 5.",
        "",
        "We again define the drive Hamiltonian in PennyLane, where we control the constant amplitude and phase, set by the callable",
        "constant function :func:`~.pennylane.pulse.constant`.",
        "For execution on the device, we need specific Hamiltonian objects for transmon qubit devices. In particular, we use",
        ":func:`~.pennylane.pulse.transmon_interaction` and :func:`~.pennylane.pulse.transmon_drive`.",
        "This corresponds to the Z term for a single qubit with no interactions.",
        "This corresponds to the drive term proportional to Y.",
        "We can control the amplitude and phase via a callable parameter.",
        "The drive frequency is set equal to the qubit's resonance frequency.",
        "We create two qunodes, one that executes on the remote device",
        "and one in simulation for comparison.",
        "",
        "We are going to fit the resulting Rabi oscillations to a sinusoid. For this we use",
        "a little helper function.",
        "Define the function to fit (sinusoidal)",
        "Perform the curve fit",
        "Generate the fitted curve",
        "",
        "We can now execute the same constant pulse for different evolution times and see Rabi oscillation",
        "in the evolution of :math:`\\langle Z \\rangle`.",
        "",
        "And we compare that to the same pulses in simulation.",
        "",
        "",
        ".. figure:: ../demonstrations/oqc_pulse/calibration0.png",
        ":align: center",
        ":width: 70%",
        ":alt: Rabi oscillation for different pulse lengths.",
        ":target: javascript:void(0);",
        "",
        "Calibrating the attenuation of the amplitude on the real device. We see much slower Rabi oscillations compared to simulation because on the real device, the amplitude that arrives at the qubit is attenuated.",
        "",
        "",
        "We see that the oscillation on the real device is significantly slower due to the attenuation.",
        "We can estimate this attenuation by the ratio of the measured Rabi frequency for the simulation and device execution.",
        "",
        ".. rst-class:: sphx-glr-script-out",
        "",
        "",
        ".. code-block:: none",
        "",
        "0.14315176924173267",
        "",
        "",
        "We can now plot the same comparison above but with the attenuation factored in and see a",
        "better match between simulation and device execution.",
        "same circuit but in simulation",
        "",
        "",
        ".. figure:: ../demonstrations/oqc_pulse/calibration1.png",
        ":align: center",
        ":width: 70%",
        ":alt: Rabi oscillation for different pulse lengths.",
        ":target: javascript:void(0);",
        "",
        "Taking into account the attenuation, we get a much better match between simulation and hardware execution.",
        "",
        "",
        "",
        "In particular, we see a match in both Rabi frequencies. The error in terms of the magnitude of the Rabi oscillation",
        "may be due to different sources. For one, the qubit has a readout fidelity of :math:`93\\%`, according to the vendor.",
        "Another possible source is classical and quantum crosstalk that is not considered in our classical model. Though, we suspect the main source",
        "for error beyond readout fidelity to come from excitations to higher levels, caused by strong amplitudes and rapid",
        "changes in the signal.",
        "",
        "X-Y Rotations",
        "-------------",
        "",
        "We now want to experiment with performing X- and Y-rotations by setting the phase.",
        "For that, we compute expectation values of :math:`\\langle X \\rangle`, :math:`\\langle Y \\rangle`, and :math:`\\langle Z \\rangle`",
        "while changing the phase :math:`\\phi` at a fixed duration of :math:`15 \\text{ ns}` and output amplitude of :math:`0.3` (arbitrary unit :math:`\\in [0, 1]`).",
        "For more realistic simulations, we attenuate the (constant) amplitude",
        "",
        "With the attenuation explicitly taken into account, we can now achieve a good comparison",
        "between simulation and device execution.",
        "",
        "",
        ".. figure:: ../demonstrations/oqc_pulse/calibration2.png",
        ":align: center",
        ":width: 85%",
        ":alt: Rabi oscillation for different pulse lengths.",
        ":target: javascript:void(0);",
        "",
        "By changing the phase of our constant drive, we arrive on different longitudes on the Bloch sphere. The rotation angle, given by the constant amplitude and pulse duration, is constant as indicated by the Z component.",
        "",
        "As expected, we see a constant :math:`\\langle Z \\rangle` contribution, as changing :math:`\\phi` delays the precession around the Z-axis",
        "and we land on a fixed latitude. What is changed is the longitude, leading to different rotation axes in the X-Y-plane.",
        "The qubit frame interpretation of this picture is that we simply change the rotation axis by setting different phases, as discussed in",
        "the last paragraph of the transmon physics section above.",
        "",
        "",
        "",
        "Conclusion",
        "----------",
        "",
        "Overall, we have demonstrated the basic working principles of transmon qubit devices and have shown how one can perform such hardware-level manipulations",
        "on a physical device in PennyLane. Stay tuned for more content on differentiating pulse circuits natively on hardware in a future demo on ``ODEgen`` [#Kottmann]_.",
        "",
        "",
        "",
        "References",
        "----------",
        "",
        ".. [#Rahamim]",
        "",
        "J. Rahamim, T. Behrle, M. J. Peterer, A. Patterson, P. Spring, T. Tsunoda, R. Manenti, G. Tancredi, P. J. Leek",
        "\"Double-sided coaxial circuit QED with out-of-plane wiring\"",
        "`arXiv:1703.05828 <https://arxiv.org/abs/1703.05828>`__, 2017.",
        "",
        ".. [#Krantz]",
        "",
        "Philip Krantz, Morten Kjaergaard, Fei Yan, Terry P. Orlando, Simon Gustavsson, William D. Oliver",
        "\"A Quantum Engineer's Guide to Superconducting Qubits\"",
        "`arXiv:1904.06560 <https://arxiv.org/abs/1904.06560>`__, 2019.",
        "",
        ".. [#Kottmann]",
        "",
        "Korbinian Kottmann, Nathan Killoran",
        "\"Evaluating analytic gradients of pulse programs on quantum computers\"",
        "`arXiv:2309.16756 <https://arxiv.org/abs/2309.16756>`__, 2023.",
        "",
        "",
        "About the author",
        "----------------",
        ".. include:: ../_static/authors/korbinian_kottmann.txt"
    ],
    "docstrings": [
        "\"\"\"initial guess = [A, omega, phi]\"\"\""
    ],
    "functions": [
        "amp",
        "wrapped",
        "trajectory",
        "amp",
        "wrapped",
        "trajectory",
        "circuit",
        "fint_sine",
        "sinusoidal_func",
        "amplitude",
        "qnode_sim",
        "qnode_lucy"
    ],
    "classes": []
}