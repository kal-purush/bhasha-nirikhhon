{
    "identifiers": [
        "kOS",
        "Safe",
        "Encapsulation",
        "kOS",
        "Safe",
        "Encapsulation",
        "Suffixes",
        "kOS",
        "Safe",
        "Serialization",
        "Collections",
        "Generic",
        "kOS",
        "Safe",
        "kOS",
        "Suffixed",
        "kOS",
        "Safe",
        "Utilities",
        "KOSNomenclature",
        "SerializableStructure",
        "KSPUtil",
        "dateTimeFormatter",
        "Day",
        "KSPUtil",
        "dateTimeFormatter",
        "Hour",
        "KSPUtil",
        "dateTimeFormatter",
        "Year",
        "KSPUtil",
        "dateTimeFormatter",
        "Minute",
        "InitializeSuffixes",
        "unixStyleTime",
        "seconds",
        "unixStyleTime",
        "Floor",
        "seconds",
        "SecondsPerYear",
        "CountOffset",
        "ScalarValue",
        "newValue",
        "newValue",
        "CountOffset",
        "seconds",
        "seconds",
        "SecondsPerYear",
        "zeroBasedNewValue",
        "SecondsPerYear",
        "Floor",
        "seconds",
        "SecondsPerYear",
        "SecondsPerDay",
        "CountOffset",
        "ScalarValue",
        "newValue",
        "newValue",
        "CountOffset",
        "seconds",
        "Floor",
        "seconds",
        "SecondsPerYear",
        "SecondsPerDay",
        "seconds",
        "zeroBasedNewValue",
        "SecondsPerDay",
        "Floor",
        "seconds",
        "SecondsPerDay",
        "SecondsPerHour",
        "ScalarValue",
        "newValue",
        "newValue",
        "CountOffset",
        "seconds",
        "Floor",
        "seconds",
        "SecondsPerDay",
        "SecondsPerHour",
        "seconds",
        "zeroBasedNewValue",
        "SecondsPerHour",
        "Floor",
        "seconds",
        "SecondsPerHour",
        "SecondsPerMinute",
        "ScalarValue",
        "newValue",
        "newValue",
        "CountOffset",
        "seconds",
        "Floor",
        "seconds",
        "SecondsPerHour",
        "SecondsPerMinute",
        "seconds",
        "zeroBasedNewValue",
        "SecondsPerMinute",
        "Floor",
        "seconds",
        "SecondsPerMinute",
        "ScalarValue",
        "newValue",
        "newValue",
        "CountOffset",
        "seconds",
        "Floor",
        "seconds",
        "SecondsPerMinute",
        "seconds",
        "zeroBasedNewValue",
        "seconds",
        "seconds",
        "GetHashCode",
        "Format",
        "seconds"
    ],
    "literals": [
        "\"TimeBase\"",
        "\"TIME({0:0})\""
    ],
    "variables": [
        "DumpName",
        "CountOffset",
        "seconds",
        "SecondsPerDay",
        "SecondsPerHour",
        "SecondsPerYear",
        "SecondsPerMinute",
        "zeroBasedNewValue",
        "zeroBasedNewValue",
        "zeroBasedNewValue",
        "zeroBasedNewValue",
        "zeroBasedNewValue"
    ],
    "comments": [
        "Both TimeStamp and TimeSpan will be derived from this common base class,",
        "to avoid duplicate code between them.  This is because really the only",
        "difference between TimeStamp and TimeSpan is whether the nomenlcature",
        "counts starting at 1 or starting at 0.  The Kerbal calendar doesn't have",
        "all the same ugly problems as the real world calender that necessitate a",
        "separate timestamp type (a leap day in the middle of the year instead of",
        "at the end offsetting all the dates that come after Feb 29th, for example,",
        "or having this mythical concept of 'a month' which isn't even the same",
        "number of days for all months, etc.  The Kerbals never bothered with months",
        "and instead just count days into the year, and don't put in leap days, instead",
        "just having the same leftover fractional day at the end of every year.  These",
        "things make a seprate timespan and timestamp type a bit less necessary in the",
        "Kerbal world, but one the remaining difference is whether you count starting at 1",
        "or starting at 0.",
        "</summary>",
        "For serializaation, how will it be named in the JSON output.",
        "</summary>",
        "Override with either 0 or 1 for whether counting years and days starts counting at 0 or at 1.",
        "</summary>",
        "Only used by CreateFromDump() and the other constructors.",
        "Don't make it public because it leaves fields",
        "unpopulated:",
        "Required for all IDumpers for them to work, but can't enforced by the interface because it's static:",
        "Derivative classes of TimeBase need to make something like this, replacing \"TimeBase\" with their own\n         * class name:\n         * \n        public static TimeBase CreateFromDump(SafeSharedObjects shared, Dump d)\n        {\n            var newObj = new TimeBase();\n            newObj.LoadDump(d);\n            return newObj;\n        }\n        *",
        "need to give the two types different suffixes\n         * \n        private void InitializeSuffixes()\n        {\n            AddSuffix(\"YEAR\", new Suffix<ScalarValue>(CalculateYear));\n            AddSuffix(\"DAY\", new Suffix<ScalarValue>(CalculateDay));\n            AddSuffix(\"HOUR\", new Suffix<ScalarValue>(CalculateHour));\n            AddSuffix(\"MINUTE\", new Suffix<ScalarValue>(CalculateMinute));\n            AddSuffix(\"SECOND\", new Suffix<ScalarValue>(CalculateSecond));\n            AddSuffix(\"SECONDS\", new Suffix<ScalarValue>(() => seconds));\n            AddSuffix(\"CLOCK\", new Suffix<StringValue>(() => string.Format(\"{0:00}:{1:00}:{2:00}\", (int)CalculateHour(), (int)CalculateMinute(), (int)CalculateSecond())));\n            AddSuffix(\"CALENDAR\", new Suffix<StringValue>(() => \"Year \" + CalculateYear() + \", day \" + CalculateDay()));\n        }",
        "Change JUST the year part of the time, leaving the remainder (days, hours, etc) still intact.",
        "</summary>",
        "<param name=\"newValue\"></param>",
        "Change JUST the day part of the time, leaving the year, hour, minute, and second intact:",
        "</summary>",
        "<param name=\"newValue\"></param>",
        "Subtract old day value:",
        "Add new day value:",
        "Change JUST the Hour part of the time, leaving the year, day, minute, and second intact:",
        "</summary>",
        "<param name=\"newValue\"></param>",
        "Subtract old hour value:",
        "Add new hour value:",
        "Change JUST the Minute part of the time, leaving the year, day, hour, and second intact:",
        "</summary>",
        "<param name=\"newValue\"></param>",
        "Subtract old minute value:",
        "Add new minute value:",
        "Change JUST the Second part of the time, leaving the year, day, hour, and minute intact:",
        "</summary>",
        "<param name=\"newValue\"></param>",
        "Subtract old minute value:",
        "Add new minute value:",
        "These conversions will have to be in the overriding classes:\n         * \n         * \n        public static TimeBase operator +(TimeBase a, TimeBase b) { return new TimeBase(a.ToUnixStyleTime() + b.ToUnixStyleTime()); }\n        public static TimeBase operator -(TimeBase a, TimeBase b) { return new TimeBase(a.ToUnixStyleTime() - b.ToUnixStyleTime()); }\n        public static TimeBase operator +(TimeBase a, double b) { return new TimeBase(a.ToUnixStyleTime() + b); }\n        public static TimeBase operator -(TimeBase a, double b) { return new TimeBase(a.ToUnixStyleTime() - b); }\n        public static TimeBase operator *(TimeBase a, double b) { return new TimeBase(a.ToUnixStyleTime() * b); }\n        public static TimeBase operator /(TimeBase a, double b) { return new TimeBase(a.ToUnixStyleTime() / b); }\n        public static TimeBase operator +(double b, TimeBase a) { return new TimeBase(b + a.ToUnixStyleTime()); }\n        public static TimeBase operator -(double b, TimeBase a) { return new TimeBase(b - a.ToUnixStyleTime()); }\n        public static TimeBase operator *(double b, TimeBase a) { return new TimeBase(b * a.ToUnixStyleTime()); }\n        public static TimeBase operator /(double b, TimeBase a) { return new TimeBase(b / a.ToUnixStyleTime()); }\n        public static TimeBase operator /(TimeBase b, TimeBase a) { return new TimeBase(b.ToUnixStyleTime() / a.ToUnixStyleTime()); }\n        public static bool operator >(TimeBase a, TimeBase b) { return a.ToUnixStyleTime() > b.ToUnixStyleTime(); }\n        public static bool operator <(TimeBase a, TimeBase b) { return a.ToUnixStyleTime() < b.ToUnixStyleTime(); }\n        public static bool operator >=(TimeBase a, TimeBase b) { return a.ToUnixStyleTime() >= b.ToUnixStyleTime(); }\n        public static bool operator <=(TimeBase a, TimeBase b) { return a.ToUnixStyleTime() <= b.ToUnixStyleTime(); }\n        public static bool operator >(TimeBase a, double b) { return a.ToUnixStyleTime() > b; }\n        public static bool operator <(TimeBase a, double b) { return a.ToUnixStyleTime() < b; }\n        public static bool operator >=(TimeBase a, double b) { return a.ToUnixStyleTime() >= b; }\n        public static bool operator <=(TimeBase a, double b) { return a.ToUnixStyleTime() <= b; }\n        public static bool operator >(double a, TimeBase b) { return a > b.ToUnixStyleTime(); }\n        public static bool operator <(double a, TimeBase b) { return a < b.ToUnixStyleTime(); }\n        public static bool operator >=(double a, TimeBase b) { return a >= b.ToUnixStyleTime(); }\n        public static bool operator <=(double a, TimeBase b) { return a <= b.ToUnixStyleTime(); }\n\n        public static TimeBase operator +(TimeBase a, ScalarValue b) { return new TimeBase(a.ToUnixStyleTime() + b); }\n        public static TimeBase operator -(TimeBase a, ScalarValue b) { return new TimeBase(a.ToUnixStyleTime() - b); }\n        public static TimeBase operator *(TimeBase a, ScalarValue b) { return new TimeBase(a.ToUnixStyleTime() * b); }\n        public static TimeBase operator /(TimeBase a, ScalarValue b) { return new TimeBase(a.ToUnixStyleTime() / b); }\n        public static TimeBase operator +(ScalarValue b, TimeBase a) { return new TimeBase(b + a.ToUnixStyleTime()); }\n        public static TimeBase operator -(ScalarValue b, TimeBase a) { return new TimeBase(b - a.ToUnixStyleTime()); }\n        public static TimeBase operator *(ScalarValue b, TimeBase a) { return new TimeBase(b * a.ToUnixStyleTime()); }\n        public static TimeBase operator /(ScalarValue b, TimeBase a) { return new TimeBase(b / a.ToUnixStyleTime()); }\n        public static bool operator >(TimeBase a, ScalarValue b) { return a.ToUnixStyleTime() > b; }\n        public static bool operator <(TimeBase a, ScalarValue b) { return a.ToUnixStyleTime() < b; }\n        public static bool operator >=(TimeBase a, ScalarValue b) { return a.ToUnixStyleTime() >= b; }\n        public static bool operator <=(TimeBase a, ScalarValue b) { return a.ToUnixStyleTime() <= b; }\n        public static bool operator >(ScalarValue a, TimeBase b) { return a > b.ToUnixStyleTime(); }\n        public static bool operator <(ScalarValue a, TimeBase b) { return a < b.ToUnixStyleTime(); }\n        public static bool operator >=(ScalarValue a, TimeBase b) { return a >= b.ToUnixStyleTime(); }\n        public static bool operator <=(ScalarValue a, TimeBase b) { return a <= b.ToUnixStyleTime(); }\n        *\n        *",
        "public override bool Equals(object obj)\n        {\n            Type compareType = typeof(TimeSpan);\n            if (compareType.IsInstanceOfType(obj))\n            {\n                TimeSpan t = obj as TimeSpan;\n                // Check the equality of the span value\n                return seconds == t.ToUnixStyleTime();\n            }\n            return false;\n        }",
        "public static bool operator ==(TimeSpan a, TimeSpan b)\n        {\n            Type compareType = typeof(TimeSpan);\n            if (compareType.IsInstanceOfType(a))\n            {\n                return a.Equals(b); // a is not null, we can use the built in equals function\n            }\n            return !compareType.IsInstanceOfType(b); // a is null, return true if b is null and false if not null\n        }\n\n        public static bool operator !=(TimeSpan a, TimeSpan b)\n        {\n            return !(a == b);\n        }",
        "public override Dump Dump()\n        {\n            var dump = new Dump\n            {\n                {DumpSpan, seconds}\n            };\n\n            return dump;\n        }\n\n        public override void LoadDump(Dump dump)\n        {\n            seconds = Convert.ToDouble(dump[DumpSpan]);\n        }\n            \n        public int CompareTo(TimeSpan other)\n        {\n            return seconds.CompareTo(other.seconds);\n        }"
    ],
    "docstrings": [
        "<summary>",
        "<summary>",
        "<summary>",
        "<summary>",
        "<summary>",
        "<summary>",
        "<summary>",
        "<summary>"
    ],
    "functions": [
        "TimeBase",
        "TimeBase",
        "InitializeSuffixes",
        "ScalarValue",
        "CalculateYear",
        "ChangeYear",
        "ScalarValue",
        "CalculateDay",
        "ChangeDay",
        "ScalarValue",
        "CalculateHour",
        "ChangeHour",
        "ScalarValue",
        "CalculateMinute",
        "ChangeMinute",
        "ScalarValue",
        "CalculateSecond",
        "ChangeSecond",
        "ToUnixStyleTime",
        "GetHashCode",
        "ToString"
    ],
    "classes": [
        "TimeBase"
    ]
}