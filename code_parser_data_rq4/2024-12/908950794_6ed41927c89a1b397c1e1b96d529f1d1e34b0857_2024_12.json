{
    "identifiers": [
        "numpy",
        "np",
        "arrays",
        "casting",
        "dtype",
        "arrays",
        "arrays",
        "np",
        "broadcast_arrays",
        "arrays",
        "np",
        "stack",
        "broadcasts",
        "axis",
        "casting",
        "casting",
        "dtype",
        "dtype",
        "np",
        "array",
        "dtype",
        "arrays",
        "casting",
        "dtype",
        "np",
        "asanyarray",
        "arrays",
        "arrays",
        "np",
        "broadcast_shapes",
        "a",
        "shape",
        "a",
        "arrays",
        "np",
        "broadcast_to",
        "a",
        "loop",
        "a",
        "shape",
        "a",
        "arrays",
        "np",
        "concatenate",
        "broadcasts",
        "axis",
        "casting",
        "casting",
        "dtype",
        "dtype",
        "np",
        "array",
        "dtype",
        "shape",
        "indices",
        "np",
        "indices",
        "shape",
        "len",
        "shape",
        "len",
        "indices",
        "sparse",
        "indices",
        "a",
        "indices",
        "np",
        "asanyarray",
        "a",
        "a",
        "pad_indices",
        "a",
        "shape",
        "indices"
    ],
    "literals": [
        "\"same_kind\"",
        "\"same_kind\""
    ],
    "variables": [
        "arrays",
        "broadcasts",
        "arrays",
        "loop",
        "broadcasts",
        "a"
    ],
    "comments": [],
    "docstrings": [
        "\"\"\"Functions for NumPy arrays that loop like gufuncs.\n\n    There is a general need for looping over not only functions on\n    scalars but also over functions on vectors (or arrays). This concept\n    is realized in NumPy by generalizing the universal functions\n    (ufuncs). In regular ufuncs, the elementary function is limited to\n    element-by-element operations, whereas the generalized version\n    (gufuncs) supports \"sub-array\" by \"sub-array\" operations. The Perl\n    vector library PDL provides a similar functionality and its terms\n    are re-used in the following.\n\n    Each generalized ufunc has information associated with it that\n    states what the \"core\" dimensionality of the inputs is, as well as\n    the corresponding dimensionality of the outputs (the element-wise\n    ufuncs have zero core dimensions). The list of the core dimensions\n    for all arguments is called the \"signature\" of a ufunc. For example,\n    the ufunc numpy.add has signature (),()->() defining two scalar\n    inputs and one scalar output.\n\n    Another example is the function inner1d(a, b) with a signature of\n    (i),(i)->(). This applies the inner product along the last axis of\n    each input, but keeps the remaining indices intact. For example,\n    where a is of shape (3, 5, N) and b is of shape (5, N), this will\n    return an output of shape (3,5). The underlying elementary function\n    is called 3 * 5 times. In the signature, we specify one core\n    dimension (i) for each input and zero core dimensions () for the\n    output, since it takes two 1-d arrays and returns a scalar. By using\n    the same name i, we specify that the two corresponding dimensions\n    should be of the same size.\n\n    The dimensions beyond the core dimensions are called \"loop\"\n    dimensions. In the above example, this corresponds to (3, 5).\n\n    -- https://numpy.org/doc/stable/reference/c-api/generalized-ufuncs.html\n\nFunctions\n---------\nstack\n    Stack arrays, broadcasting over their dimensions.\nconcatenate\n    Concatenate arrays along their innermost dimension.\npad_indices\n    Pad indices with arrays for the outermost dimensions of a shape.\nget\n    Index an array's innermost dimensions, broadcasting over the others.\n\"\"\"",
        "\"\"\"Stack arrays, broadcasting over their dimensions.\n\n    - lambda: stack([]) has signature ->(0);\n    - lambda a: stack([a]) has signature ()->(1);\n    - lambda a, b: stack([a, b]) has signature (),()->(2);\n\n    and so on.\n\n    >>> import gufunky\n    >>> gufunky.stack([0, [1, 2]])\n    array([[0, 1],\n           [0, 2]])\n    \"\"\"",
        "\"\"\"Concatenate arrays along their innermost dimension.\n\n    - lambda: concatenate([]) has signature ->(0);\n    - lambda a: concatenate([a]) has signature (n)->(n);\n    - lambda a, b: concatenate([a, b]) has signature (n),(o)->(n+o);\n\n    and so on.\n\n    >>> import gufunky\n    >>> gufunky.concatenate([[0, 1], [[2], [3]]])\n    array([[0, 1, 2],\n           [0, 1, 3]])\n    \"\"\"",
        "\"\"\"Pad indices with arrays for the outermost dimensions of shape.\n\n    >>> import numpy as np\n    >>> import gufunky\n    >>> a = np.arange(6).reshape((3, 2))\n    >>> a\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> indices = gufunky.pad_indices(a.shape, ([1, 0, 1],))\n    >>> indices\n    (array([0, 1, 2]), [1, 0, 1])\n    >>> a[indices] += 10\n    >>> a\n    array([[ 0, 11],\n           [12,  3],\n           [ 4, 15]])\n    \"\"\"",
        "\"\"\"Index with indices a's innermost dimensions, broadcasting over the others.\n\n    - lambda a: get(a, ()) has signature ()->();\n    - lambda a, z: get(a, (z,)) has signature (m),()->();\n    - lambda a, y, z: get(a, (y, z)) has signature (l,m),(),()->();\n\n    and so on.\n\n    >>> import numpy as np\n    >>> import gufunky\n    >>> a = np.arange(6).reshape((3, 2))\n    >>> a\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> gufunky.get(a, ([1, 0, 1],))\n    array([1, 2, 5])\n    >>> gufunky.get(a, ([[1, 0, 1], [0, 0, 1], [1, 1, 0], [0, 0, 0]],))\n    array([[1, 2, 5],\n           [0, 2, 5],\n           [1, 3, 4],\n           [0, 2, 4]])\n    >>> gufunky.get(a, ())\n    array([[0, 1],\n           [2, 3],\n           [4, 5]])\n    >>> gufunky.get(a, (2, [1, 0]))\n    array([5, 4])\n    >>> b = np.arange(24).reshape((4, 3, 2))\n    >>> b\n    array([[[ 0,  1],\n            [ 2,  3],\n            [ 4,  5]],\n    <BLANKLINE>\n           [[ 6,  7],\n            [ 8,  9],\n            [10, 11]],\n    <BLANKLINE>\n           [[12, 13],\n            [14, 15],\n            [16, 17]],\n    <BLANKLINE>\n           [[18, 19],\n            [20, 21],\n            [22, 23]]])\n    >>> gufunky.get(b, ([1, 0, 1],))\n    array([[ 1,  2,  5],\n           [ 7,  8, 11],\n           [13, 14, 17],\n           [19, 20, 23]])\n    >>> gufunky.get(b, ([1, 1, 0, 2], 1))\n    array([ 3,  9, 13, 23])\n    \"\"\""
    ],
    "functions": [
        "stack",
        "concatenate",
        "pad_indices",
        "get"
    ],
    "classes": []
}