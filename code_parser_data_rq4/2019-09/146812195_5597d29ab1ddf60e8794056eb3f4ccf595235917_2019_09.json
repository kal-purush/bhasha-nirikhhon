{
    "identifiers": [
        "collections",
        "defaultdict",
        "_defaultdict",
        "datetime",
        "_dt",
        "itertools",
        "_itertools",
        "time",
        "_time",
        "load_namespace",
        "vertex_source",
        "edge_source",
        "database",
        "timestamp",
        "release_timestamp",
        "load_version",
        "merge_source",
        "batch_size",
        "database",
        "merge_source",
        "db",
        "get_merge_collection",
        "ValueError",
        "db",
        "register_load_start",
        "load_namespace",
        "load_version",
        "timestamp",
        "release_timestamp",
        "_get_current_timestamp",
        "_process_verts",
        "db",
        "vertex_source",
        "timestamp",
        "release_timestamp",
        "load_version",
        "batch_size",
        "merge_source",
        "_process_merges",
        "db",
        "merge_source",
        "timestamp",
        "release_timestamp",
        "load_version",
        "batch_size",
        "_VERBOSE",
        "_time",
        "time",
        "db",
        "expire_extant_vertices_without_last_version",
        "timestamp",
        "load_version",
        "_process_edges",
        "db",
        "edge_source",
        "timestamp",
        "release_timestamp",
        "load_version",
        "batch_size",
        "_VERBOSE",
        "_time",
        "time",
        "col",
        "db",
        "get_edge_collections",
        "db",
        "expire_extant_edges_without_last_version",
        "timestamp",
        "load_version",
        "edge_collection",
        "col",
        "db",
        "register_load_complete",
        "load_namespace",
        "load_version",
        "_get_current_timestamp",
        "_dt",
        "datetime",
        "now",
        "tz",
        "_dt",
        "timezone",
        "utc",
        "timestamp",
        "db",
        "vertex_source",
        "timestamp",
        "release_timestamp",
        "load_version",
        "batch_size",
        "vertgen",
        "_chunkiter",
        "vertex_source",
        "batch_size",
        "vertgen",
        "_VERBOSE",
        "count",
        "_time",
        "time",
        "count",
        "v",
        "_ID",
        "v",
        "vertices",
        "_VERBOSE",
        "len",
        "keys",
        "_time",
        "time",
        "db",
        "get_vertices",
        "keys",
        "timestamp",
        "_VERBOSE",
        "len",
        "dbverts",
        "_time",
        "time",
        "db",
        "get_batch_updater",
        "v",
        "vertices",
        "dbverts",
        "get",
        "v",
        "_ID",
        "dbv",
        "bulk",
        "create_vertex",
        "v",
        "_ID",
        "load_version",
        "timestamp",
        "release_timestamp",
        "v",
        "_special_equal",
        "v",
        "dbv",
        "bulk",
        "expire_vertex",
        "dbv",
        "_KEY",
        "timestamp",
        "bulk",
        "create_vertex",
        "v",
        "_ID",
        "load_version",
        "timestamp",
        "release_timestamp",
        "v",
        "bulk",
        "set_last_version_on_vertex",
        "dbv",
        "_KEY",
        "load_version",
        "_VERBOSE",
        "bulk",
        "count",
        "_time",
        "time",
        "bulk",
        "update",
        "db",
        "merge_source",
        "timestamp",
        "release_timestamp",
        "load_version",
        "batch_size",
        "mergen",
        "_chunkiter",
        "merge_source",
        "batch_size",
        "mergen",
        "_VERBOSE",
        "count",
        "_time",
        "time",
        "count",
        "m",
        "m",
        "merges",
        "m",
        "m",
        "merges",
        "_VERBOSE",
        "len",
        "keys",
        "_time",
        "time",
        "db",
        "get_vertices",
        "keys",
        "timestamp",
        "_VERBOSE",
        "len",
        "dbverts",
        "_time",
        "time",
        "db",
        "get_batch_updater",
        "db",
        "get_merge_collection",
        "db",
        "get_batch_updater",
        "m",
        "merges",
        "dbverts",
        "get",
        "m",
        "dbverts",
        "get",
        "m",
        "dbmerged",
        "dbtarget",
        "vertbulk",
        "expire_vertex",
        "dbmerged",
        "_KEY",
        "timestamp",
        "bulk",
        "create_edge",
        "m",
        "_ID",
        "dbmerged",
        "dbtarget",
        "load_version",
        "timestamp",
        "release_timestamp",
        "m",
        "_VERBOSE",
        "bulk",
        "count",
        "_time",
        "time",
        "bulk",
        "update",
        "_VERBOSE",
        "vertbulk",
        "count",
        "_time",
        "time",
        "vertbulk",
        "update",
        "db",
        "edge_source",
        "timestamp",
        "release_timestamp",
        "load_version",
        "batch_size",
        "edgegen",
        "_chunkiter",
        "edge_source",
        "batch_size",
        "edgegen",
        "_VERBOSE",
        "count",
        "_time",
        "time",
        "count",
        "_defaultdict",
        "e",
        "edges",
        "vertkeys",
        "add",
        "e",
        "vertkeys",
        "add",
        "e",
        "e",
        "get",
        "col",
        "db",
        "get_default_edge_collection",
        "keys",
        "col",
        "append",
        "e",
        "_ID",
        "col",
        "bulkset",
        "db",
        "get_batch_updater",
        "col",
        "col",
        "keys",
        "keys",
        "items",
        "_VERBOSE",
        "len",
        "keys",
        "col",
        "_time",
        "time",
        "db",
        "get_edges",
        "keys",
        "timestamp",
        "edge_collection",
        "col",
        "_VERBOSE",
        "len",
        "dbedges",
        "col",
        "_time",
        "time",
        "_VERBOSE",
        "len",
        "vertkeys",
        "_time",
        "time",
        "db",
        "get_vertices",
        "vertkeys",
        "timestamp",
        "_VERBOSE",
        "len",
        "dbverts",
        "_time",
        "time",
        "e",
        "edges",
        "e",
        "pop",
        "col",
        "db",
        "get_default_edge_collection",
        "dbedges",
        "col",
        "get",
        "e",
        "_ID",
        "bulkset",
        "col",
        "dbverts",
        "e",
        "dbverts",
        "e",
        "dbe",
        "_special_equal",
        "e",
        "dbe",
        "dbe",
        "from_",
        "dbe",
        "to",
        "bulk",
        "expire_edge",
        "dbe",
        "timestamp",
        "bulk",
        "create_edge",
        "e",
        "_ID",
        "from_",
        "to",
        "load_version",
        "timestamp",
        "release_timestamp",
        "e",
        "bulk",
        "set_last_version_on_edge",
        "dbe",
        "load_version",
        "bulk",
        "create_edge",
        "e",
        "_ID",
        "from_",
        "to",
        "load_version",
        "timestamp",
        "release_timestamp",
        "e",
        "b",
        "bulkset",
        "values",
        "_VERBOSE",
        "b",
        "count",
        "b",
        "get_collection",
        "_time",
        "time",
        "b",
        "update",
        "_KEY",
        "doc1",
        "doc2",
        "doc1",
        "doc2",
        "f",
        "_SPECIAL_EQUAL_IGNORED_FIELDS",
        "d1c",
        "pop",
        "f",
        "d2c",
        "pop",
        "f",
        "d1c",
        "d2c",
        "iterable",
        "size",
        "iter",
        "iterable",
        "first",
        "iterator",
        "_itertools",
        "chain",
        "first",
        "_itertools",
        "islice",
        "iterator",
        "size",
        "database",
        "load_namespace",
        "database",
        "get_registered_loads",
        "load_namespace",
        "len",
        "loads",
        "ValueError",
        "loads",
        "loads",
        "loads",
        "loads",
        "loads",
        "loads",
        "collections",
        "append",
        "loads",
        "database",
        "get_instance",
        "loads",
        "edge_collections",
        "loads",
        "merge_collection",
        "loads",
        "db",
        "register_load_rollback",
        "load_namespace",
        "current_ver",
        "c",
        "collections",
        "db",
        "delete_created_documents",
        "c",
        "timestamp",
        "db",
        "undo_expire_documents",
        "c",
        "timestamp",
        "db",
        "reset_last_version",
        "c",
        "current_ver",
        "prior_ver",
        "db",
        "delete_registered_load",
        "load_namespace",
        "current_ver"
    ],
    "literals": [
        "'id'",
        "'_key'",
        "'A merge source is specified but the database '",
        "'has no merge collection'",
        "f'expiring vertices: {_time.time()}'",
        "f'expiring edges: {_time.time()}'",
        "f'vertex batch {count}: {_time.time()}'",
        "f'  looking up {len(keys)} vertices: {_time.time()}'",
        "f'  got {len(dbverts)} vertices: {_time.time()}'",
        "f'  updating {bulk.count()} vertices: {_time.time()}'",
        "f'merge batch {count}: {_time.time()}'",
        "'from'",
        "'to'",
        "f'  looking up {len(keys)} vertices: {_time.time()}'",
        "f'  got {len(dbverts)} vertices: {_time.time()}'",
        "'from'",
        "'to'",
        "f'  updating {bulk.count()} edges: {_time.time()}'",
        "f'  updating {vertbulk.count()} vertices: {_time.time()}'",
        "f'edge batch {count}: {_time.time()}'",
        "'to'",
        "'from'",
        "'_collection'",
        "f'  looking up {len(keys)} edges in {col}: {_time.time()}'",
        "f'  got {len(dbedges[col])} edges: {_time.time()}'",
        "f'  looking up {len(vertkeys)} vertices: {_time.time()}'",
        "f'  got {len(dbverts)} vertices: {_time.time()}'",
        "'_collection'",
        "'from'",
        "'to'",
        "'_from'",
        "'_id'",
        "'_to'",
        "'_id'",
        "f'  updating {b.count()} edges in {b.get_collection()}: {_time.time()}'",
        "'_id'",
        "'_to'",
        "'_from'",
        "'created'",
        "'expired'",
        "'release_created'",
        "'release_expired'",
        "'first_version'",
        "'last_version'",
        "'Nothing to roll back'",
        "'load_timestamp'",
        "'load_version'",
        "'load_version'",
        "'edge_collections'",
        "'vertex_collection'",
        "'merge_collection'",
        "'merge_collection'",
        "'vertex_collection'",
        "'edge_collections'",
        "'merge_collection'"
    ],
    "variables": [
        "_VERBOSE",
        "_ID",
        "_KEY",
        "db",
        "count",
        "vertices",
        "keys",
        "dbverts",
        "bulk",
        "dbv",
        "count",
        "merges",
        "keys",
        "dbverts",
        "bulk",
        "vertbulk",
        "dbmerged",
        "dbtarget",
        "count",
        "edges",
        "keys",
        "bulkset",
        "vertkeys",
        "col",
        "col",
        "bulkset",
        "col",
        "dbedges",
        "dbedges",
        "col",
        "dbverts",
        "keys",
        "vertkeys",
        "col",
        "col",
        "dbe",
        "bulk",
        "from_",
        "to",
        "_SPECIAL_EQUAL_IGNORED_FIELDS",
        "d1c",
        "d2c",
        "iterator",
        "loads",
        "timestamp",
        "current_ver",
        "prior_ver",
        "collections",
        "db"
    ],
    "comments": [
        "TODO TEST",
        "TODO DOCS document reserved fields that will be overwritten if supplied",
        "TODO CODE add notification callback so that the caller can implement % complete or logs or whatever based on what's happening in the delta load algorithm. Remove _VERBOSE prints at that point",
        "TODO CODE consider threading / multiprocessing here. Virtually all the time is db access",
        "mark node as seen in this version",
        "only add the merge if nodes exist at this point",
        "trying to figure out where to set the edge if nodes are deleted gets complicated,",
        "so we don't worry about it for now.",
        "assumes verts have been processed",
        "The edges exists in the current load so their nodes must exist by now",
        "Could cache these, may be fetching the same vertex over and over, but no guarantees",
        "the same vertexes are repeated in a reasonable amount of time",
        "Batching the fetch is probably enough",
        "these two conditions check whether the nodes the edge is attached to",
        "have been updated this load",
        "This is an abstraction leak, bleah",
        "TODO CODE these fields are shared between here and the database. Should probably put them somewhere in common.",
        "same with the id and _key fields in the code above",
        "arango db api is leaking a bit here, but the chance we're going to rewrite this for something",
        "else is pretty tiny",
        "TODO CODE fields here shared with the DB. Put them somewhere in common.",
        "Was checking state == complete here, but that means if a load or rollback fails midway,",
        "it can't be rolled back. Rollbacks should generally always work.",
        "TODO CODE take an option to abort rollback if load not in complete state",
        "This state change is transient and so is pretty hard to automatically test without",
        "somewhat complex unit tests that ensure this occurs prior to the data alterations.",
        "For now just testing manually",
        "TODO NOW pass release timestamp"
    ],
    "docstrings": [
        "\"\"\"\nContains a function for loading new versions of the same graph into a graph database in a batch\nusing a time travelling strategy\n(see https://www.arangodb.com/2018/07/time-traveling-with-graph-databases/).\n\nNote that while the load is in progress, any queries against the graph with a timestamp after\nthe load timestamp are not reproducible as the load may be partially complete. Loaders must\ntake this into account and take measures to prevent it.\n\"\"\"",
        "\"\"\"\n    Loads a new version of a graph into a graph database, calculating the delta between the graphs\n    and expiring / creating new vertices and edges as neccessary.\n\n    load_namespace - the name of the data that is being loaded, e.g. ncbi_taxa, gene_ontology, etc.\n        Must be unique across all load sources.\n    vertex_source - an iterator that produces vertices as dicts. An 'id' field is required that\n      uniquely identifies the vertex in this load (and any previous loads in which it exists).\n    edge_source - an iterator that produces edges as dicts. An 'id' field is required that\n      uniquely identifies the edge in this load (and any previous loads in which it exists).\n      'from' and 'to' fields are required that identify the vertices where the edge originates and\n      terminates.\n    database - a wrapper for the database storing the graph. It must have the same interface as\n      batchload.time_travelling_database.ArangoBatchTimeTravellingDB, which is currently the\n      only implementation of the interface. The default collections will be used for the vertices\n      and edges unless edge_collections is provided and the _collection field is specified for\n      edges.\n    timestamp - the timestamp, in Unix epoch milliseconds, when the load should be considered as\n      active.\n    release_timestamp - the timestamp, in Unix epoch milliseconds, when the load was released\n      at the data source.\n    load_version - a unique ID for this load - often the date of the data release.\n    merge_source - an iterator that produces edges as dicts that represent merges of vertices.\n         An 'id' field is required that uniquely identifies the edge in this load (and any previous\n         loads in which it exists). 'from' and 'to' fields are required that identify the vertices\n         where the edge originates (the merged vertex) and terminates (the vertex the old vertex\n         was merged into). If merge_source is specified, the database must have a merge collection\n         specified.\n    batch_size - the number of vertices or edges to process per batch. Higher batch sizes typically\n      decrease processing time and increase memory usage.\n    \"\"\"",
        "\"\"\"\n    For each vertex we're importing, either replace and expire an existing vertex, create a\n    new vertex, or leave an existing vertex unchanged, updating its version.\n    \"\"\"",
        "\"\"\"\n    For each merge edge, if both vertices exist in the current graph (it is expected that vertices\n    have been updated by _process_verts), add the merge edge to the database.\n\n    This could be made smarter in the future.\n    \"\"\"",
        "\"\"\"\n    For each edge we're importing, either replace and expire an existing edge, create a\n    new edge, or leave an existing edge unchanged, updating its version.\n    \"\"\"",
        "\"\"\"\n    Checks if two dicts are equal other than special fields.\n    \"\"\"",
        "\"\"\"\n    Iterate over chunks of size 'size' of an iterable.\n    \"\"\"",
        "\"\"\"\n    Removes the most recent data load to a namespace and reverts it to the prior state.\n\n    database - a wrapper for the database storing the graph. It must have the same interface as\n      batchload.time_travelling_database.ArangoBatchTimeTravellingDBFactory, which is\n      currently the only implementation of the interface.\n    load_namespace - the name of the data set that is to be reverted,\n        e.g. ncbi_taxa, gene_ontology, etc. Must be unique across all load sources.\n    \"\"\""
    ],
    "functions": [
        "load_graph_delta",
        "_get_current_timestamp",
        "_process_verts",
        "_process_merges",
        "_process_edges",
        "_special_equal",
        "_chunkiter",
        "roll_back_last_load"
    ],
    "classes": []
}