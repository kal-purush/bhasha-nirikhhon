{
    "identifiers": [
        "json",
        "logging",
        "os",
        "datetime",
        "datetime",
        "uuid",
        "uuid4",
        "UUID",
        "inspect",
        "signature",
        "getsignature",
        "logging",
        "getLogger",
        "path",
        "f",
        "f",
        "os",
        "listdir",
        "path",
        "os",
        "path",
        "isdir",
        "os",
        "path",
        "join",
        "path",
        "f",
        "f",
        "startswith",
        "IOError",
        "OSError",
        "e",
        "logger",
        "error",
        "format",
        "path",
        "format_exception_message",
        "e",
        "path",
        "__list_valid_directories",
        "path",
        "data",
        "event_id",
        "retry",
        "isinstance",
        "data",
        "json",
        "dumps",
        "data",
        "data",
        "format",
        "event_id",
        "formatted",
        "format",
        "retry",
        "formatted",
        "format",
        "retry",
        "data",
        "formatted",
        "format",
        "data",
        "formatted",
        "db_type",
        "path",
        "username",
        "password",
        "host",
        "db_type",
        "db_type",
        "path",
        "db_type",
        "supported_dbs",
        "username",
        "password",
        "db_type",
        "username",
        "password",
        "host",
        "path",
        "username",
        "db_type",
        "username",
        "host",
        "path",
        "logger",
        "error",
        "db_type",
        "logger",
        "error",
        "db_type",
        "path",
        "sqlalchemy_path",
        "func",
        "getsignature",
        "func",
        "parameters",
        "keys",
        "exception",
        "exception",
        "exception",
        "__class__",
        "class_name",
        "exception_message",
        "exception_message",
        "class_name",
        "argument",
        "argument",
        "json",
        "loads",
        "argument",
        "ValueError",
        "argument",
        "arg",
        "argument",
        "tmp",
        "append",
        "convert_action_argument",
        "arg",
        "tmp",
        "argument",
        "workflow",
        "uuid4",
        "workflow",
        "get",
        "action",
        "actions",
        "action",
        "uuid4",
        "action",
        "param",
        "workflow",
        "get",
        "uuid4",
        "workflow",
        "get",
        "condition",
        "conditions",
        "condition",
        "uuid4",
        "condition",
        "workflow",
        "get",
        "transform",
        "transforms",
        "transform",
        "uuid4",
        "transform",
        "workflow",
        "get",
        "trigger",
        "triggers",
        "trigger",
        "uuid4",
        "trigger",
        "workflow",
        "get",
        "workflow_variable",
        "workflow_variables",
        "workflow_variable",
        "uuid4",
        "workflow_variable",
        "workflow",
        "get",
        "tags",
        "branch",
        "workflow",
        "get",
        "id_mapping",
        "branch",
        "id_mapping",
        "branch",
        "regenerate_ids",
        "branch",
        "id_mapping",
        "id_mapping",
        "workflow",
        "json_in",
        "id_mapping",
        "regenerate_id",
        "is_arguments",
        "regenerate_id",
        "uuid4",
        "is_arguments",
        "json_in",
        "pop",
        "json_in",
        "get",
        "id_mapping",
        "json_in",
        "field",
        "value",
        "json_in",
        "items",
        "field",
        "isinstance",
        "value",
        "__regenerate_ids_of_list",
        "value",
        "id_mapping",
        "is_arguments",
        "is_arguments",
        "isinstance",
        "value",
        "regenerate_ids",
        "value",
        "id_mapping",
        "id_mapping",
        "is_arguments",
        "is_arguments",
        "value",
        "id_mapping",
        "is_arguments",
        "list_element",
        "list_element_",
        "list_element_",
        "value",
        "isinstance",
        "list_element_",
        "regenerate_ids",
        "list_element",
        "id_mapping",
        "id_mapping",
        "is_arguments",
        "is_arguments",
        "timestamp",
        "timestamp",
        "isoformat",
        "time",
        "datetime",
        "strptime",
        "time",
        "val",
        "json",
        "dumps",
        "val",
        "ValueError",
        "val",
        "filename",
        "indent",
        "indent",
        "open",
        "filename",
        "file_open",
        "indent",
        "line",
        "line",
        "file_open",
        "open",
        "os",
        "path",
        "join",
        "API_PATH",
        "api_yaml",
        "line_num",
        "line",
        "api_yaml",
        "line",
        "lstrip",
        "startswith",
        "line",
        "split",
        "split_line",
        "strip",
        "split_line",
        "count",
        "final_yaml",
        "extend",
        "read_and_indent",
        "os",
        "path",
        "join",
        "API_PATH",
        "reference",
        "indentation",
        "final_yaml",
        "append",
        "os",
        "linesep",
        "IOError",
        "OSError",
        "logger",
        "error",
        "reference",
        "line_num",
        "final_yaml",
        "append",
        "line",
        "open",
        "os",
        "path",
        "join",
        "API_PATH",
        "composed_yaml",
        "composed_yaml",
        "writelines",
        "final_yaml",
        "logger",
        "info",
        "original_exception",
        "message",
        "original_exception",
        "message",
        "ValueError",
        "original_exception",
        "message",
        "format_exception_message",
        "original_exception",
        "ExecutionError"
    ],
    "literals": [
        "'__'",
        "'Cannot get valid directories inside {0}. Error: {1}'",
        "'id: {}\\n'",
        "'event: {}\\n'",
        "'retry: {}\\n'",
        "'data: {}\\n'",
        "'\\n'",
        "'postgresql'",
        "'postgresql+psycopg2'",
        "'postgresql+pg8000'",
        "'mysql'",
        "'mysql+mysqldb'",
        "'mysql+mysqlconnector'",
        "'mysql+oursql'",
        "'oracle'",
        "'oracle+cx_oracle'",
        "'mssql+pyodbc'",
        "'mssql+pymssql'",
        "'sqlite'",
        "f\"{db_type}:///{path}\"",
        "f\"{db_type}://{username}:{password}@{host}/{path}\"",
        "f\"{db_type}://{username}@{host}/{path}\"",
        "f\"Database type was set to {db_type}, but no login was provided.\"",
        "f\"Database type {db_type} not supported for database {path}\"",
        "f\"{class_name}: {exception_message}\"",
        "'value'",
        "'value'",
        "'value'",
        "'selection'",
        "'selection'",
        "'selection'",
        "'id_'",
        "'actions'",
        "'id_'",
        "'id_'",
        "'id_'",
        "'parameters'",
        "'id_'",
        "'conditions'",
        "'id_'",
        "'id_'",
        "'id_'",
        "'transforms'",
        "'id_'",
        "'id_'",
        "'id_'",
        "'triggers'",
        "'id_'",
        "'id_'",
        "'id_'",
        "'workflow_variables'",
        "\"id_\"",
        "'id_'",
        "'id_'",
        "'tags'",
        "\"tags\"",
        "'branches'",
        "'source_id'",
        "'source_id'",
        "'destination_id'",
        "'destination_id'",
        "'start'",
        "'start'",
        "'id_'",
        "'id_'",
        "'variant'",
        "\"ACTION_RESULT\"",
        "\"WORKFLOW_VARIABLE\"",
        "'value'",
        "'value'",
        "'arguments'",
        "'device_id'",
        "'T'",
        "'Z'",
        "'%Y-%m-%dT%H:%M:%S.%fZ'",
        "'  '",
        "'r'",
        "f'{indent}{line}'",
        "'api.yaml'",
        "'r'",
        "'$ref:'",
        "'$ref:'",
        "'  '",
        "f\"Could not find or open {reference} on line {line_num}\"",
        "'composed_api.yaml'",
        "'w'",
        "\"Wrote composed_api.yaml\"",
        "'Either original exception or message must be provided'"
    ],
    "variables": [
        "logger",
        "data",
        "data",
        "formatted",
        "supported_dbs",
        "sqlalchemy_path",
        "sqlalchemy_path",
        "sqlalchemy_path",
        "sqlalchemy_path",
        "exception_message",
        "class_name",
        "argument",
        "tmp",
        "argument",
        "workflow",
        "id_mapping",
        "actions",
        "prev_id",
        "action",
        "id_mapping",
        "prev_id",
        "param",
        "conditions",
        "prev_id",
        "condition",
        "id_mapping",
        "prev_id",
        "transforms",
        "prev_id",
        "transform",
        "id_mapping",
        "prev_id",
        "triggers",
        "prev_id",
        "trigger",
        "id_mapping",
        "prev_id",
        "workflow_variables",
        "prev_id",
        "workflow_variable",
        "id_mapping",
        "prev_id",
        "tags",
        "id_mapping",
        "branch",
        "branch",
        "workflow",
        "json_in",
        "json_in",
        "is_arguments",
        "indent",
        "final_yaml",
        "split_line",
        "reference",
        "indentation",
        "exc",
        "message"
    ],
    "comments": [
        "def list_interfaces(path=None):",
        "return __list_valid_directories(path)",
        "def locate_playbooks_in_directory(path):",
        "\"\"\"Get a list of workflows in a specified directory or the workflows_path directory as specified in the configuration.",
        "",
        "Args:",
        "path (str, optional): The directory path from which to locate the workflows.",
        "",
        "Returns:",
        "A list of workflow names from the specified path, or the directory specified in the configuration.",
        "\"\"\"",
        "if os.path.exists(path):",
        "return [workflow for workflow in os.listdir(path) if (os.path.isfile(os.path.join(path, workflow))",
        "and workflow.endswith('.playbook'))]",
        "else:",
        "logger.warning('Could not locate any workflows in directory {0}. Directory does not exist'.format(path))",
        "return []",
        "def import_submodules(package, recursive=False):",
        "\"\"\"Imports the submodules from a given package.",
        "",
        "Args:",
        "package (str): The name of the package from which to import the submodules.",
        "recursive (bool, optional): A boolean to determine whether or not to recursively load the submodules.",
        "Defaults to False.",
        "",
        "Returns:",
        "A dictionary containing the imported module objects.",
        "\"\"\"",
        "successful_base_import = True",
        "if isinstance(package, str):",
        "try:",
        "package = importlib.import_module(package)",
        "except ImportError:",
        "successful_base_import = False",
        "logger.warning('Could not import {}. Skipping'.format(package), exc_info=True)",
        "if successful_base_import:",
        "results = {}",
        "if hasattr(package, '__path__'):",
        "for loader, name, is_package in pkgutil.walk_packages(package.__path__):",
        "full_name = '{0}.{1}'.format(package.__name__, name)",
        "try:",
        "results[full_name] = importlib.import_module(full_name)",
        "except ImportError:",
        "logger.warning('Could not import {}. Skipping.'.format(full_name), exc_info=True)",
        "if recursive and is_package:",
        "results.update(import_submodules(full_name))",
        "return results",
        "return {}",
        "def create_sse_event(event_id=None, event=None, data=None):",
        "warnings.warn('create_sse_event is deprecated.'",
        "' Please use the api_gateway.sse.SseStream class to construct SSE streams.'",
        "' This function will be removed in version 0.10.0',",
        "DeprecationWarning)",
        "if data is None and event_id is None and event is None:",
        "return ''",
        "response = ''",
        "if event_id is not None:",
        "response += 'id: {}\\n'.format(event_id)",
        "if event is not None:",
        "response += 'event: {}\\n'.format(event)",
        "if data is None:",
        "data = ''",
        "try:",
        "response += 'data: {}\\n'.format(json.dumps(data))",
        "except ValueError:",
        "response += 'data: {}\\n'.format(data)",
        "return response + '\\n'",
        "for action in actions:",
        "regenerate_ids(action, id_mapping, regenerate_id=False)",
        "ToDo: These will be needed if condition/transform parameters are changed to be more like actions",
        "for condition in conditions:",
        "regenerate_ids(condition, id_mapping, regenerate_id=False)",
        "",
        "for transform in transforms:",
        "regenerate_ids(transform, id_mapping, regenerate_id=False)",
        "def strip_device_ids(workflow):",
        "for action in workflow.get('actions', []):",
        "action.pop('device_id', None)",
        "",
        "",
        "def strip_argument_ids(workflow):",
        "for action in workflow.get('actions', []):",
        "strip_argument_ids_from_element(action)",
        "if 'device_id' in action:",
        "action['device_id'].pop('id_', None)",
        "",
        "",
        "def strip_argument_ids_from_conditional(conditional):",
        "for conditional_expression in conditional.get('child_expressions', []):",
        "strip_argument_ids_from_conditional(conditional_expression)",
        "for condition in conditional.get('conditions', []):",
        "strip_argument_ids_from_element(condition)",
        "for transform in condition.get('transforms', []):",
        "strip_argument_ids_from_element(transform)",
        "",
        "",
        "def strip_argument_ids_from_element(element):",
        "for argument in element.get('arguments', []):",
        "argument.pop('id_', None)"
    ],
    "docstrings": [
        "\"\"\"Get a list of the apps.\n\n    Args:\n        path (str): The path to the apps folder\n\n    Returns:\n        A list of the apps given the apps path or the apps_path in the configuration.\n    \"\"\"",
        "\"\"\"Get this SSE formatted as needed to send to the client\n    Args:\n        event_id (int): The ID related to this event.\n        retry (int): The time in milliseconds the client should wait to retry to connect to this SSE stream if the\n            connection is broken. Default is 3 seconds (3000 milliseconds)\n    Returns:\n        (str): This SSE formatted to be sent to the client\n    \"\"\"",
        "\"\"\"\n    Formats the path to the database\n\n    Args:\n        db_type (str): Type of database being used\n        path (str): Path to the database\n        username (str): Username for this db\n        password (str): Password for this db\n        host (str): The hostname where the database is hosted\n    Returns:\n        (str): The path of the database formatted for SqlAlchemy\n    \"\"\""
    ],
    "functions": [
        "__list_valid_directories",
        "list_apps",
        "sse_format",
        "format_db_path",
        "get_function_arg_names",
        "format_exception_message",
        "convert_action_argument",
        "regenerate_workflow_ids",
        "regenerate_ids",
        "__regenerate_ids_of_list",
        "utc_as_rfc_datetime",
        "timestamp_to_datetime",
        "json_dumps_or_string",
        "read_and_indent",
        "compose_api"
    ],
    "classes": [
        "ExecutionError"
    ]
}