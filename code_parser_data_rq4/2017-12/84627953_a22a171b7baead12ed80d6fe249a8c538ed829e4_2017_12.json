{
    "identifiers": [
        "java",
        "util",
        "root",
        "root",
        "root",
        "root",
        "root",
        "root",
        "root",
        "root",
        "root",
        "root",
        "root",
        "getTreeItem",
        "root",
        "root",
        "key",
        "findItem",
        "root",
        "key",
        "node",
        "key",
        "node",
        "node",
        "getTreeItem",
        "getKey",
        "compareTo",
        "key",
        "node",
        "getTreeItem",
        "node",
        "getTreeItem",
        "getKey",
        "compareTo",
        "key",
        "findItem",
        "node",
        "getLeftChild",
        "key",
        "findItem",
        "node",
        "getRightChild",
        "key",
        "treeItem",
        "root",
        "insertItem",
        "root",
        "treeItem",
        "node",
        "parent",
        "treeItem",
        "node",
        "node",
        "treeItem",
        "node",
        "setParent",
        "parent",
        "node",
        "getTreeItem",
        "getKey",
        "compareTo",
        "treeItem",
        "getKey",
        "node",
        "setLeftChild",
        "insertItem",
        "node",
        "getLeftChild",
        "node",
        "treeItem",
        "node",
        "setRightChild",
        "insertItem",
        "node",
        "getRightChild",
        "node",
        "treeItem",
        "node",
        "key",
        "setRoot",
        "deleteItem",
        "getRoot",
        "key",
        "node",
        "key",
        "node",
        "treeItem",
        "node",
        "getTreeItem",
        "key",
        "compareTo",
        "treeItem",
        "getKey",
        "node",
        "deleteNode",
        "node",
        "key",
        "compareTo",
        "treeItem",
        "getKey",
        "node",
        "setLeftChild",
        "deleteItem",
        "node",
        "getLeftChild",
        "key",
        "node",
        "setRightChild",
        "deleteItem",
        "node",
        "getRightChild",
        "key",
        "node",
        "node",
        "node",
        "getLeftChild",
        "node",
        "findLeftmost",
        "node",
        "getLeftChild",
        "node",
        "node",
        "getLeftChild",
        "node",
        "getRightChild",
        "node",
        "getLeftChild",
        "node",
        "getRightChild",
        "node",
        "getRightChild",
        "node",
        "getLeftChild",
        "successorNode",
        "successorNode",
        "findLeftmost",
        "node",
        "getRightChild",
        "node",
        "setTreeItem",
        "successorNode",
        "getTreeItem",
        "node",
        "setRightChild",
        "deleteLeftmost",
        "node",
        "getRightChild",
        "node",
        "rightChild",
        "treeHeight",
        "root",
        "node",
        "node",
        "leftHeight",
        "treeHeight",
        "node",
        "getLeftChild",
        "rightHeight",
        "treeHeight",
        "node",
        "getRightChild",
        "leftHeight",
        "rightHeight",
        "leftHeight",
        "rightHeight",
        "isBalancedSubtree",
        "root",
        "node",
        "node",
        "leftHeight",
        "treeHeight",
        "node",
        "getLeftChild",
        "rightHeight",
        "treeHeight",
        "node",
        "getRightChild",
        "heightDifference",
        "leftHeight",
        "rightHeight",
        "heightDifference",
        "heightDifference",
        "heightDifference",
        "isBalancedSubtree",
        "node",
        "getLeftChild",
        "isBalancedSubtree",
        "node",
        "getRightChild",
        "it",
        "it",
        "setInorder",
        "count",
        "it",
        "size",
        "arr",
        "count",
        "i",
        "i",
        "count",
        "i",
        "arr",
        "i",
        "it",
        "next",
        "root",
        "balanceTree",
        "arr",
        "count",
        "arr",
        "first",
        "last",
        "first",
        "last",
        "center",
        "first",
        "last",
        "item",
        "arr",
        "center",
        "node",
        "item",
        "node",
        "setLeftChild",
        "balanceTree",
        "arr",
        "first",
        "center",
        "node",
        "setRightChild",
        "balanceTree",
        "arr",
        "center",
        "last",
        "node"
    ],
    "literals": [
        "\"TreeException: Tree Is Empty, No Root Item\"",
        "\"TreeException:  Item not found\""
    ],
    "variables": [
        "root",
        "successorNode"
    ],
    "comments": [
        "end delete",
        "item is in this node, which is the root of a subtree",
        "delete the item",
        "search the left subtree",
        "search the right subtree",
        "end if",
        "end if",
        "end deleteItem",
        "private TreeNode<K, V> deleteNode(TreeNode<K, V> node) {",
        "if ((node.getLeftChild() == null) && (node.getRightChild() == null)) {",
        "// node is a leaf",
        "return null;",
        "} else if (node.getLeftChild() == null) {",
        "// no left child",
        "return node.getRightChild();",
        "} else if (node.getRightChild() == null) {",
        "// no right child",
        "return node.getLeftChild();",
        "} else {",
        "// there are two children:",
        "TreeNode<K, V> successorNode;",
        "successorNode = findLeftmost(node.getRightChild());",
        "node.setRightChild(deleteLeftmost(node.getRightChild()));",
        "return node;",
        "}   // end if",
        "}   // end deleteNode",
        "",
        "end if",
        "end findLeftmost",
        "node is a leaf",
        "no left child",
        "no right child",
        "there are two children:",
        "TreeNode deleteLeftmostNode;",
        "end if",
        "end deleteNode",
        "The recursive helper method",
        "The private recursive method to calculate the height of a subtree rooted at the specified TreeNode",
        "call the private recursive method",
        "The recursive helper method",
        "The private recursive method to calculate the height of a subtree rooted at the specified TreeNode",
        "Here, if  the node is null height is 0 (Base case of recursion.",
        "empty node, means no height",
        "Otherwise, we get the left and right height. Then we return the greater one :",
        "get height of left subtree (with recursion)",
        "get height of right subtree (with recursion)",
        "return the bigger height",
        "make sure to add +1 for the height of the current node",
        "The next method is isBalanced(). Here, we also have a recursive helper.",
        "So the method itself is :",
        "This is the method the user calls to find out if the BinarySearchTree is balanced.",
        "call the private recursive method",
        "The recursive helper method",
        "The private recursive method to determine if the subtree rooted at the given node is balanced",
        "This will also need some help from the previous height methods. We start by getting left-right heights :",
        "get height of left subtree (with treeHeight method)",
        "get height of right subtree (with treeHeight method)",
        "Now, the height difference :",
        "obtain the left-right height difference",
        "This should only be -1, 0, or 1 for balance",
        "height difference can be a max of 1 (on left side or right side)",
        "check subtree height balance on both and right child",
        "when all success, return true",
        "And recursively we also check if left and right subtrees are balanced.",
        "If the conditions fail, then we return false:",
        "not found, return false",
        "now the construct left and right subtree"
    ],
    "docstrings": [
        "* Default constructor for BinarySearchTree. This constructor instantiates\n\t * an empty tree",
        "* This constructor instantiates a BinarySearchTree with the given <code>root</code>\n\t *\n\t * @param root The root TreeNode for this BinarySearchTree",
        "* Method to get the current root of this BinarySearchTree\n\t *\n\t * @return The root TreeNode for this BinarySearchTree",
        "* Method to set set the root of this BinarySearchTree\n\t *\n\t * @param root The new root of this BinarySearchTree",
        "* Method to get the <b>TreeItem</b> currently in the root of this BinarySearchTree\n\t *\n\t * @return Returns the <b>TreeItem</b> currently in the root\n\t * @throws TreeException Throws a <b>TreeException</b> if the root of the tree is <b>null</b>",
        "* Method to find out if the BinarySearchTree is empty\n\t *\n\t * @return Returns <b>true</b> if the root in <b>null</b>, otherwise, returns <b>false</b>",
        "* Method to remove all entries from the BinarySearchTree.",
        "* Method to find and retrieve the <b>TreeItem</b>\n\t * with the given <b>key</b> if it is in the BinarySearchTree.\n\t *\n\t * @param key The <b>key</b> that the user wishes to search for\n\t * @return The <b>TreeItem</b> with the given <b>key</b> if found. Otherwise, returns\n\t * <b>null</b>",
        "* The <b>private recursive</b> method to find and retrieve  the <b>TreeItem</b>\n\t * with the given <b>key</b> if it is in the BinarySearchTree. This method is initially\n\t * called by the {@link #find <b><u>find</u></b>} method\n\t *\n\t * @param node The current TreeNode being searched\n\t * @param key  The <b>key</b> that the user wishes to search for\n\t * @return The <b>TreeItem</b> with the given <b>key</b> if found. Otherwise, returns\n\t * <b>null</b>",
        "* Method to insert the given <b>TreeItem</b> into the BinarySearchTree\n\t *\n\t * @param treeItem The <b>TreeItem</b> to insert into the BinarySearchTree",
        "* The <b>private recursive</b> method to insert the <b>TreeItem</b>\n\t * into the BinarySearchTree. This method is initially\n\t * called by the {@link #insert <b><u>insert</u></b>} method\n\t *\n\t * @param node     The current TreeNode being examined for insertion\n\t * @param parent   The current parent of the TreeNode being examined\n\t * @param treeItem The <b>TreeItem</b> to insert into the BinarySearchTree\n\t * @return The node that existed or was inserted into the BinarySearchTree",
        "* This is the public method used to delete a TreeItem from the <code>BinarySearchTree</code> based\n\t * on the specified <b>key</b>.\n\t *\n\t * @param key The <b>key</b> of the TreeItem the user wishes to delete from the <code>BinarySearchTree</code>.",
        "* The <b>private recursive</b> method to delete the <b>TreeItem</b>\n\t * with the specified <b>key</b> from BinarySearchTree. This method is initially\n\t * called by the {@link #delete <b><u>delete</u></b>} method\n\t *\n\t * @param node The current TreeNode being examined for deletion\n\t * @param key  The <b>key</b> of the TreeItem to be deleted\n\t * @return The TreeNode reference that will replace the deleted TreeNode",
        "* The <b>private recursive</b> method to delete the specified <b>TreeNode</b>.\n\t * There are four cases to consider:\n\t * <ol>\n\t * <li>The node is a leaf: just remove the node.</li>\n\t * <li>The node has no left child: replace the node with it's right child</li>\n\t * <li>The node has no right child: replace the node with it's left child</li>\n\t * <li>The node has two children: find the in-order successor, swap TreeItems and delete the successor</li>\n\t * </ol>\n\t * This method is initally called by the {@link #deleteItem <b><u>deleteItem</u></b>} method\n\t *\n\t * @param node The current TreeNode being examined for deletion\n\t * @return The TreeNode reference that will replace the deleted TreeNode",
        "* The <b>private recursive</b> method to find the left-most child of a subtree\n\t * This method is initially called by the {@link #deleteNode <b><u>deleteNode</u></b>} method\n\t *\n\t * @param node The current TreeNode being examined for being the left-most child\n\t * @return The TreeNode reference that is the left-most child",
        "* The <b>private recursive</b> method to deleted the left-most child of a subtree\n\t * This method is initially called by the {@link #deleteNode <b><u>deleteNode</u></b>} method\n\t *\n\t * @param node The current TreeNode being examined for being the left-most child\n\t * @return The TreeNode reference that is the left-most child"
    ],
    "functions": [
        "BinarySearchTree",
        "BinarySearchTree",
        "getRoot",
        "setRoot",
        "getRootItem",
        "isEmpty",
        "makeEmpty",
        "find",
        "findItem",
        "insert",
        "insertItem",
        "deleteItem",
        "findLeftmost",
        "deleteNode",
        "deleteLeftmost",
        "height",
        "treeHeight",
        "isBalanced",
        "isBalancedSubtree",
        "balance",
        "balanceTree"
    ],
    "classes": [
        "BinarySearchTree"
    ]
}