{
    "identifiers": [
        "UnityEngine",
        "Collections",
        "Collections",
        "Generic",
        "MachineEntity",
        "PowerConsumerInterface",
        "ItemConsumerInterface",
        "StorageMachineInterface",
        "ItemBase",
        "eHopperPermissions",
        "AddAndRemove",
        "mrTimeSinceLogistics",
        "mrLogisticsDebounce",
        "mrTimeSinceLogistics",
        "mbAllowLogistics",
        "Segment",
        "segment",
        "x",
        "y",
        "z",
        "cube",
        "flags",
        "lValue",
        "lbFromDisk",
        "eSegmentEntity",
        "StorageHopper",
        "SpawnableObjectEnum",
        "StorageHopper",
        "x",
        "y",
        "z",
        "cube",
        "flags",
        "lValue",
        "Vector3",
        "zero",
        "segment",
        "mbNeedsLowFrequencyUpdate",
        "mbNeedsUnityUpdate",
        "maItemInventory",
        "ItemBase",
        "mnMaxStorage",
        "mrMaxPower",
        "lValue",
        "MOTORISED_HOPPER",
        "mnMaxStorage",
        "mrLogisticsDebounce",
        "mrMaxPower",
        "lValue",
        "CRYO_HOPPER",
        "mnMaxStorage",
        "mrLogisticsDebounce",
        "mrMaxPower",
        "lValue",
        "mnMaxStorage",
        "mrLogisticsDebounce",
        "DifficultySettings",
        "mbRushMode",
        "mrLogisticsDebounce",
        "lValue",
        "mnMaxStorage",
        "mrLogisticsDebounce",
        "DifficultySettings",
        "mbRushMode",
        "mrLogisticsDebounce",
        "lValue",
        "mrLogisticsDebounce",
        "mnMaxStorage",
        "CountFreeSlots",
        "CheckSegments",
        "Segment",
        "SteamManager",
        "Initialized",
        "lbFromDisk",
        "SurvivalPlayerScript",
        "meTutorialState",
        "SurvivalPlayerScript",
        "eTutorialState",
        "NowFuckOff",
        "AddCube",
        "eCubeTypes",
        "OreCoal",
        "AddCube",
        "eCubeTypes",
        "OreCoal",
        "AddCube",
        "eCubeTypes",
        "OreCoal",
        "AddCube",
        "eCubeTypes",
        "OreCoal",
        "AddCube",
        "eCubeTypes",
        "OreCoal",
        "Debug",
        "LogWarning",
        "mValue",
        "CRYO_HOPPER",
        "mObjectType",
        "SpawnableObjectEnum",
        "CryoHopper",
        "mValue",
        "MOTORISED_HOPPER",
        "mObjectType",
        "SpawnableObjectEnum",
        "MotorisedLogisticsHopper",
        "mValue",
        "mObjectType",
        "SpawnableObjectEnum",
        "LogisticsHopper",
        "mValue",
        "mObjectType",
        "SpawnableObjectEnum",
        "MicroHopper",
        "mValue",
        "STORAGE_HOPPER",
        "mObjectType",
        "SpawnableObjectEnum",
        "StorageHopper",
        "SpawnGameObject",
        "DropGameObject",
        "mbLinkedToGO",
        "GameObject",
        "Destroy",
        "TutorialEffect",
        "ItemBase",
        "lItemToAdd",
        "lItemToAdd",
        "UNITY_EDITOR",
        "Debug",
        "LogError",
        "Environment",
        "StackTrace",
        "CountFreeSlots",
        "mnStorageFree",
        "ItemManager",
        "GetCurrentStackSize",
        "lItemToAdd",
        "mnStorageFree",
        "lItemToAdd",
        "mType",
        "ItemType",
        "ItemStack",
        "lItemToAdd",
        "ItemStack",
        "mnAmount",
        "Debug",
        "LogError",
        "ItemManager",
        "GetItemName",
        "lItemToAdd",
        "UNITY_EDITOR",
        "lItemToAdd",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "CubeHelper",
        "IsIngottableOre",
        "lItemToAdd",
        "ItemCubeStack",
        "mCubeType",
        "lItemToAdd",
        "ItemCubeStack",
        "mCubeValue",
        "Debug",
        "LogError",
        "Environment",
        "StackTrace",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "existingItem",
        "existingItem",
        "mType",
        "lItemToAdd",
        "mType",
        "ItemManager",
        "StackWholeItems",
        "existingItem",
        "lItemToAdd",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "WorldScript",
        "mLocalPlayer",
        "mResearch",
        "IsKnown",
        "lItemToAdd",
        "mLastItemAdded",
        "ItemManager",
        "GetItemName",
        "lItemToAdd",
        "mLastItemAdded",
        "PlayerResearch",
        "UnknownMaterial",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "lItemToAdd",
        "WorldScript",
        "mLocalPlayer",
        "mResearch",
        "IsKnown",
        "lItemToAdd",
        "mLastItemAdded",
        "ItemManager",
        "GetItemName",
        "lItemToAdd",
        "mLastItemAdded",
        "PlayerResearch",
        "UnknownMaterial",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "mnStorageUsed",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "item",
        "mType",
        "ItemType",
        "ItemStack",
        "mnStorageUsed",
        "item",
        "ItemStack",
        "mnAmount",
        "item",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "mnStorageUsed",
        "item",
        "ItemCubeStack",
        "mnAmount",
        "mnStorageUsed",
        "mnStorageUsed",
        "mnMaxStorage",
        "WorldScript",
        "mbIsServer",
        "ServerConsole",
        "DebugLog",
        "mnStorageUsed",
        "mnMaxStorage",
        "Environment",
        "StackTrace",
        "mLastItemAdded",
        "ConsoleMessageType",
        "Debug",
        "LogError",
        "mnStorageUsed",
        "mnMaxStorage",
        "Environment",
        "StackTrace",
        "mLastItemAdded",
        "mnStorageFree",
        "mnMaxStorage",
        "mnStorageUsed",
        "lnOldStorage",
        "mnStorageFree",
        "mbForceTextUpdate",
        "Segment",
        "mrTimeSinceLogistics",
        "mrTimeSinceLogistics",
        "LowFrequencyThread",
        "mrPreviousUpdateTimeStep",
        "mbAllowLogistics",
        "mbAllowLogistics",
        "mrTimeUntilPlayerDistanceUpdate",
        "LowFrequencyThread",
        "mrPreviousUpdateTimeStep",
        "mrTimeUntilPlayerDistanceUpdate",
        "mrPrevDistanceToPlayer",
        "mDistanceToPlayer",
        "UpdatePlayerDistanceInfo",
        "mrTimeUntilPlayerDistanceUpdate",
        "mDistanceToPlayer",
        "mrTimeUntilPlayerDistanceUpdate",
        "mrTimeUntilPlayerDistanceUpdate",
        "mnLowFrequencyUpdates",
        "UpdateHoover",
        "UpdatePoweredHopper",
        "WorldScript",
        "mbIsServer",
        "UpdateSpoilage",
        "mrNormalisedPower",
        "mrCurrentPower",
        "mrMaxPower",
        "mrReadoutTick",
        "LowFrequencyThread",
        "mrPreviousUpdateTimeStep",
        "mrReadoutTick",
        "MUSEUM",
        "maItemInventory",
        "maStorage",
        "eCubeTypes",
        "NULL",
        "CountFreeSlots",
        "mrReadoutTick",
        "mnReadouts",
        "mnX",
        "mnY",
        "mnZ",
        "mnReadouts",
        "lnWhich",
        "checkX",
        "lnWhich",
        "checkX",
        "lnWhich",
        "checkY",
        "lnWhich",
        "checkY",
        "lnWhich",
        "checkZ",
        "lnWhich",
        "checkZ",
        "CheckSegments",
        "lnWhich",
        "CheckSegments",
        "lnWhich",
        "AttemptGetSegment",
        "checkX",
        "checkY",
        "checkZ",
        "CheckSegments",
        "lnWhich",
        "mbDestroyed",
        "CheckSegments",
        "lnWhich",
        "mbInitialGenerationComplete",
        "CheckSegments",
        "lnWhich",
        "CheckSegments",
        "lnWhich",
        "GetCube",
        "checkX",
        "checkY",
        "checkZ",
        "CubeHelper",
        "HasEntity",
        "lCube",
        "mnStorageFree",
        "CheckSuppliers",
        "CheckSegments",
        "lnWhich",
        "lCube",
        "checkX",
        "checkY",
        "checkZ",
        "mnStorageUsed",
        "CheckConsumers",
        "CheckSegments",
        "lnWhich",
        "lCube",
        "checkX",
        "checkY",
        "checkZ",
        "CheckHoppers",
        "checkX",
        "checkY",
        "checkZ",
        "CheckSegments",
        "lnWhich",
        "lCube",
        "mValue",
        "CRYO_HOPPER",
        "mrCurrentTemperature",
        "SAFE_COLD_TEMP",
        "lbSpoil",
        "lbSpoil",
        "mrSpoilTimer",
        "LowFrequencyThread",
        "mrPreviousUpdateTimeStep",
        "mrSpoilTimer",
        "i",
        "mnMaxStorage",
        "i",
        "AttemptToSpoilOrganicItem",
        "i",
        "mrSpoilTimer",
        "mrSpoilTimer",
        "mrSpoilTimer",
        "i",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "mnItemID",
        "maItemInventory",
        "i",
        "mnItemID",
        "maItemInventory",
        "i",
        "mnItemID",
        "mrSpoilTimer",
        "DecrementInventorySlot",
        "i",
        "ItemManager",
        "SpawnItem",
        "SPOILED_ORGANICS",
        "AddItem",
        "lSpoiledItem",
        "mValue",
        "CRYO_HOPPER",
        "mnY",
        "WorldScript",
        "mDefaultOffset",
        "BiomeLayer",
        "CavernColdCeiling",
        "mnY",
        "WorldScript",
        "mDefaultOffset",
        "BiomeLayer",
        "CavernColdFloor",
        "lrExternalTemp",
        "lbInColdCavern",
        "lrExternalTemp",
        "mrCurrentTemperature",
        "lrDiff",
        "LowFrequencyThread",
        "mrPreviousUpdateTimeStep",
        "lrDiff",
        "mrCurrentTemperature",
        "lrDiff",
        "lrDiff",
        "lrDesiredTemp",
        "mrCurrentTemperature",
        "lrDiff",
        "LowFrequencyThread",
        "mrPreviousUpdateTimeStep",
        "lrPowerNeeded",
        "lrPowerNeeded",
        "lrPowerNeeded",
        "lrPowerNeeded",
        "mrCurrentPower",
        "lrPowerNeeded",
        "mrCurrentPower",
        "lrDiff",
        "lrDiff",
        "lrPowerNeeded",
        "lrDiff",
        "lrPowerNeeded",
        "lbInColdCavern",
        "lrPowerNeeded",
        "mrCurrentPower",
        "lrPowerNeeded",
        "mrCurrentTemperature",
        "lrDiff",
        "lrPowerNeeded",
        "LowFrequencyThread",
        "mrPreviousUpdateTimeStep",
        "lrPowerNeeded",
        "mrPPS",
        "mrPPS",
        "lrPowerDiff",
        "checkX",
        "checkY",
        "checkZ",
        "Segment",
        "checkSegment",
        "lCube",
        "mPermissions",
        "eHopperPermissions",
        "AddOnly",
        "mPermissions",
        "eHopperPermissions",
        "Locked",
        "mnStorageUsed",
        "CubeHelper",
        "HasEntity",
        "lCube",
        "checkSegment",
        "SearchEntity",
        "checkX",
        "checkY",
        "checkZ",
        "StorageMachineInterface",
        "lHopper",
        "i",
        "mnHopperLoops",
        "i",
        "mnStorageUsed",
        "lHopper",
        "GetPermissions",
        "permissions",
        "eHopperPermissions",
        "Locked",
        "permissions",
        "eHopperPermissions",
        "RemoveOnly",
        "lHopper",
        "RemainingCapacity",
        "lHopper",
        "UsedCapacity",
        "mnStorageUsed",
        "GetSpecificCube",
        "eHopperRequestType",
        "eAny",
        "lType",
        "lValue",
        "lType",
        "eCubeTypes",
        "NULL",
        "lHopper",
        "TryInsert",
        "lType",
        "lValue",
        "mrReadoutTick",
        "Segment",
        "checkSegment",
        "lCube",
        "checkX",
        "checkY",
        "checkZ",
        "mPermissions",
        "eHopperPermissions",
        "Locked",
        "mPermissions",
        "eHopperPermissions",
        "RemoveOnly",
        "mnStorageFree",
        "checkSegment",
        "SearchEntity",
        "checkX",
        "checkY",
        "checkZ",
        "StorageSupplierInterface",
        "targetEntity",
        "targetEntity",
        "ProcessStorageSupplier",
        "Segment",
        "checkSegment",
        "lCube",
        "checkX",
        "checkY",
        "checkZ",
        "mPermissions",
        "eHopperPermissions",
        "Locked",
        "mPermissions",
        "eHopperPermissions",
        "AddOnly",
        "checkSegment",
        "SearchEntity",
        "checkX",
        "checkY",
        "checkZ",
        "StorageConsumerInterface",
        "targetEntity",
        "targetEntity",
        "ProcessStorageConsumer",
        "lCube",
        "eCubeTypes",
        "GeothermalGenerator",
        "checkSegment",
        "FetchEntity",
        "eSegmentEntity",
        "GeothermalGenerator",
        "checkX",
        "checkY",
        "checkZ",
        "GeothermalGenerator",
        "lGT",
        "lGT",
        "mLinkedCenter",
        "lGT",
        "lGT",
        "mLinkedCenter",
        "lGT",
        "CheckHopper",
        "Segment",
        "WorldScript",
        "mbIsServer",
        "mbHooverOn",
        "HooverSegment",
        "HooverSegment",
        "Segment",
        "mnStorageFree",
        "mbHooverOn",
        "SegmentUpdater",
        "mnNumHoovers",
        "x",
        "x",
        "y",
        "y",
        "z",
        "z",
        "HooverSegment",
        "x",
        "y",
        "z",
        "mnX",
        "x",
        "WorldHelper",
        "SegmentX",
        "mnY",
        "y",
        "WorldHelper",
        "SegmentY",
        "mnZ",
        "z",
        "WorldHelper",
        "SegmentZ",
        "AttemptGetSegment",
        "lookupX",
        "lookupY",
        "lookupZ",
        "segment",
        "segment",
        "mbInitialGenerationComplete",
        "segment",
        "mbDestroyed",
        "HooverSegment",
        "x",
        "y",
        "z",
        "segment",
        "ItemManager",
        "instance",
        "UpdateCollectionSpecificSegment",
        "mnX",
        "mnY",
        "mnZ",
        "Vector3",
        "HooverSegment",
        "x",
        "y",
        "z",
        "mnStorageFree",
        "droppedItem",
        "AddItem",
        "droppedItem",
        "mItem",
        "ItemManager",
        "instance",
        "DropItem",
        "droppedItem",
        "mItem",
        "mnX",
        "mnY",
        "mnZ",
        "Vector3",
        "up",
        "WorkLight",
        "mHooverPart",
        "mTextMesh",
        "mHopperPart",
        "mDistanceToPlayer",
        "lbShowHopper",
        "mbWellBehindPlayer",
        "lbShowHopper",
        "Mathf",
        "Abs",
        "mVectorToPlayer",
        "y",
        "lbShowHopper",
        "mSegment",
        "mbOutOfView",
        "lbShowHopper",
        "lbShowHopper",
        "mbShowHopper",
        "mbShowHopper",
        "lbShowHopper",
        "mbForceHoloUpdate",
        "lbShowHopper",
        "mHopperPart",
        "activeSelf",
        "mHopperPart",
        "SetActive",
        "mHopperPart",
        "GetComponent",
        "Renderer",
        "enabled",
        "mHopperPart",
        "activeSelf",
        "mHopperPart",
        "SetActive",
        "mHopperPart",
        "GetComponent",
        "Renderer",
        "enabled",
        "UpdateHooverEmission",
        "mDistanceToPlayer",
        "mbWellBehindPlayer",
        "mDistanceToPlayer",
        "CamDetail",
        "SegmentDrawDistance",
        "mTextMesh",
        "GetComponent",
        "Renderer",
        "enabled",
        "mbForceHoloUpdate",
        "mTextMesh",
        "GetComponent",
        "Renderer",
        "enabled",
        "mTextMesh",
        "GetComponent",
        "Renderer",
        "enabled",
        "mbForceHoloUpdate",
        "mTextMesh",
        "GetComponent",
        "Renderer",
        "enabled",
        "mDistanceToPlayer",
        "mbWellBehindPlayer",
        "lbAllowHoover",
        "mDistanceToPlayer",
        "CamDetail",
        "SegmentDrawDistance",
        "Mathf",
        "Abs",
        "mVectorToPlayer",
        "y",
        "mbWellBehindPlayer",
        "lbAllowHoover",
        "lbAllowHoover",
        "mnHooverEmissionRate",
        "mnHooverEmissionRate",
        "mHooverPart",
        "emissionRate",
        "mnHooverEmissionRate",
        "mbHooverOn",
        "mnHooverEmissionRate",
        "mnHooverEmissionRate",
        "mHooverPart",
        "emissionRate",
        "mnHooverEmissionRate",
        "mnHooverEmissionRate",
        "mnHooverEmissionRate",
        "mHooverPart",
        "emissionRate",
        "mnHooverEmissionRate",
        "mnStorageUsed",
        "lbLightShouldBeEnabled",
        "mnStorageFree",
        "lbLightShouldBeEnabled",
        "mValue",
        "CRYO_HOPPER",
        "lbLightShouldBeEnabled",
        "mbWellBehindPlayer",
        "lbLightShouldBeEnabled",
        "mrMaxLightDistance",
        "CamDetail",
        "FPS",
        "mrMaxLightDistance",
        "Time",
        "deltaTime",
        "mrMaxLightDistance",
        "mrMaxLightDistance",
        "mrMaxLightDistance",
        "mrMaxLightDistance",
        "mDistanceToPlayer",
        "mrMaxLightDistance",
        "lbLightShouldBeEnabled",
        "lbLightShouldBeEnabled",
        "WorkLight",
        "enabled",
        "WorkLight",
        "enabled",
        "WorkLight",
        "mValue",
        "CRYO_HOPPER",
        "mrCurrentTemperature",
        "SAFE_COLD_TEMP",
        "WorkLight",
        "color",
        "Color",
        "Lerp",
        "WorkLight",
        "color",
        "Color",
        "red",
        "Time",
        "deltaTime",
        "WorkLight",
        "WorkLight",
        "color",
        "Color",
        "Lerp",
        "WorkLight",
        "color",
        "Color",
        "cyan",
        "Time",
        "deltaTime",
        "WorkLight",
        "mnStorageUsed",
        "WorkLight",
        "color",
        "Color",
        "Lerp",
        "WorkLight",
        "color",
        "Color",
        "green",
        "Time",
        "deltaTime",
        "WorkLight",
        "mnStorageFree",
        "WorkLight",
        "color",
        "Color",
        "Lerp",
        "WorkLight",
        "color",
        "Color",
        "red",
        "Time",
        "deltaTime",
        "WorkLight",
        "WorkLight",
        "color",
        "Color",
        "Lerp",
        "WorkLight",
        "color",
        "Color",
        "cyan",
        "Time",
        "deltaTime",
        "WorkLight",
        "WorkLight",
        "WorkLight",
        "WorkLight",
        "enabled",
        "WorkLight",
        "WorkLight",
        "enabled",
        "WorkLight",
        "eHopperPermissions",
        "eNumPermissions",
        "mHoloStatus",
        "mbForceHoloUpdate",
        "mPreviousPermissions",
        "eHopperPermissions",
        "eNumPermissions",
        "mbForceHoloUpdate",
        "mDistanceToPlayer",
        "mbWellBehindPlayer",
        "mHoloStatus",
        "activeSelf",
        "mHoloStatus",
        "SetActive",
        "mHoloStatus",
        "activeSelf",
        "mPreviousPermissions",
        "eHopperPermissions",
        "eNumPermissions",
        "mHoloStatus",
        "SetActive",
        "mPreviousPermissions",
        "mPermissions",
        "mPreviousPermissions",
        "mPermissions",
        "mPermissions",
        "eHopperPermissions",
        "AddAndRemove",
        "mHoloStatus",
        "GetComponent",
        "Renderer",
        "material",
        "mainTextureOffset",
        "Vector2",
        "mPermissions",
        "eHopperPermissions",
        "RemoveOnly",
        "mHoloStatus",
        "GetComponent",
        "Renderer",
        "material",
        "mainTextureOffset",
        "Vector2",
        "mPermissions",
        "eHopperPermissions",
        "Locked",
        "mHoloStatus",
        "GetComponent",
        "Renderer",
        "material",
        "mainTextureOffset",
        "Vector2",
        "mPermissions",
        "eHopperPermissions",
        "AddOnly",
        "mHoloStatus",
        "GetComponent",
        "Renderer",
        "material",
        "mainTextureOffset",
        "Vector2",
        "mTextMesh",
        "GetComponent",
        "Renderer",
        "enabled",
        "mDistanceToPlayer",
        "mPermissions",
        "ToString",
        "mnStorageFree",
        "lText",
        "mnStorageUsed",
        "lText",
        "lText",
        "mnStorageFree",
        "ToString",
        "mrTimeSinceLogistics",
        "lText",
        "lText",
        "mLastItemAdded",
        "mTextMesh",
        "text",
        "lText",
        "mbForceTextUpdate",
        "mWrapper",
        "mWrapper",
        "mbHasGameObject",
        "mWrapper",
        "mGameObjectList",
        "Debug",
        "LogError",
        "mWrapper",
        "mGameObjectList",
        "gameObject",
        "Debug",
        "LogError",
        "WorkLight",
        "mWrapper",
        "mGameObjectList",
        "transform",
        "Search",
        "GetComponent",
        "Light",
        "WorkLight",
        "Debug",
        "LogError",
        "mHooverPart",
        "mWrapper",
        "mGameObjectList",
        "transform",
        "Search",
        "GetComponent",
        "ParticleSystem",
        "mHooverPart",
        "emissionRate",
        "mTextMesh",
        "mWrapper",
        "mGameObjectList",
        "gameObject",
        "transform",
        "Search",
        "GetComponent",
        "TextMesh",
        "mHopperPart",
        "mWrapper",
        "mGameObjectList",
        "transform",
        "Find",
        "gameObject",
        "mHoloStatus",
        "mHopperPart",
        "transform",
        "Find",
        "gameObject",
        "mHoloStatus",
        "SetActive",
        "mPreviousPermissions",
        "eHopperPermissions",
        "eNumPermissions",
        "SetHoloStatus",
        "mbForceTextUpdate",
        "mbLinkedToGO",
        "mbTutorialComplete",
        "WorldScript",
        "meGameMode",
        "eGameMode",
        "eSurvival",
        "SurvivalPlayerScript",
        "meTutorialState",
        "SurvivalPlayerScript",
        "eTutorialState",
        "RemoveCoalFromHopper",
        "TutorialEffect",
        "TutorialEffect",
        "GameObject",
        "GameObject",
        "Instantiate",
        "SurvivalSpawns",
        "instance",
        "EmptySH",
        "mWrapper",
        "mGameObjectList",
        "gameObject",
        "transform",
        "position",
        "Vector3",
        "up",
        "Vector3",
        "up",
        "Quaternion",
        "identity",
        "TutorialEffect",
        "SetActive",
        "TutorialEffect",
        "GameObject",
        "Destroy",
        "TutorialEffect",
        "TutorialEffect",
        "mbTutorialComplete",
        "mrTimeElapsed",
        "Time",
        "deltaTime",
        "mbLinkedToGO",
        "LinkToGO",
        "ConfigTutorial",
        "mbWellBehindPlayer",
        "mSegment",
        "mbOutOfView",
        "mDistanceToPlayer",
        "mrPrevDistanceToPlayer",
        "mbForceHoloUpdate",
        "mDistanceToPlayer",
        "mrPrevDistanceToPlayer",
        "mbForceHoloUpdate",
        "mbForceHoloUpdate",
        "SetHoloStatus",
        "mbForceTextUpdate",
        "UpdateMeshText",
        "mnUpdates",
        "UpdateLOD",
        "UpdateWorkLight",
        "lType",
        "lValue",
        "lType",
        "eCubeTypes",
        "NULL",
        "Debug",
        "LogError",
        "Environment",
        "StackTrace",
        "mnStorageFree",
        "Debug",
        "LogError",
        "lType",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "item",
        "i",
        "firstEmpty",
        "firstEmpty",
        "i",
        "WorldScript",
        "mLocalPlayer",
        "mResearch",
        "IsKnown",
        "lType",
        "mLastItemAdded",
        "TerrainData",
        "GetNameForValue",
        "lType",
        "lValue",
        "mLastItemAdded",
        "PlayerResearch",
        "UnknownMaterial",
        "item",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "item",
        "ItemCubeStack",
        "stack",
        "Debug",
        "LogError",
        "item",
        "mType",
        "item",
        "mnItemID",
        "stack",
        "mCubeType",
        "lType",
        "stack",
        "mCubeValue",
        "lValue",
        "stack",
        "mnAmount",
        "WorldScript",
        "mLocalPlayer",
        "mResearch",
        "IsKnown",
        "lType",
        "lType",
        "TerrainData",
        "mEntries",
        "Length",
        "Debug",
        "LogError",
        "lType",
        "TerrainData",
        "mEntries",
        "Length",
        "mLastItemAdded",
        "lType",
        "mLastItemAdded",
        "TerrainData",
        "GetNameForValue",
        "lType",
        "lValue",
        "mLastItemAdded",
        "PlayerResearch",
        "UnknownMaterial",
        "MarkDirtyDelayed",
        "CountFreeSlots",
        "firstEmpty",
        "mnMaxStorage",
        "Debug",
        "Log",
        "maItemInventory",
        "firstEmpty",
        "ItemManager",
        "SpawnCubeStack",
        "lType",
        "lValue",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "x",
        "mnMaxStorage",
        "x",
        "y",
        "mnMaxStorage",
        "y",
        "x",
        "y",
        "ItemManager",
        "StackWholeItems",
        "maItemInventory",
        "x",
        "maItemInventory",
        "y",
        "Debug",
        "LogError",
        "maItemInventory",
        "y",
        "ToString",
        "maItemInventory",
        "x",
        "maItemInventory",
        "y",
        "IterateItem",
        "itemFunc",
        "state",
        "itemFunc",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "item",
        "itemFunc",
        "maItemInventory",
        "i",
        "state",
        "lType",
        "CubeHelper",
        "IsOre",
        "lType",
        "Debug",
        "LogError",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "maItemInventory",
        "i",
        "ItemCubeStack",
        "stack",
        "mCubeType",
        "lType",
        "lnNumFound",
        "stack",
        "mnAmount",
        "lnNumFound",
        "lType",
        "lValue",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "maItemInventory",
        "i",
        "ItemCubeStack",
        "lValue",
        "MaxValue",
        "stack",
        "mCubeType",
        "lType",
        "lnNumFound",
        "stack",
        "mnAmount",
        "stack",
        "mCubeType",
        "lType",
        "stack",
        "mCubeValue",
        "lValue",
        "lnNumFound",
        "stack",
        "mnAmount",
        "lnNumFound",
        "itemID",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "item",
        "item",
        "mnItemID",
        "itemID",
        "item",
        "ItemStack",
        "stack",
        "lnNumFound",
        "stack",
        "mnAmount",
        "lnNumFound",
        "lnNumFound",
        "lSearchType",
        "knownOnly",
        "CraftData",
        "recipes",
        "lBestChoice",
        "lSearchType",
        "eCubeTypes",
        "NULL",
        "lBestChoice",
        "lSearchType",
        "CountHowManyOfOreType",
        "lSearchType",
        "lBestChoice",
        "eCubeTypes",
        "NULL",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "maItemInventory",
        "i",
        "ItemCubeStack",
        "mnAmount",
        "maItemInventory",
        "i",
        "ItemCubeStack",
        "lStack",
        "Debug",
        "LogError",
        "WorldScript",
        "mLocalPlayer",
        "WorldScript",
        "mLocalPlayer",
        "mResearch",
        "Debug",
        "LogError",
        "lStack",
        "mnItemID",
        "lBestChoice",
        "CubeHelper",
        "IsIngottableOre",
        "lStack",
        "mCubeType",
        "recipes",
        "validRecipe",
        "CraftData",
        "recipe",
        "recipes",
        "CraftCost",
        "cost",
        "recipe",
        "Costs",
        "cost",
        "CubeType",
        "lStack",
        "mCubeType",
        "validRecipe",
        "validRecipe",
        "validRecipe",
        "knownOnly",
        "WorldScript",
        "mLocalPlayer",
        "mResearch",
        "IsKnown",
        "lStack",
        "mCubeType",
        "CountHowManyOfOreType",
        "lStack",
        "mCubeType",
        "lnNumStored",
        "lnNumFound",
        "lBestChoice",
        "lStack",
        "mCubeType",
        "lnNumFound",
        "lnNumStored",
        "lnNumFound",
        "lType",
        "mnStorageUsed",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "maItemInventory",
        "i",
        "ItemCubeStack",
        "lInvStack",
        "mnAmount",
        "lInvStack",
        "mCubeType",
        "lType",
        "lInvStack",
        "mnAmount",
        "lInvStack",
        "mnAmount",
        "maItemInventory",
        "i",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lType",
        "lValue",
        "amount",
        "mnStorageUsed",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "item",
        "item",
        "mnItemID",
        "item",
        "ItemCubeStack",
        "stack",
        "mCubeType",
        "lType",
        "stack",
        "mCubeValue",
        "lValue",
        "stack",
        "mnAmount",
        "amountToRemove",
        "maItemInventory",
        "i",
        "amountToRemove",
        "stack",
        "mnAmount",
        "amountToRemove",
        "stack",
        "mnAmount",
        "amountToRemove",
        "amountToRemove",
        "amountToRemove",
        "amount",
        "RequestImmediateNetworkUpdate",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "mnStorageUsed",
        "mLastItemAdded",
        "amount",
        "amountToRemove",
        "ItemBase",
        "itemToUnload",
        "itemToUnload",
        "Debug",
        "LogError",
        "mnStorageFree",
        "ItemManager",
        "GetCurrentStackSize",
        "itemToUnload",
        "Mathf",
        "Min",
        "count",
        "mnStorageFree",
        "i",
        "maItemInventory",
        "Length",
        "i",
        "maItemInventory",
        "i",
        "existingItem",
        "existingItem",
        "mType",
        "itemToUnload",
        "mType",
        "ItemManager",
        "StackPartialItems",
        "existingItem",
        "itemToUnload",
        "itemsLeft",
        "itemsLeft",
        "stackAmount",
        "itemsLeft",
        "itemsLeft",
        "CountFreeSlots",
        "mnStorageFree",
        "AddItem",
        "itemToUnload",
        "itemsLeft",
        "i",
        "maItemInventory",
        "Length",
        "i",
        "maItemInventory",
        "i",
        "ItemManager",
        "GetMaxStackSize",
        "itemToUnload",
        "lnMax",
        "itemsLeft",
        "lnMax",
        "itemsLeft",
        "lnMax",
        "mnStorageFree",
        "lnMax",
        "mnStorageFree",
        "Debug",
        "LogWarning",
        "itemToUnload",
        "ToString",
        "lnMax",
        "ItemManager",
        "CloneItem",
        "itemToUnload",
        "ItemManager",
        "SetItemCount",
        "lItem",
        "maItemInventory",
        "i",
        "lItem",
        "ItemManager",
        "StackPartialItems",
        "lItem",
        "itemToUnload",
        "lnMax",
        "itemsLeft",
        "stackAmount",
        "itemsLeft",
        "CountFreeSlots",
        "Debug",
        "LogWarning",
        "itemsToStore",
        "itemsLeft",
        "itemToUnload",
        "ToString",
        "itemsLeft",
        "Debug",
        "LogError",
        "FinaliseHopperChange",
        "itemsToStore",
        "itemsLeft",
        "eHopperRequestType",
        "lType",
        "cubeType",
        "cubeValue",
        "lType",
        "eHopperRequestType",
        "eNone",
        "cubeType",
        "eCubeTypes",
        "NULL",
        "cubeValue",
        "mnStorageUsed",
        "lType",
        "eHopperRequestType",
        "eBarsOnly",
        "lType",
        "eHopperRequestType",
        "eAnyCraftedItem",
        "cubeType",
        "eCubeTypes",
        "NULL",
        "cubeValue",
        "l",
        "mnMaxStorage",
        "l",
        "mnRoundRobinOffset",
        "mnRoundRobinOffset",
        "mnMaxStorage",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "maItemInventory",
        "i",
        "ItemCubeStack",
        "lType",
        "eHopperRequestType",
        "eOrganic",
        "lType",
        "eHopperRequestType",
        "eHighCalorieOnly",
        "CubeHelper",
        "IsHighCalorie",
        "lStack",
        "mCubeType",
        "lType",
        "eHopperRequestType",
        "eOreOnly",
        "CubeHelper",
        "IsSmeltableOre",
        "lStack",
        "mCubeType",
        "lType",
        "eHopperRequestType",
        "eGarbage",
        "CubeHelper",
        "IsGarbage",
        "lStack",
        "mCubeType",
        "lType",
        "eHopperRequestType",
        "eCrystals",
        "lStack",
        "mCubeType",
        "eCubeTypes",
        "OreCrystal",
        "lType",
        "eHopperRequestType",
        "eGems",
        "lStack",
        "mCubeType",
        "eCubeTypes",
        "Crystal",
        "lType",
        "eHopperRequestType",
        "eBioMass",
        "lStack",
        "mCubeType",
        "eCubeTypes",
        "OreBioMass",
        "lType",
        "eHopperRequestType",
        "eSmeltable",
        "CubeHelper",
        "IsIngottableOre",
        "lStack",
        "mCubeType",
        "lType",
        "eHopperRequestType",
        "eResearchable",
        "TerrainData",
        "mEntries",
        "lStack",
        "mCubeType",
        "entry",
        "entry",
        "DecomposeValue",
        "RemoveInventoryCube",
        "lStack",
        "mCubeType",
        "lStack",
        "mCubeValue",
        "mnStorageUsed",
        "mLastItemAdded",
        "cubeType",
        "lStack",
        "mCubeType",
        "cubeValue",
        "lStack",
        "mCubeValue",
        "cubeType",
        "eCubeTypes",
        "NULL",
        "cubeValue",
        "eHopperRequestType",
        "lType",
        "cubeType",
        "cubeValue",
        "lType",
        "eHopperRequestType",
        "eNone",
        "cubeType",
        "eCubeTypes",
        "NULL",
        "cubeValue",
        "mnStorageUsed",
        "lType",
        "eHopperRequestType",
        "eBarsOnly",
        "lType",
        "eHopperRequestType",
        "eAnyCraftedItem",
        "cubeType",
        "eCubeTypes",
        "NULL",
        "cubeValue",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "maItemInventory",
        "i",
        "ItemCubeStack",
        "lType",
        "eHopperRequestType",
        "eHighCalorieOnly",
        "CubeHelper",
        "IsHighCalorie",
        "lStack",
        "mCubeType",
        "lType",
        "eHopperRequestType",
        "eOreOnly",
        "CubeHelper",
        "IsSmeltableOre",
        "lStack",
        "mCubeType",
        "lType",
        "eHopperRequestType",
        "eGarbage",
        "CubeHelper",
        "IsGarbage",
        "lStack",
        "mCubeType",
        "lType",
        "eHopperRequestType",
        "eCrystals",
        "lStack",
        "mCubeType",
        "eCubeTypes",
        "OreCrystal",
        "lType",
        "eHopperRequestType",
        "eGems",
        "lStack",
        "mCubeType",
        "eCubeTypes",
        "Crystal",
        "lType",
        "eHopperRequestType",
        "eBioMass",
        "lStack",
        "mCubeType",
        "eCubeTypes",
        "OreBioMass",
        "lType",
        "eHopperRequestType",
        "eSmeltable",
        "CubeHelper",
        "IsIngottableOre",
        "lStack",
        "mCubeType",
        "lType",
        "eHopperRequestType",
        "eResearchable",
        "TerrainData",
        "mEntries",
        "lStack",
        "mCubeType",
        "entry",
        "entry",
        "DecomposeValue",
        "RemoveInventoryCube",
        "lStack",
        "mCubeType",
        "lStack",
        "mCubeValue",
        "mnStorageUsed",
        "mLastItemAdded",
        "cubeType",
        "lStack",
        "mCubeType",
        "cubeValue",
        "lStack",
        "mCubeValue",
        "cubeType",
        "eCubeTypes",
        "NULL",
        "cubeValue",
        "ItemCubeStack",
        "lItem",
        "lbInvertSearch",
        "lItem",
        "Debug",
        "LogError",
        "mnStorageUsed",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "maItemInventory",
        "i",
        "ItemCubeStack",
        "lbInvertSearch",
        "lStack",
        "mCubeType",
        "lItem",
        "mCubeType",
        "lStack",
        "mCubeValue",
        "lItem",
        "mCubeValue",
        "lItem",
        "mCubeValue",
        "MaxValue",
        "lbFound",
        "lbInvertSearch",
        "lStack",
        "mCubeType",
        "lItem",
        "mCubeType",
        "lbFound",
        "lStack",
        "mCubeValue",
        "lItem",
        "mCubeValue",
        "lbFound",
        "lbFound",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "lnItemID",
        "lbInvertSearch",
        "lnItemID",
        "Debug",
        "LogError",
        "mnStorageUsed",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "lbInvertSearch",
        "maItemInventory",
        "i",
        "mnItemID",
        "lnItemID",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "maItemInventory",
        "i",
        "mnItemID",
        "lnItemID",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "eHopperRequestType",
        "lType",
        "lType",
        "eHopperRequestType",
        "eNone",
        "lType",
        "eHopperRequestType",
        "eHighCalorieOnly",
        "lType",
        "eHopperRequestType",
        "eOreOnly",
        "lType",
        "eHopperRequestType",
        "eGarbage",
        "lType",
        "eHopperRequestType",
        "eHighCalorieOnly",
        "l",
        "mnMaxStorage",
        "l",
        "mnRoundRobinOffset",
        "mnRoundRobinOffset",
        "mnMaxStorage",
        "maItemInventory",
        "i",
        "lType",
        "eHopperRequestType",
        "eAny",
        "lRet",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemStack",
        "maItemInventory",
        "i",
        "mnItemID",
        "lType",
        "eHopperRequestType",
        "eOrganic",
        "lnID",
        "lnID",
        "lRet",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "lType",
        "eHopperRequestType",
        "eBarsOnly",
        "lnID",
        "ItemEntries",
        "CopperBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "TinBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "IronBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "LithiumBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "GoldBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "NickelBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "TitaniumBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "MolybdenumBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "ChromiumBar",
        "lbIsBar",
        "lbIsBar",
        "lRet",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "lType",
        "eHopperRequestType",
        "eAnyCraftedItem",
        "lRet",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "lType",
        "eHopperRequestType",
        "eAnyCraftedItem",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemSingle",
        "lRet",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemDurability",
        "lRet",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemCharge",
        "lRet",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "lType",
        "eHopperRequestType",
        "eResearchable",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "maItemInventory",
        "i",
        "mnItemID",
        "ItemEntry",
        "mEntries",
        "maItemInventory",
        "i",
        "mnItemID",
        "entry",
        "entry",
        "DecomposeValue",
        "lRet",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "lRet",
        "eHopperRequestType",
        "lType",
        "lType",
        "eHopperRequestType",
        "eNone",
        "lType",
        "eHopperRequestType",
        "eHighCalorieOnly",
        "lType",
        "eHopperRequestType",
        "eOreOnly",
        "lType",
        "eHopperRequestType",
        "eGarbage",
        "lType",
        "eHopperRequestType",
        "eHighCalorieOnly",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "lType",
        "eHopperRequestType",
        "eAny",
        "lRet",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "lRet",
        "eHopperRequestType",
        "lType",
        "lType",
        "eHopperRequestType",
        "eNone",
        "lType",
        "eHopperRequestType",
        "eHighCalorieOnly",
        "lType",
        "eHopperRequestType",
        "eOreOnly",
        "lType",
        "eHopperRequestType",
        "eGarbage",
        "lType",
        "eHopperRequestType",
        "eHighCalorieOnly",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "lType",
        "eHopperRequestType",
        "eAny",
        "lRet",
        "DecrementInventorySlot",
        "i",
        "lRet",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "lRet",
        "i",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "maItemInventory",
        "i",
        "item",
        "ItemCubeStack",
        "lRet",
        "ItemManager",
        "CloneItem",
        "item",
        "lRet",
        "ItemCubeStack",
        "mnAmount",
        "lInvStack",
        "mnAmount",
        "lInvStack",
        "mnAmount",
        "maItemInventory",
        "i",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "maItemInventory",
        "i",
        "ItemStack",
        "lStack",
        "maItemInventory",
        "i",
        "ItemStack",
        "mnAmount",
        "maItemInventory",
        "i",
        "ItemStack",
        "mnAmount",
        "maItemInventory",
        "i",
        "ItemStack",
        "mnAmount",
        "lRet",
        "ItemManager",
        "CloneItem",
        "maItemInventory",
        "i",
        "lRet",
        "ItemStack",
        "mnAmount",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "lRet",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "lRet",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "lRet",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "mnStorageUsed",
        "mLastItemAdded",
        "RequestImmediateNetworkUpdate",
        "lRet",
        "mnStorageUsed",
        "Debug",
        "LogError",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "ItemManager",
        "CloneItem",
        "maItemInventory",
        "i",
        "lRet",
        "mType",
        "ItemType",
        "ItemStack",
        "lRet",
        "ItemStack",
        "mnAmount",
        "maItemInventory",
        "i",
        "ItemStack",
        "mnAmount",
        "maItemInventory",
        "i",
        "ItemStack",
        "mnAmount",
        "maItemInventory",
        "i",
        "lRet",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "lRet",
        "ItemCubeStack",
        "mnAmount",
        "maItemInventory",
        "i",
        "ItemCubeStack",
        "mnAmount",
        "maItemInventory",
        "i",
        "ItemCubeStack",
        "mnAmount",
        "maItemInventory",
        "i",
        "maItemInventory",
        "i",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "mnStorageUsed",
        "mLastItemAdded",
        "lRet",
        "itemID",
        "count",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "item",
        "item",
        "mnItemID",
        "itemID",
        "item",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "Debug",
        "LogError",
        "item",
        "mType",
        "ItemType",
        "ItemStack",
        "item",
        "ItemStack",
        "stack",
        "mnAmount",
        "count",
        "amountRemoved",
        "amountRemoved",
        "stack",
        "mnAmount",
        "stack",
        "mnAmount",
        "maItemInventory",
        "i",
        "stack",
        "mnAmount",
        "count",
        "amountRemoved",
        "amountRemoved",
        "count",
        "amountRemoved",
        "maItemInventory",
        "i",
        "amountRemoved",
        "count",
        "amountRemoved",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "RequestImmediateNetworkUpdate",
        "mnStorageUsed",
        "mLastItemAdded",
        "amountRemoved",
        "ItemBase",
        "cargoList",
        "amountToExtract",
        "i",
        "maItemInventory",
        "Length",
        "i",
        "maItemInventory",
        "i",
        "item",
        "ItemManager",
        "GetCurrentStackSize",
        "item",
        "count",
        "count",
        "amountLeft",
        "ItemManager",
        "SetItemCount",
        "item",
        "count",
        "amountLeft",
        "ItemManager",
        "CloneItem",
        "item",
        "ItemManager",
        "SetItemCount",
        "newItem",
        "amountLeft",
        "ItemManager",
        "FitCargo",
        "cargoList",
        "newItem",
        "FinaliseHopperChange",
        "amountToExtract",
        "amountLeft",
        "count",
        "ItemManager",
        "FitCargo",
        "cargoList",
        "item",
        "maItemInventory",
        "i",
        "FinaliseHopperChange",
        "amountToExtract",
        "amountLeft",
        "MarkDirtyDelayed",
        "RequestImmediateNetworkUpdate",
        "CountFreeSlots",
        "IO",
        "BinaryWriter",
        "writer",
        "i",
        "mnMaxStorage",
        "i",
        "writer",
        "Write",
        "writer",
        "Write",
        "mPermissions",
        "writer",
        "Write",
        "mbHooverOn",
        "writer",
        "Write",
        "writer",
        "Write",
        "writer",
        "Write",
        "writer",
        "Write",
        "mnMaxStorage",
        "writer",
        "Write",
        "mrCurrentPower",
        "writer",
        "Write",
        "mrCurrentTemperature",
        "writer",
        "Write",
        "lnDummy",
        "writer",
        "Write",
        "lnDummy",
        "writer",
        "Write",
        "lnDummy",
        "i",
        "mnMaxStorage",
        "i",
        "ItemFile",
        "SerialiseItem",
        "maItemInventory",
        "i",
        "writer",
        "IO",
        "BinaryReader",
        "reader",
        "entityVersion",
        "i",
        "mnMaxStorage",
        "i",
        "reader",
        "ReadUInt16",
        "cubeType",
        "eCubeTypes",
        "NULL",
        "legacyStorageList",
        "legacyStorageList",
        "legacyStorageList",
        "ContainsKey",
        "cubeType",
        "legacyStorageList",
        "cubeType",
        "legacyStorageList",
        "Add",
        "cubeType",
        "mPermissions",
        "eHopperPermissions",
        "reader",
        "ReadInt32",
        "mSegment",
        "mbValidateOnly",
        "NetworkManager",
        "mbClientRunning",
        "FloatingCombatTextManager",
        "instance",
        "mbLinkedToGO",
        "mPermissions",
        "lPermissions",
        "mDistanceToPlayer",
        "FloatingCombatTextManager",
        "instance",
        "QueueText",
        "mnX",
        "mnY",
        "mnZ",
        "mPermissions",
        "ToString",
        "Color",
        "cyan",
        "lFQ",
        "lFQ",
        "mrStartRadiusRand",
        "mbHooverOn",
        "reader",
        "ReadBoolean",
        "reader",
        "ReadByte",
        "reader",
        "ReadByte",
        "reader",
        "ReadByte",
        "reader",
        "ReadInt32",
        "mrCurrentPower",
        "reader",
        "ReadSingle",
        "mrCurrentTemperature",
        "reader",
        "ReadSingle",
        "mrCurrentTemperature",
        "mrCurrentTemperature",
        "mrCurrentTemperature",
        "mrCurrentTemperature",
        "IsNaN",
        "mrCurrentTemperature",
        "mrCurrentTemperature",
        "IsInfinity",
        "mrCurrentTemperature",
        "mrCurrentTemperature",
        "reader",
        "ReadInt32",
        "reader",
        "ReadInt32",
        "reader",
        "ReadInt32",
        "CountFreeSlots",
        "entityVersion",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "ItemFile",
        "DeserialiseItem",
        "reader",
        "maItemInventory",
        "i",
        "lastItemIndex",
        "i",
        "CountFreeSlots",
        "mSegment",
        "mbValidateOnly",
        "lastItemIndex",
        "maItemInventory",
        "lastItemIndex",
        "WorldScript",
        "mbHasPlayer",
        "item",
        "WorldScript",
        "mLocalPlayer",
        "mResearch",
        "WorldScript",
        "mLocalPlayer",
        "mResearch",
        "IsKnown",
        "item",
        "mLastItemAdded",
        "ItemManager",
        "GetItemName",
        "item",
        "mLastItemAdded",
        "PlayerResearch",
        "UnknownMaterial",
        "legacyStorageList",
        "entry",
        "legacyStorageList",
        "entry",
        "Key",
        "entry",
        "Value",
        "ItemManager",
        "SpawnCubeStack",
        "cubeType",
        "TerrainData",
        "GetDefaultValue",
        "cubeType",
        "amount",
        "AddItem",
        "cubeStack",
        "mbForceHoloUpdate",
        "mbForceTextUpdate",
        "mPermissions",
        "mPermissions",
        "mPermissions",
        "eHopperPermissions",
        "eNumPermissions",
        "mPermissions",
        "eHopperPermissions",
        "AddAndRemove",
        "MarkDirtyDelayed",
        "mbForceTextUpdate",
        "mbForceHoloUpdate",
        "RequestImmediateNetworkUpdate",
        "FloatingCombatTextManager",
        "instance",
        "QueueText",
        "mnX",
        "mnY",
        "mnZ",
        "mPermissions",
        "ToString",
        "Color",
        "green",
        "lFQ",
        "lFQ",
        "mrStartRadiusRand",
        "mbHooverOn",
        "mbHooverOn",
        "MarkDirtyDelayed",
        "mbForceTextUpdate",
        "RequestImmediateNetworkUpdate",
        "WorldScript",
        "mbIsServer",
        "Random",
        "Random",
        "i",
        "mnMaxStorage",
        "i",
        "maItemInventory",
        "i",
        "Vector3",
        "lRand",
        "NextDouble",
        "lRand",
        "NextDouble",
        "lRand",
        "NextDouble",
        "maItemInventory",
        "i",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "Debug",
        "LogWarning",
        "i",
        "maItemInventory",
        "i",
        "ItemCubeStack",
        "mnAmount",
        "ItemManager",
        "instance",
        "DropItem",
        "maItemInventory",
        "i",
        "mnX",
        "mnY",
        "mnZ",
        "lVec",
        "maItemInventory",
        "i",
        "mrMaxPower",
        "mrCurrentPower",
        "mrMaxPower",
        "amount",
        "amount",
        "GetRemainingPowerCapacity",
        "amount",
        "GetRemainingPowerCapacity",
        "mrCurrentPower",
        "amount",
        "MarkDirtyDelayed",
        "SegmentEntity",
        "entity",
        "mValue",
        "CRYO_HOPPER",
        "mValue",
        "MOTORISED_HOPPER",
        "Holobase",
        "holobase",
        "HolobaseEntityCreationParameters",
        "creationParameters",
        "RequiresUpdates",
        "creationParameters",
        "AddVisualisation",
        "holobase",
        "mPreviewCube",
        "holobase",
        "CreateHolobaseEntity",
        "creationParameters",
        "Holobase",
        "holobase",
        "HoloMachineEntity",
        "holoMachineEntity",
        "mnStorageFree",
        "holobase",
        "SetColour",
        "holoMachineEntity",
        "VisualisationObjects",
        "Color",
        "white",
        "holobase",
        "SetColour",
        "holoMachineEntity",
        "VisualisationObjects",
        "Color",
        "green",
        "StorageUserInterface",
        "sourceEntity",
        "ItemBase",
        "item",
        "cubeType",
        "cubeValue",
        "sendImmediateNetworkUpdate",
        "mnStorageFree",
        "item",
        "AddItem",
        "item",
        "AddCube",
        "cubeType",
        "cubeValue",
        "sendImmediateNetworkUpdate",
        "RequestImmediateNetworkUpdate",
        "mPermissions",
        "mnStorageUsed",
        "mnStorageFree",
        "mnStorageUsed",
        "mnStorageFree",
        "mbAllowLogistics",
        "InventoryExtractionOptions",
        "options",
        "InventoryExtractionResults",
        "results",
        "TryExtract",
        "options",
        "RequestType",
        "options",
        "ExemplarItemID",
        "options",
        "ExemplarBlockID",
        "options",
        "ExemplarBlockValue",
        "options",
        "InvertExemplar",
        "options",
        "MinimumAmount",
        "options",
        "MaximumAmount",
        "options",
        "KnownItemsOnly",
        "options",
        "ConvertToItem",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "results",
        "Item",
        "results",
        "Amount",
        "results",
        "Cube",
        "results",
        "Value",
        "results",
        "Cube",
        "returnedCubeType",
        "results",
        "Value",
        "returnedCubeValue",
        "results",
        "Amount",
        "returnedAmount",
        "results",
        "Item",
        "returnedItem",
        "eHopperRequestType",
        "lType",
        "exemplarItemId",
        "exemplarCubeType",
        "exemplarCubeValue",
        "invertExemplar",
        "minimumAmount",
        "maximumAmount",
        "knownItemsOnly",
        "countOnly",
        "trashItems",
        "convertCubesToItems",
        "ItemBase",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "lType",
        "eHopperRequestType",
        "eNone",
        "exemplarItemId",
        "exemplarCubeType",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "l",
        "mnMaxStorage",
        "l",
        "mnRoundRobinOffset",
        "mnRoundRobinOffset",
        "mnMaxStorage",
        "maItemInventory",
        "i",
        "currentItem",
        "exemplarItemId",
        "currentItem",
        "mnItemID",
        "exemplarItemId",
        "invertExemplar",
        "invertExemplar",
        "exemplarCubeType",
        "currentItem",
        "ItemCubeStack",
        "ItemCubeStack",
        "currentItem",
        "cubeStack",
        "mCubeType",
        "exemplarCubeType",
        "cubeStack",
        "mCubeValue",
        "exemplarCubeValue",
        "exemplarCubeValue",
        "MaxValue",
        "invertExemplar",
        "invertExemplar",
        "invertExemplar",
        "lType",
        "eHopperRequestType",
        "eAny",
        "currentItem",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "currentItem",
        "mnItemID",
        "lType",
        "eHopperRequestType",
        "eOrganic",
        "lnID",
        "lnID",
        "matchedRequest",
        "lType",
        "eHopperRequestType",
        "eBarsOnly",
        "lnID",
        "ItemEntries",
        "CopperBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "TinBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "IronBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "LithiumBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "GoldBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "NickelBar",
        "lbIsBar",
        "lnID",
        "ItemEntries",
        "TitaniumBar",
        "lbIsBar",
        "lbIsBar",
        "matchedRequest",
        "lType",
        "eHopperRequestType",
        "eAnyCraftedItem",
        "matchedRequest",
        "lType",
        "eHopperRequestType",
        "eResearchable",
        "ItemEntry",
        "mEntries",
        "lnID",
        "entry",
        "entry",
        "DecomposeValue",
        "matchedRequest",
        "ItemCubeStack",
        "currentItem",
        "lType",
        "eHopperRequestType",
        "eResearchable",
        "TerrainData",
        "mEntries",
        "lStack",
        "mCubeType",
        "entry",
        "entry",
        "DecomposeValue",
        "matchedRequest",
        "lType",
        "eHopperRequestType",
        "eHighCalorieOnly",
        "CubeHelper",
        "IsHighCalorie",
        "lStack",
        "mCubeType",
        "matchedRequest",
        "lType",
        "eHopperRequestType",
        "eOreOnly",
        "CubeHelper",
        "IsSmeltableOre",
        "lStack",
        "mCubeType",
        "matchedRequest",
        "lType",
        "eHopperRequestType",
        "eGarbage",
        "CubeHelper",
        "IsGarbage",
        "lStack",
        "mCubeType",
        "matchedRequest",
        "lType",
        "eHopperRequestType",
        "eCrystals",
        "lStack",
        "mCubeType",
        "eCubeTypes",
        "OreCrystal",
        "matchedRequest",
        "lType",
        "eHopperRequestType",
        "eGems",
        "lStack",
        "mCubeType",
        "eCubeTypes",
        "Crystal",
        "matchedRequest",
        "lType",
        "eHopperRequestType",
        "eBioMass",
        "lStack",
        "mCubeType",
        "eCubeTypes",
        "OreBioMass",
        "matchedRequest",
        "lType",
        "eHopperRequestType",
        "eSmeltable",
        "CubeHelper",
        "IsIngottableOre",
        "lStack",
        "mCubeType",
        "matchedRequest",
        "matchedRequest",
        "knownItemsOnly",
        "WorldScript",
        "mLocalPlayer",
        "mResearch",
        "IsKnown",
        "currentItem",
        "countOnly",
        "numberFound",
        "ItemManager",
        "GetCurrentStackSize",
        "currentItem",
        "matchedItem",
        "matchedItem",
        "currentItem",
        "trashItems",
        "matchedItem",
        "mType",
        "currentItem",
        "mType",
        "matchedItem",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "ItemCubeStack",
        "matchedItem",
        "ItemCubeStack",
        "currentItem",
        "matchedCubeStack",
        "mCubeType",
        "currentCubeStack",
        "mCubeType",
        "exemplarCubeValue",
        "MaxValue",
        "matchedCubeStack",
        "mCubeValue",
        "currentCubeStack",
        "mCubeValue",
        "matchedItem",
        "mnItemID",
        "currentItem",
        "mnItemID",
        "currentItem",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "ItemCubeStack",
        "currentItem",
        "mnAmount",
        "stackSize",
        "numberRemaining",
        "numberRemaining",
        "stackSize",
        "numberFound",
        "stackSize",
        "minimumAmount",
        "numberFound",
        "stackSize",
        "mRemoveCache",
        "itemsToRemove",
        "i",
        "itemsToRemove",
        "maItemInventory",
        "i",
        "matchedItemRemoved",
        "ItemCubeStack",
        "currentItem",
        "mnAmount",
        "numberRemaining",
        "numberFound",
        "numberRemaining",
        "numberRemaining",
        "currentItem",
        "mType",
        "ItemType",
        "ItemStack",
        "ItemStack",
        "currentItem",
        "mnAmount",
        "stackSize",
        "numberRemaining",
        "numberRemaining",
        "stackSize",
        "numberFound",
        "stackSize",
        "minimumAmount",
        "numberFound",
        "stackSize",
        "mRemoveCache",
        "itemsToRemove",
        "i",
        "itemsToRemove",
        "maItemInventory",
        "i",
        "matchedItemRemoved",
        "ItemStack",
        "currentItem",
        "mnAmount",
        "numberRemaining",
        "numberFound",
        "numberRemaining",
        "numberRemaining",
        "trashItems",
        "returnedItem",
        "matchedItem",
        "numberFound",
        "numberRemaining",
        "maItemInventory",
        "i",
        "numberFound",
        "numberRemaining",
        "minimumAmount",
        "numberFound",
        "mRemoveCache",
        "itemsToRemove",
        "i",
        "itemsToRemove",
        "maItemInventory",
        "i",
        "matchedItemRemoved",
        "numberRemaining",
        "j",
        "itemsToRemove",
        "j",
        "maItemInventory",
        "mRemoveCache",
        "j",
        "matchedItem",
        "countOnly",
        "trashItems",
        "returnedItem",
        "matchedItem",
        "matchedItemRemoved",
        "matchedItem",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "ItemCubeStack",
        "matchedItem",
        "cubeStack",
        "mnAmount",
        "numberFound",
        "returnedItem",
        "cubeStack",
        "returnedCubeType",
        "cubeStack",
        "mCubeType",
        "returnedCubeValue",
        "cubeStack",
        "mCubeValue",
        "returnedAmount",
        "numberFound",
        "matchedItem",
        "mType",
        "ItemType",
        "ItemStack",
        "ItemStack",
        "matchedItem",
        "itemStack",
        "mnAmount",
        "numberFound",
        "returnedItem",
        "itemStack",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "numberFound",
        "returnedItem",
        "matchedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "matchedItem",
        "mType",
        "ItemType",
        "ItemCubeStack",
        "ItemCubeStack",
        "matchedItem",
        "convertCubesToItems",
        "ItemStack",
        "ItemManager",
        "CloneItem",
        "cubeStack",
        "numberFound",
        "returnedItem",
        "returnedCubeType",
        "cubeStack",
        "mCubeType",
        "returnedCubeValue",
        "cubeStack",
        "mCubeValue",
        "returnedAmount",
        "numberFound",
        "matchedItem",
        "mType",
        "ItemType",
        "ItemStack",
        "ItemStack",
        "ItemManager",
        "CloneItem",
        "matchedItem",
        "numberFound",
        "returnedItem",
        "itemStack",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "numberFound",
        "Debug",
        "LogError",
        "returnedItem",
        "matchedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "numberFound",
        "CountFreeSlots",
        "MarkDirtyDelayed",
        "LogisticsOperation",
        "RequestImmediateNetworkUpdate",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "StorageUserInterface",
        "sourceEntity",
        "cube",
        "value",
        "amount",
        "TryExtract",
        "eHopperRequestType",
        "eAny",
        "cube",
        "value",
        "amount",
        "amount",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "StorageUserInterface",
        "sourceEntity",
        "itemId",
        "amount",
        "ItemBase",
        "item",
        "TryExtract",
        "eHopperRequestType",
        "eAny",
        "itemId",
        "amount",
        "amount",
        "item",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "StorageUserInterface",
        "sourceEntity",
        "itemId",
        "cube",
        "value",
        "amount",
        "ItemBase",
        "item",
        "TryExtract",
        "eHopperRequestType",
        "eAny",
        "itemId",
        "cube",
        "value",
        "amount",
        "amount",
        "item",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "StorageUserInterface",
        "sourceEntity",
        "itemId",
        "cube",
        "value",
        "amount",
        "TryExtract",
        "eHopperRequestType",
        "eAny",
        "itemId",
        "cube",
        "value",
        "amount",
        "amount",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "StorageUserInterface",
        "sourceEntity",
        "itemId",
        "amount",
        "TryExtract",
        "eHopperRequestType",
        "eAny",
        "itemId",
        "amount",
        "amount",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "StorageUserInterface",
        "sourceEntity",
        "cube",
        "value",
        "amount",
        "TryExtract",
        "eHopperRequestType",
        "eAny",
        "cube",
        "value",
        "amount",
        "amount",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "returnedAmount",
        "StorageUserInterface",
        "sourceEntity",
        "itemId",
        "amount",
        "ItemBase",
        "item",
        "TryExtract",
        "eHopperRequestType",
        "eAny",
        "itemId",
        "amount",
        "amount",
        "item",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "returnedAmount",
        "StorageUserInterface",
        "sourceEntity",
        "itemId",
        "cube",
        "value",
        "amount",
        "ItemBase",
        "item",
        "TryExtract",
        "eHopperRequestType",
        "eAny",
        "itemId",
        "cube",
        "value",
        "amount",
        "amount",
        "item",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "returnedAmount",
        "StorageUserInterface",
        "sourceEntity",
        "itemId",
        "cube",
        "value",
        "amount",
        "TryExtract",
        "eHopperRequestType",
        "eAny",
        "itemId",
        "cube",
        "value",
        "amount",
        "amount",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "returnedAmount",
        "StorageUserInterface",
        "sourceEntity",
        "itemId",
        "amount",
        "TryExtract",
        "eHopperRequestType",
        "eAny",
        "itemId",
        "amount",
        "amount",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "returnedAmount",
        "StorageUserInterface",
        "sourceEntity",
        "amount",
        "ItemBase",
        "item",
        "TryExtract",
        "eHopperRequestType",
        "eAny",
        "amount",
        "amount",
        "item",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "InventoryInsertionOptions",
        "options",
        "InventoryInsertionResults",
        "results",
        "mnStorageFree",
        "options",
        "Item",
        "ItemManager",
        "GetCurrentStackSize",
        "options",
        "Item",
        "totalItemCount",
        "mnStorageFree",
        "options",
        "AllowPartialInsertion",
        "insertItemCount",
        "mnStorageFree",
        "item",
        "ItemManager",
        "CloneItem",
        "options",
        "Item",
        "insertItemCount",
        "item",
        "options",
        "Item",
        "AddItem",
        "item",
        "results",
        "results",
        "InventoryInsertionResults",
        "results",
        "AmountInserted",
        "insertItemCount",
        "results",
        "AmountRemaining",
        "totalItemCount",
        "insertItemCount",
        "options",
        "Amount",
        "AddCube",
        "options",
        "Cube",
        "options",
        "Value",
        "results",
        "results",
        "InventoryInsertionResults",
        "results",
        "AmountInserted",
        "options",
        "Amount",
        "mnStorageFree",
        "options",
        "AllowPartialInsertion",
        "options",
        "Amount",
        "remaining",
        "mnStorageFree",
        "AddCube",
        "options",
        "Cube",
        "options",
        "Value",
        "remaining",
        "results",
        "results",
        "InventoryInsertionResults",
        "results",
        "AmountInserted",
        "options",
        "Amount",
        "remaining",
        "results",
        "AmountRemaining",
        "remaining",
        "StorageUserInterface",
        "sourceEntity",
        "ItemBase",
        "item",
        "AddItem",
        "item",
        "StorageUserInterface",
        "sourceEntity",
        "cube",
        "value",
        "amount",
        "amount",
        "AddCube",
        "cube",
        "value",
        "mnStorageFree",
        "amount",
        "remaining",
        "mnStorageFree",
        "AddCube",
        "cube",
        "value",
        "remaining",
        "StorageUserInterface",
        "sourceEntity",
        "ItemBase",
        "item",
        "ItemManager",
        "GetCurrentStackSize",
        "item",
        "totalItemCount",
        "mnStorageFree",
        "insertItemCount",
        "mnStorageFree",
        "copyItem",
        "ItemManager",
        "CloneItem",
        "item",
        "insertItemCount",
        "copyItem",
        "item",
        "AddItem",
        "copyItem",
        "insertItemCount",
        "StorageUserInterface",
        "sourceEntity",
        "cube",
        "value",
        "amount",
        "remaining",
        "mnStorageFree",
        "AddCube",
        "cube",
        "value",
        "remaining",
        "amount",
        "remaining",
        "InventoryExtractionOptions",
        "options",
        "TryExtract",
        "options",
        "RequestType",
        "options",
        "ExemplarItemID",
        "options",
        "ExemplarBlockID",
        "options",
        "ExemplarBlockValue",
        "options",
        "InvertExemplar",
        "options",
        "MinimumAmount",
        "options",
        "MaximumAmount",
        "options",
        "KnownItemsOnly",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "returnedAmount",
        "itemId",
        "CountHowManyOfItem",
        "itemId",
        "itemId",
        "cube",
        "value",
        "itemId",
        "CountHowManyOfItem",
        "itemId",
        "CountHowManyOfType",
        "cube",
        "value",
        "cube",
        "value",
        "CountHowManyOfType",
        "cube",
        "value",
        "mnMaxStorage",
        "mnStorageUsed",
        "mnStorageFree",
        "mRetakeDebounce"
    ],
    "literals": [
        "\"Finished adding free coal!\"",
        "\"Warning, Hopper had null item added - oops?\"",
        "\"Error, attempting to add an ItemStack of ZERO to the SH?![\"",
        "\"]\"",
        "\"Error, SH got ore with no value?\"",
        "\"Storage hopper has overflowed! \"",
        "\"/\"",
        "\".\"",
        "\"Last Item was \"",
        "\"Storage hopper has overflowed! \"",
        "\"/\"",
        "\".\"",
        "\"Last Item was \"",
        "\"\\n\"",
        "\"Storage full\\n\"",
        "\"Storage Empty\\n\"",
        "\" free slots\\n\"",
        "\"Processing...\"",
        "\"[\"",
        "\"]\"",
        "\"Ore Extractor missing game object #0?\"",
        "\"Ore Extractor missing game object #0 (GO)?\"",
        "\"HooverGraphic\"",
        "\"Storage Hopper has missing light?\"",
        "\"HooverGraphic\"",
        "\"Storage Text\"",
        "\"Hopper\"",
        "\"Holo_Status\"",
        "\"Who and why is someone adding NULL to a Storage Hopper?\"",
        "\"Error, can't AddCube \"",
        "\" to hopper, it's full!\"",
        "\"Error, failed to convert item into ItemCubeStack\"",
        "\":\"",
        "\"Error, AddCube tried to get terrain data entry for\"",
        "\" but max was only \"",
        "\"ERROR Unknown cube[\"",
        "\"] added\"",
        "\"Attempted to add to Storage Hopper and failed miserably!\"",
        "\"Added \"",
        "\" to \"",
        "\"This is only for Ores and other things that we DO NOT CARE ABOUT THE VALUE OF\"",
        "\"Error stack was null in Contains Ore?\"",
        "\"mResearch was null in Contains Ore?\"",
        "\"Empty\"",
        "\"Error, (Cargo Lift?)attempted to store a null item!\"",
        "\"StoreItem is storing [\"",
        "\"] and has \"",
        "\" slots to mess around with!\"",
        "\"Stacked and stored \"",
        "\" items, but then failed to store the remaining \"",
        "\" in the storage hopper!\"",
        "\"Error, Store Item removed more than max!\"",
        "\"Empty\"",
        "\"Empty\"",
        "\"There's probably a good reason why RemoveSingleSpecificCubeStack is looking for a null Item\"",
        "\"There's probably a good reason why RemoveSingleSpecificItemByID is looking for ItemID -1\"",
        "\"Empty\"",
        "\"Attempted to remove item but hopper was empty - are you dumb?\"",
        "\"Empty\"",
        "\"Errror, RemoveInventoryItem does not support cubestacks\"",
        "\"Empty\"",
        "\"Dropping \"",
        "\". Count\"",
        "\"Non-stack matched item was not removed from the hopper inventory during extract?\""
    ],
    "variables": [
        "STORAGE_HOPPER",
        "CRYO_HOPPER",
        "MOTORISED_HOPPER",
        "SAFE_COLD_TEMP",
        "PowerPerItem",
        "maItemInventory",
        "maStorage",
        "mrMaxPower",
        "mrCurrentPower",
        "mrCurrentTemperature",
        "mnMaxStorage",
        "mnStorageUsed",
        "mnStorageFree",
        "mrNormalisedPower",
        "ExtractionX",
        "ExtractionY",
        "ExtractionZ",
        "mrExtractionTime",
        "mrPowerUsage",
        "mbLinkedToGO",
        "Light",
        "WorkLight",
        "TextMesh",
        "mTextMesh",
        "ParticleSystem",
        "mHooverPart",
        "GameObject",
        "mHopperPart",
        "GameObject",
        "mHoloStatus",
        "mLastItemAdded",
        "mrReadoutTick",
        "mnLowFrequencyUpdates",
        "mnReadouts",
        "eHopperPermissions",
        "mPermissions",
        "mbHooverOn",
        "mbAllowLogistics",
        "mrLogisticsDebounce",
        "mrTimeSinceLogistics",
        "mRemoveCache",
        "GameObject",
        "TutorialEffect",
        "i",
        "ItemBase",
        "existingItem",
        "i",
        "lnOldStorage",
        "mnStorageFree",
        "i",
        "ItemBase",
        "item",
        "mbForceTextUpdate",
        "mbForceHoloUpdate",
        "CheckSegments",
        "mrSleep",
        "mrTimeUntilPlayerDistanceUpdate",
        "checkX",
        "checkY",
        "checkZ",
        "lnWhich",
        "lCube",
        "SPOILED_ORGANICS",
        "mrSpoilTimer",
        "lbSpoil",
        "i",
        "ItemBase",
        "lSpoiledItem",
        "mrPPS",
        "lbInColdCavern",
        "lrExternalTemp",
        "lrDiff",
        "lrDesiredTemp",
        "lrPowerNeeded",
        "lrDiff",
        "lrPowerDiff",
        "mnHopperLoops",
        "StorageMachineInterface",
        "lHopper",
        "i",
        "eHopperPermissions",
        "permissions",
        "lType",
        "lValue",
        "targetEntity",
        "targetEntity",
        "GeothermalGenerator",
        "lGT",
        "HooverSegment",
        "x",
        "y",
        "z",
        "lookupX",
        "lookupY",
        "lookupZ",
        "Segment",
        "segment",
        "DroppedItemData",
        "droppedItem",
        "mnUpdates",
        "mrTimeUntilFlash",
        "mrTimeElapsed",
        "mnHooverEmissionRate",
        "mbShowHopper",
        "mrPrevDistanceToPlayer",
        "lbShowHopper",
        "lbAllowHoover",
        "mrMaxLightDistance",
        "lbLightShouldBeEnabled",
        "eHopperPermissions",
        "mPreviousPermissions",
        "MaterialPropertyBlock",
        "mHoloMPB",
        "lText",
        "mbTutorialComplete",
        "mbHooverEmissionOff",
        "firstEmpty",
        "mnMaxStorage",
        "i",
        "ItemBase",
        "item",
        "ItemCubeStack",
        "stack",
        "x",
        "y",
        "i",
        "ItemBase",
        "item",
        "lnNumFound",
        "i",
        "ItemCubeStack",
        "stack",
        "lnNumFound",
        "i",
        "ItemCubeStack",
        "stack",
        "lnNumFound",
        "i",
        "ItemBase",
        "item",
        "ItemStack",
        "stack",
        "lnNumFound",
        "i",
        "ItemCubeStack",
        "lStack",
        "validRecipe",
        "lnNumStored",
        "i",
        "ItemCubeStack",
        "lInvStack",
        "amountToRemove",
        "amount",
        "i",
        "ItemBase",
        "item",
        "ItemCubeStack",
        "stack",
        "count",
        "itemsToStore",
        "itemsLeft",
        "itemsToStore",
        "i",
        "ItemBase",
        "existingItem",
        "stackAmount",
        "i",
        "lnMax",
        "ItemBase",
        "lItem",
        "stackAmount",
        "mnRoundRobinOffset",
        "l",
        "i",
        "mnRoundRobinOffset",
        "ItemCubeStack",
        "lStack",
        "TerrainDataEntry",
        "entry",
        "i",
        "ItemCubeStack",
        "lStack",
        "TerrainDataEntry",
        "entry",
        "i",
        "ItemCubeStack",
        "lStack",
        "lbFound",
        "ItemBase",
        "lRet",
        "i",
        "ItemBase",
        "lRet",
        "ItemBase",
        "lRet",
        "ItemBase",
        "lRet",
        "l",
        "i",
        "mnRoundRobinOffset",
        "lnID",
        "lbIsBar",
        "ItemEntry",
        "entry",
        "ItemBase",
        "lRet",
        "i",
        "ItemBase",
        "lRet",
        "i",
        "ItemBase",
        "lRet",
        "ItemBase",
        "item",
        "ItemCubeStack",
        "lInvStack",
        "ItemStack",
        "lStack",
        "i",
        "ItemBase",
        "lRet",
        "i",
        "ItemBase",
        "lRet",
        "amountRemoved",
        "i",
        "ItemBase",
        "item",
        "ItemStack",
        "stack",
        "amountLeft",
        "amountToExtract",
        "i",
        "ItemBase",
        "item",
        "count",
        "ItemBase",
        "newItem",
        "i",
        "lnDummy",
        "i",
        "legacyStorageList",
        "i",
        "cubeType",
        "eHopperPermissions",
        "lPermissions",
        "mPermissions",
        "FloatingCombatTextQueue",
        "lFQ",
        "lastItemIndex",
        "i",
        "ItemBase",
        "item",
        "cubeType",
        "amount",
        "ItemBase",
        "cubeStack",
        "FloatingCombatTextQueue",
        "lFQ",
        "lRand",
        "i",
        "Vector3",
        "lVec",
        "creationParameters",
        "InventoryExtractionPermitted",
        "ItemBase",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "numberFound",
        "numberRemaining",
        "maximumAmount",
        "matchedItemRemoved",
        "ItemBase",
        "matchedItem",
        "itemsToRemove",
        "l",
        "i",
        "mnRoundRobinOffset",
        "ItemBase",
        "currentItem",
        "ItemCubeStack",
        "cubeStack",
        "matchedRequest",
        "lnID",
        "lbIsBar",
        "ItemEntry",
        "entry",
        "ItemCubeStack",
        "lStack",
        "TerrainDataEntry",
        "entry",
        "ItemCubeStack",
        "matchedCubeStack",
        "ItemCubeStack",
        "currentCubeStack",
        "stackSize",
        "stackSize",
        "j",
        "ItemCubeStack",
        "cubeStack",
        "ItemStack",
        "itemStack",
        "ItemCubeStack",
        "cubeStack",
        "ItemStack",
        "itemStack",
        "ItemStack",
        "itemStack",
        "ItemBase",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "ItemBase",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "ItemBase",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "ItemBase",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "success",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "ItemBase",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "ItemBase",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "totalItemCount",
        "insertItemCount",
        "totalItemCount",
        "ItemBase",
        "item",
        "remaining",
        "remaining",
        "amount",
        "totalItemCount",
        "insertItemCount",
        "totalItemCount",
        "ItemBase",
        "copyItem",
        "remaining",
        "amount",
        "ItemBase",
        "returnedItem",
        "returnedCubeType",
        "returnedCubeValue",
        "returnedAmount",
        "TotalCapacity",
        "UsedCapacity",
        "RemainingCapacity",
        "mRetakeDebounce"
    ],
    "comments": [
        "LogisticsHoppers should have no vacuum, no filter orders (maybe?) and only super super slow attaching to conveyors",
        "Do not current require power",
        "private bool stringDirty;",
        "yeah, so absolute zero innit",
        "theoretical max of 150/face, which is 750/min per face.",
        "only items now, no more cube ducttape.",
        "outdated - do not use!",
        "this is a lot, more than the suit can carry in one go!",
        "start smaller and upgrade?",
        "needs to be calculated",
        "seconds/ore",
        "power/sec",
        "public GameObject MiningSparks;",
        "This flickers high/low for low tiers",
        "maStorage = new ushort[mnMaxStorage];",
        "for (int i=0;i<mnMaxStorage;i++)",
        "{",
        "maStorage[i] = eCubeTypes.NULL;",
        "}",
        "Hoppers will hold 100 items in total, which is 100 differnt items, or 100 of a single item.",
        "So we need to store the worst fucking case .",
        "",
        "Fast!",
        "dunno",
        "CH",
        "This should allow 1 CH and a 50:1 of pristine -> organics",
        "Fast!",
        "ouch!",
        "LH",
        "Logistics Hopper is fast, but has no storage",
        "MH",
        "Microhopper",
        "raised from 10; you can easily get 4 of these around a single OE and mitigate having proper SHs for ages and ages.",
        "I haven't really got a good way to do this...",
        "WRONG VALUE.",
        "object based on value for tiers",
        "Debug.Log(\"LPT spawning with Value of \" + mValue);",
        "Old LH becomes new MH (ELSE SHIT ON DISK IS FUCKED AS THE STORAGE IS TOO SMALL)",
        "mHoloMPB = null;",
        "It's valid to ignore this if it's a conveyor",
        "if (mPermissions == ePermissions.RemoveOnly) Debug.LogWarning(\"Warning, about to add \" + ItemManager.GetItemName(lItemToAdd.mnItemID) +\" to a Remove Only hopper!\");",
        "if (mPermissions == ePermissions.Locked) \tDebug.LogWarning(\"Warning, about to add \" + ItemManager.GetItemName(lItemToAdd.mnItemID) +\" to a Locked hopper!\");",
        "This should really never happen (it happens only as a network client, it seems)",
        "can always fit nothing, lal",
        "this shouldn't be necessary, but okay.",
        "Do we attempt to collapse stacks at this point? yes, saves processing power when checking inventories, which happens a lot!",
        "this also covers cube stacks :)",
        "couldn't collapse, add to new spot",
        "Debug.Log(\"Failed to add item to Storage Hopper!\");",
        "Are hoppers limited to 100? If so, we need to also do this",
        "Ore Extractors have been putting more than they should into a hopper, making the stack size > max!",
        "If have no machines attached to us, we can sleep for a second or so",
        "This makes a shockingly small amount of difference!",
        "1 second at 30 metres, .5 at 15 metres (halved from before)",
        "Keep the client sim in step",
        "this is done by the server",
        "mrCurrentPower += mrIsotopeRate * GameManager.mrPreviousUpdateTimeStep;\n\t\tmrCurrentPower += mrSolarEfficiency * GameManager.mrPreviousUpdateTimeStep * Mathf.Abs(SurvivalWeatherManager.mrSunAngle);\n\t\tif(mrCurrentPower > mrMaxPower) mrCurrentPower = mrMaxPower;",
        "Debug.Log(mrReadoutTick+\"::\" + GameManager.mrPreviousUpdateTimeStep.ToString(\"F2\"));",
        "In museum mode, we continually empty out slots, just in case;this is hooked up to the 1 second readout tick",
        "Which is actually the tick where we look for places to hand out stuff.",
        "public ItemBase[] maItemInventory;",
        "this allows it to fill up first",
        "UnityEngine.Debug.Log(\"SH checking on update \"+ mnReadouts + \" with \" + mnStorageUsed + \" storage used\");",
        "See if anything adjacent wants some of our resources",
        "if (mnStorageUsed > 0)//removed as we both give and take resources",
        "don't bother, it's not a machine entity",
        "machines that give us resources",
        "machines that take our resources",
        "if  (mnReadouts % mnHopperLoops == 0)",
        "both directions",
        "Look for adjacent places to transfer storage",
        "Maybe only do this if we have power? Maybe.",
        "The ONLY way items do not spoil is if it's a Cryo and temperature is below the SAFE temp",
        "Look for an item to spoil.",
        "hurray! Well, boo.",
        "Nothing spoiled!",
        "convert any odd numbered item from 4000 upwards to 4010",
        "This means it's ruined - these can spoil!",
        "chilled items convert to ruined",
        "todo, also worry about heater hoppers",
        "this is now only a bit different from the cold internal temp",
        "above the SAFE_COLD_TEMP, but not a long way. Cuz 50 degrees isn't a long way.",
        "Lerp towards external temperature",
        "Now lerp towards desired temperature",
        "ouch",
        "we don't care what direction we're changing the temperature, it never requires negative power",
        "Negative temperature change",
        "Cold cavern gives a bit cheaty +50% power efficiency to CryoHoppers",
        "smooth it",
        "This now loops mnHopperLoops times; the FetchEntity is likely to be the expensive part here",
        "we are ADD, don't give our shit away",
        "ofc",
        "no point in attempting to start",
        "hoppers are a special case",
        "TODO - obey our and linked hopper's permissions! --- probably not. <-why probably not?",
        "we have at least 2 items",
        "only push things into the adjacent hopper if it's allowing it",
        "they have 1 spot",
        "We have at least 2 more than them",
        "TODO: rewrite this to move items as well as cubes!",
        "get and remove <-why is this not the round robin version?",
        "TODO: Cope with failure",
        "give them a cube.",
        "try again rapidly until we don't need to transfer",
        "mnReadouts--;",
        "ensure we check the SAME direction again",
        "No point calling any suppliers if we have no space left anyway.",
        "if (lCube == eCubeTypes.OreExtractor)",
        "{",
        "//\tDebug.Log(\"SH looking at OE with \" + mnStorageFree + \" free storage\");",
        "if (mnStorageFree > 0)",
        "{",
        "OreExtractor lExtractor = checkSegment.FetchEntity(eSegmentEntity.OreExtractor,checkX,checkY,checkZ) as OreExtractor;",
        "if (lExtractor != null)",
        "if (lExtractor.mnStoredOre >0)",
        "{",
        "int lnCount = lExtractor.mnStoredOre / 4;",
        "if (lnCount <1) lnCount = 1;",
        "if (lnCount > mnStorageFree) lnCount = mnStorageFree;//dont' attempt to remove more than we can fit!",
        "//remove 1 ore into the storage hopper",
        "//lExtractor.mnStoredOre-=lnCount;",
        "for (int i=0;i<lnCount;i++)",
        "{",
        "AddCube(lExtractor.mnOreType, TerrainData.GetDefaultValue(lExtractor.mnOreType));",
        "lExtractor.mnStoredOre--;",
        "if (mnStorageFree == 0) break;",
        "}",
        "mrReadoutTick = 0.0f;//try again rapidly until we don't need to transfer",
        "mnReadouts--;//ensure we check the SAME direction again",
        "}",
        "}",
        "}",
        "",
        "if (lCube == eCubeTypes.RefineryController)",
        "{",
        "//\tDebug.Log(\"SH looking at OE with \" + mnStorageFree + \" free storage\");",
        "if (mnStorageFree > 0)",
        "{",
        "RefineryController controller = checkSegment.FetchEntity(eSegmentEntity.RefineryController,checkX,checkY,checkZ) as RefineryController;",
        "if (controller != null)",
        "{",
        "if (controller.mOutputHopper != null)",
        "{",
        "int count = ItemManager.GetCurrentStackSize(controller.mOutputHopper);",
        "",
        "ItemBase item;",
        "if (count > mnStorageFree)",
        "{",
        "item = controller.GetPartialInventory(mnStorageFree);",
        "}",
        "else",
        "{",
        "item = controller.GetWholeInventory();",
        "}",
        "",
        "AddItem(item);",
        "",
        "// don't reset readout stuff, we're done already",
        "}",
        "}",
        "}",
        "}",
        "really? Manufacuturing plants don't push, we pull?!",
        "if (lCube == eCubeTypes.ManufacturingPlant)",
        "{",
        "if (mnStorageFree > 0)",
        "{",
        "ManufacturingPlant plant = checkSegment.FetchEntity(eSegmentEntity.ManufacturingPlant, checkX, checkY, checkZ) as ManufacturingPlant;",
        "",
        "if (plant != null)",
        "{",
        "GetManufacturingPlantOutput(plant);",
        "}",
        "}",
        "}",
        "",
        "if (lCube == eCubeTypes.ManufacturingPlantModule)",
        "{",
        "if (mnStorageFree > 0)",
        "{",
        "ManufacturingPlantModule module = checkSegment.FetchEntity(eSegmentEntity.ManufacturingPlantModule, checkX, checkY, checkZ) as ManufacturingPlantModule;",
        "",
        "if (module != null && module.mPlant != null)",
        "{",
        "GetManufacturingPlantOutput(module.mPlant);",
        "}",
        "}",
        "}",
        "if  (lCube == eCubeTypes.T4_Grinder)",
        "{",
        "T4_Grinder lGrinder = checkSegment.FetchEntity(eSegmentEntity.T4_Grinder,checkX,checkY,checkZ) as T4_Grinder;",
        "if (lGrinder != null)//unlikely!",
        "{",
        "if (lGrinder.mLinkedCenter != null) lGrinder = lGrinder.mLinkedCenter;",
        "",
        "lGrinder.CheckHopper(this);",
        "}",
        "}",
        "if  (lCube == eCubeTypes.T4_GasBottler)",
        "{",
        "T4_GasBottler lGB = checkSegment.FetchEntity(eSegmentEntity.T4_GasBottler,checkX,checkY,checkZ) as T4_GasBottler;",
        "if (lGB != null)//unlikely!",
        "{",
        "if (lGB.mLinkedCenter != null) lGB = lGB.mLinkedCenter;",
        "",
        "lGB.CheckHopper(this);",
        "}",
        "}",
        "//Althought I don't like this, it avoids just having a massive local list of things for the MB machine to check.\n        if  (lCube == eCubeTypes.T4_ParticleFilter)\n        {\n            T4_ParticleFilter lFilter = checkSegment.FetchEntity(eSegmentEntity.T4_ParticleFilter,checkX,checkY,checkZ) as T4_ParticleFilter;\n            if (lFilter != null)//unlikely!\n            {\n                if (lFilter.mLinkedCenter != null) lFilter = lFilter.mLinkedCenter;\n\n                lFilter.CheckHopper(this);\n            }\n        }",
        "void GetManufacturingPlantOutput(ManufacturingPlant plant)",
        "{",
        "if (plant.mOutputHopper != null)",
        "{",
        "int count = ItemManager.GetCurrentStackSize(plant.mOutputHopper);",
        "",
        "ItemBase item;",
        "if (count > mnStorageFree)",
        "{",
        "item = plant.GetPartialInventory(mnStorageFree);",
        "}",
        "else",
        "{",
        "item = plant.GetWholeInventory();",
        "}",
        "RequestImmediateNetworkUpdate();",
        "plant.RequestImmediateNetworkUpdate();",
        "AddItem(item);",
        "}",
        "}",
        "TODO: move this to the entities in question?",
        "if (lCube == eCubeTypes.CentralPowerHub)",
        "{",
        "if (WorldScript.mbIsServer)//DO NOT DO THIS FOR CLIENTS!",
        "{",
        "CentralPowerHub lHub = checkSegment.FetchEntity(eSegmentEntity.CentralPowerHub,checkX,checkY,checkZ) as CentralPowerHub;",
        "if (lHub != null)//unlikely!",
        "{",
        "//if (lHub.mrTimeLeftToConsumeMaterial <= 0.0f && lHub.mrNormalisedPower < 0.75f)",
        "if (lHub.WantsToConsumeResources())",
        "{",
        "//yay",
        "",
        "for (int i=0;i<mnMaxStorage;i++)",
        "{",
        "if (maStorage[i] != eCubeTypes.NULL)",
        "{",
        "if (CubeHelper.IsSmeltableOre(maStorage[i])) continue;//do not burn ore!",
        "",
        "if (!WorldScript.mLocalPlayer.mResearch.IsKnown(maStorage[i], 0)) //do not burn unknown materials",
        "continue;",
        "",
        "lHub.AddResourceToConsume(maStorage[i]);",
        "maStorage[i] = eCubeTypes.NULL;",
        "CountFreeSlots();",
        "MarkDirtyDelayed();",
        "return;",
        "}",
        "}",
        "",
        "for (int i=0;i<mnMaxStorage;i++)",
        "{",
        "if (maItemInventory [i] == null) continue;",
        "if (maItemInventory[i].mType != ItemType.ItemCubeStack) continue;",
        "",
        "if ((maItemInventory[i] as ItemCubeStack).mnAmount <=0) continue;//should have been nulled",
        "",
        "ushort lType = (maItemInventory[i] as ItemCubeStack).mCubeType;",
        "if (CubeHelper.IsSmeltableOre(lType)) continue;",
        "if (CubeHelper.IsHighCalorie(lType) == false) continue;",
        "",
        "lHub.AddResourceToConsume(lType);",
        "(maItemInventory[i] as ItemCubeStack).mnAmount--;",
        "if ((maItemInventory[i] as ItemCubeStack).mnAmount <=0) maItemInventory[i] = null;",
        "CountFreeSlots();",
        "MarkDirtyDelayed();",
        "return;",
        "}",
        "}",
        "}",
        "}",
        "}",
        "",
        "if (lCube == eCubeTypes.PyrothermicGenerator)",
        "{",
        "if (WorldScript.mbIsServer)//DO NOT DO THIS FOR CLIENTS!",
        "{",
        "PyrothermicGenerator lPTG = checkSegment.FetchEntity(eSegmentEntity.PyrothermicGenerator,checkX,checkY,checkZ) as PyrothermicGenerator;",
        "if (lPTG != null)",
        "{",
        "if (lPTG.mbReadyForResource)",
        "{",
        "for (int i=0;i<mnMaxStorage;i++)",
        "{",
        "if (maStorage[i] == eCubeTypes.NULL) continue;",
        "if (CubeHelper.IsSmeltableOre(maStorage[i])) continue;",
        "if (CubeHelper.IsHighCalorie(maStorage[i]) == false) continue;",
        "//todo, do not burn things that aren't consumables for priority",
        "//todo, do not burn ore, ever! (except coal)",
        "if (maStorage[i] != eCubeTypes.NULL)",
        "{",
        "lPTG.AddResourceToConsume(maStorage[i]);",
        "maStorage[i] = eCubeTypes.NULL;",
        "CountFreeSlots();",
        "MarkDirtyDelayed();",
        "return;",
        "}",
        "}",
        "for (int i=0;i<mnMaxStorage;i++)",
        "{",
        "if (maItemInventory [i] == null) continue;",
        "if (maItemInventory[i].mType != ItemType.ItemCubeStack) continue;",
        "",
        "if ((maItemInventory[i] as ItemCubeStack).mnAmount <=0) continue;//should have been nulled",
        "",
        "ushort lType = (maItemInventory[i] as ItemCubeStack).mCubeType;",
        "if (CubeHelper.IsSmeltableOre(lType)) continue;",
        "if (CubeHelper.IsHighCalorie(lType) == false) continue;",
        "",
        "lPTG.AddResourceToConsume(lType);",
        "(maItemInventory[i] as ItemCubeStack).mnAmount--;",
        "if ((maItemInventory[i] as ItemCubeStack).mnAmount <=0) maItemInventory[i] = null;",
        "CountFreeSlots();",
        "MarkDirtyDelayed();",
        "return;",
        "}",
        "}",
        "}",
        "}",
        "}",
        "This is *LOT* faster than the base round-robin-ing all of it's consumers",
        "I like this paradigm, it saves wasiting round-robin time in a larger multiblock, but it means that this class is growing - does c# support Partial classes across multiple files?",
        "Yes : http://answers.unity3d.com/questions/8009/does-unity-c-support-partial-classes.html",
        "if  (lCube == eCubeTypes.SpiderBotBase)",
        "{",
        "SpiderBotBase lBase = checkSegment.FetchEntity(eSegmentEntity.SpiderBotBase,checkX,checkY,checkZ) as SpiderBotBase;",
        "if (lBase != null)//unlikely!",
        "{",
        "if (lBase.mLinkedCenter != null) lBase = lBase.mLinkedCenter;",
        "",
        "lBase.CheckHopper(this);",
        "}",
        "}",
        "unlikely!",
        "this is done by the server",
        "if(mbHooverOn)\n\t\t{\n\t\t\tToggleHoover();\n\t\t\treturn;\n\t\t}",
        "else don't even bother allocating it, 99.9% of hoppers are never used",
        "if we have storage and are not locked, suck in items",
        "Attempt to hoover up items. This is more complex as they tend to be stacked",
        "As this was a bit expensive, an alternative version where we supply the frustrum is useful",
        "come back next frame, when this should be available",
        "DroppedItemData droppedItem = ItemManager.instance.UpdateCollection(mnX, mnY + 1, mnZ, new Vector3(0.5f, 0, 0.5f), 4, 1.0f, 2.0f,mnStorageFree);",
        "This call should also remove the item from the segment",
        "we may need to split the object apart now?",
        "Object did not fit...uh - bad code caused by collection removing items even if it fails to fit!",
        "This should do nothing if the segment isn't visible, else we're updating text and stuff when behind the player",
        "~1.5ms for 400 hoppers",
        "15ms for 1800 hopper",
        "Smartly do this work only when the vis has changed",
        "Ensure the vis is correct for this",
        "hopefully this overrides the LOD stuff - I wish everything used LODs and culled at the same point :/",
        "But if we did that, it's every frame on the main thread and fuck unity in it's stupid face",
        "disable text at unreadable distances",
        "mHooverPart.gameObject.SetActive(false);",
        "mHooverPart.gameObject.SetActive(true);",
        "Ho hum, too many lights; 12ms+ on i7 to cull...",
        "very slow lerp based on framerate",
        "I wonder if this could be a very smoothed number that follows the framerate...?",
        "fade up, don't just appear.(this is the minimum not to get immediately turned off)",
        "blue/red to quickly show temperature. Could also lerp, but nah.",
        "Not a Cryo hopper, simply show full/empty as green/red",
        "1 second to smoothly lerp? Maybe?",
        "1 second to smoothly lerp? Maybe?",
        "this should probably actually be lbLightShouldBeEnabled = false",
        "1 second to smoothly lerp? Maybe?",
        "That's ok, you're working nicely, don't need to indicate",
        "this is automatically reduced to 95% a bit below here, so it's technically oscillating a bit",
        "Do not disable light directly; light will fade rapidly and disable itself (Light does not need to be disabled, for whatever reason)",
        "maybe as much as .2? (turning this off sooner gives performance back sooner)",
        "Does its own Vis",
        "Almost an MS of frametime in here - have a serious think about a better way of doing this",
        "I HAD A SERIOUS THINK NOT REALLY BUT I CAME UP WITH A BETTER IDEA",
        "I fail",
        "only do this if the permissions have changed",
        "cache this if necessary",
        "only update if the text is being disabled",
        "we can see text up to 24m right now, but there's little point, it's not readable",
        "",
        "WorkLight = mWrapper.mGameObjectList[0].gameObject.GetComponentInChildren<Light>();",
        "if (QualitySettings.GetQualityLevel() >=3) WorkLight.shadows = LightShadows.Hard;//Object casts shadows and we're inside the object. Sad times.",
        "mHooverPart= mWrapper.mGameObjectList[0].gameObject.GetComponentInChildren<ParticleSystem>();",
        "this is like HUNDREDS of times faster than the below call..",
        ".GetComponentInChildren<TextMesh>();s",
        "force an update",
        "mHoloMPB = new MaterialPropertyBlock();",
        "the two equality checks below were upto 0.73ms/frame on a big world.",
        "add/remove tutorial",
        "When we straddle the 8m distance at which we render the holothing, then force an update",
        "if (mnUpdates % 60 == 0)",
        "|| mnUpdates % 30 == 0)//just because there's no good boundary/threshold we cross to check this (other than storing player distance last and this frame and comparing)",
        "bah",
        "if (mPermissions == ePermissions.Locked) mTextMesh.color  = Color.red;\n\t\tif (mPermissions == ePermissions.AddOnly) mTextMesh.color  = Color.blue;\n\t\tif (mPermissions == ePermissions.RemoveOnly) mTextMesh.color  = Color.cyan;\n\t\tif (mPermissions == ePermissions.AddAndRemove) mTextMesh.color  = Color.green;",
        "mHooverPart.emissionRate is using up 0.06ms on mainthread... fuck's sake guys",
        "we have a free slot to add into!",
        "TerrainData.mEntries[lType].Name;",
        "TerrainDataEntry lEntry = TerrainData.mEntries[lType];\n\t\t\t\t\t\t\tif (lEntry == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmLastItemAdded = \"ERROR Unknown cube[\" + lType + \"] added\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmLastItemAdded = lEntry.Name;\n\t\t\t\t\t\t\t}",
        "we had storage free, but no item was added??",
        "This will actually help out with disk space too",
        "Warning - untested!",
        "heh",
        "Rewrite to use item inventory and actually check value!",
        "Now abstracts Cubes and CubeStacks together",
        "Pass in ushort.MaxValue as the Value to get any value of this type back",
        "Rewrite to use item inventory and actually check value!",
        "any Value is valid!",
        "look for some ore; if we find some, count it up; allow querying of type",
        "If Type is is Null, then return the Ore we have the most of",
        "This only returns Ore that can be converted into Ingots.",
        "Just return how many of this we have",
        "if lSearchType is null, then look for any ore",
        "now search again, but take into account ItemCubeStacks",
        "The issue is that CountHowManyOfType abstracts items and cubes.",
        "So we need to only take account thigns that did not exist as cubes.",
        "what even?",
        "If we already deemed this the best type, then skip it; we've already counted it up",
        "Also check we have a recipe for this ore.",
        "Ignore unknown ore.",
        "CountHowManyOfType(lStack.mCubeType,TerrainData.GetDefaultValue(lStack.mCubeType));",
        "DEPRECATED DO NOT USE. DON'T USE ADAM. This is called by GetSpecificCube still, which MMs use - Dj",
        "Now check for CubeStacks of this type, and decrement",
        "returns how many were actually removed",
        "returns how many of item were actually stored",
        "this will ONLY attempt to stack partial items, and will not put anything into empty slots.",
        "This means that there was potentially a free slot, but the stack size left was too big?",
        "So we'll attempt to fill up a new slot",
        "BIG NUMBER",
        "The amount we have left",
        "The amount we could actually store",
        "at this point, we have a new item of count 0",
        "todo, return Value too",
        "This ensures (or at least massively improves) the return of items",
        "this is an item",
        "Unsure if we have any organic blocks yet?",
        "Didn't find anything. For shame.",
        "this is an item",
        "Now remove any itemcubes",
        "early out",
        "a different type, value isn't relevant",
        "a different value, type isn't relevant",
        "early out",
        "if (lType == eRequestType.eAnyCraftedItem)\treturn null;//This... should be ok? (or has martijns cube change fucked it?)",
        "we do this even if the mnStorageUsed is 0?",
        "we have no handy way of sub-dividing items into classes or tags",
        "For the moment, just search for the most obvious things",
        "Ruined/Pristine parts",
        "we could do an entire check here, but for NOW, just return 'any item', on the basis it was PROBABLY crafted",
        "Decomposible cubes types have already been handled in a previous call to GetSpecificCubeRoundRobin (yes this is all really horrible)",
        "if (lType == eRequestType.eAnyCraftedItem)\treturn null;//This... should be ok? (or has martijns cube change fucked it?)",
        "we do this even if the mnStorageUsed is 0?",
        "we have no handy way of sub-dividing items into classes or tags",
        "For the moment, just search for the most obvious things",
        "This does NOT return Cubes.",
        "if (lType == eRequestType.eAnyCraftedItem)\treturn null;//This... should be ok? (or has martijns cube change fucked it?)",
        "we do this even if the mnStorageUsed is 0?",
        "Essentially we want ItemSingle and ItemStack - NOT cubes",
        "we have no handy way of sub-dividing items into classes or tags",
        "For the moment, just search for the most obvious things",
        "remove item or decrement item stack then return it",
        "item stack was empty, for whatever reason. Should have been nulled.",
        "this seems a little odd, and probably isn't correct",
        "Debug.LogWarning(\"SH decrementing item stack from \" + (maItemInventory[i] as ItemStack).mnAmount);",
        "Debug.LogWarning(\"SH returning final part of itemstack\");",
        "Debug.LogWarning(\"SH returning 1 stack\");",
        "there's only 1 in the stack, return it",
        "Debug.LogWarning(\"SH returning non-itemstack\");",
        "this didn't convert to an item stack (I think);",
        "Debug.LogWarning(\"Warning, Storage Hopper was asked to decrement stack and return but did NOT return\");",
        "return null;",
        "Slightly hacky, this returns an entire stack :-)",
        "If this is a server, and a client just removed, immediately push out the change to all client IMMEDIATELY RIGHT NOW",
        "Debug.LogWarning(\"SH decremented stack to \" + (maItemInventory[i] as ItemStack).mnAmount);",
        "Debug.LogWarning(\"SH decremented itemcube stack to \" + (maItemInventory[i] as ItemCubeStack).mnAmount);",
        "DOES NOT SUPPORT CUBESTACKS",
        "non stacking item",
        "convenience function for unloading to cargo lifts",
        "dump our cargo into the given list, until the amount is met",
        "crop old item",
        "create new item",
        "we're done",
        "add entire item",
        "eventually, the upgrade will cap out at something lower than this",
        "TODO: Update entity version and remove.",
        "partial dummy",
        "partial dummy",
        "partial dummy",
        "Debug.LogWarning(\"SH LOADING WITH mnMaxStorage OF \"+ mnMaxStorage);",
        "I'm not too worried about garbage from this, the chances of any worlds still having any is remote.",
        "Move into the item inventory.",
        "if (maStorage[i] != eCubeTypes.NULL)",
        "lastCubeIndex = i;",
        "Store current permissions",
        "Read new permissions",
        "If the permissions have changed on this network read, display a thing!",
        "Permissions have changed; player is pretty close",
        "Cyan as opposed to green, to show that it's a remote command",
        "partial dummy",
        "partial dummy",
        "partial dummy",
        "dummy (mnMaxStorage stored)",
        "To address endDroppedItemCreationData",
        "dummy",
        "dummy",
        "dummy",
        "Support conversion from really old worlds.",
        "foreach because dictionary, no I don't care, this is probably never going to get called.",
        "Assume we came off the network, and things are different",
        "use defaults for WriteNetworkUpdate and ReadNetworkUpdate",
        "temp",
        "DROP ITEMS too, fool!",
        "protect against other threads using this item",
        "Called when the holobase has been opened and it requires this entity to add its",
        "visualisations. If there is no visualisation for an entity return null.",
        "",
        "To receive updates each frame set the <see cref=\"HoloMachineEntity.RequiresUpdates\"/> flag.",
        "</summary>",
        "<returns>The holobase entity visualisation.</returns>",
        "<param name=\"holobase\">Holobase.</param>",
        "Called when this entity has added a holobase machine entity with the RequiresUpdates flag",
        "</summary>",
        "<param name=\"holobase\">Holobase.</param>",
        "<param name=\"holoMachineEntity\">Holo machine entity.</param>",
        "lMachine.mVisualisationObject.renderer.material.color = Color.red;",
        "lMachine.mVisualisationObject.renderer.material.color = Color.green;",
        "Attempts to deliver the specified item or cube from the source entity to the consumer",
        "of this interface. If the delivery is successful <c>true</c> will be returned.",
        "</summary>",
        "<returns><c>true</c>, if delivery of item was successful, <c>false</c> otherwise.</returns>",
        "<param name=\"sourceEntity\">Source entity.</param>",
        "<param name=\"item\">Item.</param>",
        "<param name=\"cubeType\">Cube type.</param>",
        "<param name=\"cubeValue\">Cube value.</param>",
        "<param name=\"sendImmediateNetworkUpdate\">Sends an immediate network update.</param>",
        "Failed to extract anything",
        "If request type is none, and no exemplar supplied, then return nothing.",
        "Now begin searching though the inventory looking for something which matches the filters provided.",
        "This offset ensures that each new requests at where the previous one finished, ensuring a more even return of items.",
        "Grab the item from this inventory slot.",
        "No item in this slot.",
        "If an exemplar item id has been supplied check against it now.",
        "Look for a specific item",
        "Found the item we want!",
        "Actually, just found the item we DON'T want.",
        "Is this not the item we want, unless we have inverted the examplar.",
        "Look for a specific cube",
        "Found the cube we want!",
        "Actually, just the found cube we DON'T want.",
        "This not the cube we want, unless we have inverted the examplar.",
        "This not the cube we want, unless we have inverted the examplar.",
        "Now check against the filters.",
        "We are looking to limit to specific item types",
        "Ruined/Pristine parts",
        "TODO: Add an IsOrganic tag to the terrain",
        "we could do an entire check here, but for NOW, just return 'any item', on the basis it was PROBABLY crafted",
        "Decomposible cubes types have already been handled in a previous call to GetSpecificCubeRoundRobin (yes this is all really horrible)",
        "And the rest.",
        "if (lType == eHopperRequestType.eOrganic) continue;//Unsure if we have any organic blocks yet?",
        "We failed to match this filter, move onwards.",
        "Check research",
        "This item is not known to the player.",
        "If we get to here then this is an item that we want. Yay.",
        "If we are only looking for a count then add up the stack size.",
        "Take out the items required.",
        "We have found our first matching item! Set it here so that we can make sure anything else we get out is the same.",
        "This is not the first matching item we have found.",
        "If we are being asked to return the items then everything we take out must be the same type.",
        "Different type of item, we cannot get more of this type.",
        "Different cube type.",
        "If this is supplied then we don't give a crap what the value is.",
        "Different cube value.",
        "Not the same item",
        "We are not being asked to return the items, there is no need for everything to be the same type.",
        "Remove this item.",
        "Remove this entire stack.",
        "This is a problem. This stack does not meet the minimum requirement for anything",
        "to be extracted. We can't remove it from storage right now because we cannot be",
        "sure we'll find enough other items.",
        "Remove part of this stack.",
        "Remove this entire stack.",
        "This is a problem. This stack does not meet the minimum requirement for anything",
        "to be extracted. We can't remove it from storage right now because we cannot be",
        "sure we'll find enough other items.",
        "Remove part of this stack.",
        "If we are returning items then we cannot return multiple non-stackable items in a single request.",
        "We are trashing items from the hopper.",
        "This is a problem. This stack does not meet the minimum requirement for anything",
        "to be extracted. We can't remove it from storage right now because we cannot be",
        "sure we'll find enough other items.",
        "We are done.",
        "If we had minimum amounts that stopped us from removing items immediately then do that now.",
        "If we successfully found an item return the details.",
        "We found something.",
        "We have been asked to return the items to the caller.",
        "Ensure the cube stack has the correct total number found.",
        "Ensure the item stack has the correct total number found.",
        "We may need to spawn a cube stack here",
        "Ensure the item stack has the correct total number found.",
        "This should not happen!",
        "We don't need to return the items, just the amount removed from the storage.",
        "Did not find anything.",
        "Check we have not run out of space.",
        "Get the number of items represented by this item.",
        "Partial insertion is not allowed.",
        "This should not happen. Race condition?",
        "Only create results if required.",
        "TODO: More efficient way of inserting multiple items.",
        "if (maAttachedHoppers[0].mnStorageFree <=0)",
        "{",
        "Debug.LogError(\"Derp, how did a Quarry pick a full hopper to empty into?\");",
        "}",
        "else",
        "{",
        "maAttachedHoppers[0].AddCube(mCarryCube,mCarryValue);",
        "}",
        "This should not happen. Race condition?",
        "Use the full extract function to count using all provided options.",
        "Failed to extract anything",
        "When a hopper is selected ensure the initial debounce time is 0."
    ],
    "docstrings": [
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "*******************************************************************W********************************************************************",
        "****************************************************************************************************",
        "****************************************************************************************************",
        "****************************************************************************************************",
        "* Efficiency (inverted because power is inversion of cooling)",
        "****************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "******************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "********************************************************",
        "********************************************************",
        "********************************************************",
        "********************************************************",
        "********************************************************",
        "********************************************************",
        "********************************************************",
        "********************************************************",
        "********************************************************",
        "********************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "******************* Network Syncing *************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "***************************************************************************************************************************************",
        "******************** PowerConsumerInterface **********************",
        "<summary>",
        "<summary>",
        "******************** ItemConsumerInterface **********************",
        "<summary>",
        "****************************************************************"
    ],
    "functions": [
        "LogisticsOperation",
        "StorageHopper",
        "SpawnGameObject",
        "GetVersion",
        "DropGameObject",
        "AddItem",
        "CountFreeSlots",
        "LowFrequencyUpdate",
        "UpdateSpoilage",
        "AttemptToSpoilOrganicItem",
        "UpdatePoweredHopper",
        "CheckHoppers",
        "CheckSuppliers",
        "CheckConsumers",
        "UpdateHoover",
        "UnitySuspended",
        "UpdateLOD",
        "UpdateHooverEmission",
        "UpdateWorkLight",
        "SetHoloStatus",
        "UpdateMeshText",
        "LinkToGO",
        "ConfigTutorial",
        "UnityUpdate",
        "AddCube",
        "CollapseContents",
        "IterateContents",
        "CountHowManyOfOreType",
        "CountHowManyOfType",
        "CountHowManyOfItem",
        "ContainsOre",
        "RemoveInventoryCube",
        "RemoveInventoryCube",
        "StoreItem",
        "GetSpecificCubeRoundRobin",
        "GetSpecificCube",
        "ItemBase",
        "RemoveSingleSpecificCubeStack",
        "ItemBase",
        "RemoveSingleSpecificItemByID",
        "ItemBase",
        "RemoveSingleSpecificItemOrCubeRoundRobin",
        "ItemBase",
        "RemoveSingleSpecificItemOrCube",
        "ItemBase",
        "RemoveSingleSpecificItem",
        "ItemBase",
        "DecrementInventorySlot",
        "ItemBase",
        "RemoveFirstInventoryItem",
        "ItemBase",
        "RemoveFirstInventoryItemOrDecrementStack",
        "RemoveInventoryItem",
        "UnloadToList",
        "FinaliseHopperChange",
        "ShouldSave",
        "Write",
        "Read",
        "ShouldNetworkUpdate",
        "TogglePermissions",
        "ToggleHoover",
        "OnDelete",
        "GetRemainingPowerCapacity",
        "GetMaximumDeliveryRate",
        "GetMaxPower",
        "DeliverPower",
        "WantsPowerFromEntity",
        "HoloMachineEntity",
        "CreateHolobaseEntity",
        "HolobaseUpdate",
        "TryDeliverItem",
        "eHopperPermissions",
        "GetPermissions",
        "IsEmpty",
        "IsFull",
        "IsNotEmpty",
        "IsNotFull",
        "TryExtract",
        "TryExtract",
        "TryExtractCubes",
        "TryExtractItems",
        "TryExtractItemsOrCubes",
        "TryExtractItemsOrCubes",
        "TryExtractItems",
        "TryPartialExtractCubes",
        "TryPartialExtractItems",
        "TryPartialExtractItemsOrCubes",
        "TryPartialExtractItemsOrCubes",
        "TryPartialExtractItems",
        "TryExtractAny",
        "TryInsert",
        "TryInsert",
        "TryInsert",
        "TryPartialInsert",
        "TryPartialInsert",
        "CountItems",
        "CountItems",
        "CountItems",
        "CountCubes",
        "Selected"
    ],
    "classes": [
        "StorageHopper"
    ]
}