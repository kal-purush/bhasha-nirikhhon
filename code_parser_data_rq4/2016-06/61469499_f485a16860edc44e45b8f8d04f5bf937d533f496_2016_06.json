{
    "identifiers": [
        "Collections",
        "Generic",
        "Linq",
        "Text",
        "Text",
        "RegularExpressions",
        "Minimatch",
        "NoCase",
        "RegexOptions",
        "IgnoreCase",
        "RegexOptions",
        "NoCase",
        "NoCase",
        "value",
        "Func",
        "pattern",
        "Options",
        "options",
        "pattern",
        "ArgumentNullException",
        "IsNullOrWhiteSpace",
        "pattern",
        "IsNullOrEmpty",
        "Minimatcher",
        "pattern",
        "options",
        "m",
        "IsMatch",
        "input",
        "pattern",
        "Options",
        "options",
        "input",
        "ArgumentNullException",
        "pattern",
        "ArgumentNullException",
        "options",
        "options",
        "NoComment",
        "pattern",
        "IsNullOrWhiteSpace",
        "pattern",
        "input",
        "Minimatcher",
        "pattern",
        "options",
        "IsMatch",
        "input",
        "pattern",
        "Options",
        "options",
        "Minimatcher",
        "pattern",
        "options",
        "Where",
        "mm",
        "IsMatch",
        "options",
        "options",
        "NoNull",
        "DefaultIfEmpty",
        "pattern",
        "pattern",
        "Options",
        "options",
        "Minimatcher",
        "pattern",
        "options",
        "MakeRegex",
        "pattern",
        "Options",
        "options",
        "pattern",
        "ArgumentNullException",
        "options",
        "options",
        "Options",
        "pattern",
        "pattern",
        "Trim",
        "options",
        "AllowWindowsPaths",
        "pattern",
        "pattern",
        "Replace",
        "Make",
        "input",
        "Match",
        "input",
        "Where",
        "IsMatch",
        "options",
        "NoNull",
        "DefaultIfEmpty",
        "pattern",
        "ParseItem",
        "qmark",
        "Char",
        "ToCharArray",
        "Regex",
        "options",
        "NoComment",
        "IsNullOrEmpty",
        "pattern",
        "pattern",
        "comment",
        "IsNullOrEmpty",
        "pattern",
        "empty",
        "ParseNegate",
        "globSet",
        "BraceExpand",
        "pattern",
        "options",
        "globParts",
        "globSet",
        "Select",
        "slashSplit",
        "Split",
        "s",
        "ToList",
        "globParts",
        "Select",
        "g",
        "Select",
        "Parse",
        "t",
        "Where",
        "g",
        "Contains",
        "Select",
        "g",
        "Select",
        "t",
        "Item1",
        "ToList",
        "options",
        "NoNegate",
        "i",
        "pattern",
        "Length",
        "pattern",
        "i",
        "i",
        "negate",
        "negate",
        "negateOffset",
        "negateOffset",
        "pattern",
        "pattern",
        "Substring",
        "negateOffset",
        "Regex",
        "Regex",
        "pattern",
        "Options",
        "options",
        "options",
        "NoBrace",
        "hasBraces",
        "IsMatch",
        "pattern",
        "pattern",
        "pattern",
        "i",
        "i",
        "pattern",
        "Length",
        "i",
        "pattern",
        "i",
        "c",
        "escaping",
        "escaping",
        "c",
        "escaping",
        "prefix",
        "pattern",
        "Substring",
        "i",
        "prefix",
        "pattern",
        "BraceExpand",
        "pattern",
        "Substring",
        "i",
        "options",
        "Select",
        "prefix",
        "t",
        "numericSet",
        "Match",
        "pattern",
        "numset",
        "Success",
        "BraceExpand",
        "pattern",
        "Substring",
        "numset",
        "Length",
        "options",
        "ToList",
        "Parse",
        "numset",
        "Groups",
        "Value",
        "Parse",
        "numset",
        "Groups",
        "Value",
        "start",
        "end",
        "w",
        "end",
        "inc",
        "w",
        "inc",
        "ii",
        "suf",
        "Count",
        "ii",
        "retVal",
        "Add",
        "w",
        "ToString",
        "suf",
        "ii",
        "retVal",
        "i",
        "i",
        "i",
        "pattern",
        "Length",
        "depth",
        "i",
        "pattern",
        "i",
        "escaping",
        "escaping",
        "member",
        "c",
        "c",
        "escaping",
        "depth",
        "member",
        "depth",
        "depth",
        "Add",
        "member",
        "member",
        "member",
        "c",
        "depth",
        "Add",
        "member",
        "member",
        "member",
        "c",
        "member",
        "c",
        "depth",
        "BraceExpand",
        "pattern",
        "options",
        "Count",
        "SelectMany",
        "BraceExpand",
        "p",
        "options",
        "ToList",
        "addBraces",
        "Select",
        "s",
        "ToList",
        "BraceExpand",
        "pattern",
        "Substring",
        "i",
        "options",
        "SelectMany",
        "Select",
        "s2",
        "s1",
        "LiteralItem",
        "source",
        "LiteralItem",
        "source",
        "Options",
        "options",
        "input",
        "Options",
        "options",
        "ParseItem",
        "source",
        "Source",
        "source",
        "Options",
        "options",
        "Regex",
        "Escape",
        "Source",
        "input",
        "Options",
        "options",
        "input",
        "Equals",
        "Source",
        "options",
        "NoCase",
        "StringComparison",
        "OrdinalIgnoreCase",
        "StringComparison",
        "Ordinal",
        "ParseItem",
        "source",
        "Options",
        "options",
        "Source",
        "source",
        "regex",
        "Lazy",
        "Regex",
        "Regex",
        "source",
        "options",
        "RegexOptions",
        "Lazy",
        "Regex",
        "Options",
        "options",
        "Source",
        "input",
        "Options",
        "options",
        "regex",
        "Value",
        "IsMatch",
        "input",
        "ParseItem",
        "GlobStar",
        "Options",
        "options",
        "options",
        "NoGlobStar",
        "star",
        "options",
        "Dot",
        "twoStarDot",
        "twoStarNoDot",
        "input",
        "Options",
        "options",
        "NotSupportedException",
        "Regex",
        "Tuple",
        "ParseItem",
        "pattern",
        "isSub",
        "options",
        "NoGlobStar",
        "pattern",
        "Tuple",
        "Create",
        "GlobStar",
        "Instance",
        "pattern",
        "Tuple",
        "Create",
        "ParseItem",
        "Empty",
        "options",
        "NoCase",
        "PatternListEntry",
        "pattern",
        "options",
        "Dot",
        "stateChar",
        "stateChar",
        "re",
        "star",
        "hasMagic",
        "re",
        "qmark",
        "hasMagic",
        "re",
        "stateChar",
        "stateChar",
        "i",
        "pattern",
        "Length",
        "i",
        "pattern",
        "i",
        "escaping",
        "reSpecials",
        "Contains",
        "c",
        "re",
        "c",
        "escaping",
        "c",
        "clearStateChar",
        "escaping",
        "inClass",
        "c",
        "i",
        "classStart",
        "c",
        "re",
        "c",
        "clearStateChar",
        "stateChar",
        "c",
        "options",
        "NoExt",
        "clearStateChar",
        "inClass",
        "re",
        "stateChar",
        "re",
        "plType",
        "stateChar",
        "Value",
        "patternListStack",
        "Push",
        "PatternListEntry",
        "Type",
        "plType",
        "Start",
        "i",
        "ReStart",
        "re",
        "Length",
        "re",
        "stateChar",
        "stateChar",
        "inClass",
        "patternListStack",
        "Any",
        "re",
        "hasMagic",
        "re",
        "plType",
        "patternListStack",
        "Pop",
        "Type",
        "plType",
        "re",
        "re",
        "plType",
        "inClass",
        "patternListStack",
        "Any",
        "escaping",
        "re",
        "escaping",
        "re",
        "clearStateChar",
        "inClass",
        "re",
        "c",
        "inClass",
        "classStart",
        "i",
        "reClassStart",
        "re",
        "Length",
        "re",
        "c",
        "i",
        "classStart",
        "inClass",
        "re",
        "c",
        "escaping",
        "hasMagic",
        "inClass",
        "re",
        "c",
        "clearStateChar",
        "escaping",
        "escaping",
        "reSpecials",
        "Contains",
        "c",
        "c",
        "inClass",
        "re",
        "re",
        "c",
        "inClass",
        "pattern",
        "Substring",
        "classStart",
        "Parse",
        "cs",
        "re",
        "re",
        "Substring",
        "reClassStart",
        "sp",
        "Item1",
        "Source",
        "hasMagic",
        "hasMagic",
        "sp",
        "Item2",
        "patternListStack",
        "Any",
        "patternListStack",
        "Pop",
        "re",
        "Substring",
        "pl",
        "ReStart",
        "tail",
        "escapeCheck",
        "Replace",
        "tail",
        "m",
        "Groups",
        "Value",
        "IsNullOrEmpty",
        "escape",
        "escape",
        "m",
        "Groups",
        "Value",
        "m",
        "Groups",
        "Value",
        "escape",
        "pl",
        "Type",
        "star",
        "pl",
        "Type",
        "qmark",
        "pl",
        "Type",
        "hasMagic",
        "re",
        "re",
        "Remove",
        "pl",
        "ReStart",
        "t",
        "tail",
        "clearStateChar",
        "escaping",
        "re",
        "re",
        "addPatternStart",
        "re",
        "hasMagic",
        "re",
        "re",
        "addPatternStart",
        "re",
        "patternStart",
        "re",
        "isSub",
        "Tuple",
        "Create",
        "ParseItem",
        "Literal",
        "re",
        "hasMagic",
        "hasMagic",
        "Tuple",
        "Create",
        "ParseItem",
        "Literal",
        "GlobUnescape",
        "pattern",
        "Tuple",
        "ParseItem",
        "MagicItem",
        "re",
        "options",
        "regexp",
        "isError",
        "regexp",
        "comment",
        "empty",
        "Any",
        "isError",
        "Join",
        "Select",
        "Join",
        "pattern",
        "Select",
        "p",
        "RegexSource",
        "options",
        "re",
        "re",
        "negate",
        "re",
        "re",
        "regexp",
        "Regex",
        "re",
        "options",
        "RegexOptions",
        "isError",
        "input",
        "partial",
        "comment",
        "empty",
        "input",
        "input",
        "partial",
        "options",
        "AllowWindowsPaths",
        "input",
        "input",
        "Replace",
        "slashSplit",
        "Split",
        "input",
        "pattern",
        "MatchOne",
        "f",
        "pattern",
        "ToList",
        "partial",
        "hit",
        "options",
        "FlipNegate",
        "negate",
        "options",
        "FlipNegate",
        "negate",
        "IList",
        "file",
        "IList",
        "ParseItem",
        "pattern",
        "partial",
        "options",
        "MatchBase",
        "pattern",
        "Count",
        "file",
        "file",
        "Last",
        "IsNullOrEmpty",
        "s",
        "fi",
        "file",
        "Count",
        "pi",
        "pattern",
        "Count",
        "fi",
        "pi",
        "pattern",
        "pi",
        "file",
        "fi",
        "p",
        "p",
        "GlobStar",
        "pi",
        "pr",
        "pattern",
        "Count",
        "fi",
        "file",
        "Count",
        "fi",
        "file",
        "fi",
        "file",
        "fi",
        "options",
        "Dot",
        "IsNullOrEmpty",
        "file",
        "fi",
        "file",
        "fi",
        "fr",
        "file",
        "Count",
        "file",
        "fr",
        "MatchOne",
        "file",
        "Skip",
        "fr",
        "ToList",
        "pattern",
        "Skip",
        "pr",
        "ToList",
        "partial",
        "swallowee",
        "swallowee",
        "options",
        "Dot",
        "swallowee",
        "fr",
        "partial",
        "fr",
        "file",
        "Count",
        "p",
        "Match",
        "f",
        "options",
        "fi",
        "file",
        "Count",
        "pi",
        "pattern",
        "Count",
        "fi",
        "file",
        "Count",
        "partial",
        "pi",
        "pattern",
        "Count",
        "fi",
        "file",
        "Count",
        "file",
        "fi",
        "emptyFileEnd",
        "InvalidOperationException",
        "Regex",
        "s",
        "globUnescaper",
        "Replace",
        "s"
    ],
    "literals": [
        "\"pattern\"",
        "\"input\"",
        "\"pattern\"",
        "\"\"",
        "\"pattern\"",
        "\"[^/]\"",
        "\"*?\"",
        "\"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\"",
        "\"(?:(?!(?:\\\\/|^)\\\\.).)*?\"",
        "\"().*{}+?[]^$\\\\!\"",
        "\"/+\"",
        "\"\"",
        "\"\\\\\"",
        "\"{\"",
        "\"\"",
        "\"\"",
        "\"\\\\\"",
        "\"{\"",
        "\"}\"",
        "\"\"",
        "\"^\"",
        "\"$\"",
        "\"**\"",
        "\"\"",
        "\"\"",
        "\"\"",
        "\"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\"",
        "\"(?!\\\\.)\"",
        "\"\\\\\"",
        "\"\\\\\"",
        "\"(\"",
        "\"\\\\(\"",
        "\"(?:(?!\"",
        "\"(?:\"",
        "\"\\\\)\"",
        "\"[^/]*?)\"",
        "\"\\\\|\"",
        "\"|\"",
        "\"\\\\\"",
        "\"\\\\\"",
        "\"\\\\\"",
        "\"\\\\[\"",
        "\"\\\\\"",
        "\"|\"",
        "\"\\\\\"",
        "\"\\\\(\"",
        "\"\\\\\\\\\"",
        "\"\"",
        "\"(?=.)\"",
        "\"|\"",
        "\"\\\\/\"",
        "\"^(?:\"",
        "\")$\"",
        "\"^(?!\"",
        "\").*$\"",
        "\"\"",
        "\"/\"",
        "\"\\\\\"",
        "\"/\"",
        "\".\"",
        "\"..\"",
        "\".\"",
        "\"..\"",
        "\"\"",
        "\"wtf?\"",
        "\"$1\""
    ],
    "variables": [
        "NoComment",
        "NoNegate",
        "NoBrace",
        "NoGlobStar",
        "NoCase",
        "NoExt",
        "Dot",
        "NoNull",
        "FlipNegate",
        "MatchBase",
        "RegexOptions",
        "RegexOptions",
        "AllowWindowsPaths",
        "IgnoreCase",
        "m",
        "mm",
        "Options",
        "options",
        "pattern",
        "negate",
        "comment",
        "empty",
        "Regex",
        "regexp",
        "isError",
        "globSet",
        "globParts",
        "qmark",
        "star",
        "twoStarDot",
        "twoStarNoDot",
        "reSpecials",
        "Regex",
        "slashSplit",
        "negateOffset",
        "i",
        "Regex",
        "hasBraces",
        "Regex",
        "numericSet",
        "escaping",
        "i",
        "prefix",
        "c",
        "numset",
        "suf",
        "start",
        "end",
        "inc",
        "retVal",
        "w",
        "start",
        "ii",
        "depth",
        "member",
        "c",
        "addBraces",
        "Type",
        "Start",
        "ReStart",
        "Source",
        "ParseItem",
        "Empty",
        "regex",
        "ParseItem",
        "Instance",
        "Regex",
        "escapeCheck",
        "re",
        "hasMagic",
        "escaping",
        "inClass",
        "patternListStack",
        "plType",
        "stateChar",
        "reClassStart",
        "classStart",
        "patternStart",
        "Action",
        "clearStateChar",
        "i",
        "c",
        "cs",
        "sp",
        "pl",
        "tail",
        "escape",
        "t",
        "addPatternStart",
        "re",
        "f",
        "hit",
        "fi",
        "pi",
        "ParseItem",
        "p",
        "f",
        "fr",
        "fi",
        "pr",
        "swallowee",
        "emptyFileEnd",
        "Regex",
        "globUnescaper"
    ],
    "comments": [
        "Note that by default, <c>a/**/b</c>  will not match <c>a/.d/b</c>, unless dot is set.</summary>",
        "Aliases:",
        "\"\" only matches \"\"",
        "<remarks>This function reparses this input on each invocation.  For performance, avoid this function and reuse a Minimatcher instance instead.</remarks>",
        "shortcut: comments match nothing.",
        "\"\" only matches \"\"",
        "<remarks>This function reparses this input on each invocation.  For performance, avoid this function and reuse a Minimatcher instance instead.</remarks>",
        "any single thing other than /",
        "don't need to escape / when using new RegExp()",
        "not (^ or / followed by one or two dots followed by $ or /),",
        "followed by anything, any number of times.",
        "not a ^ or / followed by a dot,",
        "followed by anything, any number of times.",
        "characters that need to be escaped in RegExp.",
        "empty patterns and comments match nothing.",
        "step 1: figure out negation, etc.",
        "step 2: expand braces",
        "step 3: now we have a set, so turn each one into a series of path-portion",
        "matching patterns.",
        "These will be regexps, except in the case of \"**\", which is",
        "set to the GLOBSTAR object for globstar behavior,",
        "and will not contain any / characters",
        "glob --> regexps",
        "Brace expansion:",
        "a{b,c}d -> abd acd",
        "a{b,}c -> abc ac",
        "a{0..3}d -> a0d a1d a2d a3d",
        "a{b,c{d,e}f}g -> abg acdfg acefg",
        "a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg",
        "",
        "Invalid sets are not expanded.",
        "a{2..}b -> a{2..}b",
        "a{b}c -> a{b}c",
        "shortcut. no need to expand.",
        "examples and comments refer to this crazy pattern:",
        "a{b,c{d,e},{f,g}h}x{y,z}",
        "expected:",
        "abxy",
        "abxz",
        "acdxy",
        "acdxz",
        "acexy",
        "acexz",
        "afhxy",
        "afhxz",
        "aghxy",
        "aghxz",
        "everything before the first \\{ is just a prefix.",
        "So, we pluck that off, and work with the rest,",
        "and then prepend it to everything we find.",
        "console.error(pattern)",
        "console.error(i, c)",
        "actually no sets, all { were escaped.",
        "console.error(\"no sets\")",
        "now we have something like:",
        "{b,c{d,e},{f,g}h}x{y,z}",
        "walk through the set, expanding each part, until",
        "the set ends.  then, we'll expand the suffix.",
        "If the set only has a single member, then'll put the {} back",
        "first, handle numeric sets, since they're easier",
        "console.error(\"numset\", numset[1], numset[2])",
        "append all the suffixes",
        "ok, walk through the set",
        "We hope, somewhat optimistically, that there",
        "will be a } at the end.",
        "If the closing brace isn't found, then the pattern is",
        "interpreted as braceExpand(\"\\\\\" + pattern) so that",
        "the leading \\{ will be interpreted literally.",
        "skip the \\{",
        "console.error(\"\", i, c)",
        "if this closes the actual set, then we're done",
        "pluck off the close-brace",
        "switch",
        "else",
        "for",
        "now we've either finished the set, and the suffix is",
        "pattern.substr(i), or we have *not* closed the set,",
        "and need to escape the leading brace",
        "console.error(\"didn't close\", pattern)",
        "[\"b\", \"c{d,e}\",\"{f,g}h\"] ->",
        "[\"b\", \"cd\", \"ce\", \"fh\", \"gh\"]",
        "now attach the suffixes.",
        "x{y,z} -> [\"xy\", \"xz\"]",
        "console.error(\"set\", set)",
        "console.error(\"suffix\", pattern.substr(i))",
        "parse a component of the expanded set.",
        "At this point, no pattern may contain \"/\" in it",
        "so we're going to return a 2d array, where each entry is the full",
        "pattern, split on '/', and then turned into a regular expression.",
        "A regexp is made at the end which joins each array with an",
        "escaped /, and another full one which joins each regexp with |.",
        "",
        "Following the lead of Bash 4.1, note that \"**\" only has special meaning",
        "when it is the *only* thing in a path portion.  Otherwise, any series",
        "of * is equivalent to a single *.  Globstar behavior is enabled by",
        "default, and can be disabled by setting options.noglobstar.",
        "shortcuts",
        "? => one single character",
        ". and .. never match anything that doesn't start with .,",
        "even when options.dot is set.",
        "anything",
        "not (start or / followed by . or .. followed by / or end)",
        "we had some state-tracking character",
        "that wasn't consumed by this pass.",
        "if (options.debug) {",
        "console.error(\"%s\\t%s %s %j\", pattern, i, re, c)",
        "}",
        "skip over any that are escaped.",
        "completely not allowed, even escaped.",
        "Should already be path-split by now.",
        "the various stateChar values",
        "for the 'extglob' stuff.",
        "if (options.debug) {",
        "console.error(\"%s\\t%s %s %j <-- stateChar\", pattern, i, re, c)",
        "}",
        "all of those are literals inside a class, except that",
        "the glob [!a] means [^a] in regexp",
        "if we already have a stateChar, then it means",
        "that there was something like ** or +? in there.",
        "Handle the stateChar, then proceed with this one.",
        "if extglob is disabled, then +(asdf|foo) isn't a thing.",
        "just clear the statechar *now*, rather than even diving into",
        "the patternList stuff.",
        "negation is (?:(?!js)[^/]*)",
        "negation is (?:(?!js)[^/]*)",
        "The others are (?:<pattern>)<type>",
        "the default anyway",
        "these are mostly the same in regexp and glob",
        "swallow any state-tracking char before the [",
        "a right bracket shall lose its special",
        "meaning and represent itself in",
        "a bracket expression if it occurs",
        "first in the list.  -- POSIX.2 2.8.3.2",
        "finish up the class.",
        "swallow any state char that wasn't consumed",
        "no need",
        "switch",
        "for",
        "handle the case where we left a class open.",
        "\"[abc\" is valid, equivalent to \"\\[abc\"",
        "split where the last [ was, and escape it",
        "this is a huge pita.  We now have to re-walk",
        "the contents of the would-be class to re-translate",
        "any characters that were passed through as-is",
        "handle the case where we had a +( thing at the *end*",
        "of the pattern.",
        "each pattern list stack adds 3 chars, and we need to go through",
        "and escape any | chars that were passed through as-is for the regexp.",
        "Go through and escape them, taking care not to double-escape any",
        "| chars that were already escaped.",
        "maybe some even number of \\, then maybe 1 \\, followed by a |",
        "the | isn't already escaped, so escape it.",
        "need to escape all those slashes *again*, without escaping the",
        "one that we need for escaping the | character.  As it works out,",
        "escaping an even number of slashes can be done by simply repeating",
        "it exactly after itself.  That's why this trick works.",
        "",
        "I am sorry that you have to see this.",
        "console.error(\"tail=%j\\n   %s\", tail, tail)",
        "handle trailing things that only matter at the very end.",
        "trailing \\\\",
        "only need to apply the nodot start if the re starts with",
        "something that could conceivably capture a dot",
        "if the re is not \"\" at this point, then we need to make sure",
        "it doesn't match against an empty path part.",
        "Otherwise a/* will match a/, which it should not.",
        "parsing just a piece of a larger pattern.",
        "skip the regexp for non-magical patterns",
        "unescape anything in it, though, so that it'll be",
        "an exact match against a file etc.",
        "at this point, this.set is a 2d array of partial",
        "pattern strings, or \"**\".",
        "",
        "It's better to use .match().  This function shouldn't",
        "be used, really, but it's pretty convenient sometimes,",
        "when you just want to work with a regex.",
        "must match entire pattern",
        "ending in a * or ** will make it less strict.",
        "can match anything, as long as it's not this.",
        "console.error(\"match\", f, this.pattern)",
        "short-circuit in the case of busted things.",
        "comments, etc.",
        "windows: need to use /, not \\",
        "On other platforms, \\ is a valid (albeit bad) filename char.",
        "treat the test path as a set of pathparts.",
        "if (options.debug) {",
        "console.error(this.pattern, \"split\", f)",
        "}",
        "just ONE of the pattern sets in this.set needs to match",
        "in order for it to be valid.  If negating, then just one",
        "match means that we have failed.",
        "Either way, return on the first hit.",
        "didn't get any hits.  this is success if it's a negative",
        "pattern, failure otherwise.",
        "set partial to true to test if, for example,",
        "\"/a/b\" matches the start of \"/*/b/*/d\"",
        "Partial means, if you run out of file before you run",
        "out of pattern, then that's fine, as long as all",
        "the parts match.",
        "if (options.debug) {",
        "console.error(\"matchOne\",",
        "{ \"this\": this",
        ", file: file",
        ", pattern: pattern })",
        "}",
        "if (options.debug) {",
        "console.error(\"matchOne\", file.length, pattern.length)",
        "}",
        "if (options.debug) {",
        "console.error(\"matchOne loop\")",
        "}",
        "if (options.debug) {",
        "console.error(pattern, p, f)",
        "}",
        "should be impossible.",
        "some invalid regexp stuff in the set.",
        "if (options.debug)",
        "console.error('GLOBSTAR', [pattern, p, f])",
        "\"**\"",
        "a/**/b/**/c would match the following:",
        "a/b/x/y/z/c",
        "a/x/y/z/b/c",
        "a/b/x/b/x/c",
        "a/b/c",
        "To do this, take the rest of the pattern after",
        "the **, and see if it would match the file remainder.",
        "If so, return success.",
        "If not, the ** \"swallows\" a segment, and try again.",
        "This is recursively awful.",
        "",
        "a/**/b/**/c matching a/b/x/y/z/c",
        "- a matches a",
        "- doublestar",
        "- matchOne(b/x/y/z/c, b/**/c)",
        "- b matches b",
        "- doublestar",
        "- matchOne(x/y/z/c, c) -> no",
        "- matchOne(y/z/c, c) -> no",
        "- matchOne(z/c, c) -> no",
        "- matchOne(c, c) yes, hit",
        "if (options.debug)",
        "console.error('** at the end')",
        "a ** at the end will just swallow the rest.",
        "We have found a match.",
        "however, it will not swallow /.x, unless",
        "options.dot is set.",
        ". and .. are *never* matched by **, for explosively",
        "exponential reasons.",
        "ok, let's see if we can swallow whatever we can.",
        "if (options.debug) {",
        "console.error('\\nglobstar while',",
        "file, fr, pattern, pr, swallowee)",
        "}",
        "XXX remove this slice.  Just pass the start index.",
        "if (options.debug)",
        "console.error('globstar found match!', fr, file.Count, swallowee)",
        "found a match.",
        "can't swallow \".\" or \"..\" ever.",
        "can only swallow \".foo\" when explicitly asked.",
        "if (options.debug)",
        "console.error(\"dot detected!\", file, fr, pattern, pr)",
        "if (options.debug)",
        "console.error('globstar swallow a segment, and continue')",
        "no match was found.",
        "However, in partial mode, we can't say this is necessarily over.",
        "If there's more *pattern* left, then",
        "ran out of file",
        "console.error(\"\\n>>> no match, partial?\", file, fr, pattern, pr)",
        "something other than **",
        "non-magic patterns just have to match exactly",
        "patterns with magic have been turned into regexps.",
        "Note: ending in / means that we'll get a final \"\"",
        "at the end of the pattern.  This can only match a",
        "corresponding \"\" at the end of the file.",
        "If the file ends in /, then it can only match a",
        "a pattern that ends in /, unless the pattern just",
        "doesn't have any more for it. But, a/b/ should *not*",
        "match \"a/b/*\", even though \"\" matches against the",
        "[^/]*? pattern, except in partial mode, where it might",
        "simply not be reached yet.",
        "However, a/b/ should still satisfy a/*",
        "now either we fell off the end of the pattern, or we're done.",
        "ran out of pattern and filename at the same time.",
        "an exact hit!",
        "ran out of file, but still had pattern left.",
        "this is ok if we're doing the match as part of",
        "a glob fs traversal.",
        "ran out of pattern, still have file left.",
        "this is only acceptable if we're on the very last",
        "empty segment of a file with a trailing slash.",
        "a/* should match a/b/",
        "should be unreachable.",
        "replace stuff like \\* with *"
    ],
    "docstrings": [
        "<summary>Contains options that control how Minimatch matches strings.</summary>",
        "<summary>Suppresses the behavior of treating # at the start of a pattern as a comment.</summary>",
        "<summary>Suppresses the behavior of treating a leading ! character as negation.</summary>",
        "<summary>Do not expand {a,b} and {1.3} brace sets.</summary>",
        "<summary>Disable ** matching against multiple folder names.</summary>",
        "<summary>Ignores case differences when matching.</summary>",
        "<summary>Disable \"extglob\" style patterns like <c>+(a|b)</c>.</summary>",
        "<summary>Allow patterns to match filenames starting with a period, even if the pattern does not explicitly have a period in that spot.",
        "<summary>When a match is not found by Match(), return a list containing the pattern itself. If not set, an empty list is returned if there are no matches.</summary>",
        "<summary>Returns from negate expressions the same as if they were not negated. (ie, true on a hit, false on a miss).</summary>",
        "<summary>If set, then patterns without slashes will be matched against the basename of the path if it contains slashes. For example, <c>a?b</c> would match the path <c>/xyz/123/acb</c>, but not <c>/xyz/acb/123</c>.</summary>",
        "<summary>If true, backslahes in patterns and paths will be treated as forward slashes.  This disables escape characters.</summary>",
        "<summary>Ignores case differences when matching.  This is the same as NoCase.</summary>",
        "<summary>Parses a single glob pattern and tests strings against it.</summary>",
        "<summary>Creates a filter function that tests input against a pattern.</summary>",
        "<summary>Tests a single input against a pattern.</summary>",
        "<summary>Filters a list of inputs against a single pattern.</summary>",
        "<summary>Compiles a pattern into a single regular expression.</summary>",
        "<summary>Creates a new Minimatcher instance, parsing the pattern into a regex.</summary>",
        "<summary>Checks whether a given string matches this pattern.</summary>",
        "<summary>Filters a list of inputs against this pattern.</summary>",
        "* => any number of characters",
        "** when dots are allowed.  Anything goes, except .. and .",
        "<summary>Expands all brace ranges in a pattern, returning a sequence containing every possible combination.</summary>",
        "** swallows a segment, and continue."
    ],
    "functions": [
        "CreateFilter",
        "Check",
        "Filter",
        "Regex",
        "CreateRegex",
        "Minimatcher",
        "IsMatch",
        "Filter",
        "Make",
        "ParseNegate",
        "BraceExpand",
        "ParseItem",
        "Literal",
        "RegexSource",
        "Match",
        "LiteralItem",
        "RegexSource",
        "Match",
        "MagicItem",
        "RegexSource",
        "Match",
        "GlobStar",
        "RegexSource",
        "Match",
        "Parse",
        "Regex",
        "MakeRegex",
        "Match",
        "MatchOne",
        "GlobUnescape"
    ],
    "classes": [
        "Options",
        "Minimatcher",
        "PatternListEntry",
        "ParseItem",
        "LiteralItem",
        "MagicItem",
        "GlobStar"
    ]
}