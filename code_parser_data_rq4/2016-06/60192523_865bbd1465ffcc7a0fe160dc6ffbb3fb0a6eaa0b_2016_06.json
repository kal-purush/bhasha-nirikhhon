{
    "identifiers": [
        "codecs",
        "getopt",
        "math",
        "os",
        "re",
        "sre_compile",
        "sys",
        "unicodedata",
        "m",
        "m",
        "_CHECK_MACROS",
        "op",
        "replacement",
        "_CHECK_REPLACEMENT",
        "replacement",
        "_CHECK_REPLACEMENT",
        "replacement",
        "_CHECK_REPLACEMENT",
        "replacement",
        "_CHECK_REPLACEMENT",
        "replacement",
        "_CHECK_REPLACEMENT",
        "replacement",
        "_CHECK_REPLACEMENT",
        "replacement",
        "op",
        "inv_replacement",
        "_CHECK_REPLACEMENT",
        "inv_replacement",
        "_CHECK_REPLACEMENT",
        "inv_replacement",
        "_CHECK_REPLACEMENT",
        "inv_replacement",
        "_CHECK_REPLACEMENT",
        "inv_replacement",
        "re",
        "compile",
        "filename",
        "raw_line",
        "linenum",
        "error",
        "_RE_SUPPRESSION",
        "search",
        "raw_line",
        "matched",
        "matched",
        "group",
        "category",
        "_error_suppressions",
        "setdefault",
        "add",
        "linenum",
        "category",
        "startswith",
        "category",
        "endswith",
        "category",
        "category",
        "_ERROR_CATEGORIES",
        "_error_suppressions",
        "setdefault",
        "category",
        "add",
        "linenum",
        "error",
        "filename",
        "linenum",
        "category",
        "_error_suppressions",
        "clear",
        "category",
        "linenum",
        "linenum",
        "_error_suppressions",
        "get",
        "category",
        "linenum",
        "_error_suppressions",
        "get",
        "pattern",
        "s",
        "pattern",
        "_regexp_compile_cache",
        "sre_compile",
        "compile",
        "pattern",
        "_regexp_compile_cache",
        "pattern",
        "match",
        "s",
        "pattern",
        "s",
        "pattern",
        "_regexp_compile_cache",
        "sre_compile",
        "compile",
        "pattern",
        "_regexp_compile_cache",
        "pattern",
        "search",
        "s",
        "_C_SYS_HEADER",
        "_CPP_SYS_HEADER",
        "_LIKELY_MY_HEADER",
        "_POSSIBLE_MY_HEADER",
        "_OTHER_HEADER",
        "_INITIAL_SECTION",
        "_MY_H_SECTION",
        "_C_SECTION",
        "_CPP_SECTION",
        "_OTHER_H_SECTION",
        "_INITIAL_SECTION",
        "header_path",
        "header_path",
        "replace",
        "replace",
        "lower",
        "header_path",
        "CanonicalizeAlphabeticalOrder",
        "header_path",
        "_last_header",
        "canonical_header",
        "canonical_header",
        "header_type",
        "_TYPE_NAMES",
        "header_type",
        "_SECTION_NAMES",
        "_section",
        "_section",
        "header_type",
        "_C_SYS_HEADER",
        "_section",
        "_C_SECTION",
        "_C_SECTION",
        "error_message",
        "header_type",
        "_CPP_SYS_HEADER",
        "_section",
        "_CPP_SECTION",
        "_CPP_SECTION",
        "error_message",
        "header_type",
        "_LIKELY_MY_HEADER",
        "_section",
        "_MY_H_SECTION",
        "_MY_H_SECTION",
        "_OTHER_H_SECTION",
        "header_type",
        "_POSSIBLE_MY_HEADER",
        "_section",
        "_MY_H_SECTION",
        "_MY_H_SECTION",
        "_OTHER_H_SECTION",
        "header_type",
        "_OTHER_HEADER",
        "_OTHER_H_SECTION",
        "last_section",
        "_section",
        "_DEFAULT_FILTERS",
        "output_format",
        "output_format",
        "level",
        "verbose_level",
        "level",
        "last_verbose_level",
        "counting_style",
        "counting_style",
        "filters",
        "_DEFAULT_FILTERS",
        "filt",
        "filters",
        "split",
        "filt",
        "strip",
        "clean_filt",
        "filters",
        "append",
        "clean_filt",
        "filt",
        "filters",
        "filt",
        "startswith",
        "filt",
        "startswith",
        "ValueError",
        "filt",
        "category",
        "error_count",
        "counting",
        "counting",
        "category",
        "split",
        "category",
        "errors_by_category",
        "errors_by_category",
        "errors_by_category",
        "category",
        "category",
        "count",
        "errors_by_category",
        "iteritems",
        "sys",
        "stderr",
        "write",
        "category",
        "count",
        "sys",
        "stderr",
        "write",
        "error_count",
        "_CppLintState",
        "_cpplint_state",
        "output_format",
        "output_format",
        "_cpplint_state",
        "SetOutputFormat",
        "output_format",
        "_cpplint_state",
        "verbose_level",
        "level",
        "_cpplint_state",
        "SetVerboseLevel",
        "level",
        "level",
        "_cpplint_state",
        "SetCountingStyle",
        "level",
        "_cpplint_state",
        "filters",
        "filters",
        "_cpplint_state",
        "SetFilters",
        "filters",
        "function_name",
        "function_name",
        "in_a_function",
        "lines_in_function",
        "error",
        "filename",
        "linenum",
        "Match",
        "current_function",
        "_TEST_TRIGGER",
        "_NORMAL_TRIGGER",
        "base_trigger",
        "_VerboseLevel",
        "lines_in_function",
        "trigger",
        "math",
        "log",
        "lines_in_function",
        "base_trigger",
        "error_level",
        "error",
        "filename",
        "linenum",
        "error_level",
        "current_function",
        "lines_in_function",
        "trigger",
        "filename",
        "filename",
        "os",
        "path",
        "abspath",
        "_filename",
        "replace",
        "FullName",
        "os",
        "path",
        "exists",
        "fullname",
        "os",
        "path",
        "dirname",
        "fullname",
        "os",
        "path",
        "exists",
        "os",
        "path",
        "join",
        "project_dir",
        "project_dir",
        "os",
        "path",
        "dirname",
        "root_dir",
        "os",
        "path",
        "exists",
        "os",
        "path",
        "join",
        "one_up_dir",
        "os",
        "path",
        "dirname",
        "root_dir",
        "os",
        "path",
        "dirname",
        "one_up_dir",
        "os",
        "path",
        "commonprefix",
        "root_dir",
        "project_dir",
        "fullname",
        "len",
        "prefix",
        "os",
        "path",
        "dirname",
        "fullname",
        "root_dir",
        "os",
        "path",
        "dirname",
        "root_dir",
        "os",
        "path",
        "exists",
        "os",
        "path",
        "join",
        "root_dir",
        "os",
        "path",
        "exists",
        "os",
        "path",
        "join",
        "root_dir",
        "os",
        "path",
        "exists",
        "os",
        "path",
        "join",
        "root_dir",
        "os",
        "path",
        "dirname",
        "root_dir",
        "os",
        "path",
        "exists",
        "os",
        "path",
        "join",
        "root_dir",
        "os",
        "path",
        "exists",
        "os",
        "path",
        "join",
        "root_dir",
        "os",
        "path",
        "exists",
        "os",
        "path",
        "join",
        "root_dir",
        "os",
        "path",
        "commonprefix",
        "root_dir",
        "project_dir",
        "fullname",
        "len",
        "prefix",
        "fullname",
        "RepositoryName",
        "os",
        "path",
        "split",
        "googlename",
        "project",
        "os",
        "path",
        "splitext",
        "rest",
        "Split",
        "Split",
        "join",
        "Split",
        "Extension",
        "category",
        "confidence",
        "linenum",
        "IsErrorSuppressedByNolint",
        "category",
        "linenum",
        "confidence",
        "_cpplint_state",
        "verbose_level",
        "one_filter",
        "_Filters",
        "one_filter",
        "startswith",
        "category",
        "startswith",
        "one_filter",
        "one_filter",
        "startswith",
        "category",
        "startswith",
        "one_filter",
        "is_filtered",
        "filename",
        "linenum",
        "category",
        "confidence",
        "message",
        "_ShouldPrintError",
        "category",
        "confidence",
        "linenum",
        "_cpplint_state",
        "IncrementErrorCount",
        "category",
        "_cpplint_state",
        "output_format",
        "sys",
        "stderr",
        "write",
        "filename",
        "linenum",
        "message",
        "category",
        "confidence",
        "sys",
        "stderr",
        "write",
        "filename",
        "linenum",
        "message",
        "category",
        "confidence",
        "re",
        "compile",
        "re",
        "compile",
        "re",
        "compile",
        "re",
        "compile",
        "re",
        "VERBOSE",
        "line",
        "line",
        "replace",
        "line",
        "count",
        "line",
        "count",
        "line",
        "count",
        "lines",
        "lineix",
        "lineix",
        "len",
        "lines",
        "lines",
        "lineix",
        "strip",
        "startswith",
        "lines",
        "lineix",
        "strip",
        "find",
        "lineix",
        "lineix",
        "len",
        "lines",
        "lines",
        "lineix",
        "lineix",
        "len",
        "lines",
        "lines",
        "lineix",
        "strip",
        "endswith",
        "lineix",
        "lineix",
        "len",
        "lines",
        "lines",
        "begin",
        "end",
        "i",
        "begin",
        "end",
        "filename",
        "lines",
        "error",
        "lineix",
        "len",
        "lines",
        "FindNextMultiLineCommentStart",
        "lines",
        "lineix",
        "lineix_begin",
        "len",
        "lines",
        "FindNextMultiLineCommentEnd",
        "lines",
        "lineix_begin",
        "lineix_end",
        "len",
        "lines",
        "error",
        "filename",
        "lineix_begin",
        "RemoveMultiLineCommentsFromRange",
        "lines",
        "lineix_begin",
        "lineix_end",
        "lineix_end",
        "line",
        "line",
        "find",
        "commentpos",
        "IsCppString",
        "line",
        "commentpos",
        "line",
        "commentpos",
        "rstrip",
        "_RE_PATTERN_CLEANSE_LINE_C_COMMENTS",
        "sub",
        "line",
        "lines",
        "lines",
        "len",
        "lines",
        "linenum",
        "len",
        "lines",
        "lines",
        "append",
        "CleanseComments",
        "lines",
        "linenum",
        "_CollapseStrings",
        "lines",
        "linenum",
        "elided",
        "append",
        "CleanseComments",
        "elided",
        "num_lines",
        "staticmethod",
        "elided",
        "_RE_PATTERN_INCLUDE",
        "match",
        "elided",
        "_RE_PATTERN_CLEANSE_LINE_ESCAPES",
        "sub",
        "elided",
        "_RE_PATTERN_CLEANSE_LINE_SINGLE_QUOTES",
        "sub",
        "elided",
        "_RE_PATTERN_CLEANSE_LINE_DOUBLE_QUOTES",
        "sub",
        "elided",
        "elided",
        "clean_lines",
        "linenum",
        "pos",
        "clean_lines",
        "elided",
        "linenum",
        "line",
        "pos",
        "startchar",
        "line",
        "clean_lines",
        "NumLines",
        "startchar",
        "startchar",
        "startchar",
        "line",
        "count",
        "startchar",
        "line",
        "count",
        "endchar",
        "linenum",
        "clean_lines",
        "NumLines",
        "num_open",
        "linenum",
        "clean_lines",
        "elided",
        "linenum",
        "num_open",
        "line",
        "count",
        "startchar",
        "line",
        "count",
        "endchar",
        "len",
        "line",
        "num_open",
        "line",
        "rfind",
        "endpos",
        "num_open",
        "line",
        "linenum",
        "endpos",
        "filename",
        "lines",
        "error",
        "line",
        "xrange",
        "min",
        "len",
        "lines",
        "re",
        "search",
        "lines",
        "line",
        "re",
        "I",
        "error",
        "filename",
        "filename",
        "re",
        "sub",
        "filename",
        "FileInfo",
        "filename",
        "re",
        "sub",
        "fileinfo",
        "RepositoryName",
        "upper",
        "filename",
        "lines",
        "error",
        "GetHeaderGuardCPPVariable",
        "filename",
        "linenum",
        "line",
        "lines",
        "line",
        "split",
        "len",
        "linesplit",
        "ifndef",
        "linesplit",
        "linesplit",
        "linenum",
        "define",
        "linesplit",
        "linesplit",
        "line",
        "startswith",
        "line",
        "linenum",
        "ifndef",
        "error",
        "filename",
        "cppvar",
        "define",
        "error",
        "filename",
        "cppvar",
        "ifndef",
        "cppvar",
        "ifndef",
        "cppvar",
        "ParseNolintSuppressions",
        "filename",
        "lines",
        "ifndef_linenum",
        "ifndef_linenum",
        "error",
        "error",
        "filename",
        "ifndef_linenum",
        "error_level",
        "cppvar",
        "define",
        "ifndef",
        "error",
        "filename",
        "cppvar",
        "endif",
        "cppvar",
        "endif",
        "cppvar",
        "ParseNolintSuppressions",
        "filename",
        "lines",
        "endif_linenum",
        "endif_linenum",
        "error",
        "error",
        "filename",
        "endif_linenum",
        "error_level",
        "cppvar",
        "filename",
        "lines",
        "error",
        "linenum",
        "line",
        "lines",
        "line",
        "error",
        "filename",
        "linenum",
        "filename",
        "lines",
        "error",
        "len",
        "lines",
        "lines",
        "error",
        "filename",
        "len",
        "lines",
        "filename",
        "clean_lines",
        "linenum",
        "error",
        "clean_lines",
        "elided",
        "linenum",
        "line",
        "replace",
        "line",
        "count",
        "line",
        "count",
        "error",
        "filename",
        "linenum",
        "line",
        "count",
        "line",
        "count",
        "error",
        "filename",
        "linenum",
        "filename",
        "clean_lines",
        "linenum",
        "error",
        "clean_lines",
        "elided",
        "linenum",
        "single_thread_function",
        "multithread_safe_function",
        "threading_list",
        "line",
        "find",
        "single_thread_function",
        "ix",
        "ix",
        "line",
        "ix",
        "isalnum",
        "line",
        "ix",
        "error",
        "filename",
        "linenum",
        "multithread_safe_function",
        "single_thread_function",
        "re",
        "compile",
        "filename",
        "clean_lines",
        "linenum",
        "error",
        "clean_lines",
        "elided",
        "linenum",
        "_RE_PATTERN_INVALID_INCREMENT",
        "match",
        "line",
        "error",
        "filename",
        "linenum",
        "name",
        "clean_lines",
        "linenum",
        "name",
        "linenum",
        "i",
        "linenum",
        "clean_lines",
        "NumLines",
        "clean_lines",
        "lines",
        "i",
        "depth",
        "line",
        "count",
        "line",
        "count",
        "depth",
        "i",
        "filename",
        "error",
        "classinfo_stack",
        "error",
        "filename",
        "classinfo_stack",
        "linenum",
        "classinfo_stack",
        "name",
        "filename",
        "clean_lines",
        "linenum",
        "class_state",
        "error",
        "clean_lines",
        "lines",
        "linenum",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "line",
        "replace",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "clean_lines",
        "elided",
        "linenum",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Match",
        "line",
        "error",
        "filename",
        "linenum",
        "Match",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "class_state",
        "classinfo_stack",
        "Match",
        "line",
        "class_decl_match",
        "classinfo_stack",
        "append",
        "_ClassInfo",
        "class_decl_match",
        "group",
        "clean_lines",
        "linenum",
        "classinfo_stack",
        "classinfo_stack",
        "classinfo",
        "seen_open_brace",
        "line",
        "find",
        "classinfo_stack",
        "pop",
        "line",
        "find",
        "Search",
        "line",
        "classinfo",
        "seen_open_brace",
        "classinfo",
        "name",
        "split",
        "Match",
        "re",
        "escape",
        "base_classname",
        "line",
        "args",
        "args",
        "group",
        "Match",
        "re",
        "escape",
        "base_classname",
        "args",
        "group",
        "strip",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "linenum",
        "Search",
        "base_classname",
        "line",
        "classinfo",
        "brace_depth",
        "brace_depth",
        "line",
        "count",
        "line",
        "count",
        "brace_depth",
        "classinfo_stack",
        "pop",
        "classinfo",
        "virtual_method_linenumber",
        "classinfo",
        "has_virtual_destructor",
        "classinfo",
        "is_derived",
        "error",
        "filename",
        "classinfo",
        "linenum",
        "classinfo",
        "name",
        "classinfo",
        "virtual_method_linenumber",
        "brace_depth",
        "filename",
        "line",
        "linenum",
        "error",
        "line",
        "pattern",
        "Search",
        "pattern",
        "line",
        "match",
        "match",
        "group",
        "Search",
        "fncall",
        "Search",
        "fncall",
        "Search",
        "fncall",
        "Search",
        "fncall",
        "error",
        "filename",
        "linenum",
        "Search",
        "fncall",
        "error",
        "filename",
        "linenum",
        "Search",
        "fncall",
        "Search",
        "fncall",
        "error",
        "filename",
        "linenum",
        "Search",
        "fncall",
        "Search",
        "fncall",
        "error",
        "filename",
        "linenum",
        "error",
        "filename",
        "linenum",
        "line",
        "line",
        "line",
        "isspace",
        "filename",
        "clean_lines",
        "linenum",
        "function_state",
        "error",
        "clean_lines",
        "lines",
        "lines",
        "linenum",
        "clean_lines",
        "raw_lines",
        "raw",
        "linenum",
        "Match",
        "regexp",
        "line",
        "match_result",
        "match_result",
        "group",
        "split",
        "function_name",
        "function_name",
        "Match",
        "function_name",
        "starting_func",
        "start_linenum",
        "xrange",
        "linenum",
        "clean_lines",
        "NumLines",
        "lines",
        "start_linenum",
        "joined_line",
        "start_line",
        "lstrip",
        "Search",
        "start_line",
        "Search",
        "start_line",
        "Search",
        "line",
        "group",
        "Match",
        "Search",
        "joined_line",
        "parameter_regexp",
        "parameter_regexp",
        "group",
        "function_state",
        "Begin",
        "body_found",
        "error",
        "filename",
        "linenum",
        "Match",
        "line",
        "function_state",
        "Check",
        "error",
        "filename",
        "linenum",
        "function_state",
        "End",
        "Match",
        "line",
        "function_state",
        "Count",
        "re",
        "compile",
        "comment",
        "filename",
        "linenum",
        "error",
        "_RE_PATTERN_TODO",
        "match",
        "comment",
        "match",
        "match",
        "group",
        "len",
        "leading_whitespace",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "username",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "middle_whitespace",
        "middle_whitespace",
        "error",
        "filename",
        "linenum",
        "filename",
        "clean_lines",
        "linenum",
        "error",
        "clean_lines",
        "raw_lines",
        "raw",
        "linenum",
        "IsBlankLine",
        "line",
        "clean_lines",
        "elided",
        "elided",
        "linenum",
        "prev_line",
        "rfind",
        "prevbrace",
        "prev_line",
        "prevbrace",
        "find",
        "prev_line",
        "prevbrace",
        "find",
        "Match",
        "prev_line",
        "linenum",
        "search_position",
        "Match",
        "elided",
        "search_position",
        "search_position",
        "search_position",
        "elided",
        "search_position",
        "Match",
        "prev_line",
        "Match",
        "prev_line",
        "exception",
        "error",
        "filename",
        "linenum",
        "linenum",
        "clean_lines",
        "NumLines",
        "raw",
        "linenum",
        "next_line",
        "Match",
        "next_line",
        "next_line",
        "find",
        "next_line",
        "find",
        "error",
        "filename",
        "linenum",
        "Match",
        "prev_line",
        "matched",
        "error",
        "filename",
        "linenum",
        "matched",
        "group",
        "line",
        "find",
        "commentpos",
        "line",
        "count",
        "commentpos",
        "line",
        "count",
        "commentpos",
        "Match",
        "line",
        "commentpos",
        "line",
        "commentpos",
        "whitespace",
        "commentpos",
        "line",
        "commentpos",
        "whitespace",
        "error",
        "filename",
        "linenum",
        "commentpos",
        "commentend",
        "len",
        "line",
        "line",
        "commentend",
        "Search",
        "line",
        "commentend",
        "Search",
        "line",
        "commentend",
        "Search",
        "line",
        "commentend",
        "match",
        "error",
        "filename",
        "linenum",
        "CheckComment",
        "line",
        "commentpos",
        "filename",
        "linenum",
        "error",
        "clean_lines",
        "elided",
        "linenum",
        "re",
        "sub",
        "line",
        "Search",
        "line",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "match",
        "Search",
        "line",
        "Search",
        "line",
        "match",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "Search",
        "line",
        "match",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "Search",
        "line",
        "match",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "Search",
        "line",
        "match",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "Search",
        "line",
        "match",
        "len",
        "match",
        "group",
        "len",
        "match",
        "group",
        "match",
        "group",
        "len",
        "match",
        "group",
        "len",
        "match",
        "group",
        "match",
        "group",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "len",
        "match",
        "group",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "CheckSpacingForFunctionCall",
        "filename",
        "line",
        "linenum",
        "error",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "filename",
        "clean_lines",
        "class_info",
        "linenum",
        "error",
        "class_info",
        "last_line",
        "class_info",
        "linenum",
        "linenum",
        "class_info",
        "linenum",
        "Match",
        "clean_lines",
        "lines",
        "linenum",
        "matched",
        "clean_lines",
        "lines",
        "linenum",
        "IsBlankLine",
        "prev_line",
        "Search",
        "prev_line",
        "class_info",
        "linenum",
        "i",
        "class_info",
        "linenum",
        "linenum",
        "Search",
        "clean_lines",
        "lines",
        "i",
        "i",
        "end_class_head",
        "linenum",
        "error",
        "filename",
        "linenum",
        "matched",
        "group",
        "clean_lines",
        "linenum",
        "linenum",
        "prevlinenum",
        "clean_lines",
        "elided",
        "prevlinenum",
        "IsBlankLine",
        "prevline",
        "prevline",
        "prevlinenum",
        "prevlinenum",
        "filename",
        "clean_lines",
        "linenum",
        "error",
        "clean_lines",
        "elided",
        "linenum",
        "Match",
        "line",
        "GetPreviousNonBlankLine",
        "clean_lines",
        "linenum",
        "Search",
        "prevline",
        "error",
        "filename",
        "linenum",
        "Match",
        "line",
        "GetPreviousNonBlankLine",
        "clean_lines",
        "linenum",
        "Match",
        "prevline",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "Match",
        "line",
        "Search",
        "line",
        "line",
        "find",
        "line",
        "find",
        "pos",
        "pos",
        "CloseExpression",
        "clean_lines",
        "linenum",
        "pos",
        "endline",
        "endpos",
        "find",
        "error",
        "filename",
        "linenum",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Match",
        "line",
        "error",
        "filename",
        "linenum",
        "linenum",
        "GetPreviousNonBlankLine",
        "clean_lines",
        "prevlinenum",
        "Match",
        "line",
        "prevline",
        "count",
        "prevline",
        "line",
        "Search",
        "line",
        "line",
        "count",
        "line",
        "count",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "macro",
        "line",
        "macro",
        "match_constant",
        "match_constant",
        "Match",
        "match_this",
        "line",
        "Search",
        "line",
        "filename",
        "clean_lines",
        "linenum",
        "error",
        "clean_lines",
        "raw_lines",
        "macro",
        "_CHECK_MACROS",
        "raw_lines",
        "linenum",
        "find",
        "macro",
        "macro",
        "current_macro",
        "clean_lines",
        "elided",
        "linenum",
        "ReplaceableCheck",
        "current_macro",
        "line",
        "error",
        "filename",
        "linenum",
        "_CHECK_REPLACEMENT",
        "current_macro",
        "current_macro",
        "line",
        "isinstance",
        "line",
        "unicode",
        "uc",
        "unicodedata",
        "normalize",
        "line",
        "unicodedata",
        "east_asian_width",
        "uc",
        "width",
        "unicodedata",
        "combining",
        "uc",
        "width",
        "width",
        "len",
        "line",
        "filename",
        "clean_lines",
        "linenum",
        "file_extension",
        "class_state",
        "error",
        "clean_lines",
        "raw_lines",
        "raw_lines",
        "linenum",
        "line",
        "find",
        "error",
        "filename",
        "linenum",
        "clean_lines",
        "elided",
        "linenum",
        "initial_spaces",
        "len",
        "line",
        "line",
        "initial_spaces",
        "initial_spaces",
        "line",
        "line",
        "isspace",
        "error",
        "filename",
        "linenum",
        "initial_spaces",
        "initial_spaces",
        "Match",
        "cleansed_line",
        "error",
        "filename",
        "linenum",
        "initial_spaces",
        "line",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "file_extension",
        "GetHeaderGuardCPPVariable",
        "filename",
        "line",
        "startswith",
        "cppvar",
        "line",
        "startswith",
        "cppvar",
        "line",
        "startswith",
        "cppvar",
        "line",
        "startswith",
        "is_header_guard",
        "Match",
        "line",
        "Match",
        "line",
        "GetLineWidth",
        "line",
        "line_width",
        "error",
        "filename",
        "linenum",
        "line_width",
        "error",
        "filename",
        "linenum",
        "cleansed_line",
        "count",
        "cleansed_line",
        "find",
        "GetPreviousNonBlankLine",
        "clean_lines",
        "linenum",
        "find",
        "GetPreviousNonBlankLine",
        "clean_lines",
        "linenum",
        "find",
        "cleansed_line",
        "find",
        "cleansed_line",
        "find",
        "cleansed_line",
        "find",
        "error",
        "filename",
        "linenum",
        "CheckBraces",
        "filename",
        "clean_lines",
        "linenum",
        "error",
        "CheckSpacing",
        "filename",
        "clean_lines",
        "linenum",
        "error",
        "CheckCheck",
        "filename",
        "clean_lines",
        "linenum",
        "error",
        "class_state",
        "class_state",
        "classinfo_stack",
        "CheckSectionSpacing",
        "filename",
        "clean_lines",
        "class_state",
        "classinfo_stack",
        "linenum",
        "error",
        "re",
        "compile",
        "re",
        "compile",
        "re",
        "compile",
        "filename",
        "suffix",
        "filename",
        "endswith",
        "suffix",
        "len",
        "filename",
        "len",
        "suffix",
        "filename",
        "len",
        "suffix",
        "filename",
        "len",
        "suffix",
        "os",
        "path",
        "splitext",
        "filename",
        "filename",
        "filename",
        "endswith",
        "filename",
        "endswith",
        "filename",
        "endswith",
        "fileinfo",
        "include",
        "is_system",
        "include",
        "_STL_HEADERS",
        "is_stl_h",
        "include",
        "_CPP_HEADERS",
        "is_system",
        "is_cpp_h",
        "_CPP_SYS_HEADER",
        "_C_SYS_HEADER",
        "os",
        "path",
        "split",
        "_DropCommonSuffixes",
        "fileinfo",
        "RepositoryName",
        "os",
        "path",
        "split",
        "_DropCommonSuffixes",
        "include",
        "target_base",
        "include_base",
        "include_dir",
        "target_dir",
        "include_dir",
        "os",
        "path",
        "normpath",
        "target_dir",
        "_LIKELY_MY_HEADER",
        "_RE_FIRST_COMPONENT",
        "match",
        "target_base",
        "_RE_FIRST_COMPONENT",
        "match",
        "include_base",
        "target_first_component",
        "include_first_component",
        "target_first_component",
        "group",
        "include_first_component",
        "group",
        "_POSSIBLE_MY_HEADER",
        "_OTHER_HEADER",
        "filename",
        "clean_lines",
        "linenum",
        "include_state",
        "error",
        "FileInfo",
        "filename",
        "clean_lines",
        "lines",
        "linenum",
        "_RE_PATTERN_INCLUDE_NEW_STYLE",
        "search",
        "line",
        "error",
        "filename",
        "linenum",
        "_RE_PATTERN_INCLUDE",
        "search",
        "line",
        "match",
        "match",
        "group",
        "match",
        "group",
        "include",
        "include_state",
        "error",
        "filename",
        "linenum",
        "include",
        "filename",
        "include_state",
        "include",
        "linenum",
        "include_state",
        "CheckNextIncludeOrder",
        "_ClassifyInclude",
        "fileinfo",
        "include",
        "is_system",
        "error_message",
        "error",
        "filename",
        "linenum",
        "error_message",
        "fileinfo",
        "BaseName",
        "include_state",
        "IsInAlphabeticalOrder",
        "include",
        "error",
        "filename",
        "linenum",
        "include",
        "_RE_PATTERN_INCLUDE",
        "match",
        "line",
        "match",
        "match",
        "group",
        "Match",
        "include",
        "_IsTestFilename",
        "filename",
        "error",
        "filename",
        "linenum",
        "text",
        "start_pattern",
        "matching_punctuation",
        "itervalues",
        "re",
        "search",
        "start_pattern",
        "text",
        "re",
        "M",
        "match",
        "match",
        "end",
        "start_position",
        "text",
        "start_position",
        "matching_punctuation",
        "matching_punctuation",
        "text",
        "start_position",
        "start_position",
        "punctuation_stack",
        "position",
        "len",
        "text",
        "text",
        "position",
        "punctuation_stack",
        "punctuation_stack",
        "pop",
        "text",
        "position",
        "closing_punctuation",
        "text",
        "position",
        "matching_punctuation",
        "punctuation_stack",
        "append",
        "matching_punctuation",
        "text",
        "position",
        "position",
        "punctuation_stack",
        "text",
        "start_position",
        "position",
        "filename",
        "clean_lines",
        "linenum",
        "file_extension",
        "include_state",
        "error",
        "clean_lines",
        "elided",
        "linenum",
        "line",
        "_RE_PATTERN_INCLUDE",
        "search",
        "line",
        "match",
        "CheckIncludeLine",
        "filename",
        "clean_lines",
        "linenum",
        "include_state",
        "error",
        "linenum",
        "clean_lines",
        "NumLines",
        "line",
        "clean_lines",
        "elided",
        "linenum",
        "line",
        "os",
        "path",
        "abspath",
        "filename",
        "replace",
        "line",
        "split",
        "len",
        "re",
        "findall",
        "fnline",
        "len",
        "re",
        "findall",
        "fnline",
        "len",
        "re",
        "findall",
        "fnline",
        "Search",
        "fnline",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "match",
        "match",
        "group",
        "Match",
        "line",
        "Match",
        "line",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "CheckCStyleCast",
        "filename",
        "linenum",
        "line",
        "clean_lines",
        "raw_lines",
        "linenum",
        "error",
        "CheckCStyleCast",
        "filename",
        "linenum",
        "line",
        "clean_lines",
        "raw_lines",
        "linenum",
        "error",
        "CheckCStyleCast",
        "filename",
        "linenum",
        "line",
        "clean_lines",
        "raw_lines",
        "linenum",
        "error",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Match",
        "line",
        "match",
        "Match",
        "match",
        "group",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "match",
        "group",
        "Search",
        "line",
        "_IsTestFilename",
        "filename",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "file_extension",
        "Search",
        "line",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "match",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "Search",
        "line",
        "match",
        "match",
        "group",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "match",
        "group",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "match",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "_GetTextInside",
        "line",
        "printf_args",
        "Match",
        "printf_args",
        "match",
        "re",
        "search",
        "line",
        "re",
        "I",
        "group",
        "error",
        "filename",
        "linenum",
        "function_name",
        "match",
        "group",
        "Search",
        "line",
        "match",
        "Match",
        "match",
        "group",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "match",
        "group",
        "Search",
        "line",
        "error",
        "filename",
        "linenum",
        "Match",
        "line",
        "match",
        "match",
        "group",
        "match",
        "group",
        "match",
        "group",
        "find",
        "re",
        "split",
        "match",
        "group",
        "tok",
        "tokens",
        "skip_next",
        "Search",
        "tok",
        "Search",
        "tok",
        "tok",
        "lstrip",
        "tok",
        "rstrip",
        "tok",
        "Match",
        "tok",
        "Match",
        "tok",
        "Match",
        "tok",
        "Match",
        "tok",
        "Match",
        "tok",
        "tok",
        "startswith",
        "is_const",
        "error",
        "filename",
        "linenum",
        "Match",
        "line",
        "match",
        "linenum",
        "clean_lines",
        "NumLines",
        "clean_lines",
        "elided",
        "linenum",
        "Search",
        "next_line",
        "error",
        "filename",
        "linenum",
        "match",
        "group",
        "file_extension",
        "Search",
        "line",
        "line",
        "error",
        "filename",
        "linenum",
        "filename",
        "linenum",
        "line",
        "raw_line",
        "cast_type",
        "pattern",
        "error",
        "Search",
        "pattern",
        "line",
        "match",
        "Match",
        "line",
        "match",
        "start",
        "sizeof_match",
        "error",
        "filename",
        "linenum",
        "line",
        "match",
        "end",
        "Match",
        "remainder",
        "function_match",
        "function_match",
        "group",
        "function_match",
        "group",
        "raw_line",
        "raw_line",
        "error",
        "filename",
        "linenum",
        "error",
        "filename",
        "linenum",
        "cast_type",
        "match",
        "group",
        "re",
        "compile",
        "_template",
        "_re_pattern_algorithm_header",
        "append",
        "re",
        "compile",
        "_template",
        "_template",
        "_header",
        "_templates",
        "_HEADERS_CONTAINING_TEMPLATES",
        "_template",
        "_templates",
        "_re_pattern_templates",
        "append",
        "re",
        "compile",
        "_template",
        "_template",
        "_header",
        "filename_cc",
        "filename_h",
        "filename_cc",
        "endswith",
        "filename_cc",
        "len",
        "filename_cc",
        "endswith",
        "filename_cc",
        "len",
        "filename_cc",
        "endswith",
        "filename_cc",
        "len",
        "filename_cc",
        "replace",
        "filename_cc",
        "replace",
        "filename_h",
        "endswith",
        "filename_h",
        "len",
        "filename_h",
        "endswith",
        "filename_h",
        "len",
        "filename_h",
        "replace",
        "filename_h",
        "replace",
        "filename_cc",
        "endswith",
        "filename_h",
        "files_belong_to_same_module",
        "filename_cc",
        "len",
        "filename_h",
        "files_belong_to_same_module",
        "common_path",
        "filename",
        "include_state",
        "io",
        "codecs",
        "io",
        "open",
        "filename",
        "IOError",
        "line",
        "headerfile",
        "linenum",
        "CleanseComments",
        "line",
        "_RE_PATTERN_INCLUDE",
        "search",
        "clean_line",
        "match",
        "match",
        "group",
        "include_state",
        "setdefault",
        "include",
        "filename",
        "linenum",
        "filename",
        "clean_lines",
        "include_state",
        "error",
        "io",
        "codecs",
        "linenum",
        "xrange",
        "clean_lines",
        "NumLines",
        "clean_lines",
        "elided",
        "linenum",
        "line",
        "line",
        "_RE_PATTERN_STRING",
        "search",
        "line",
        "matched",
        "line",
        "matched",
        "start",
        "prefix",
        "endswith",
        "prefix",
        "endswith",
        "linenum",
        "pattern",
        "template",
        "header",
        "_re_pattern_algorithm_header",
        "pattern",
        "search",
        "line",
        "linenum",
        "template",
        "line",
        "pattern",
        "template",
        "header",
        "_re_pattern_templates",
        "pattern",
        "search",
        "line",
        "linenum",
        "template",
        "include_state",
        "copy",
        "FileInfo",
        "filename",
        "FullName",
        "re",
        "sub",
        "abs_filename",
        "include_state",
        "keys",
        "header",
        "header_keys",
        "FilesBelongToSameModule",
        "abs_filename",
        "header",
        "common_path",
        "header",
        "same_module",
        "UpdateIncludeState",
        "fullpath",
        "include_state",
        "io",
        "filename",
        "endswith",
        "header_found",
        "required_header_unstripped",
        "required",
        "required",
        "required_header_unstripped",
        "required_header_unstripped",
        "strip",
        "include_state",
        "error",
        "filename",
        "required",
        "required_header_unstripped",
        "required_header_unstripped",
        "template",
        "re",
        "compile",
        "filename",
        "clean_lines",
        "linenum",
        "error",
        "clean_lines",
        "raw_lines",
        "raw",
        "linenum",
        "_RE_PATTERN_EXPLICIT_MAKEPAIR",
        "search",
        "line",
        "match",
        "error",
        "filename",
        "linenum",
        "filename",
        "file_extension",
        "clean_lines",
        "line",
        "include_state",
        "function_state",
        "class_state",
        "error",
        "extra_check_functions",
        "clean_lines",
        "raw_lines",
        "ParseNolintSuppressions",
        "filename",
        "raw_lines",
        "line",
        "line",
        "error",
        "CheckForFunctionLengths",
        "filename",
        "clean_lines",
        "line",
        "function_state",
        "error",
        "CheckForMultilineCommentsAndStrings",
        "filename",
        "clean_lines",
        "line",
        "error",
        "CheckStyle",
        "filename",
        "clean_lines",
        "line",
        "file_extension",
        "class_state",
        "error",
        "CheckLanguage",
        "filename",
        "clean_lines",
        "line",
        "file_extension",
        "include_state",
        "error",
        "CheckForNonStandardConstructs",
        "filename",
        "clean_lines",
        "line",
        "class_state",
        "error",
        "CheckPosixThreading",
        "filename",
        "clean_lines",
        "line",
        "error",
        "CheckInvalidIncrement",
        "filename",
        "clean_lines",
        "line",
        "error",
        "CheckMakePairUsesDeduction",
        "filename",
        "clean_lines",
        "line",
        "error",
        "check_fn",
        "extra_check_functions",
        "check_fn",
        "filename",
        "clean_lines",
        "line",
        "error",
        "filename",
        "file_extension",
        "lines",
        "error",
        "extra_check_functions",
        "lines",
        "_IncludeState",
        "_FunctionState",
        "_ClassState",
        "ResetNolintSuppressions",
        "CheckForCopyright",
        "filename",
        "lines",
        "error",
        "file_extension",
        "CheckForHeaderGuard",
        "filename",
        "lines",
        "error",
        "RemoveMultiLineComments",
        "filename",
        "lines",
        "error",
        "CleansedLines",
        "lines",
        "line",
        "xrange",
        "clean_lines",
        "NumLines",
        "ProcessLine",
        "filename",
        "file_extension",
        "clean_lines",
        "line",
        "include_state",
        "function_state",
        "class_state",
        "error",
        "extra_check_functions",
        "class_state",
        "CheckFinished",
        "filename",
        "error",
        "CheckForIncludeWhatYouUse",
        "filename",
        "clean_lines",
        "include_state",
        "error",
        "CheckForUnicodeReplacementCharacters",
        "filename",
        "lines",
        "error",
        "CheckForNewlineAtEOF",
        "filename",
        "lines",
        "error",
        "filename",
        "vlevel",
        "extra_check_functions",
        "_SetVerboseLevel",
        "vlevel",
        "filename",
        "codecs",
        "StreamReaderWriter",
        "sys",
        "stdin",
        "codecs",
        "getreader",
        "codecs",
        "getwriter",
        "read",
        "split",
        "codecs",
        "open",
        "filename",
        "read",
        "split",
        "linenum",
        "len",
        "lines",
        "lines",
        "linenum",
        "endswith",
        "lines",
        "linenum",
        "rstrip",
        "IOError",
        "sys",
        "stderr",
        "write",
        "filename",
        "filename",
        "filename",
        "rfind",
        "filename",
        "file_extension",
        "file_extension",
        "file_extension",
        "sys",
        "stderr",
        "write",
        "filename",
        "ProcessFileData",
        "filename",
        "file_extension",
        "lines",
        "extra_check_functions",
        "carriage_return_found",
        "os",
        "linesep",
        "filename",
        "sys",
        "stderr",
        "write",
        "filename",
        "message",
        "sys",
        "stderr",
        "write",
        "_USAGE",
        "message",
        "sys",
        "exit",
        "message",
        "sys",
        "exit",
        "sys",
        "stderr",
        "write",
        "join",
        "cat",
        "cat",
        "_ERROR_CATEGORIES",
        "sys",
        "exit",
        "args",
        "getopt",
        "getopt",
        "args",
        "getopt",
        "GetoptError",
        "PrintUsage",
        "_VerboseLevel",
        "_OutputFormat",
        "opt",
        "val",
        "opts",
        "opt",
        "PrintUsage",
        "opt",
        "val",
        "PrintUsage",
        "val",
        "opt",
        "val",
        "opt",
        "val",
        "filters",
        "PrintCategories",
        "opt",
        "val",
        "PrintUsage",
        "val",
        "filenames",
        "PrintUsage",
        "_SetOutputFormat",
        "output_format",
        "_SetVerboseLevel",
        "verbosity",
        "_SetFilters",
        "filters",
        "_SetCountingStyle",
        "counting_style",
        "filenames",
        "ParseArguments",
        "sys",
        "argv",
        "codecs",
        "StreamReaderWriter",
        "sys",
        "stderr",
        "codecs",
        "getreader",
        "codecs",
        "getwriter",
        "_cpplint_state",
        "ResetErrorCounts",
        "filename",
        "filenames",
        "ProcessFile",
        "filename",
        "_cpplint_state",
        "verbose_level",
        "_cpplint_state",
        "PrintErrorCounts",
        "sys",
        "exit",
        "_cpplint_state",
        "error_count",
        "main"
    ],
    "literals": [
        "'build/class'",
        "'build/deprecated'",
        "'build/endif_comment'",
        "'build/explicit_make_pair'",
        "'build/forward_decl'",
        "'build/header_guard'",
        "'build/include'",
        "'build/include_alpha'",
        "'build/include_order'",
        "'build/include_what_you_use'",
        "'build/namespaces'",
        "'build/printf_format'",
        "'build/storage_class'",
        "'legal/copyright'",
        "'readability/braces'",
        "'readability/casting'",
        "'readability/check'",
        "'readability/constructors'",
        "'readability/fn_size'",
        "'readability/function'",
        "'readability/multiline_comment'",
        "'readability/multiline_string'",
        "'readability/nolint'",
        "'readability/streams'",
        "'readability/todo'",
        "'readability/utf8'",
        "'runtime/arrays'",
        "'runtime/casting'",
        "'runtime/explicit'",
        "'runtime/int'",
        "'runtime/init'",
        "'runtime/invalid_increment'",
        "'runtime/member_string_references'",
        "'runtime/memset'",
        "'runtime/operator'",
        "'runtime/printf'",
        "'runtime/printf_format'",
        "'runtime/references'",
        "'runtime/rtti'",
        "'runtime/sizeof'",
        "'runtime/string'",
        "'runtime/threadsafe_fn'",
        "'runtime/virtual'",
        "'whitespace/blank_line'",
        "'whitespace/braces'",
        "'whitespace/comma'",
        "'whitespace/comments'",
        "'whitespace/end_of_line'",
        "'whitespace/ending_newline'",
        "'whitespace/indent'",
        "'whitespace/labels'",
        "'whitespace/line_length'",
        "'whitespace/newline'",
        "'whitespace/operators'",
        "'whitespace/parens'",
        "'whitespace/semicolon'",
        "'whitespace/tab'",
        "'whitespace/todo'",
        "'-build/include_alpha'",
        "'algobase.h'",
        "'algorithm'",
        "'alloc.h'",
        "'bitset'",
        "'deque'",
        "'exception'",
        "'function.h'",
        "'functional'",
        "'hash_map'",
        "'hash_map.h'",
        "'hash_set'",
        "'hash_set.h'",
        "'iterator'",
        "'list'",
        "'list.h'",
        "'map'",
        "'memory'",
        "'new'",
        "'pair.h'",
        "'pthread_alloc'",
        "'queue'",
        "'set'",
        "'set.h'",
        "'sstream'",
        "'stack'",
        "'stl_alloc.h'",
        "'stl_relops.h'",
        "'type_traits.h'",
        "'utility'",
        "'vector'",
        "'vector.h'",
        "'algo.h'",
        "'builtinbuf.h'",
        "'bvector.h'",
        "'cassert'",
        "'cctype'",
        "'cerrno'",
        "'cfloat'",
        "'ciso646'",
        "'climits'",
        "'clocale'",
        "'cmath'",
        "'complex'",
        "'complex.h'",
        "'csetjmp'",
        "'csignal'",
        "'cstdarg'",
        "'cstddef'",
        "'cstdio'",
        "'cstdlib'",
        "'cstring'",
        "'ctime'",
        "'cwchar'",
        "'cwctype'",
        "'defalloc.h'",
        "'deque.h'",
        "'editbuf.h'",
        "'exception'",
        "'fstream'",
        "'fstream.h'",
        "'hashtable.h'",
        "'heap.h'",
        "'indstream.h'",
        "'iomanip'",
        "'iomanip.h'",
        "'ios'",
        "'iosfwd'",
        "'iostream'",
        "'iostream.h'",
        "'istream'",
        "'istream.h'",
        "'iterator.h'",
        "'limits'",
        "'map.h'",
        "'multimap.h'",
        "'multiset.h'",
        "'numeric'",
        "'ostream'",
        "'ostream.h'",
        "'parsestream.h'",
        "'pfstream.h'",
        "'PlotFile.h'",
        "'procbuf.h'",
        "'pthread_alloc.h'",
        "'rope'",
        "'rope.h'",
        "'ropeimpl.h'",
        "'SFile.h'",
        "'slist'",
        "'slist.h'",
        "'stack.h'",
        "'stdexcept'",
        "'stdiostream.h'",
        "'streambuf.h'",
        "'stream.h'",
        "'strfile.h'",
        "'string'",
        "'strstream'",
        "'strstream.h'",
        "'tempbuf.h'",
        "'tree.h'",
        "'typeinfo'",
        "'valarray'",
        "'DCHECK'",
        "'CHECK'",
        "'EXPECT_TRUE_M'",
        "'EXPECT_TRUE'",
        "'ASSERT_TRUE_M'",
        "'ASSERT_TRUE'",
        "'EXPECT_FALSE_M'",
        "'EXPECT_FALSE'",
        "'ASSERT_FALSE_M'",
        "'ASSERT_FALSE'",
        "'=='",
        "'EQ'",
        "'!='",
        "'NE'",
        "'>='",
        "'GE'",
        "'>'",
        "'GT'",
        "'<='",
        "'LE'",
        "'<'",
        "'LT'",
        "'DCHECK'",
        "'DCHECK_%s'",
        "'CHECK'",
        "'CHECK_%s'",
        "'EXPECT_TRUE'",
        "'EXPECT_%s'",
        "'ASSERT_TRUE'",
        "'ASSERT_%s'",
        "'EXPECT_TRUE_M'",
        "'EXPECT_%s_M'",
        "'ASSERT_TRUE_M'",
        "'ASSERT_%s_M'",
        "'=='",
        "'NE'",
        "'!='",
        "'EQ'",
        "'>='",
        "'LT'",
        "'>'",
        "'LE'",
        "'<='",
        "'GT'",
        "'<'",
        "'GE'",
        "'EXPECT_FALSE'",
        "'EXPECT_%s'",
        "'ASSERT_FALSE'",
        "'ASSERT_%s'",
        "'EXPECT_FALSE_M'",
        "'EXPECT_%s_M'",
        "'ASSERT_FALSE_M'",
        "'ASSERT_%s_M'",
        "r'\\bNOLINT\\b(\\([^)]*\\))?'",
        "'(*)'",
        "'('",
        "')'",
        "'readability/nolint'",
        "'Unknown NOLINT error category: %s'",
        "\"Resets the set of NOLINT suppressions to empty.\"",
        "'C system header'",
        "'C++ system header'",
        "'header this file implements'",
        "'header this file may implement'",
        "'other header'",
        "\"... nothing. (This can't be an error.)\"",
        "'a header this file implements'",
        "'C system header'",
        "'C++ system header'",
        "'other header'",
        "''",
        "'-inl.h'",
        "'.h'",
        "'-'",
        "'_'",
        "'Found %s after %s'",
        "''",
        "''",
        "''",
        "''",
        "'total'",
        "'emacs'",
        "','",
        "'+'",
        "'-'",
        "'Every filter in --filters must start with + or -'",
        "' (%s does not)'",
        "'toplevel'",
        "'detailed'",
        "'detailed'",
        "'/'",
        "'Category \\'%s\\' errors found: %d\\n'",
        "'Total errors found: %d\\n'",
        "''",
        "r'T(EST|est)'",
        "'readability/fn_size'",
        "'Small and focused functions are preferred:'",
        "' %s has %d non-comment lines'",
        "' (error triggered by exceeding %d lines).'",
        "'\\\\'",
        "'/'",
        "\".svn\"",
        "\".svn\"",
        "\".git\"",
        "\".hg\"",
        "\".svn\"",
        "\".git\"",
        "\".hg\"",
        "\".svn\"",
        "'/'",
        "'c'",
        "'cc'",
        "'cpp'",
        "'cxx'",
        "'-'",
        "'+'",
        "'vs7'",
        "'%s(%s):  %s  [%s] [%d]\\n'",
        "'%s:%s:  %s  [%s] [%d]\\n'",
        "r'\\\\([abfnrtv?\"\\\\\\']|\\d+|x[0-9a-fA-F]+)'",
        "r'\"[^\"]*\"'",
        "r\"'.'\"",
        "r\"\"\"(\\s*/\\*.*\\*/\\s*$|\n            /\\*.*\\*/\\s+|\n         \\s+/\\*.*\\*/(?=\\W)|\n            /\\*.*\\*/)\"\"\"",
        "r'\\\\'",
        "'XX'",
        "'\"'",
        "r'\\\"'",
        "\"'\\\"'\"",
        "'/*'",
        "'*/'",
        "'*/'",
        "'// dummy'",
        "'readability/multiline_comment'",
        "'Could not find end of multi-line comment'",
        "'//'",
        "''",
        "''",
        "\"''\"",
        "'\"\"'",
        "'({['",
        "'('",
        "')'",
        "'['",
        "']'",
        "'{'",
        "'}'",
        "')'",
        "r'Copyright'",
        "'legal/copyright'",
        "'No copyright message found.  '",
        "'You should have a line: \"Copyright [year] <Copyright Owner>\"'",
        "r'_flymake\\.h$'",
        "'.h'",
        "r'[-./\\s]'",
        "'_'",
        "'_'",
        "'#ifndef'",
        "'#define'",
        "'#endif'",
        "'build/header_guard'",
        "'No #ifndef header guard found, suggested CPP variable is: %s'",
        "'build/header_guard'",
        "'No #define header guard found, suggested CPP variable is: %s'",
        "'_'",
        "'build/header_guard'",
        "'#ifndef header guard has wrong style, please use: %s'",
        "'build/header_guard'",
        "'#ifndef and #define don\\'t match, suggested CPP variable is: %s'",
        "'#endif  // %s'",
        "'#endif  // %s'",
        "'_'",
        "'build/header_guard'",
        "'#endif line should be \"#endif  // %s\"'",
        "u'\\ufffd'",
        "'readability/utf8'",
        "'Line contains invalid UTF-8 (or Unicode replacement character).'",
        "'whitespace/ending_newline'",
        "'Could not find a newline character at the end of the file.'",
        "'\\\\\\\\'",
        "''",
        "'/*'",
        "'*/'",
        "'readability/multiline_comment'",
        "'Complex multi-line /*...*/-style comment found. '",
        "'Lint may give bogus warnings.  '",
        "'Consider replacing these with //-style comments, '",
        "'with #if 0...#endif, '",
        "'or with more clearly structured multi-line comments.'",
        "'\"'",
        "'\\\\\"'",
        "'readability/multiline_string'",
        "'Multi-line string (\"...\") found.  This lint script doesn\\'t '",
        "'do well with such strings, and may give bogus warnings.  They\\'re '",
        "'ugly and unnecessary, and you should use concatenation instead\".'",
        "'asctime('",
        "'asctime_r('",
        "'ctime('",
        "'ctime_r('",
        "'getgrgid('",
        "'getgrgid_r('",
        "'getgrnam('",
        "'getgrnam_r('",
        "'getlogin('",
        "'getlogin_r('",
        "'getpwnam('",
        "'getpwnam_r('",
        "'getpwuid('",
        "'getpwuid_r('",
        "'gmtime('",
        "'gmtime_r('",
        "'localtime('",
        "'localtime_r('",
        "'rand('",
        "'rand_r('",
        "'readdir('",
        "'readdir_r('",
        "'strtok('",
        "'strtok_r('",
        "'ttyname('",
        "'ttyname_r('",
        "'_'",
        "'.'",
        "'>'",
        "'runtime/threadsafe_fn'",
        "'Consider using '",
        "'...) instead of '",
        "'...) for improved thread safety.'",
        "r'^\\s*\\*\\w+(\\+\\+|--);'",
        "'runtime/invalid_increment'",
        "'Changing pointer instead of value (or unused value of operator*).'",
        "'{'",
        "'}'",
        "'build/class'",
        "'Failed to find complete declaration of class %s'",
        "r'printf\\s*\\(.*\".*%[-+ ]?\\d*q'",
        "'runtime/printf_format'",
        "'%q in format strings is deprecated.  Use %ll instead.'",
        "r'printf\\s*\\(.*\".*%\\d+\\$'",
        "'runtime/printf_format'",
        "'%N$ formats are unconventional.  Try rewriting to avoid them.'",
        "'\\\\\\\\'",
        "''",
        "r'(\"|\\').*\\\\(%|\\[|\\(|{)'",
        "'build/printf_format'",
        "'%, [, (, and { are undefined character escapes.  Unescape them.'",
        "r'\\b(const|volatile|void|char|short|int|long'",
        "r'|float|double|signed|unsigned'",
        "r'|schar|u?int8|u?int16|u?int32|u?int64)'",
        "r'\\s+(auto|register|static|extern|typedef)\\b'",
        "'build/storage_class'",
        "'Storage class (static, extern, typedef, etc) should be first.'",
        "r'\\s*#\\s*endif\\s*[^/\\s]+'",
        "'build/endif_comment'",
        "'Uncommented text after #endif is non-standard.  Use a comment.'",
        "r'\\s*class\\s+(\\w+\\s*::\\s*)+\\w+\\s*;'",
        "'build/forward_decl'",
        "'Inner-style forward declarations are invalid.  Remove this line.'",
        "r'(\\w+|[+-]?\\d+(\\.\\d*)?)\\s*(<|>)\\?=?\\s*(\\w+|[+-]?\\d+)(\\.\\d*)?'",
        "'build/deprecated'",
        "'>? and <? (max and min) operators are non-standard and deprecated.'",
        "r'^\\s*const\\s*string\\s*&\\s*\\w+\\s*;'",
        "'runtime/member_string_references'",
        "'const string& members are dangerous. It is much better to use '",
        "'alternatives, such as pointers or simple constants.'",
        "r'\\s*(template\\s*<[\\w\\s<>,:]*>\\s*)?'",
        "'(class|struct)\\s+([A-Z_]+\\s+)*(\\w+(::\\w+)*)'",
        "';'",
        "'{'",
        "'(^|[^:]):($|[^:])'",
        "'::'",
        "r'\\s+(?:inline\\s+)?%s\\s*\\(([^,()]+)\\)'",
        "'void'",
        "r'(const\\s+)?%s\\s*(?:<\\w+>\\s*)?&'",
        "'runtime/explicit'",
        "'Single-argument constructors should be marked explicit.'",
        "r'\\bvirtual\\b'",
        "r'~%s\\s*\\('",
        "'{'",
        "'}'",
        "'runtime/virtual'",
        "'The class %s probably needs a virtual destructor due to '",
        "'having virtual method(s), one declared at line %d.'",
        "r'\\bif\\s*\\((.*)\\)\\s*{'",
        "r'\\bfor\\s*\\((.*)\\)\\s*{'",
        "r'\\bwhile\\s*\\((.*)\\)\\s*[{;]'",
        "r'\\bswitch\\s*\\((.*)\\)\\s*{'",
        "r'\\b(if|for|while|switch|return|delete)\\b'",
        "r' \\([^)]+\\)\\([^)]*(\\)|,$)'",
        "r' \\([^)]+\\)\\[[^\\]]+\\]'",
        "r'\\w\\s*\\(\\s(?!\\s*\\\\$)'",
        "'whitespace/parens'",
        "'Extra space after ( in function call'",
        "r'\\(\\s+(?!(\\s*\\\\)|\\()'",
        "'whitespace/parens'",
        "'Extra space after ('",
        "r'\\w\\s+\\('",
        "r'#\\s*define|typedef'",
        "'whitespace/parens'",
        "'Extra space before ( in function call'",
        "r'[^)]\\s+\\)\\s*[^{\\s]'",
        "r'^\\s+\\)'",
        "'whitespace/parens'",
        "'Closing ) should be moved to the previous line'",
        "'whitespace/parens'",
        "'Extra space before )'",
        "''",
        "r'(\\w(\\w|::|\\*|\\&|\\s)*)\\('",
        "'TEST'",
        "'TEST_F'",
        "r'[A-Z_]+$'",
        "' '",
        "r'(;|})'",
        "r'{'",
        "r'((\\w|:)*)\\('",
        "r'TEST'",
        "r'(\\(.*\\))'",
        "'()'",
        "'readability/fn_size'",
        "'Lint failed to find start of function body.'",
        "r'^\\}\\s*$'",
        "r'^\\s*$'",
        "r'^//(\\s*)TODO(\\(.+?\\))?:?(\\s|$)?'",
        "'whitespace/todo'",
        "'Too many spaces before TODO'",
        "'readability/todo'",
        "'Missing username in TODO; it should look like '",
        "'\"// TODO(my_username): Stuff.\"'",
        "' '",
        "''",
        "'whitespace/todo'",
        "'TODO(my_username) should be followed by a space'",
        "'{'",
        "'}'",
        "'namespace'",
        "r' {6}\\w'",
        "r' {6}\\w'",
        "'    :'",
        "r' {4}\\w[^\\(]*\\)\\s*(const\\s*)?(\\{\\s*$|:)'",
        "r' {4}:'",
        "'whitespace/blank_line'",
        "'Blank line at the start of a code block.  Is this needed?'",
        "r'\\s*}'",
        "'namespace'",
        "'} else '",
        "'whitespace/blank_line'",
        "'Blank line at the end of a code block.  Is this needed?'",
        "r'\\s*(public|protected|private):'",
        "'whitespace/blank_line'",
        "'Do not leave a blank line after \"%s:\"'",
        "'//'",
        "'\"'",
        "'\\\\\"'",
        "r'^\\s*{ //'",
        "'whitespace/comments'",
        "'At least two spaces is best between code and comments'",
        "' '",
        "r'[=/-]{4,}\\s*$'",
        "r'^/$'",
        "r'^/+ '",
        "'whitespace/comments'",
        "'Should have a space between // and comment'",
        "r'operator(==|!=|<|<<|<=|>=|>>|>)\\('",
        "'operator\\('",
        "r'[\\w.]=[\\w.]'",
        "r'\\b(if|while) '",
        "'whitespace/operators'",
        "'Missing spaces around ='",
        "r'[^<>=!\\s](==|!=|<=|>=)[^<>=!\\s]'",
        "r'<[^<]*,\\s*$'",
        "r'[^<>=!\\s](<)[^<>=!\\s]([^>]|->)*$'",
        "'whitespace/operators'",
        "'Missing spaces around %s'",
        "r'[^0-9\\s](<<|>>)[^0-9\\s]'",
        "'whitespace/operators'",
        "'Missing spaces around %s'",
        "r'(!\\s|~\\s|[\\s]--[\\s;]|[\\s]\\+\\+[\\s;])'",
        "'whitespace/operators'",
        "'Extra space for operator %s'",
        "r' (if\\(|for\\(|while\\(|switch\\()'",
        "'whitespace/parens'",
        "'Missing space before ( in %s'",
        "r'\\b(if|for|while|switch)\\s*'",
        "r'\\(([ ]*)(.).*[^ ]+([ ]*)\\)\\s*{\\s*$'",
        "';'",
        "r'\\bfor\\s*\\(.*; \\)'",
        "'whitespace/parens'",
        "'Mismatching spaces inside () in %s'",
        "'whitespace/parens'",
        "'Should have zero or one spaces inside ( and ) in %s'",
        "r',[^\\s]'",
        "'whitespace/comma'",
        "'Missing space after ,'",
        "r';[^\\s};\\\\)/]'",
        "'whitespace/semicolon'",
        "'Missing space after ;'",
        "r'[^ ({]{'",
        "'whitespace/braces'",
        "'Missing space before {'",
        "r'}else'",
        "'whitespace/braces'",
        "'Missing space before else'",
        "r'\\w\\s+\\['",
        "r'delete\\s+\\['",
        "'whitespace/braces'",
        "'Extra space before ['",
        "r':\\s*;\\s*$'",
        "'whitespace/semicolon'",
        "'Semicolon defining empty statement. Use { } instead.'",
        "r'^\\s*;\\s*$'",
        "'whitespace/semicolon'",
        "'Line contains only semicolon. If this should be an empty statement, '",
        "'use { } instead.'",
        "r'\\s+;\\s*$'",
        "r'\\bfor\\b'",
        "'whitespace/semicolon'",
        "'Extra space before last semicolon. If this should be an empty '",
        "'statement, use { } instead.'",
        "r'\\s*(public|protected|private):'",
        "r'\\b(class|struct)\\b'",
        "r'\\{\\s*$'",
        "'whitespace/blank_line'",
        "'\"%s:\" should be preceded by a blank line'",
        "''",
        "r'\\s*{\\s*$'",
        "r'[;:}{]\\s*$'",
        "'whitespace/braces'",
        "'{ should almost always be at the end of the previous line'",
        "r'\\s*else\\s*'",
        "r'\\s*}\\s*$'",
        "'whitespace/newline'",
        "'An else should appear on the same line as the preceding }'",
        "r'}\\s*else[^{]*$'",
        "r'[^}]*else\\s*{'",
        "r'}\\s*else if([^{]*)$'",
        "'else if'",
        "'('",
        "'{'",
        "'readability/braces'",
        "'If an else has a brace on one side, it should have it on both'",
        "'readability/braces'",
        "'If an else has a brace on one side, it should have it on both'",
        "r'\\belse [^\\s{]'",
        "r'\\belse if\\b'",
        "'whitespace/newline'",
        "'Else clause should never be on same line as else (use 2 lines)'",
        "r'\\s*do [^\\s{]'",
        "'whitespace/newline'",
        "'do/while clauses should not be on a single line'",
        "r'\\s+{.*}\\s*;'",
        "';'",
        "r'{.*}\\s*;'",
        "'{'",
        "'}'",
        "r'struct|class|enum|\\s*=\\s*{'",
        "'readability/braces'",
        "\"You don't need a ; after a }\"",
        "r'([-+]?(\\d+|0[xX][0-9a-fA-F]+)[lLuU]{0,3}|\".*\"|\\'.*\\')'",
        "r'\\s*'",
        "r'\\((\\s*'",
        "r'\\s*'",
        "r'[^<>].*|'",
        "r'.*[^<>]'",
        "r'\\s*'",
        "r'\\s*\\))'",
        "r'NULL|&&|\\|\\|'",
        "''",
        "'=='",
        "'!='",
        "'>='",
        "'>'",
        "'<='",
        "'<'",
        "'readability/check'",
        "'Consider using %s instead of %s(a %s b)'",
        "'NFC'",
        "'W'",
        "'F'",
        "'\\t'",
        "'whitespace/tab'",
        "'Tab found; better to use spaces'",
        "' '",
        "'whitespace/end_of_line'",
        "'Line ends in whitespace.  Consider deleting these extra spaces.'",
        "r'\\s*\\w+\\s*:\\s*$'",
        "'whitespace/indent'",
        "'Weird number of spaces at line-start.  '",
        "'Are you using a 2-space indent?'",
        "'//'",
        "r'[^:]:\\s*$'",
        "'whitespace/labels'",
        "'Labels should always be indented at least one space.  '",
        "'If this is a member-initializer list in a constructor or '",
        "'the base class list in a class definition, the colon should '",
        "'be on the following line.'",
        "'h'",
        "'#ifndef %s'",
        "'#define %s'",
        "'#endif  // %s'",
        "'#include'",
        "r'^\\s*//.*http(s?)://\\S*$'",
        "r'^// \\$Id:.*#[0-9]+ \\$$'",
        "'whitespace/line_length'",
        "'Lines should very rarely be longer than 100 characters'",
        "'whitespace/line_length'",
        "'Lines should be <= 80 characters long'",
        "';'",
        "'for'",
        "'for'",
        "';'",
        "'case '",
        "'default:'",
        "'break;'",
        "'whitespace/newline'",
        "'More than one command on the same line'",
        "r'#include +\"[^/]+\\.h\"'",
        "r'^\\s*#\\s*include\\s*([<\"])([^>\"]*)[>\"].*$'",
        "r'^[^-_.]+'",
        "'test.cc'",
        "'regtest.cc'",
        "'unittest.cc'",
        "'inl.h'",
        "'impl.h'",
        "'internal.h'",
        "'-'",
        "'_'",
        "'_test.cc'",
        "'_unittest.cc'",
        "'_regtest.cc'",
        "'/../public'",
        "'build/include'",
        "'Include the directory when naming .h files'",
        "'<'",
        "'build/include'",
        "'\"%s\" already included at %s:%s'",
        "'build/include_order'",
        "'%s. Should be: %s.h, c system, c++ system, other.'",
        "'build/include_alpha'",
        "'Include \"%s\" not in alphabetical order'",
        "r'(f|ind|io|i|o|parse|pf|stdio|str|)?stream$'",
        "'readability/streams'",
        "'Streams are highly discouraged.'",
        "'('",
        "')'",
        "'{'",
        "'}'",
        "'['",
        "']'",
        "'start_pattern must ends with an opening punctuation.'",
        "'start_pattern must ends with an opening punctuation.'",
        "'\\\\'",
        "'/'",
        "'{'",
        "r'\\([^()]*\\b(?:[\\w:]|<[^()]*>)+(\\s?&|&\\s?)\\w+'",
        "r'\\([^()]*\\bconst\\s+(?:typename\\s+)?(?:struct\\s+)?'",
        "r'(?:[\\w:]|<[^()]*>)+(\\s?&|&\\s?)\\w+'",
        "r'\\([^()]*\\b(?:[\\w:]|<[^()]*>)+\\s+const(\\s?&|&\\s?)[\\w]+'",
        "r'(swap|Swap|operator[<>][<>])\\s*\\(\\s*(?:[\\w:]|<.*>)+\\s*&'",
        "'runtime/references'",
        "'Is this a non-const reference? '",
        "'If so, make const or use a pointer.'",
        "r'(\\bnew\\s+)?\\b'",
        "r'(int|float|double|bool|char|int32|uint32|int64|uint64)\\([^)]'",
        "r'^\\s*MOCK_(CONST_)?METHOD\\d+(_T)?\\('",
        "r'^\\s*MockCallback<.*>'",
        "'readability/casting'",
        "'Using deprecated casting style.  '",
        "'Use static_cast<%s>(...) instead'",
        "'static_cast'",
        "r'\\((int|float|double|bool|char|u?int(16|32|64))\\)'",
        "'const_cast'",
        "r'\\((char\\s?\\*+\\s?)\\)\\s*\"'",
        "'reinterpret_cast'",
        "r'\\((\\w+\\s?\\*+\\s?)\\)'",
        "r'(&\\([^)]+\\)[\\w(])|(&(static|dynamic|reinterpret)_cast\\b)'",
        "'runtime/casting'",
        "'Are you taking an address of a cast?  '",
        "'This is dangerous: could be a temp var.  '",
        "'Take the address before doing the cast, rather than after'",
        "r'((?:|static +)(?:|const +))string +([a-zA-Z0-9_:]+)\\b(.*)'",
        "r'\\s*(<.*>)?(::[a-zA-Z0-9_]+)?\\s*\\(([^\"]|$)'",
        "'runtime/string'",
        "'For a static/global string constant, use a C style string instead: '",
        "'\"%schar %s[]\".'",
        "r'\\bdynamic_cast<'",
        "'runtime/rtti'",
        "'Do not use dynamic_cast<>.  If you need to cast within a class '",
        "\"hierarchy, use static_cast<> to upcast.  Google doesn't support \"",
        "'RTTI.'",
        "r'\\b([A-Za-z0-9_]*_)\\(\\1\\)'",
        "'runtime/init'",
        "'You seem to be initializing a member variable with itself.'",
        "'h'",
        "r'\\bshort port\\b'",
        "r'\\bunsigned short port\\b'",
        "'runtime/int'",
        "'Use \"unsigned short\" for ports, not \"short\"'",
        "r'\\b(short|long(?! +double)|long long)\\b'",
        "'runtime/int'",
        "'Use int16/int64/etc, rather than the C type %s'",
        "r'snprintf\\s*\\(([^,]*),\\s*([0-9]*)\\s*,'",
        "'0'",
        "'runtime/printf'",
        "'If you can, use sizeof(%s) instead of %s as the 2nd arg '",
        "'to snprintf.'",
        "r'\\bsprintf\\b'",
        "'runtime/printf'",
        "'Never use sprintf.  Use snprintf instead.'",
        "r'\\b(strcpy|strcat)\\b'",
        "'runtime/printf'",
        "'Almost always, snprintf is better than %s'",
        "r'\\bsscanf\\b'",
        "'runtime/printf'",
        "'sscanf can be ok, but is slow and can overflow buffers.'",
        "r'\\boperator\\s*&\\s*\\(\\s*\\)'",
        "'runtime/operator'",
        "'Unary operator& is dangerous.  Do not use it.'",
        "r'\\}\\s*if\\s*\\('",
        "'readability/braces'",
        "'Did you mean \"else if\"? If not, start a new line for \"if\".'",
        "r'(?i)\\b(string)?printf\\s*\\('",
        "r'([\\w.\\->()]+)$'",
        "r'\\b((?:string)?printf)\\s*\\('",
        "'runtime/printf'",
        "'Potential format string bug. Do %s(\"%%s\", %s) instead.'",
        "r'memset\\s*\\(([^,]*),\\s*([^,]*),\\s*0\\s*\\)'",
        "r\"^''|-?[0-9]+|0x[0-9A-Fa-f]$\"",
        "'runtime/memset'",
        "'Did you mean \"memset(%s, 0, %s)\"?'",
        "r'\\busing namespace\\b'",
        "'build/namespaces'",
        "'Do not use namespace using-directives.  '",
        "'Use using-declarations instead.'",
        "r'\\s*(.+::)?(\\w+) [a-z]\\w*\\[(.+)];'",
        "'return'",
        "'delete'",
        "']'",
        "r'\\s|\\+|\\-|\\*|\\/|<<|>>]'",
        "r'sizeof\\(.+\\)'",
        "r'arraysize\\(\\w+\\)'",
        "'('",
        "')'",
        "r'\\d+'",
        "r'0[xX][0-9a-fA-F]+'",
        "r'k[A-Z0-9]\\w*'",
        "r'(.+::)?k[A-Z0-9]\\w*'",
        "r'(.+::)?[A-Z][A-Z0-9_]*'",
        "'sizeof'",
        "'runtime/arrays'",
        "'Do not use variable-length arrays.  Use an appropriately named '",
        "\"('k' followed by CamelCase) compile-time constant for the size.\"",
        "r'\\s*'",
        "r'(DISALLOW_(EVIL_CONSTRUCTORS|COPY_AND_ASSIGN|IMPLICIT_CONSTRUCTORS))'",
        "r'\\(.*\\);$'",
        "r'^\\s*}[\\w\\*,\\s]*;'",
        "'readability/constructors'",
        "' should be the last thing in the class'",
        "'h'",
        "r'\\bnamespace\\s*{'",
        "'\\\\'",
        "'build/namespaces'",
        "'Do not use unnamed namespaces in header files.  See '",
        "'http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Namespaces'",
        "' for more information.'",
        "r'.*sizeof\\s*$'",
        "'runtime/sizeof'",
        "'Using sizeof(type).  Use sizeof(varname) instead if possible'",
        "r'\\s*(\\)|=|(const)?\\s*(;|\\{|throw\\(\\)|>))'",
        "';'",
        "'MockCallback<'",
        "'/*'",
        "'readability/function'",
        "'All parameters should be named in a function'",
        "'readability/casting'",
        "'Using C-style cast.  Use %s<%s>(...) instead'",
        "'<deque>'",
        "'deque'",
        "'<functional>'",
        "'unary_function'",
        "'binary_function'",
        "'plus'",
        "'minus'",
        "'multiplies'",
        "'divides'",
        "'modulus'",
        "'negate'",
        "'equal_to'",
        "'not_equal_to'",
        "'greater'",
        "'less'",
        "'greater_equal'",
        "'less_equal'",
        "'logical_and'",
        "'logical_or'",
        "'logical_not'",
        "'unary_negate'",
        "'not1'",
        "'binary_negate'",
        "'not2'",
        "'bind1st'",
        "'bind2nd'",
        "'pointer_to_unary_function'",
        "'pointer_to_binary_function'",
        "'ptr_fun'",
        "'mem_fun_t'",
        "'mem_fun'",
        "'mem_fun1_t'",
        "'mem_fun1_ref_t'",
        "'mem_fun_ref_t'",
        "'const_mem_fun_t'",
        "'const_mem_fun1_t'",
        "'const_mem_fun_ref_t'",
        "'const_mem_fun1_ref_t'",
        "'mem_fun_ref'",
        "'<limits>'",
        "'numeric_limits'",
        "'<list>'",
        "'list'",
        "'<map>'",
        "'map'",
        "'multimap'",
        "'<memory>'",
        "'allocator'",
        "'<queue>'",
        "'queue'",
        "'priority_queue'",
        "'<set>'",
        "'set'",
        "'multiset'",
        "'<stack>'",
        "'stack'",
        "'<string>'",
        "'char_traits'",
        "'basic_string'",
        "'<utility>'",
        "'pair'",
        "'<vector>'",
        "'vector'",
        "'<hash_map>'",
        "'hash_map'",
        "'hash_multimap'",
        "'<hash_set>'",
        "'hash_set'",
        "'hash_multiset'",
        "'<slist>'",
        "'slist'",
        "r'\\bstring\\b'",
        "'copy'",
        "'max'",
        "'min'",
        "'min_element'",
        "'sort'",
        "'swap'",
        "'transform'",
        "r'[^>.]\\b'",
        "r'(<.*?>)?\\([^\\)]'",
        "'<algorithm>'",
        "r'(\\<|\\b)'",
        "r'\\s*\\<'",
        "'<>'",
        "'.cc'",
        "''",
        "'.cc'",
        "'_unittest'",
        "'_unittest'",
        "'_test'",
        "'_test'",
        "'/public/'",
        "'/'",
        "'/internal/'",
        "'/'",
        "'.h'",
        "''",
        "'.h'",
        "'-inl'",
        "'-inl'",
        "'/public/'",
        "'/'",
        "'/internal/'",
        "'/'",
        "''",
        "'r'",
        "'utf8'",
        "'replace'",
        "'%s:%d'",
        "'#'",
        "'std::'",
        "'::'",
        "'<string>'",
        "'string'",
        "'<'",
        "r'_flymake\\.cc$'",
        "'.cc'",
        "'.cc'",
        "'<>\"'",
        "'build/include_what_you_use'",
        "'Add #include '",
        "' for '",
        "r'\\bmake_pair\\s*<'",
        "'build/explicit_make_pair'",
        "'Omit template arguments from make_pair OR use pair directly OR'",
        "' if appropriate, construct a pair directly'",
        "'// marker so line numbers and indices both start at 1'",
        "'// marker so line numbers end in a known way'",
        "'h'",
        "'-'",
        "'utf8'",
        "'utf8'",
        "'replace'",
        "'\\n'",
        "'r'",
        "'utf8'",
        "'replace'",
        "'\\n'",
        "'\\r'",
        "'\\r'",
        "\"Skipping input '%s': Can't open for reading\\n\"",
        "'.'",
        "'-'",
        "'cc'",
        "'h'",
        "'cpp'",
        "'Ignoring %s; not a .cc or .h file\\n'",
        "'\\r\\n'",
        "'whitespace/newline'",
        "'One or more unexpected \\\\r (^M) found;'",
        "'better to use only a \\\\n'",
        "'Done processing %s\\n'",
        "'\\nFATAL ERROR: '",
        "''",
        "'  %s\\n'",
        "''",
        "'help'",
        "'output='",
        "'verbose='",
        "'counting='",
        "'filter='",
        "'Invalid arguments.'",
        "''",
        "''",
        "'--help'",
        "'--output'",
        "'emacs'",
        "'vs7'",
        "'The only allowed output formats are emacs and vs7.'",
        "'--verbose'",
        "'--filter'",
        "'--counting'",
        "'total'",
        "'toplevel'",
        "'detailed'",
        "'Valid counting options are total, toplevel, and detailed'",
        "'No files were specified.'",
        "'utf8'",
        "'utf8'",
        "'replace'",
        "'__main__'"
    ],
    "variables": [
        "_USAGE",
        "_ERROR_CATEGORIES",
        "_DEFAULT_FILTERS",
        "_STL_HEADERS",
        "_CPP_HEADERS",
        "_CHECK_MACROS",
        "_CHECK_REPLACEMENT",
        "op",
        "op",
        "op",
        "op",
        "op",
        "op",
        "op",
        "op",
        "op",
        "op",
        "_C_SYS_HEADER",
        "_CPP_SYS_HEADER",
        "_LIKELY_MY_HEADER",
        "_POSSIBLE_MY_HEADER",
        "_OTHER_HEADER",
        "_regexp_compile_cache",
        "_RE_SUPPRESSION",
        "_error_suppressions",
        "matched",
        "category",
        "category",
        "_regexp_compile_cache",
        "pattern",
        "_regexp_compile_cache",
        "pattern",
        "_INITIAL_SECTION",
        "_MY_H_SECTION",
        "_C_SECTION",
        "_CPP_SECTION",
        "_OTHER_H_SECTION",
        "_TYPE_NAMES",
        "_SECTION_NAMES",
        "_section",
        "_last_header",
        "canonical_header",
        "_last_header",
        "error_message",
        "last_section",
        "_section",
        "_last_header",
        "_section",
        "_last_header",
        "_section",
        "_section",
        "_section",
        "_section",
        "_section",
        "_last_header",
        "verbose_level",
        "error_count",
        "filters",
        "counting",
        "errors_by_category",
        "output_format",
        "output_format",
        "last_verbose_level",
        "verbose_level",
        "counting",
        "filters",
        "clean_filt",
        "error_count",
        "errors_by_category",
        "category",
        "category",
        "_cpplint_state",
        "_NORMAL_TRIGGER",
        "_TEST_TRIGGER",
        "in_a_function",
        "lines_in_function",
        "current_function",
        "in_a_function",
        "lines_in_function",
        "current_function",
        "base_trigger",
        "base_trigger",
        "trigger",
        "error_level",
        "error_level",
        "in_a_function",
        "_filename",
        "fullname",
        "project_dir",
        "root_dir",
        "one_up_dir",
        "root_dir",
        "one_up_dir",
        "prefix",
        "root_dir",
        "root_dir",
        "prefix",
        "googlename",
        "project",
        "rest",
        "is_filtered",
        "is_filtered",
        "is_filtered",
        "_RE_PATTERN_CLEANSE_LINE_ESCAPES",
        "_RE_PATTERN_CLEANSE_LINE_DOUBLE_QUOTES",
        "_RE_PATTERN_CLEANSE_LINE_SINGLE_QUOTES",
        "_RE_PATTERN_CLEANSE_LINE_C_COMMENTS",
        "line",
        "lines",
        "i",
        "lineix",
        "lineix_begin",
        "lineix_end",
        "lineix",
        "commentpos",
        "line",
        "elided",
        "lines",
        "raw_lines",
        "num_lines",
        "elided",
        "elided",
        "elided",
        "elided",
        "line",
        "startchar",
        "endchar",
        "endchar",
        "endchar",
        "num_open",
        "line",
        "endpos",
        "endpos",
        "filename",
        "fileinfo",
        "cppvar",
        "ifndef",
        "ifndef_linenum",
        "define",
        "endif",
        "endif_linenum",
        "linesplit",
        "ifndef",
        "ifndef_linenum",
        "define",
        "endif",
        "endif_linenum",
        "error_level",
        "error_level",
        "error_level",
        "error_level",
        "line",
        "line",
        "threading_list",
        "line",
        "ix",
        "_RE_PATTERN_INVALID_INCREMENT",
        "line",
        "name",
        "linenum",
        "seen_open_brace",
        "is_derived",
        "virtual_method_linenumber",
        "has_virtual_destructor",
        "brace_depth",
        "last_line",
        "depth",
        "line",
        "last_line",
        "classinfo_stack",
        "line",
        "line",
        "line",
        "classinfo_stack",
        "class_decl_match",
        "classinfo",
        "classinfo",
        "seen_open_brace",
        "classinfo",
        "is_derived",
        "base_classname",
        "args",
        "classinfo",
        "virtual_method_linenumber",
        "classinfo",
        "has_virtual_destructor",
        "brace_depth",
        "brace_depth",
        "classinfo",
        "classinfo",
        "brace_depth",
        "fncall",
        "match",
        "fncall",
        "lines",
        "line",
        "raw",
        "raw_line",
        "joined_line",
        "starting_func",
        "regexp",
        "match_result",
        "function_name",
        "starting_func",
        "body_found",
        "start_line",
        "body_found",
        "body_found",
        "parameter_regexp",
        "_RE_PATTERN_TODO",
        "match",
        "leading_whitespace",
        "username",
        "middle_whitespace",
        "raw",
        "line",
        "elided",
        "prev_line",
        "prevbrace",
        "exception",
        "search_position",
        "exception",
        "exception",
        "next_line",
        "matched",
        "commentpos",
        "commentend",
        "match",
        "line",
        "line",
        "match",
        "match",
        "match",
        "match",
        "match",
        "match",
        "matched",
        "prev_line",
        "end_class_head",
        "end_class_head",
        "prevlinenum",
        "prevline",
        "line",
        "prevline",
        "prevline",
        "pos",
        "pos",
        "endline",
        "_",
        "endpos",
        "prevlinenum",
        "prevline",
        "prevlinenum",
        "line",
        "match_constant",
        "match_this",
        "raw_lines",
        "current_macro",
        "current_macro",
        "line",
        "width",
        "raw_lines",
        "line",
        "initial_spaces",
        "cleansed_line",
        "is_header_guard",
        "cppvar",
        "is_header_guard",
        "line_width",
        "_RE_PATTERN_INCLUDE_NEW_STYLE",
        "_RE_PATTERN_INCLUDE",
        "_RE_FIRST_COMPONENT",
        "is_stl_h",
        "is_cpp_h",
        "target_dir",
        "target_base",
        "include_dir",
        "include_base",
        "target_first_component",
        "include_first_component",
        "fileinfo",
        "line",
        "match",
        "include",
        "is_system",
        "include_state",
        "include",
        "error_message",
        "match",
        "include",
        "matching_punctuation",
        "closing_punctuation",
        "match",
        "start_position",
        "punctuation_stack",
        "position",
        "line",
        "match",
        "extended_line",
        "extended_line",
        "fullname",
        "fnline",
        "match",
        "match",
        "match",
        "match",
        "match",
        "printf_args",
        "match",
        "function_name",
        "match",
        "match",
        "tokens",
        "is_const",
        "skip_next",
        "skip_next",
        "tok",
        "tok",
        "skip_next",
        "is_const",
        "match",
        "next_line",
        "match",
        "sizeof_match",
        "remainder",
        "function_match",
        "_HEADERS_CONTAINING_TEMPLATES",
        "_RE_PATTERN_STRING",
        "_re_pattern_algorithm_header",
        "_re_pattern_templates",
        "filename_cc",
        "filename_cc",
        "filename_cc",
        "filename_cc",
        "filename_cc",
        "filename_h",
        "filename_h",
        "filename_h",
        "filename_h",
        "files_belong_to_same_module",
        "common_path",
        "common_path",
        "headerfile",
        "headerfile",
        "linenum",
        "clean_line",
        "match",
        "include",
        "required",
        "line",
        "matched",
        "prefix",
        "required",
        "required",
        "header",
        "required",
        "header",
        "include_state",
        "header_found",
        "abs_filename",
        "abs_filename",
        "header_keys",
        "same_module",
        "common_path",
        "fullpath",
        "header_found",
        "template",
        "_RE_PATTERN_EXPLICIT_MAKEPAIR",
        "raw",
        "line",
        "match",
        "raw_lines",
        "lines",
        "include_state",
        "function_state",
        "class_state",
        "clean_lines",
        "lines",
        "lines",
        "carriage_return_found",
        "lines",
        "linenum",
        "carriage_return_found",
        "file_extension",
        "opts",
        "filenames",
        "verbosity",
        "output_format",
        "filters",
        "counting_style",
        "output_format",
        "verbosity",
        "filters",
        "counting_style",
        "filenames",
        "sys",
        "stderr"
    ],
    "comments": [
        "",
        "Copyright (c) 2009 Google Inc. All rights reserved.",
        "",
        "Redistribution and use in source and binary forms, with or without",
        "modification, are permitted provided that the following conditions are",
        "met:",
        "",
        "notice, this list of conditions and the following disclaimer.",
        "copyright notice, this list of conditions and the following disclaimer",
        "in the documentation and/or other materials provided with the",
        "distribution.",
        "contributors may be used to endorse or promote products derived from",
        "this software without specific prior written permission.",
        "",
        "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS",
        "\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT",
        "LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR",
        "A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT",
        "OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,",
        "SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT",
        "LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,",
        "DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY",
        "THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT",
        "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE",
        "OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
        "Here are some issues that I've had people identify in my code during reviews,",
        "that I think are possible to flag automatically in a lint tool.  If these were",
        "caught by lint, it would save time both for myself and that of my reviewers.",
        "Most likely, some of these are beyond the scope of the current lint framework,",
        "but I think it is valuable to retain these wish-list items even if they cannot",
        "be immediately implemented.",
        "",
        "Suggestions",
        "-----------",
        "- Check for no 'explicit' for multi-arg ctor",
        "- Check for boolean assign RHS in parens",
        "- Check for ctor initializer-list colon position and spacing",
        "- Check that if there's a ctor, there should be a dtor",
        "- Check accessors that return non-pointer member variables are",
        "declared const",
        "- Check accessors that return non-const pointer member vars are",
        "- Check for using public includes for testing",
        "- Check for spaces between brackets in one-line inline method",
        "- Check for no assert()",
        "- Check for spaces surrounding operators",
        "- Check for 0 in pointer context (should be NULL)",
        "- Check for 0 in char context (should be '\\0')",
        "- Check for camel-case method name conventions for methods",
        "that are not simple inline getters and setters",
        "- Check that base classes have virtual destructors",
        "put \"  // namespace\" after } that closes a namespace, with",
        "namespace's name after 'namespace' if it is named.",
        "- Do not indent namespace contents",
        "- Avoid inlining non-trivial constructors in header files",
        "include base/basictypes.h if DISALLOW_EVIL_CONSTRUCTORS is used",
        "- Check for old-school (void) cast for call-sites of functions",
        "ignored return value",
        "- Check gUnit usage of anonymous namespace",
        "- Check for class declaration order (typedefs, consts, enums,",
        "ctor(s?), dtor, friend declarations, methods, member vars)",
        "",
        "for log",
        "We categorize each error message we print.  Here are the categories.",
        "We want an explicit list so we can list them all in cpplint --filter=.",
        "If you add a new error message with a new category, add it to the list",
        "here!  cpplint_unittest.py should tell you if you forget to do this.",
        "\\ used for clearer layout -- pylint: disable-msg=C6013",
        "The default state of the category filter. This is overrided by the --filter=",
        "flag. By default all errors are on, so only add here categories that should be",
        "off by default (i.e., categories that must be enabled by the --filter= flags).",
        "All entries here should start with a '-' or '+', as in the --filter= flag.",
        "We used to check for high-bit characters, but after much discussion we",
        "decided those were OK, as long as they were in UTF-8 and didn't represent",
        "hard-coded international strings, which belong in a separate i18n file.",
        "Headers that we consider STL headers.",
        "Non-STL C++ system headers.",
        "Assertion macros.  These are defined in base/logging.h and",
        "testing/base/gunit.h.  Note that the _M versions need to come first",
        "for substring matching to work.",
        "Replacement macros for CHECK/DCHECK/EXPECT_TRUE/EXPECT_FALSE",
        "These constants define types of headers for use with",
        "_IncludeState.CheckNextIncludeOrder().",
        "Finds occurrences of NOLINT or NOLINT(...).",
        "{str, set(int)}: a map from error categories to sets of linenumbers",
        "on which those errors are expected and should be suppressed.",
        "FIXME(adonovan): \"NOLINT(\" is misparsed as NOLINT(*).",
        "=> \"suppress all\"",
        "The regexp compilation caching is inlined in both Match and Search for",
        "performance reasons; factoring it out into a separate function turns out",
        "to be noticeably expensive.",
        "self._section will move monotonically through this set. If it ever",
        "needs to move backwards, CheckNextIncludeOrder will raise an error.",
        "The name of the current section.",
        "The path of last found header.",
        "This will always be the fallback because we're not sure",
        "enough that the header is associated with this file.",
        "global setting.",
        "global count of reported errors",
        "filters to apply when emitting error messages",
        "In what way are we counting errors?",
        "string to int dict storing error counts",
        "output format:",
        "\"emacs\" - format that emacs can parse (default)",
        "\"vs7\" - format that Microsoft Visual Studio 7 can parse",
        "Default filters always have less priority than the flag ones.",
        "for --v=0, 500 for --v=1, etc.",
        "about 50% more than _NORMAL_TRIGGER.",
        "50 => 0, 100 => 1, 200 => 2, 400 => 3, 800 => 4, 1600 => 5, ...",
        "If there's a .svn file in the current directory, we recursively look",
        "up the directory tree for the top of the SVN checkout",
        "Not SVN <= 1.6? Try to find a git, hg, or svn top level directory by",
        "searching up from the current path.",
        "Don't know what to do; header guard warnings may be wrong...",
        "There are three ways we might decide not to print an error message:",
        "a \"NOLINT(category)\" comment appears in the source,",
        "the verbosity level isn't high enough, or the filters filter it out.",
        "should have been checked for in SetFilter.",
        "Matches standard C++ escape esequences per 2.13.2.3 of the C++ standard.",
        "Matches strings.  Escape codes should already be removed by ESCAPES.",
        "Matches characters.  Escape codes should already be removed by ESCAPES.",
        "Matches multi-line C++ comments.",
        "This RE is a little bit more complicated than one might expect, because we",
        "have to take care of space removals tools so we can handle comments inside",
        "statements better.",
        "The current rule is: We only clear spaces from both sides when we're at the",
        "end of the line. Otherwise, we try to remove spaces from the right side,",
        "if this doesn't work we try on left side but only if there's a non-character",
        "on the right.",
        "after this, \\\\\" does not match to \\\"",
        "Only return this marker if the comment goes beyond this line",
        "Having // dummy comments makes the lines non-empty, so we will not get",
        "unnecessary blank line warnings later in the code.",
        "get rid of /* ... */",
        "Remove escaped characters first to make quote/single quote collapsing",
        "basic.  Things that look like escaped characters shouldn't occur",
        "outside of strings and chars.",
        "OK, now find the endchar that actually got us back to even",
        "chopped off another )",
        "We'll say it should occur by line 10. Don't forget there's a",
        "dummy line at the front.",
        "means no copyright line was found",
        "Restores original filename in case that cpplint is invoked from Emacs's",
        "flymake.",
        "find the first occurrence of #ifndef and #define, save arg",
        "set ifndef to the header guard presented on the #ifndef line.",
        "find the last occurrence of #endif, save entire line",
        "The guard should be PATH_FILE_H_, but we also allow PATH_FILE_H__",
        "for backward compatibility.",
        "The array lines() was created by adding two newlines to the",
        "original file (go figure), then splitting on \\n.",
        "To verify that the file ends in \\n, we just have to make sure the",
        "last-but-two element of lines() exists and is empty.",
        "Remove all \\\\ (escaped backslashes) from the line. They are OK, and the",
        "second (escaped) slash may trigger later \\\" detection erroneously.",
        "Comparisons made explicit for clarity -- pylint: disable-msg=C6403",
        "Matches invalid increment: *count++, which moves pointer instead of",
        "incrementing a value.",
        "Try to find the end of the class.  This will be confused by things like:",
        "class A {",
        "} *x = { ...",
        "",
        "But it's still good enough for CheckSectionSpacing.",
        "Note: This test can result in false positives if #ifdef constructs",
        "get in the way of brace matching. See the testBuildClass test in",
        "cpplint_unittest.py for an example of this.",
        "Remove comments from the line, but leave in strings for now.",
        "Remove escaped backslashes before looking for undefined escapes.",
        "For the rest, work with both comments and strings removed.",
        "TODO(unknown): Could it be expanded safely to arbitrary references,",
        "without triggering too many false positives? The first",
        "attempt triggered 5 warnings for mostly benign code in the regtest, hence",
        "the restriction.",
        "Here's the original regexp, for the reference:",
        "type_name = r'\\w+((\\s*::\\s*\\w+)|(\\s*<\\s*\\w+?\\s*>))?'",
        "r'\\s*const\\s*' + type_name + '\\s*&\\s*\\w+\\s*;'",
        "Track class entry and exit, and attempt to find cases within the",
        "class declaration that don't meet the C++ style",
        "guidelines. Tracking is very dependent on the code matching Google",
        "style guidelines, but it seems to perform well enough in testing",
        "to be a worthwhile addition to the checks.",
        "Look for a class declaration. The regexp accounts for decorated classes",
        "such as in:",
        "class LOCKABLE API Object {",
        "};",
        "Everything else in this function uses the top of the stack if it's",
        "not empty.",
        "If the opening brace hasn't been seen look for it and also",
        "parent class declarations.",
        "If the line has a ';' in it, assume it's a forward declaration or",
        "a single-line class declaration, which we won't process.",
        "Look for a bare ':'",
        "Everything else in this function is for after open brace",
        "The class may have been declared with namespace or classname qualifiers.",
        "The constructor and destructor will not have those qualifiers.",
        "Look for single-argument constructors that aren't marked explicit.",
        "Technically a valid construct, but against style.",
        "Look for methods declared virtual.",
        "Only look for a destructor declaration on the same line. It would",
        "be extremely unlikely for the destructor declaration to occupy",
        "more than one line.",
        "Look for class end.",
        "Try to detect missing virtual destructor declarations.",
        "For now, only warn if a non-derived class with virtual methods lacks",
        "a virtual destructor. This is to make it less likely that people will",
        "declare derived virtual destructors without declaring the base",
        "destructor virtual.",
        "Only warn for base classes",
        "Since function calls often occur inside if/for/while/switch",
        "expressions - which have their own, more liberal conventions - we",
        "first see if we should be looking inside such an expression for a",
        "function call, to which we can apply more strict standards.",
        "if there's no control flow construct, look at whole line",
        "look inside the parens for function calls",
        "Except in if/for/while/switch, there should never be space",
        "immediately inside parens (eg \"f( 3, 4 )\").  We make an exception",
        "for nested parens ( (a+b) + c ).  Likewise, there should never be",
        "a space before a ( when it's a function argument.  I assume it's a",
        "function argument when the char before the whitespace is legal in",
        "a function name (alnum + _) and we're not starting a macro. Also ignore",
        "pointers and references to arrays and functions coz they're too tricky:",
        "we use a very simple way to recognize these:",
        "\" (something)(maybe-something)\" or",
        "\" (something)(maybe-something,\" or",
        "\" (something)[something]\"",
        "Note that we assume the contents of [] to be short enough that",
        "they'll never need to wrap.",
        "Ignore control structures.",
        "Ignore pointers/references to functions.",
        "Ignore pointers/references to arrays.",
        "a ( used for a fn call",
        "If the ) is followed only by a newline or a { + newline, assume it's",
        "part of a control statement (if/while/etc), and don't complain",
        "If the closing parenthesis is preceded by only whitespaces,",
        "try to give a more descriptive error message.",
        "decls * & space::name( ...",
        "If the name is all caps and underscores, figure it's a macro and",
        "ignore it, unless it's TEST or TEST_F.",
        "Declarations and trivial functions",
        "... ignore",
        "Handle TEST... macros",
        "Ignore bad syntax",
        "No body for the function (or evidence of a non-function) was found.",
        "function end",
        "Count non-blank/non-comment lines.",
        "One whitespace is correct; zero whitespace is handled elsewhere.",
        "Comparisons made explicit for correctness -- pylint: disable-msg=C6403",
        "Before nixing comments, check if the line is blank for no good",
        "reason.  This includes the first line after a block is opened, and",
        "blank lines at the end of a function (ie, right before a line like '}'",
        "TODO(unknown): Don't complain if line before blank line, and line after,",
        "both start with alnums and are indented the same amount.",
        "This ignores whitespace at the start of a namespace block",
        "because those are not usually indented.",
        "OK, we have a blank line at the start of a code block.  Before we",
        "complain, we check if it is an exception to the rule: The previous",
        "non-empty line has the parameters of a function header that are indented",
        "4 spaces (because they did not fit in a 80 column line when placed on",
        "the same line as the function name).  We also check for the case where",
        "the previous line is indented 6 spaces, which may happen when the",
        "initializers of a constructor do not fit into a 80 column line.",
        "Initializer list?",
        "We are looking for the opening column of initializer list, which",
        "should be indented 4 spaces to cause 6 space indentation afterwards.",
        "Search for the function arguments or an initializer list.  We use a",
        "simple heuristic here: If the line is indented 4 spaces; and we have a",
        "closing paren, without the opening paren, followed by an opening brace",
        "or colon (for initializer lists) we assume that it is the last line of",
        "a function header.  If we have a colon indented 4 spaces, it is an",
        "initializer list.",
        "This doesn't ignore whitespace at the end of a namespace block",
        "because that is too hard without pairing open/close braces;",
        "however, a special exception is made for namespace closing",
        "brackets which have a comment containing \"namespace\".",
        "",
        "Also, ignore blank lines at the end of a block in a long if-else",
        "chain, like this:",
        "if (condition1) {",
        "// Something followed by a blank line",
        "",
        "} else if (condition2) {",
        "// Something else",
        "}",
        "Next, we complain if there's a comment too near the text",
        "Check if the // may be in quotes.  If so, ignore it",
        "Comparisons made explicit for clarity -- pylint: disable-msg=C6403",
        "not in quotes",
        "Allow one space for new scopes, two spaces otherwise:",
        "There should always be a space between the // and the comment",
        "but some lines are exceptions -- e.g. if they're big",
        "comment delimiters like:",
        "//----------------------------------------------------------",
        "or are an empty C++ style Doxygen comment, like:",
        "///",
        "or they begin with multiple slashes followed by a space:",
        "//////// Header comment",
        "get rid of comments and strings",
        "Don't try to do spacing checks for operator methods",
        "We allow no-spaces around = within an if: \"if ( (a=Foo()) == 0 )\".",
        "Otherwise not.  Note we only check for non-spaces on *both* sides;",
        "sometimes people put non-spaces on one side when aligning ='s among",
        "many lines (not that this is behavior that I approve of...)",
        "It's ok not to have spaces around binary operators like + - * /, but if",
        "there's too little whitespace, we get concerned.  It's hard to tell,",
        "though, so we punt on this one for now.  TODO.",
        "You should always have whitespace around binary operators.",
        "Alas, we can't test < or > because they're legitimately used sans spaces",
        "(a->b, vector<int> a).  The only time we can tell is a < with no >, and",
        "only if it's not template params list spilling into the next line.",
        "Note that while it seems that the '<[^<]*' term in the following",
        "regexp could be simplified to '<.*', which would indeed match",
        "the same class of strings, the [^<] means that searching for the",
        "regexp takes linear rather than quadratic time.",
        "template params spill",
        "We allow no-spaces around << and >> when used like this: 10<<20, but",
        "not otherwise (particularly, not when used as streams)",
        "There shouldn't be space around unary operators",
        "A pet peeve of mine: no spaces after an if, while, switch, or for",
        "For if/for/while/switch, the left and right parens should be",
        "consistent about how many spaces are inside the parens, and",
        "there should either be zero or one spaces inside the parens.",
        "We don't want: \"if ( foo)\" or \"if ( foo   )\".",
        "Exception: \"for ( ; foo; bar)\" and \"for (foo; bar; )\" are allowed.",
        "You should always have a space after a comma (either as fn arg or operator)",
        "You should always have a space after a semicolon",
        "except for few corner cases",
        "TODO(unknown): clarify if 'if (1) { return 1;}' is requires one more",
        "space after ;",
        "Next we will look for issues with function calls.",
        "Except after an opening paren, or after another opening brace (in case of",
        "an initializer list, for instance), you should have spaces before your",
        "braces. And since you should never have braces at the beginning of a line,",
        "this is an easy test.",
        "Make sure '} else {' has spaces.",
        "You shouldn't have spaces before your brackets, except maybe after",
        "'delete []' or 'new char * []'.",
        "You shouldn't have a space before a semicolon at the end of the line.",
        "There's a special case for \"for\" since the style guide allows space before",
        "the semicolon there.",
        "Skip checks if the class is small, where small means 25 lines or less.",
        "25 lines seems like a good cutoff since that's the usual height of",
        "terminals, and any class that can't fit in one screen can't really",
        "be considered \"small\".",
        "",
        "Also skip checks if we are on the first line.  This accounts for",
        "classes that look like",
        "class Foo { public: ... };",
        "",
        "If we didn't find the end of the class, last_line would be zero,",
        "and the check will be skipped by the first condition.",
        "Issue warning if the line before public/protected/private was",
        "not a blank line, but don't do this if the previous line contains",
        "\"class\" or \"struct\".  This can happen two ways:",
        "- We are at the beginning of the class.",
        "- We are forward-declaring an inner class that is semantically",
        "private, but needed to be public for implementation reasons.",
        "Try a bit harder to find the beginning of the class.  This is to",
        "account for multi-line base-specifier lists, e.g.:",
        "class Derived",
        ": public Base {",
        "if not a blank line...",
        "get rid of comments and strings",
        "We allow an open brace to start a line in the case where someone",
        "is using braces in a block to explicitly create a new scope,",
        "which is commonly used to control the lifetime of",
        "stack-allocated variables.  We don't detect this perfectly: we",
        "just don't complain if the last non-whitespace character on the",
        "previous non-blank line is ';', ':', '{', or '}'.",
        "An else clause should be on the same line as the preceding closing brace.",
        "If braces come on one side of an else, they should be on both.",
        "However, we have to worry about \"else if\" that spans multiple lines!",
        "could be multi-line if",
        "find the ( after the if",
        "must be brace after if",
        "common case: else not followed by a multi-line if",
        "Likewise, an else should never have the else clause on the same line",
        "In the same way, a do/while should never be on one line",
        "Braces shouldn't be followed by a ; unless they're defining a struct",
        "or initializing an array.",
        "We can't tell in general, but we can for some common cases.",
        "This matches decimal and hex integers, strings, and chars (in that order).",
        "Expression to match two sides of the operator with something that",
        "looks like a literal, since CHECK(x == iterator) won't compile.",
        "This means we can't catch all the cases where a more specific",
        "CHECK is possible, but it's less annoying than dealing with",
        "extraneous warnings.",
        "Don't complain about CHECK(x == NULL) or similar because",
        "CHECK_EQ(x, NULL) won't compile (requires a cast).",
        "Also, don't complain about more complex boolean expressions",
        "involving && or || such as CHECK(a == b || c == d).",
        "Decide the set of replacement macros that should be suggested",
        "Don't waste time here if line doesn't contain 'CHECK' or 'EXPECT'",
        "get rid of comments and strings",
        "Encourage replacing plain CHECKs with CHECK_EQ/CHECK_NE/etc.",
        "One or three blank spaces at the beginning of the line is weird; it's",
        "hard to reconcile that with 2-space indents.",
        "NOTE: here are the conditions rob pike used for his tests.  Mine aren't",
        "as sophisticated, but it may be worth becoming so:  RLENGTH==initial_spaces",
        "if(RLENGTH > 20) complain = 0;",
        "if(match($0, \" +(error|private|public|protected):\")) complain = 0;",
        "if(match(prev, \"&& *$\")) complain = 0;",
        "if(match(prev, \"\\\\|\\\\| *$\")) complain = 0;",
        "if(match(prev, \"[\\\",=><] *$\")) complain = 0;",
        "if(match($0, \" <<\")) complain = 0;",
        "if(match(prev, \" +for \\\\(\")) complain = 0;",
        "if(prevodd && match(prevprev, \" +for \\\\(\")) complain = 0;",
        "There are certain situations we allow one space, notably for labels",
        "Labels should always be indented at least one space.",
        "Check if the line is a header guard.",
        "#include lines and header guards can be long, since there's no clean way to",
        "split them.",
        "",
        "URLs can be long too.  It's possible to split these, but it makes them",
        "harder to cut&paste.",
        "",
        "The \"$Id:...$\" comment may also get very long without it being the",
        "developers fault.",
        "for loops are allowed two ;'s (and may run over two lines).",
        "It's ok to have many commands in a switch case that fits in 1 line",
        "Some more style checks",
        "Matches the first component of a filename delimited by -s and _s. That is:",
        "_RE_FIRST_COMPONENT.match('foo').group(0) == 'foo'",
        "_RE_FIRST_COMPONENT.match('foo.cc').group(0) == 'foo'",
        "_RE_FIRST_COMPONENT.match('foo-bar_baz.cc').group(0) == 'foo'",
        "_RE_FIRST_COMPONENT.match('foo_bar-baz.cc').group(0) == 'foo'",
        "This is a list of all standard c++ header files, except",
        "those already checked for above.",
        "If the target file and the include we're checking share a",
        "basename when we drop common extensions, and the include",
        "lives in . , then it's likely to be owned by the target file.",
        "If the target and include share some initial basename",
        "component, it's possible the target is implementing the",
        "include, so it's allowed to be first, but we'll never",
        "complain if it's not there.",
        "\"include\" should use the new style \"foo/bar.h\" instead of just \"bar.h\"",
        "we shouldn't include a file more than once. actually, there are a",
        "handful of instances where doing so is okay, but in general it's",
        "not.",
        "We want to ensure that headers appear in the right order:",
        "1) for foo.cc, foo.h  (preferred location)",
        "2) c system files",
        "3) cpp system files",
        "4) for foo.cc, foo.h  (deprecated location)",
        "5) other google headers",
        "",
        "We classify each include statement as one of those 5 types",
        "using a number of techniques. The include_state object keeps",
        "track of the highest type seen, and complains if we see a",
        "lower type after that.",
        "Look for any of the stream classes that are part of standard C++.",
        "Many unit tests use cout, so we exempt them.",
        "TODO(sugawarayu): Audit cpplint.py to see what places could be profitably",
        "rewritten to use _GetTextInside (and use inferior regexp matching today).",
        "Give opening punctuations to get the matching close-punctuations.",
        "Find the position to start extracting text.",
        "start_pattern not found in text.",
        "Stack of closing punctuations we expect to have in text after position.",
        "A closing punctuation without matching opening punctuations.",
        "Opening punctuations left without matching close-punctuations.",
        "punctuations match.",
        "If the line is empty or consists of entirely a comment, no need to",
        "check it.",
        "Create an extended_line, which is the concatenation of the current and",
        "next lines, for more effective checking of code that may span more than one",
        "line.",
        "Make Windows paths like Unix.",
        "TODO(unknown): figure out if they're using default arguments in fn proto.",
        "Check for non-const references in functions.  This is tricky because &",
        "is also used to take the address of something.  We allow <> for templates,",
        "(ignoring whatever is between the braces) and : for classes.",
        "These are complicated re's.  They try to capture the following:",
        "paren (for fn-prototype start), typename, &, varname.  For the const",
        "version, we're willing for const to be before typename or after",
        "Don't check the implementation on same line.",
        "We allow non-const references in a few standard places, like functions",
        "called \"swap()\" or iostream operators like \"<<\" or \">>\".",
        "Check to see if they're using an conversion function cast.",
        "I just try to capture the most common basic types, though there are more.",
        "Parameterless conversion functions, such as bool(), are allowed as they are",
        "probably a member operator declaration or default constructor.",
        "Grab 'new' operator, if it's there",
        "gMock methods are defined using some variant of MOCK_METHODx(name, type)",
        "where type may be float(), int(string), etc.  Without context they are",
        "virtually indistinguishable from int(x) casts. Likewise, gMock's",
        "MockCallback takes a template parameter of the form return_type(arg_type),",
        "which looks much like the cast we're trying to detect.",
        "If new operator, then this isn't a cast",
        "This doesn't catch all cases. Consider (const char * const)\"hello\".",
        "",
        "(char *) \"foo\" should always be a const_cast (reinterpret_cast won't",
        "compile).",
        "Check pointer casts for other than string constants",
        "In addition, we look for people taking the address of a cast.  This",
        "is dangerous -- casts can assign to temporaries, so the pointer doesn't",
        "point where you think.",
        "Check for people declaring static/global STL strings at the top level.",
        "This is dangerous because the C++ language does not guarantee that",
        "globals with constructors are initialized before the first access.",
        "Make sure it's not a function.",
        "Function template specialization looks like: \"string foo<Type>(...\".",
        "Class template definitions look like: \"string Foo<Type>::Method(...\".",
        "Check that we're not using RTTI outside of testing code.",
        "TODO(unknown): check that 1-arg constructors are explicit.",
        "How to tell it's a constructor?",
        "(handled in CheckForNonStandardConstructs for now)",
        "TODO(unknown): check that classes have DISALLOW_EVIL_CONSTRUCTORS",
        "(level 1 error)",
        "Check if people are using the verboten C basic types.  The only exception",
        "we regularly allow is \"unsigned short port\" for port.",
        "When snprintf is used, the second argument shouldn't be a literal.",
        "If 2nd arg is zero, snprintf is used to calculate size.",
        "Check if some verboten C functions are being used.",
        "Check if some verboten operator overloading is going on",
        "TODO(unknown): catch out-of-line unary operator&:",
        "class X {};",
        "int operator&(const X& x) { return 42; }  // unary operator&",
        "The trick is it's hard to tell apart from binary operator&:",
        "class Y { int operator&(const Y& x) { return 23; } }; // binary operator&",
        "Check for suspicious usage of \"if\" like",
        "} if (a == b) {",
        "Check for potential format string bugs like printf(foo).",
        "We constrain the pattern not to pick things like DocidForPrintf(foo).",
        "Not perfect but it can catch printf(foo.c_str()) and printf(foo->c_str())",
        "TODO(sugawarayu): Catch the following case. Need to change the calling",
        "convention of the whole function to process multiple line to handle it.",
        "printf(",
        "boy_this_is_a_really_long_variable_that_cannot_fit_on_the_prev_line);",
        "Check for potential memset bugs like memset(buf, sizeof(buf), 0).",
        "Detect variable-length arrays.",
        "Split the size using space and arithmetic operators as delimiters.",
        "If any of the resulting tokens are not compile time constants then",
        "report the error.",
        "A catch all for tricky sizeof cases, including 'sizeof expression',",
        "'sizeof(*type)', 'sizeof(const type)', 'sizeof(struct StructName)'",
        "requires skipping the next token because we split on ' ' and '*'.",
        "If DISALLOW_EVIL_CONSTRUCTORS, DISALLOW_COPY_AND_ASSIGN, or",
        "DISALLOW_IMPLICIT_CONSTRUCTORS is present, then it should be the last thing",
        "in the class declaration.",
        "We allow some, but not all, declarations of variables to be present",
        "in the statement that defines the class.  The [\\w\\*,\\s]* fragment of",
        "the regular expression below allows users to declare instances of",
        "the class or pointers to instances, but not less common types such",
        "as function pointers or arrays.  It's a tradeoff between allowing",
        "reasonable code and avoiding trying to parse more C++ using regexps.",
        "Check for use of unnamed namespaces in header files.  Registration",
        "macros are typically OK, so we allow use of \"namespace {\" on lines",
        "that end with backslashes.",
        "e.g., sizeof(int)",
        "The close paren is for function pointers as arguments to a function.",
        "eg, void foo(void (*bar)(int));",
        "The semicolon check is a more basic function check; also possibly a",
        "function pointer typedef.",
        "eg, void foo(int); or void foo(int) const;",
        "The equals check is for function pointer assignment.",
        "eg, void *(*foo)(int) = ...",
        "The > is for MockCallback<...> ...",
        "",
        "Right now, this will only catch cases where there's a single argument, and",
        "it's unnamed.  It should probably be expanded to check for multiple",
        "arguments with some unnamed.",
        "At this point, all that should be left is actual casts.",
        "gcc extensions.",
        "Note: std::hash is their hash, ::hash is our hash",
        "Match max<type>(..., ...), max(..., ...), but not foo->max, foo.max or",
        "type::max().",
        "The value formatting is cute, but not really used right now.",
        "What matters here is that the key is in include_state.",
        "A map of header name to linenumber and the template entity.",
        "Example of required: { '<functional>': (1219, 'less<>') }",
        "String is special -- it is a non-templatized type in STL.",
        "Don't warn about strings in non-STL namespaces:",
        "(We check only the first match per line; good enough.)",
        "The following function is just a speed up, no semantics are changed.",
        "Reduces the cpu time usage by skipping lines.",
        "The policy is that if you #include something in foo.h you don't need to",
        "include it again in foo.cc. Here, we will look at possible includes.",
        "Let's copy the include_state so it is only messed up within this function.",
        "Did we find the header for this file (if any) and succesfully load it?",
        "Use the absolute path so that matching works properly.",
        "For Emacs's flymake.",
        "If cpplint is invoked from Emacs's flymake, a temporary file is generated",
        "by flymake and that file name might end with '_flymake.cc'. In that case,",
        "restore original file name here so that the corresponding header file can be",
        "found.",
        "e.g. If the file name is 'foo_flymake.cc', we should search for 'foo.h'",
        "instead of 'foo_flymake.h'",
        "include_state is modified during iteration, so we iterate over a copy of",
        "the keys.",
        "If we can't find the header file for a .cc, assume it's because we don't",
        "know where to look. In that case we'll give up as we're not sure they",
        "didn't include it in the .h file.",
        "TODO(unknown): Do a better job of finding .h files so we are confident that",
        "not having the .h file means there isn't one.",
        "All the lines have been processed, report the errors found.",
        "4 = high confidence",
        "We check here rather than inside ProcessLine so that we see raw",
        "lines rather than \"cleaned\" lines.",
        "Support the UNIX convention of using \"-\" for stdin.  Note that",
        "we are not opening the file with universal newline support",
        "(which codecs doesn't support anyway), so the resulting lines do",
        "contain trailing '\\r' characters if we are reading a file that",
        "has CRLF endings.",
        "If after the split a trailing '\\r' is present, it is removed",
        "below. If it is not expected to be present (i.e. os.linesep !=",
        "'\\r\\n' as in Windows), a warning is issued below if this file",
        "is processed.",
        "Remove trailing '\\r'.",
        "Note, if no dot is found, this will give the entire filename as the ext.",
        "When reading from stdin, the extension is unknown, so no cpplint tests",
        "should rely on the extension.",
        "Use 0 for linenum since outputting only one error for potentially",
        "several lines.",
        "Change stderr to write with replacement characters so we don't die",
        "if we try to print something containing non-ASCII characters."
    ],
    "docstrings": [
        "* Redistributions of source code must retain the above copyright",
        "* Redistributions in binary form must reproduce the above",
        "* Neither the name of Google Inc. nor the names of its",
        "*not* declared const",
        "\"\"\"Does google-lint on c++ files.\n\nThe goal of this script is to identify places in the code that *may*\nbe in non-compliance with google style.  It does not attempt to fix\nup these problems -- the point is to educate.  It does also not\nattempt to find all problems, or to ensure that everything it does\nfind is legitimately a problem.\n\nIn particular, we can get very confused by /* and // inside strings!\nWe do a small hack, which is to ignore //'s with \"'s after them on the\nsame line, but it is far from perfect (in either direction).\n\"\"\"",
        "\"\"\"\nSyntax: cpplint.py [--verbose=#] [--output=vs7] [--filter=-x,+y,...]\n                   [--counting=total|toplevel|detailed]\n        <file> [file] ...\n\n  The style guidelines this tries to follow are those in\n    http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml\n\n  Every problem is given a confidence score from 1-5, with 5 meaning we are\n  certain of the problem, and 1 meaning it could be a legitimate construct.\n  This will miss some errors, and is not a substitute for a code review.\n\n  To suppress false-positive errors of a certain category, add a\n  'NOLINT(category)' comment to the line.  NOLINT or NOLINT(*)\n  suppresses errors of all categories on that line.\n\n  The files passed in will be linted; at least one file must be provided.\n  Linted extensions are .cc, .cpp, and .h.  Other file types will be ignored.\n\n  Flags:\n\n    output=vs7\n      By default, the output is formatted to ease emacs parsing.  Visual Studio\n      compatible output (vs7) may also be used.  Other formats are unsupported.\n\n    verbose=#\n      Specify a number 0-5 to restrict errors to certain verbosity levels.\n\n    filter=-x,+y,...\n      Specify a comma-separated list of category-filters to apply: only\n      error messages whose category names pass the filters will be printed.\n      (Category names are printed with the message and look like\n      \"[whitespace/indent]\".)  Filters are evaluated left to right.\n      \"-FOO\" and \"FOO\" means \"do not print categories that start with FOO\".\n      \"+FOO\" means \"do print categories that start with FOO\".\n\n      Examples: --filter=-whitespace,+whitespace/braces\n                --filter=whitespace,runtime/printf,+runtime/printf_format\n                --filter=-,+build/include_what_you_use\n\n      To see a list of all the categories used in cpplint, pass no arg:\n         --filter=\n\n    counting=total|toplevel|detailed\n      The total number of errors found is always printed. If\n      'toplevel' is provided, then the count of errors in each of\n      the top-level categories like 'build' and 'whitespace' will\n      also be printed. If 'detailed' is provided, then a count\n      is provided for each category like 'build/class'.\n\"\"\"",
        "\"\"\"Updates the global list of error-suppressions.\n\n  Parses any NOLINT comments on the current line, updating the global\n  error_suppressions store.  Reports an error if the NOLINT comment\n  was malformed.\n\n  Args:\n    filename: str, the name of the input file.\n    raw_line: str, the line of input text, with comments.\n    linenum: int, the number of the current line.\n    error: function, an error handler.\n  \"\"\"",
        "\"\"\"Returns true if the specified error category is suppressed on this line.\n\n  Consults the global error_suppressions map populated by\n  ParseNolintSuppressions/ResetNolintSuppressions.\n\n  Args:\n    category: str, the category of the error.\n    linenum: int, the current line number.\n  Returns:\n    bool, True iff the error should be suppressed due to a NOLINT comment.\n  \"\"\"",
        "\"\"\"Matches the string with the pattern, caching the compiled regexp.\"\"\"",
        "\"\"\"Searches the string for the pattern, caching the compiled regexp.\"\"\"",
        "\"\"\"Tracks line numbers for includes, and the order in which includes appear.\n\n  As a dict, an _IncludeState object serves as a mapping between include\n  filename and line number on which that file was included.\n\n  Call CheckNextIncludeOrder() once for each header in the file, passing\n  in the type constants defined above. Calls in an illegal order will\n  raise an _IncludeError with an appropriate error message.\n\n  \"\"\"",
        "\"\"\"Returns a path canonicalized for alphabetical comparison.\n\n    - replaces \"-\" with \"_\" so they both cmp the same.\n    - removes '-inl' since we don't require them to be after the main header.\n    - lowercase everything, just in case.\n\n    Args:\n      header_path: Path to be canonicalized.\n\n    Returns:\n      Canonicalized path.\n    \"\"\"",
        "\"\"\"Check if a header is in alphabetical order with the previous header.\n\n    Args:\n      header_path: Header to be checked.\n\n    Returns:\n      Returns true if the header is in alphabetical order.\n    \"\"\"",
        "\"\"\"Returns a non-empty error message if the next header is out of order.\n\n    This function also updates the internal state to be ready to check\n    the next include.\n\n    Args:\n      header_type: One of the _XXX_HEADER constants defined above.\n\n    Returns:\n      The empty string if the header is in the right order, or an\n      error message describing what's wrong.\n\n    \"\"\"",
        "\"\"\"Maintains module-wide state..\"\"\"",
        "\"\"\"Sets the output format for errors.\"\"\"",
        "\"\"\"Sets the module's verbosity, and returns the previous setting.\"\"\"",
        "\"\"\"Sets the module's counting options.\"\"\"",
        "\"\"\"Sets the error-message filters.\n\n    These filters are applied when deciding whether to emit a given\n    error message.\n\n    Args:\n      filters: A string of comma-separated filters (eg \"+whitespace/indent\").\n               Each filter should start with + or -; else we die.\n\n    Raises:\n      ValueError: The comma-separated filters did not all start with '+' or '-'.\n                  E.g. \"-,+whitespace,-whitespace/indent,whitespace/badfilter\"\n    \"\"\"",
        "\"\"\"Sets the module's error statistic back to zero.\"\"\"",
        "\"\"\"Bumps the module's error statistic.\"\"\"",
        "\"\"\"Print a summary of errors by category, and the total.\"\"\"",
        "\"\"\"Gets the module's output format.\"\"\"",
        "\"\"\"Sets the module's output format.\"\"\"",
        "\"\"\"Returns the module's verbosity setting.\"\"\"",
        "\"\"\"Sets the module's verbosity, and returns the previous setting.\"\"\"",
        "\"\"\"Sets the module's counting options.\"\"\"",
        "\"\"\"Returns the module's list of output filters, as a list.\"\"\"",
        "\"\"\"Sets the module's error-message filters.\n\n  These filters are applied when deciding whether to emit a given\n  error message.\n\n  Args:\n    filters: A string of comma-separated filters (eg \"whitespace/indent\").\n             Each filter should start with + or -; else we die.\n  \"\"\"",
        "\"\"\"Tracks current function name and the number of lines in its body.\"\"\"",
        "\"\"\"Start analyzing function body.\n\n    Args:\n      function_name: The name of the function being tracked.\n    \"\"\"",
        "\"\"\"Count line in current function body.\"\"\"",
        "\"\"\"Report if too many lines in function body.\n\n    Args:\n      error: The function to call with any errors found.\n      filename: The name of the current file.\n      linenum: The number of the line to check.\n    \"\"\"",
        "\"\"\"Stop analyzing function body.\"\"\"",
        "\"\"\"Indicates a problem with the include order in a file.\"\"\"",
        "\"\"\"Provides utility functions for filenames.\n\n  FileInfo provides easy access to the components of a file's path\n  relative to the project root.\n  \"\"\"",
        "\"\"\"Make Windows paths like Unix.\"\"\"",
        "\"\"\"FullName after removing the local path to the repository.\n\n    If we have a real absolute path name here we can try to do something smart:\n    detecting the root of the checkout and truncating /path/to/checkout from\n    the name so that we get header guards that don't include things like\n    \"C:\\Documents and Settings\\...\" or \"/home/username/...\" in them and thus\n    people on different computers who have checked the source out to different\n    locations won't see bogus errors.\n    \"\"\"",
        "\"\"\"Splits the file into the directory, basename, and extension.\n\n    For 'chrome/browser/browser.cc', Split() would\n    return ('chrome/browser', 'browser', '.cc')\n\n    Returns:\n      A tuple of (directory, basename, extension).\n    \"\"\"",
        "\"\"\"File base name - text after the final slash, before the final period.\"\"\"",
        "\"\"\"File extension - text following the final period.\"\"\"",
        "\"\"\"File has no source file extension.\"\"\"",
        "\"\"\"File has a source file extension.\"\"\"",
        "\"\"\"If confidence >= verbose, category passes filter and is not suppressed.\"\"\"",
        "\"\"\"Logs the fact we've found a lint error.\n\n  We log where the error was found, and also our confidence in the error,\n  that is, how certain we are this is a legitimate style regression, and\n  not a misidentification or a use that's sometimes justified.\n\n  False positives can be suppressed by the use of\n  \"cpplint(category)\"  comments on the offending line.  These are\n  parsed into _error_suppressions.\n\n  Args:\n    filename: The name of the file containing the error.\n    linenum: The number of the line containing the error.\n    category: A string used to describe the \"category\" this bug\n      falls under: \"whitespace\", say, or \"runtime\".  Categories\n      may have a hierarchy separated by slashes: \"whitespace/indent\".\n    confidence: A number from 1-5 representing a confidence score for\n      the error, with 5 meaning that we are certain of the problem,\n      and 1 meaning that it could be a legitimate construct.\n    message: The error message.\n  \"\"\"",
        "\"\"\"Does line terminate so, that the next symbol is in string constant.\n\n  This function does not consider single-line nor multi-line comments.\n\n  Args:\n    line: is a partial line of code starting from the 0..n.\n\n  Returns:\n    True, if next character appended to 'line' is inside a\n    string constant.\n  \"\"\"",
        "\"\"\"Find the beginning marker for a multiline comment.\"\"\"",
        "\"\"\"We are inside a comment, find the end marker.\"\"\"",
        "\"\"\"Clears a range of lines for multi-line comments.\"\"\"",
        "\"\"\"Removes multiline (c-style) comments from lines.\"\"\"",
        "\"\"\"Removes //-comments and single-line C-style /* */ comments.\n\n  Args:\n    line: A line of C++ source.\n\n  Returns:\n    The line with single-line comments removed.\n  \"\"\"",
        "\"\"\"Holds 3 copies of all lines with different preprocessing applied to them.\n\n  1) elided member contains lines without strings and comments,\n  2) lines member contains lines without comments, and\n  3) raw member contains all the lines without processing.\n  All these three members are of <type 'list'>, and of the same length.\n  \"\"\"",
        "\"\"\"Returns the number of lines represented.\"\"\"",
        "\"\"\"Collapses strings and chars on a line to simple \"\" or '' blocks.\n\n    We nix strings first so we're not fooled by text like '\"http://\"'\n\n    Args:\n      elided: The line being processed.\n\n    Returns:\n      The line with collapsed strings.\n    \"\"\"",
        "\"\"\"If input points to ( or { or [, finds the position that closes it.\n\n  If lines[linenum][pos] points to a '(' or '{' or '[', finds the\n  linenum/pos that correspond to the closing of the expression.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    pos: A position on the line.\n\n  Returns:\n    A tuple (line, linenum, pos) pointer *past* the closing brace, or\n    (line, len(lines), -1) if we never find a close.  Note we ignore\n    strings and comments when matching; and the line we return is the\n    'cleansed' line at linenum.\n  \"\"\"",
        "\"\"\"Logs an error if no Copyright message appears at the top of the file.\"\"\"",
        "\"\"\"Returns the CPP variable that should be used as a header guard.\n\n  Args:\n    filename: The name of a C++ header file.\n\n  Returns:\n    The CPP variable that should be used as a header guard in the\n    named file.\n\n  \"\"\"",
        "\"\"\"Checks that the file contains a header guard.\n\n  Logs an error if no #ifndef header guard is present.  For other\n  headers, checks that the full pathname is used.\n\n  Args:\n    filename: The name of the C++ header file.\n    lines: An array of strings, each representing a line of the file.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Logs an error for each line containing Unicode replacement characters.\n\n  These indicate that either the file contained invalid UTF-8 (likely)\n  or Unicode replacement characters (which it shouldn't).  Note that\n  it's possible for this to throw off line numbering if the invalid\n  UTF-8 occurred adjacent to a newline.\n\n  Args:\n    filename: The name of the current file.\n    lines: An array of strings, each representing a line of the file.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Logs an error if there is no newline char at the end of the file.\n\n  Args:\n    filename: The name of the current file.\n    lines: An array of strings, each representing a line of the file.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Logs an error if we see /* ... */ or \"...\" that extend past one line.\n\n  /* ... */ comments are legit inside macros, for one line.\n  Otherwise, we prefer // comments, so it's ok to warn about the\n  other.  Likewise, it's ok for strings to extend across multiple\n  lines, as long as a line continuation character (backslash)\n  terminates each line. Although not currently prohibited by the C++\n  style guide, it's ugly and unnecessary. We don't do well with either\n  in this lint program, so we warn about both.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Checks for calls to thread-unsafe functions.\n\n  Much code has been originally written without consideration of\n  multi-threading. Also, engineers are relying on their old experience;\n  they have learned posix before threading extensions were added. These\n  tests guide the engineers to use thread-safe functions (when using\n  posix directly).\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Checks for invalid increment *count++.\n\n  For example following function:\n  void increment_counter(int* count) {\n    *count++;\n  }\n  is invalid, because it effectively does count++, moving pointer, and should\n  be replaced with ++*count, (*count)++ or *count += 1.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Stores information about a class.\"\"\"",
        "\"\"\"Holds the current state of the parse relating to class declarations.\n\n  It maintains a stack of _ClassInfos representing the parser's guess\n  as to the current nesting of class declarations. The innermost class\n  is at the top (back) of the stack. Typically, the stack will either\n  be empty or have exactly one entry.\n  \"\"\"",
        "\"\"\"Checks that all classes have been completely parsed.\n\n    Call this when all lines in a file have been processed.\n    Args:\n      filename: The name of the current file.\n      error: The function to call with any errors found.\n    \"\"\"",
        "\"\"\"Logs an error if we see certain non-ANSI constructs ignored by gcc-2.\n\n  Complain about several constructs which gcc-2 accepts, but which are\n  not standard C++.  Warning about these in lint is one way to ease the\n  transition to new compilers.\n  - put storage class first (e.g. \"static const\" instead of \"const static\").\n  - \"%lld\" instead of %qd\" in printf-type functions.\n  - \"%1$d\" is non-standard in printf-type functions.\n  - \"\\%\" is an undefined character escape sequence.\n  - text after #endif is not allowed.\n  - invalid inner-style forward declaration.\n  - >? and <? operators, and their >?= and <?= cousins.\n  - classes with virtual methods need virtual destructors (compiler warning\n    available, but not turned on yet.)\n\n  Additionally, check for constructor/destructor style violations and reference\n  members, as it is very convenient to do so while checking for\n  gcc-2 compliance.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    class_state: A _ClassState instance which maintains information about\n                 the current stack of nested class declarations being parsed.\n    error: A callable to which errors are reported, which takes 4 arguments:\n           filename, line number, error level, and message\n  \"\"\"",
        "\"\"\"Checks for the correctness of various spacing around function calls.\n\n  Args:\n    filename: The name of the current file.\n    line: The text of the line to check.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Returns true if the given line is blank.\n\n  We consider a line to be blank if the line is empty or consists of\n  only white spaces.\n\n  Args:\n    line: A line of a string.\n\n  Returns:\n    True, if the given line is blank.\n  \"\"\"",
        "\"\"\"Reports for long function bodies.\n\n  For an overview why this is done, see:\n  http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Write_Short_Functions\n\n  Uses a simplistic algorithm assuming other style guidelines\n  (especially spacing) are followed.\n  Only checks unindented functions, so class members are unchecked.\n  Trivial bodies are unchecked, so constructors with huge initializer lists\n  may be missed.\n  Blank/comment lines are not counted so as to avoid encouraging the removal\n  of vertical space and comments just to get through a lint check.\n  NOLINT *on the last line of a function* disables this check.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    function_state: Current function name and lines in body so far.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Checks for common mistakes in TODO comments.\n\n  Args:\n    comment: The text of the comment from the line in question.\n    filename: The name of the current file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Checks for the correctness of various spacing issues in the code.\n\n  Things we check for: spaces around operators, spaces after\n  if/for/while/switch, no spaces around parens in function calls, two\n  spaces between code and comment, don't start a block with a blank\n  line, don't end a function with a blank line, don't add a blank line\n  after public/protected/private, don't have too many blank lines in a row.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Checks for additional blank line issues related to sections.\n\n  Currently the only thing checked here is blank line before protected/private.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    class_info: A _ClassInfo objects.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Return the most recent non-blank line and its line number.\n\n  Args:\n    clean_lines: A CleansedLines instance containing the file contents.\n    linenum: The number of the line to check.\n\n  Returns:\n    A tuple with two elements.  The first element is the contents of the last\n    non-blank line before the current line, or the empty string if this is the\n    first non-blank line.  The second is the line number of that line, or -1\n    if this is the first non-blank line.\n  \"\"\"",
        "\"\"\"Looks for misplaced braces (e.g. at the end of line).\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Determine whether a basic CHECK can be replaced with a more specific one.\n\n  For example suggest using CHECK_EQ instead of CHECK(a == b) and\n  similarly for CHECK_GE, CHECK_GT, CHECK_LE, CHECK_LT, CHECK_NE.\n\n  Args:\n    operator: The C++ operator used in the CHECK.\n    macro: The CHECK or EXPECT macro being called.\n    line: The current source line.\n\n  Returns:\n    True if the CHECK can be replaced with a more specific one.\n  \"\"\"",
        "\"\"\"Checks the use of CHECK and EXPECT macros.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Determines the width of the line in column positions.\n\n  Args:\n    line: A string, which may be a Unicode string.\n\n  Returns:\n    The width of the line in column positions, accounting for Unicode\n    combining characters and wide characters.\n  \"\"\"",
        "\"\"\"Checks rules from the 'C++ style rules' section of cppguide.html.\n\n  Most of these rules are hard to test (naming, comment style), but we\n  do what we can.  In particular we check for 2-space indents, line lengths,\n  tab usage, spaces inside code, etc.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    file_extension: The extension (without the dot) of the filename.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Drops common suffixes like _test.cc or -inl.h from filename.\n\n  For example:\n    >>> _DropCommonSuffixes('foo/foo-inl.h')\n    'foo/foo'\n    >>> _DropCommonSuffixes('foo/bar/foo.cc')\n    'foo/bar/foo'\n    >>> _DropCommonSuffixes('foo/foo_internal.h')\n    'foo/foo'\n    >>> _DropCommonSuffixes('foo/foo_unusualinternal.h')\n    'foo/foo_unusualinternal'\n\n  Args:\n    filename: The input filename.\n\n  Returns:\n    The filename with the common suffix removed.\n  \"\"\"",
        "\"\"\"Determines if the given filename has a suffix that identifies it as a test.\n\n  Args:\n    filename: The input filename.\n\n  Returns:\n    True if 'filename' looks like a test, False otherwise.\n  \"\"\"",
        "\"\"\"Figures out what kind of header 'include' is.\n\n  Args:\n    fileinfo: The current file cpplint is running over. A FileInfo instance.\n    include: The path to a #included file.\n    is_system: True if the #include used <> rather than \"\".\n\n  Returns:\n    One of the _XXX_HEADER constants.\n\n  For example:\n    >>> _ClassifyInclude(FileInfo('foo/foo.cc'), 'stdio.h', True)\n    _C_SYS_HEADER\n    >>> _ClassifyInclude(FileInfo('foo/foo.cc'), 'string', True)\n    _CPP_SYS_HEADER\n    >>> _ClassifyInclude(FileInfo('foo/foo.cc'), 'foo/foo.h', False)\n    _LIKELY_MY_HEADER\n    >>> _ClassifyInclude(FileInfo('foo/foo_unknown_extension.cc'),\n    ...                  'bar/foo_other_ext.h', False)\n    _POSSIBLE_MY_HEADER\n    >>> _ClassifyInclude(FileInfo('foo/foo.cc'), 'foo/bar.h', False)\n    _OTHER_HEADER\n  \"\"\"",
        "\"\"\"Check rules that are applicable to #include lines.\n\n  Strings on #include lines are NOT removed from elided line, to make\n  certain tasks easier. However, to prevent false positives, checks\n  applicable to #include lines in CheckLanguage must be put here.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    include_state: An _IncludeState instance in which the headers are inserted.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Retrieves all the text between matching open and close parentheses.\n\n  Given a string of lines and a regular expression string, retrieve all the text\n  following the expression and between opening punctuation symbols like\n  (, [, or {, and the matching close-punctuation symbol. This properly nested\n  occurrences of the punctuations, so for the text like\n    printf(a(), b(c()));\n  a call to _GetTextInside(text, r'printf\\(') will return 'a(), b(c())'.\n  start_pattern must match string having an open punctuation symbol at the end.\n\n  Args:\n    text: The lines to extract text. Its comments and strings must be elided.\n           It can be single line and can span multiple lines.\n    start_pattern: The regexp string indicating where to start extracting\n                   the text.\n  Returns:\n    The extracted text.\n    None if either the opening string or ending punctuation could not be found.\n  \"\"\"",
        "\"\"\"Checks rules from the 'C++ language rules' section of cppguide.html.\n\n  Some of these rules are hard to test (function overloading, using\n  uint32 inappropriately), but we do the best we can.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    file_extension: The extension (without the dot) of the filename.\n    include_state: An _IncludeState instance in which the headers are inserted.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Checks for a C-style cast by looking for the pattern.\n\n  This also handles sizeof(type) warnings, due to similarity of content.\n\n  Args:\n    filename: The name of the current file.\n    linenum: The number of the line to check.\n    line: The line of code to check.\n    raw_line: The raw line of code to check, with comments.\n    cast_type: The string for the C++ cast to recommend.  This is either\n      reinterpret_cast, static_cast, or const_cast, depending.\n    pattern: The regular expression used to find C-style casts.\n    error: The function to call with any errors found.\n\n  Returns:\n    True if an error was emitted.\n    False otherwise.\n  \"\"\"",
        "\"\"\"Check if these two filenames belong to the same module.\n\n  The concept of a 'module' here is a as follows:\n  foo.h, foo-inl.h, foo.cc, foo_test.cc and foo_unittest.cc belong to the\n  same 'module' if they are in the same directory.\n  some/path/public/xyzzy and some/path/internal/xyzzy are also considered\n  to belong to the same module here.\n\n  If the filename_cc contains a longer path than the filename_h, for example,\n  '/absolute/path/to/base/sysinfo.cc', and this file would include\n  'base/sysinfo.h', this function also produces the prefix needed to open the\n  header. This is used by the caller of this function to more robustly open the\n  header file. We don't have access to the real include paths in this context,\n  so we need this guesswork here.\n\n  Known bugs: tools/base/bar.cc and base/bar.h belong to the same module\n  according to this implementation. Because of this, this function gives\n  some false positives. This should be sufficiently rare in practice.\n\n  Args:\n    filename_cc: is the path for the .cc file\n    filename_h: is the path for the header path\n\n  Returns:\n    Tuple with a bool and a string:\n    bool: True if filename_cc and filename_h belong to the same module.\n    string: the additional prefix needed to open the header file.\n  \"\"\"",
        "\"\"\"Fill up the include_state with new includes found from the file.\n\n  Args:\n    filename: the name of the header to read.\n    include_state: an _IncludeState instance in which the headers are inserted.\n    io: The io factory to use to read the file. Provided for testability.\n\n  Returns:\n    True if a header was succesfully added. False otherwise.\n  \"\"\"",
        "\"\"\"Reports for missing stl includes.\n\n  This function will output warnings to make sure you are including the headers\n  necessary for the stl containers and functions that you use. We only give one\n  reason to include a header. For example, if you use both equal_to<> and\n  less<> in a .h file, only one (the latter in the file) of these will be\n  reported as a reason to include the <functional>.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    include_state: An _IncludeState instance.\n    error: The function to call with any errors found.\n    io: The IO factory to use to read the header file. Provided for unittest\n        injection.\n  \"\"\"",
        "\"\"\"Check that make_pair's template arguments are deduced.\n\n  G++ 4.6 in C++0x mode fails badly if make_pair's template arguments are\n  specified explicitly, and such use isn't intended in any case.\n\n  Args:\n    filename: The name of the current file.\n    clean_lines: A CleansedLines instance containing the file.\n    linenum: The number of the line to check.\n    error: The function to call with any errors found.\n  \"\"\"",
        "\"\"\"Processes a single line in the file.\n\n  Args:\n    filename: Filename of the file that is being processed.\n    file_extension: The extension (dot not included) of the file.\n    clean_lines: An array of strings, each representing a line of the file,\n                 with comments stripped.\n    line: Number of line being processed.\n    include_state: An _IncludeState instance in which the headers are inserted.\n    function_state: A _FunctionState instance which counts function lines, etc.\n    class_state: A _ClassState instance which maintains information about\n                 the current stack of nested class declarations being parsed.\n    error: A callable to which errors are reported, which takes 4 arguments:\n           filename, line number, error level, and message\n    extra_check_functions: An array of additional check functions that will be\n                           run on each source line. Each function takes 4\n                           arguments: filename, clean_lines, line, error\n  \"\"\"",
        "\"\"\"Performs lint checks and reports any errors to the given error function.\n\n  Args:\n    filename: Filename of the file that is being processed.\n    file_extension: The extension (dot not included) of the file.\n    lines: An array of strings, each representing a line of the file, with the\n           last element being empty if the file is terminated with a newline.\n    error: A callable to which errors are reported, which takes 4 arguments:\n           filename, line number, error level, and message\n    extra_check_functions: An array of additional check functions that will be\n                           run on each source line. Each function takes 4\n                           arguments: filename, clean_lines, line, error\n  \"\"\"",
        "\"\"\"Does google-lint on a single file.\n\n  Args:\n    filename: The name of the file to parse.\n\n    vlevel: The level of errors to report.  Every error of confidence\n    >= verbose_level will be reported.  0 is a good default.\n\n    extra_check_functions: An array of additional check functions that will be\n                           run on each source line. Each function takes 4\n                           arguments: filename, clean_lines, line, error\n  \"\"\"",
        "\"\"\"Prints a brief usage string and exits, optionally with an error message.\n\n  Args:\n    message: The optional error message.\n  \"\"\"",
        "\"\"\"Prints a list of all the error-categories used by error messages.\n\n  These are the categories used to filter messages via --filter.\n  \"\"\"",
        "\"\"\"Parses the command line arguments.\n\n  This may set the output format and verbosity level as side-effects.\n\n  Args:\n    args: The command line arguments:\n\n  Returns:\n    The list of filenames to lint.\n  \"\"\""
    ],
    "functions": [
        "ParseNolintSuppressions",
        "ResetNolintSuppressions",
        "IsErrorSuppressedByNolint",
        "Match",
        "Search",
        "CanonicalizeAlphabeticalOrder",
        "IsInAlphabeticalOrder",
        "CheckNextIncludeOrder",
        "SetOutputFormat",
        "SetVerboseLevel",
        "SetCountingStyle",
        "SetFilters",
        "ResetErrorCounts",
        "IncrementErrorCount",
        "PrintErrorCounts",
        "_OutputFormat",
        "_SetOutputFormat",
        "_VerboseLevel",
        "_SetVerboseLevel",
        "_SetCountingStyle",
        "_Filters",
        "_SetFilters",
        "Begin",
        "Count",
        "Check",
        "End",
        "FullName",
        "RepositoryName",
        "Split",
        "BaseName",
        "Extension",
        "NoExtension",
        "IsSource",
        "_ShouldPrintError",
        "IsCppString",
        "FindNextMultiLineCommentStart",
        "FindNextMultiLineCommentEnd",
        "RemoveMultiLineCommentsFromRange",
        "RemoveMultiLineComments",
        "CleanseComments",
        "NumLines",
        "_CollapseStrings",
        "CloseExpression",
        "CheckForCopyright",
        "GetHeaderGuardCPPVariable",
        "CheckForHeaderGuard",
        "CheckForUnicodeReplacementCharacters",
        "CheckForNewlineAtEOF",
        "CheckForMultilineCommentsAndStrings",
        "CheckPosixThreading",
        "CheckInvalidIncrement",
        "CheckFinished",
        "CheckForNonStandardConstructs",
        "CheckSpacingForFunctionCall",
        "IsBlankLine",
        "CheckForFunctionLengths",
        "CheckComment",
        "CheckSpacing",
        "CheckSectionSpacing",
        "GetPreviousNonBlankLine",
        "CheckBraces",
        "ReplaceableCheck",
        "CheckCheck",
        "GetLineWidth",
        "CheckStyle",
        "_DropCommonSuffixes",
        "_IsTestFilename",
        "_ClassifyInclude",
        "CheckIncludeLine",
        "_GetTextInside",
        "CheckLanguage",
        "CheckCStyleCast",
        "FilesBelongToSameModule",
        "UpdateIncludeState",
        "CheckForIncludeWhatYouUse",
        "CheckMakePairUsesDeduction",
        "ProcessLine",
        "ProcessFileData",
        "ProcessFile",
        "PrintUsage",
        "PrintCategories",
        "ParseArguments",
        "main"
    ],
    "classes": [
        "_IncludeState",
        "_CppLintState",
        "_FunctionState",
        "_IncludeError",
        "FileInfo",
        "CleansedLines",
        "_ClassInfo",
        "_ClassState"
    ]
}