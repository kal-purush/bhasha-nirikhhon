{
    "identifiers": [
        "math",
        "numpy",
        "np",
        "qiskit",
        "exceptions",
        "QiskitError",
        "qiskit",
        "circuit",
        "QuantumCircuit",
        "qiskit",
        "circuit",
        "QuantumRegister",
        "qiskit",
        "circuit",
        "Instruction",
        "qiskit",
        "circuit",
        "exceptions",
        "CircuitError",
        "qiskit",
        "circuit",
        "library",
        "standard_gates",
        "x",
        "CXGate",
        "XGate",
        "qiskit",
        "circuit",
        "library",
        "standard_gates",
        "h",
        "HGate",
        "qiskit",
        "circuit",
        "library",
        "standard_gates",
        "s",
        "SGate",
        "SdgGate",
        "qiskit",
        "circuit",
        "library",
        "standard_gates",
        "ry",
        "RYGate",
        "qiskit",
        "circuit",
        "library",
        "standard_gates",
        "rz",
        "RZGate",
        "qiskit",
        "circuit",
        "reset",
        "Reset",
        "qiskit",
        "quantum_info",
        "Statevector",
        "Instruction",
        "ctrl_state",
        "num_qubits",
        "isinstance",
        "Statevector",
        "data",
        "isinstance",
        "num_qubits",
        "QiskitError",
        "isinstance",
        "len",
        "isinstance",
        "num_qubits",
        "math",
        "log2",
        "math",
        "log2",
        "len",
        "num_qubits",
        "num_qubits",
        "is_integer",
        "QiskitError",
        "math",
        "isclose",
        "sum",
        "np",
        "absolute",
        "abs_tol",
        "_EPS",
        "QiskitError",
        "num_qubits",
        "ctrl_state",
        "len",
        "ctrl_state",
        "num_qubits",
        "_from_label",
        "_define_from_label",
        "_from_int",
        "_define_from_int",
        "_define_synthesis",
        "QuantumRegister",
        "num_qubits",
        "QuantumCircuit",
        "q",
        "name",
        "qubit",
        "param",
        "reversed",
        "initialize_circuit",
        "append",
        "Reset",
        "q",
        "qubit",
        "param",
        "initialize_circuit",
        "append",
        "XGate",
        "q",
        "qubit",
        "param",
        "initialize_circuit",
        "append",
        "HGate",
        "q",
        "qubit",
        "param",
        "initialize_circuit",
        "append",
        "XGate",
        "q",
        "qubit",
        "initialize_circuit",
        "append",
        "HGate",
        "q",
        "qubit",
        "param",
        "initialize_circuit",
        "append",
        "HGate",
        "q",
        "qubit",
        "initialize_circuit",
        "append",
        "SGate",
        "q",
        "qubit",
        "param",
        "initialize_circuit",
        "append",
        "HGate",
        "q",
        "qubit",
        "initialize_circuit",
        "append",
        "SdgGate",
        "q",
        "qubit",
        "initialize_circuit",
        "QuantumRegister",
        "num_qubits",
        "QuantumCircuit",
        "q",
        "name",
        "np",
        "real",
        "num_qubits",
        "len",
        "intstr",
        "num_qubits",
        "QiskitError",
        "len",
        "intstr",
        "num_qubits",
        "qubit",
        "bit",
        "intstr",
        "initialize_circuit",
        "append",
        "Reset",
        "q",
        "qubit",
        "bit",
        "initialize_circuit",
        "append",
        "XGate",
        "q",
        "qubit",
        "initialize_circuit",
        "gates_to_uncompute",
        "disentangling_circuit",
        "to_instruction",
        "inverse",
        "QuantumRegister",
        "num_qubits",
        "QuantumRegister",
        "num_ctrl_qubits",
        "QuantumCircuit",
        "cq",
        "q",
        "name",
        "i",
        "i",
        "cq",
        "i",
        "i",
        "q",
        "initialize_circuit",
        "append",
        "initialize_instr",
        "qregs",
        "initialize_circuit",
        "QuantumRegister",
        "num_qubits",
        "QuantumRegister",
        "num_ctrl_qubits",
        "QuantumCircuit",
        "cq",
        "q",
        "name",
        "i",
        "num_qubits",
        "ctrl_Initialize",
        "_rotations_to_disentangle",
        "remaining_param",
        "q",
        "q",
        "cq",
        "qubit",
        "qubit",
        "q",
        "i",
        "num_qubits",
        "np",
        "linalg",
        "norm",
        "phis",
        "np",
        "linalg",
        "norm",
        "thetas",
        "np",
        "linalg",
        "norm",
        "phis",
        "_multiplex",
        "RZGate",
        "phis",
        "last_cnot",
        "add_last_cnot",
        "circuit",
        "append",
        "rz_mult",
        "to_instruction",
        "qregs",
        "np",
        "linalg",
        "norm",
        "thetas",
        "_multiplex",
        "RYGate",
        "thetas",
        "last_cnot",
        "add_last_cnot",
        "circuit",
        "append",
        "ry_mult",
        "to_instruction",
        "reverse_ops",
        "qregs",
        "circuit",
        "global_phase",
        "np",
        "angle",
        "sum",
        "remaining_param",
        "circuit",
        "staticmethod",
        "local_param",
        "len",
        "local_param",
        "i",
        "param_len",
        "ctrl_Initialize",
        "_bloch_angles",
        "local_param",
        "i",
        "i",
        "remaining_vector",
        "append",
        "remains",
        "thetas",
        "append",
        "add_theta",
        "phis",
        "append",
        "add_phi",
        "remaining_vector",
        "thetas",
        "phis",
        "staticmethod",
        "pair_of_complex",
        "pair_of_complex",
        "a_complex",
        "b_complex",
        "np",
        "absolute",
        "a_complex",
        "np",
        "sqrt",
        "mag_a",
        "np",
        "absolute",
        "b_complex",
        "final_r",
        "_EPS",
        "np",
        "arccos",
        "mag_a",
        "final_r",
        "np",
        "angle",
        "a_complex",
        "np",
        "angle",
        "b_complex",
        "a_arg",
        "b_arg",
        "b_arg",
        "a_arg",
        "final_r",
        "np",
        "exp",
        "final_t",
        "theta",
        "phi",
        "target_gate",
        "list_of_angles",
        "last_cnot",
        "len",
        "list_of_angles",
        "math",
        "log2",
        "list_len",
        "QuantumRegister",
        "num_ctrl_qubits",
        "QuantumRegister",
        "local_num_qubits",
        "QuantumCircuit",
        "cq",
        "q",
        "name",
        "local_num_qubits",
        "__str__",
        "q",
        "q",
        "local_num_qubits",
        "i",
        "i",
        "cq",
        "q",
        "i",
        "j",
        "num_ctrl_qubits",
        "reversed",
        "num_ctrl_qubits",
        "ctrl_state",
        "i",
        "circuit",
        "x",
        "cq",
        "j",
        "target_gate",
        "list_of_angles",
        "control",
        "num_ctrl_qubits",
        "num_ctrl_qubits",
        "circuit",
        "append",
        "ctrl_gate",
        "qregs",
        "i",
        "j",
        "num_ctrl_qubits",
        "reversed",
        "num_ctrl_qubits",
        "ctrl_state",
        "i",
        "circuit",
        "x",
        "cq",
        "j",
        "circuit",
        "np",
        "kron",
        "np",
        "identity",
        "local_num_qubits",
        "angle_weight",
        "dot",
        "np",
        "array",
        "list_of_angles",
        "tolist",
        "_multiplex",
        "target_gate",
        "list_of_angles",
        "list_len",
        "i",
        "i",
        "cq",
        "i",
        "i",
        "q",
        "circuit",
        "append",
        "multiplex_1",
        "to_instruction",
        "qregs",
        "circuit",
        "append",
        "CXGate",
        "msb",
        "lsb",
        "_multiplex",
        "target_gate",
        "list_of_angles",
        "list_len",
        "i",
        "i",
        "cq",
        "i",
        "i",
        "q",
        "list_len",
        "circuit",
        "append",
        "multiplex_2",
        "to_instruction",
        "reverse_ops",
        "qregs",
        "circuit",
        "append",
        "multiplex_2",
        "to_instruction",
        "qregs",
        "last_cnot",
        "circuit",
        "append",
        "CXGate",
        "msb",
        "lsb",
        "circuit",
        "qargs",
        "cargs",
        "qarg",
        "sublist",
        "qargs",
        "qarg",
        "sublist",
        "num_qubits",
        "num_ctrl_qubits",
        "len",
        "flat_qargs",
        "QiskitError",
        "num_qubits",
        "num_qubits",
        "len",
        "flat_qargs",
        "flat_qargs",
        "statevector",
        "ctrl_state",
        "ctrl_qubits",
        "qubits",
        "statevector",
        "QiskitError",
        "ctrl_qubits",
        "QiskitError",
        "ctrl_state",
        "len",
        "ctrl_qubits",
        "qubits",
        "qubits",
        "isinstance",
        "qubits",
        "qubits",
        "isinstance",
        "ctrl_qubits",
        "ctrl_qubits",
        "isinstance",
        "statevector",
        "len",
        "qubits",
        "i",
        "i",
        "ctrl_qubits",
        "i",
        "i",
        "qubits",
        "append",
        "ctrl_Initialize",
        "statevector",
        "ctrl_state",
        "regs",
        "ctrl_initialize"
    ],
    "literals": [
        "\"The num_qubits parameter to Initialize should only be\"",
        "\" used when params is an integer\"",
        "\"Desired statevector length not a positive power of 2.\"",
        "\"Sum of amplitudes-squared does not equal one.\"",
        "\"ctrl_initialize\"",
        "\"q\"",
        "\"init_def\"",
        "\"1\"",
        "\"+\"",
        "\"-\"",
        "\"r\"",
        "\"l\"",
        "\"q\"",
        "\"init_def\"",
        "f\"{int(np.real(self.params[0])):0{self.num_qubits}b}\"",
        "\"Initialize integer has %s bits, but this exceeds the\"",
        "\" number of qubits in the circuit, %s.\"",
        "\"1\"",
        "'q'",
        "'cq'",
        "'init_def'",
        "'disentangler'",
        "\"multiplex\"",
        "'0'",
        "'0'",
        "\"Initialize parameter vector has %d elements, therefore expects %s \"",
        "\"qubits. However, %s were provided.\"",
        "r\"\"\"Initialize qubits in a specific state.\n\n\tQubit initialization is done by first resetting the qubits to :math:`|0\\rangle`\n\tfollowed by an state preparing unitary. Both these steps are included in the\n\t`Initialize` instruction.\n\n\tArgs:\n\t\tparams (str or list or int):\n\t\t\t* str: labels of basis states of the Pauli eigenstates Z, X, Y. See\n\t\t\t\t:meth:`~qiskit.quantum_info.states.statevector.Statevector.from_label`.\n\t\t\t\tNotice the order of the labels is reversed with respect to the qubit index to\n\t\t\t\tbe applied to. Example label '01' initializes the qubit zero to `|1>` and the\n\t\t\t\tqubit one to `|0>`.\n\t\t\t* list: vector of complex amplitudes to initialize to.\n\t\t\t* int: an integer that is used as a bitmap indicating which qubits to initialize\n\t\t\t   to `|1>`. Example: setting params to 5 would initialize qubit 0 and qubit 2\n\t\t\t   to `|1>` and qubit 1 to `|0>`.\n\t\tqubits (QuantumRegister or int):\n\t\t\t* QuantumRegister: A list of qubits to be initialized [Default: None].\n\t\t\t* int: Index of qubit to initialized [Default: None].\n\n\tReturns:\n\t\tqiskit.circuit.Instruction: a handle to the instruction that was just initialized\n\n\tExamples:\n\t\tPrepare a qubit in the state :math:`(|0\\rangle - |1\\rangle) / \\sqrt{2}`.\n\n\t\t.. jupyter-execute::\n\n\t\t\timport numpy as np\n\t\t\tfrom qiskit import QuantumCircuit\n\n\t\t\tcircuit = QuantumCircuit(1)\n\t\t\tcircuit.initialize([1/np.sqrt(2), -1/np.sqrt(2)], 0)\n\t\t\tcircuit.draw()\n\n\t\toutput:\n\t\t\t ┌──────────────────────────────┐\n\t\tq_0: ┤ initialize(0.70711,-0.70711) ├\n\t\t\t └──────────────────────────────┘\n\n\n\t\tInitialize from a string two qubits in the state `|10>`.\n\t\tThe order of the labels is reversed with respect to qubit index.\n\t\tMore information about labels for basis states are in\n\t\t:meth:`~qiskit.quantum_info.states.statevector.Statevector.from_label`.\n\n\t\t.. jupyter-execute::\n\n\t\t\timport numpy as np\n\t\t\tfrom qiskit import QuantumCircuit\n\n\t\t\tcircuit = QuantumCircuit(2)\n\t\t\tcircuit.initialize('01', circuit.qubits)\n\t\t\tcircuit.draw()\n\n\t\toutput:\n\t\t\t ┌──────────────────┐\n\t\tq_0: ┤0                 ├\n\t\t\t │  initialize(0,1) │\n\t\tq_1: ┤1                 ├\n\t\t\t └──────────────────┘\n\n\n\t\tInitialize two qubits from an array of complex amplitudes\n\t\t.. jupyter-execute::\n\n\t\t\timport numpy as np\n\t\t\tfrom qiskit import QuantumCircuit\n\n\t\t\tcircuit = QuantumCircuit(2)\n\t\t\tcircuit.initialize([0, 1/np.sqrt(2), -1.j/np.sqrt(2), 0], circuit.qubits)\n\t\t\tcircuit.draw()\n\n\t\toutput:\n\t\t\t ┌────────────────────────────────────┐\n\t\tq_0: ┤0                                   ├\n\t\t\t │  initialize(0,0.70711,-0.70711j,0) │\n\t\tq_1: ┤1                                   ├\n\t\t\t └────────────────────────────────────┘\n\t\"\"\"",
        "\"Null State vector\"",
        "\"Control qubits not specified\"",
        "\"1\""
    ],
    "variables": [
        "_EPS",
        "_from_label",
        "_from_int",
        "_from_label",
        "num_qubits",
        "_from_int",
        "num_qubits",
        "num_qubits",
        "num_qubits",
        "ctrl_state",
        "num_ctrl_qubits",
        "definition",
        "definition",
        "definition",
        "q",
        "initialize_circuit",
        "q",
        "initialize_circuit",
        "intstr",
        "disentangling_circuit",
        "initialize_instr",
        "q",
        "cq",
        "initialize_circuit",
        "qregs",
        "q",
        "cq",
        "circuit",
        "remaining_param",
        "remaining_param",
        "thetas",
        "phis",
        "qregs",
        "add_last_cnot",
        "add_last_cnot",
        "rz_mult",
        "ry_mult",
        "remaining_vector",
        "thetas",
        "phis",
        "param_len",
        "remains",
        "add_theta",
        "add_phi",
        "a_complex",
        "b_complex",
        "a_complex",
        "b_complex",
        "mag_a",
        "final_r",
        "theta",
        "phi",
        "final_r",
        "final_t",
        "theta",
        "a_arg",
        "b_arg",
        "final_t",
        "phi",
        "list_len",
        "local_num_qubits",
        "cq",
        "q",
        "circuit",
        "lsb",
        "msb",
        "qregs",
        "ctrl_gate",
        "angle_weight",
        "list_of_angles",
        "multiplex_1",
        "qregs",
        "multiplex_2",
        "qregs",
        "flat_qargs",
        "ctrl_state",
        "qubits",
        "qubits",
        "ctrl_qubits",
        "num_qubits",
        "regs",
        "QuantumCircuit",
        "ctrl_initialize"
    ],
    "comments": [
        "This code is part of Qiskit.",
        "",
        "(C) Copyright IBM 2017.",
        "",
        "This code is licensed under the Apache License, Version 2.0. You may",
        "obtain a copy of this license in the LICENSE.txt file in the root directory",
        "of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.",
        "",
        "Any modifications or derivative works of this code must retain this",
        "copyright notice, and modified files need to carry a notice indicating",
        "that they have been altered from the originals.",
        "global variable used to chop very small numbers to zero",
        "Check if param is a power of 2",
        "Check if probabilities (amplitudes squared) sum to 1",
        "|+i>",
        "|-i>",
        "Convert to int since QuantumCircuit converted to complex",
        "and make a bit string and reverse it",
        "Raise if number of bits is greater than num_qubits",
        "call to generate the circuit that takes the desired vector to zero",
        "invert the circuit to create the desired vector from zero (assuming",
        "the qubits are in the zero state)",
        "kick start the peeling loop, and disentangle one-by-one from LSB to MSB",
        "work out which rotations must be done to disentangle the LSB",
        "qubit (we peel away one qubit at a time)",
        "perform the required rotations to decouple the LSB qubit (so that",
        "it can be \"factored\" out, leaving a shorter amplitude vector to peel away)",
        "circuit.append(rz_mult.to_instruction(), q[i : self.num_qubits])",
        "circuit.append(ry_mult.to_instruction().reverse_ops(), q[i : self.num_qubits])",
        "Ry and Rz rotations to move bloch vector from 0 to \"imaginary\"",
        "qubit",
        "(imagine a qubit state signified by the amplitudes at index 2*i",
        "and 2*(i+1), corresponding to the select qubits of the",
        "multiplexor being in state |i>)",
        "rotations for all imaginary qubits of the full vector",
        "to move from where it is to zero, hence the negative sign",
        "Force a and b to be complex, as otherwise numpy.angle might fail.",
        "q[local_num_qubits - 1]",
        "case of no multiplexing: base case for recursion",
        "circuit.append(target_gate(list_of_angles[0]), [q[0]])",
        "ctrl_gate = target_gate(list_of_angles[0]).control(num_ctrl_qubits = self.num_ctrl_qubits,ctrl_state=self.ctrl_state)",
        "calc angle weights, assuming recursion (that is the lower-level",
        "requested angles have been correctly implemented by recursion",
        "calc the combo angles",
        "recursive step on half the angles fulfilling the above assumption",
        "attach CNOT as follows, thereby flipping the LSB qubit",
        "implement extra efficiency from the paper of cancelling adjacent",
        "CNOTs (by leaving out last CNOT and reversing (NOT inverting) the",
        "second lower-level multiplex)",
        "attach a final CNOT",
        "qubits = self._bit_argument_conversion(qubits, self.qubits)"
    ],
    "docstrings": [
        "\"\"\"\nInitialize qubit registers to desired arbitrary state.\n\"\"\"",
        "\"\"\"Complex amplitude initialization.\n\n\tClass that implements the (complex amplitude) initialization of some\n\tflexible collection of qubit registers.\n\tNote that Initialize is an Instruction and not a Gate since it contains a reset instruction,\n\twhich is not unitary.\n\t\"\"\"",
        "\"\"\"Create new initialize composite.\n\n\t\tparams (str, list, int or Statevector):\n\t\t  * Statevector: Statevector to initialize to.\n\t\t  * list: vector of complex amplitudes to initialize to.\n\t\t  * string: labels of basis states of the Pauli eigenstates Z, X, Y. See\n\t\t\t   :meth:`~qiskit.quantum_info.states.statevector.Statevector.from_label`.\n\t\t\t   Notice the order of the labels is reversed with respect to the qubit index to\n\t\t\t   be applied to. Example label '01' initializes the qubit zero to `|1>` and the\n\t\t\t   qubit one to `|0>`.\n\t\t  * int: an integer that is used as a bitmap indicating which qubits to initialize\n\t\t\t   to `|1>`. Example: setting params to 5 would initialize qubit 0 and qubit 2\n\t\t\t   to `|1>` and qubit 1 to `|0>`.\n\t\tnum_qubits (int): This parameter is only used if params is an int. Indicates the total\n\t\t\tnumber of qubits in the `initialize` call. Example: `initialize` covers 5 qubits\n\t\t\tand params is 3. This allows qubits 0 and 1 to be initialized to `|1>` and the\n\t\t\tremaining 3 qubits to be initialized to `|0>`.\n\t\t\"\"\"",
        "\"\"\"Calculate a subcircuit that implements this initialization\n\n\t\tImplements a recursive initialization algorithm, including optimizations,\n\t\tfrom \"Synthesis of Quantum Logic Circuits\" Shende, Bullock, Markov\n\t\thttps://arxiv.org/abs/quant-ph/0406176v5\n\n\t\tAdditionally implements some extra optimizations: remove zero rotations and\n\t\tdouble cnots.\n\t\t\"\"\"",
        "'''\n\t\tfor qubit in q:\n\t\t\tinitialize_circuit.append(Reset(), [qubit])\n\t\t'''",
        "\"\"\"Call to create a circuit with gates that take the desired vector to zero.\n\n\t\tReturns:\n\t\t\tQuantumCircuit: circuit to take self.params vector to :math:`|{00\\\\ldots0}\\\\rangle`\n\t\t\"\"\"",
        "\"\"\"\n\t\tStatic internal method to work out Ry and Rz rotation angles used\n\t\tto disentangle the LSB qubit.\n\t\tThese rotations make up the block diagonal matrix U (i.e. multiplexor)\n\t\tthat disentangles the LSB.\n\n\t\t[[Ry(theta_1).Rz(phi_1)  0   .   .   0],\n\t\t [0         Ry(theta_2).Rz(phi_2) .  0],\n\t\t\t\t\t\t\t\t\t.\n\t\t\t\t\t\t\t\t\t\t.\n\t\t  0         0           Ry(theta_2^n).Rz(phi_2^n)]]\n\t\t\"\"\"",
        "\"\"\"\n\t\tStatic internal method to work out rotation to create the passed-in\n\t\tqubit from the zero vector.\n\t\t\"\"\"",
        "\"\"\"\n\t\tReturn a recursive implementation of a multiplexor circuit,\n\t\twhere each instruction itself has a decomposition based on\n\t\tsmaller multiplexors.\n\n\t\tThe LSB is the multiplexor \"data\" and the other bits are multiplexor \"select\".\n\n\t\tArgs:\n\t\t\ttarget_gate (Gate): Ry or Rz gate to apply to target qubit, multiplexed\n\t\t\t\tover all other \"select\" qubits\n\t\t\tlist_of_angles (list[float]): list of rotation angles to apply Ry and Rz\n\t\t\tlast_cnot (bool): add the last cnot if last_cnot = True\n\n\t\tReturns:\n\t\t\tDAGCircuit: the circuit implementing the multiplexor's action\n\t\t\"\"\"",
        "'''\n\tdef validate_parameter(self, parameter):\n\t\t\"\"\"Initialize instruction parameter can be str, int, float, and complex.\"\"\"\n\n\t\t# Initialize instruction parameter can be str\n\t\tif self._from_label:\n\t\t\tif parameter in [\"0\", \"1\", \"+\", \"-\", \"l\", \"r\"]:\n\t\t\t\treturn parameter\n\t\t\traise CircuitError(\n\t\t\t\t\"invalid param label {} for instruction {}. Label should be \"\n\t\t\t\t\"0, 1, +, -, l, or r \".format(type(parameter), self.name)\n\t\t\t)\n\t\tprint(parameter)\n\t\tprint(\"fck\")\n\t\t# Initialize instruction parameter can be int, float, and complex.\n\t\tif isinstance(parameter, (int, float, complex)):\n\t\t\treturn complex(parameter)\n\t\telif isinstance(parameter, np.number):\n\t\t\treturn complex(parameter.item())\n\t\telse:\n\t\t\t\n\t\t\traise CircuitError(\n\t\t\t\t\"invalid param type {} for instruction  \" \"{}\".format(type(parameter), self.name)\n\t\t\t)\n\t'''"
    ],
    "functions": [
        "_define",
        "_define_from_label",
        "_define_from_int",
        "_define_synthesis",
        "gates_to_uncompute",
        "_rotations_to_disentangle",
        "_bloch_angles",
        "_multiplex",
        "broadcast_arguments",
        "ctrl_initialize"
    ],
    "classes": [
        "ctrl_Initialize"
    ]
}