{
    "identifiers": [
        "uhal",
        "sys",
        "argparse",
        "time",
        "time",
        "sleep",
        "CommonTools",
        "uInt32HexStr",
        "uInt32HexListStr",
        "array",
        "binascii",
        "itertools",
        "izip",
        "izip_longest",
        "argparse",
        "datetime",
        "datetime",
        "datetime",
        "ROOT",
        "ROOT",
        "TFile",
        "ROOT",
        "TH1",
        "ROOT",
        "TTree",
        "array",
        "ROOT",
        "TDatime",
        "name",
        "addr",
        "port",
        "branch_form",
        "name",
        "addr",
        "port",
        "branch_form",
        "dcuname",
        "dcunames",
        "dcu",
        "dcuname",
        "dcuname",
        "dcuname",
        "branch_form",
        "dcus",
        "append",
        "d",
        "d",
        "name",
        "array",
        "array",
        "ROOT",
        "TFile",
        "ROOT",
        "TTree",
        "dcu",
        "dcus",
        "tt",
        "Branch",
        "dcu",
        "name",
        "dcuAddress",
        "dcu",
        "name",
        "dcu",
        "brch",
        "reg",
        "reg",
        "reg",
        "reg",
        "reg",
        "join",
        "chr",
        "register",
        "client",
        "node",
        "node",
        "getAddress",
        "client",
        "read",
        "address",
        "client",
        "dispatch",
        "reg",
        "bin",
        "ord",
        "zfill",
        "hex",
        "ord",
        "split",
        "zfill",
        "upper",
        "val",
        "width",
        "val",
        "val",
        "width",
        "join",
        "chr",
        "val",
        "n",
        "n",
        "reversed",
        "width",
        "val",
        "width",
        "val",
        "val",
        "width",
        "join",
        "chr",
        "val",
        "n",
        "n",
        "width",
        "bstr",
        "width",
        "sum",
        "ord",
        "b",
        "n",
        "n",
        "b",
        "reversed",
        "bstr",
        "val",
        "width",
        "val",
        "width",
        "val",
        "bstr",
        "width",
        "sum",
        "ord",
        "b",
        "n",
        "n",
        "b",
        "bstr",
        "val",
        "width",
        "val",
        "width",
        "val",
        "x",
        "n",
        "x",
        "round",
        "x",
        "n",
        "math",
        "ceil",
        "math",
        "log10",
        "abs",
        "x",
        "argparse",
        "ArgumentParser",
        "description",
        "parser",
        "add_argument",
        "help",
        "parser",
        "add_argument",
        "parser",
        "parse_args",
        "args",
        "file",
        "args",
        "file",
        "format",
        "outputFile",
        "args",
        "connectionFile",
        "format",
        "connectFile",
        "format",
        "connFile",
        "uhal",
        "setLogLevelTo",
        "uhal",
        "LogLevel",
        "WARNING",
        "uhal",
        "ConnectionManager",
        "connFile",
        "manager",
        "getDevice",
        "hw",
        "getClient",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "dispatch",
        "user_ver_yyyy",
        "format",
        "regToString",
        "userID",
        "format",
        "userVersionMajor",
        "userVersionMinor",
        "userVersionBuild",
        "join",
        "user_ver_dd",
        "user_ver_mm",
        "user_ver_yyyy",
        "dest",
        "source",
        "ch",
        "data",
        "array",
        "array",
        "msgB",
        "append",
        "dest",
        "msgB",
        "append",
        "source",
        "len",
        "data",
        "lenData",
        "msgB",
        "append",
        "lenData",
        "msgB",
        "append",
        "lenData",
        "msgB",
        "append",
        "lenData",
        "msgB",
        "append",
        "ch",
        "msgB",
        "append",
        "composeTRmsg",
        "transnum",
        "msgB",
        "extend",
        "data",
        "composeTRmsg",
        "transnum",
        "composeTRmsg",
        "transnum",
        "composeTRmsg",
        "transnum",
        "len",
        "msgB",
        "len4",
        "msgB",
        "extend",
        "len4",
        "array",
        "array",
        "sb0",
        "sb1",
        "sb2",
        "sb3",
        "iter",
        "msgB",
        "msgU32",
        "append",
        "sb0",
        "sb1",
        "sb2",
        "sb3",
        "msgU32",
        "composeTRmsg",
        "transnum",
        "hw",
        "getNode",
        "read",
        "hw",
        "dispatch",
        "recMT",
        "maxReads",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "dispatch",
        "msg",
        "append",
        "rxWord",
        "maxReads",
        "msg",
        "msg",
        "array",
        "array",
        "dat",
        "msg",
        "msgB",
        "append",
        "dat",
        "msgB",
        "append",
        "dat",
        "msgB",
        "append",
        "dat",
        "msgB",
        "append",
        "dat",
        "msgB",
        "msgB",
        "msgB",
        "msglen",
        "msgB",
        "msglen",
        "msglen",
        "msgB",
        "msgdat",
        "msgB",
        "msgdat",
        "msgB",
        "msgdat",
        "msgdat",
        "msglen",
        "msgB",
        "msgdat",
        "msglen",
        "ret",
        "word",
        "word",
        "word",
        "word",
        "word",
        "rxTimeout",
        "rxTimeout",
        "recMT",
        "rxTO",
        "hw",
        "getNode",
        "read",
        "hw",
        "dispatch",
        "rxTO",
        "recMT",
        "sys",
        "exit",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "dispatch",
        "msg",
        "append",
        "rxWord",
        "msgB",
        "extend",
        "word2byte",
        "rxWord",
        "msgB",
        "msgB",
        "msgB",
        "msglen",
        "msgB",
        "msglen",
        "msglen",
        "ret",
        "msgdat",
        "bytes2read",
        "bytes2read",
        "words2read",
        "words2read",
        "rxTimeout",
        "recMT",
        "rxTO",
        "hw",
        "getNode",
        "read",
        "hw",
        "dispatch",
        "rxTO",
        "recMT",
        "sys",
        "exit",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "dispatch",
        "msg",
        "append",
        "rxWord",
        "msgB",
        "extend",
        "word2byte",
        "rxWord",
        "words2read",
        "msgB",
        "msgdat",
        "msgB",
        "msgdat",
        "msgB",
        "msgdat",
        "msgdat",
        "msglen",
        "msgB",
        "msgdat",
        "msglen",
        "msg",
        "msgB",
        "ret",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "dispatch",
        "format",
        "ctrl0",
        "format",
        "stat0",
        "format",
        "ds",
        "format",
        "stat1",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "Data",
        "Verbose",
        "composeTRmsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "Data",
        "Verbose",
        "join",
        "x",
        "x",
        "Msg",
        "hw",
        "getNode",
        "writeBlock",
        "Msg",
        "hw",
        "dispatch",
        "hw",
        "getNode",
        "write",
        "hw",
        "dispatch",
        "hw",
        "getNode",
        "write",
        "hw",
        "dispatch",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "Data",
        "Verbose",
        "postMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "Data",
        "Verbose",
        "recvMsg",
        "Verbose",
        "retMsg",
        "FE_CCU_addr",
        "retMsg",
        "FECaddr",
        "retMsg",
        "Channel",
        "retMsg",
        "composeTRmsg",
        "transnumLast",
        "retMsg",
        "Data",
        "format",
        "FE_CCU_addr",
        "Channel",
        "retMsg",
        "format",
        "retMsg",
        "FE_CCU_addr",
        "Channel",
        "Verbose",
        "err",
        "IRQtimeout",
        "IRQ",
        "IRQtimeout",
        "sleep",
        "hw",
        "getNode",
        "read",
        "hw",
        "dispatch",
        "IRQtimeout",
        "IRQ",
        "IRQtimeout",
        "sys",
        "exit",
        "receiveTRmsg",
        "join",
        "x",
        "x",
        "rxMsg",
        "hw",
        "getNode",
        "write",
        "hw",
        "dispatch",
        "decomposeTRmsg",
        "rxMsg",
        "format",
        "rxMsgD",
        "rxMsgD",
        "rxMsgD",
        "rxMsgD",
        "rxMsgD",
        "rxMsgD",
        "join",
        "x",
        "x",
        "rxMsgD",
        "rxMsgD",
        "RXtimeout",
        "Verbose",
        "receiveTRmsg",
        "RXtimeout",
        "Verbose",
        "join",
        "x",
        "x",
        "rxMsg",
        "hw",
        "getNode",
        "write",
        "hw",
        "dispatch",
        "Verbose",
        "format",
        "rxMsg",
        "rxMsg",
        "rxMsg",
        "rxMsg",
        "rxMsg",
        "rxMsg",
        "join",
        "x",
        "x",
        "rxMsg",
        "rxMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "RXtimeout",
        "Verbose",
        "recvMsg",
        "RXtimeout",
        "Verbose",
        "rxmsg",
        "FE_CCU_addr",
        "rxmsg",
        "FECaddr",
        "rxmsg",
        "Channel",
        "rxmsg",
        "composeTRmsg",
        "transnumLast",
        "rxmsg",
        "format",
        "retMsg",
        "Verbose",
        "err",
        "rxmsg",
        "CCU_addr",
        "I2C_Port",
        "I2C_Addr",
        "ACK",
        "ACK",
        "sys",
        "exit",
        "format",
        "CCU_addr",
        "I2C_Port",
        "I2C_Addr",
        "ACK",
        "FE_CCU_addr",
        "FECaddr",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "sleep",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "replyMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "rxMsg",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "replyMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "rxMsg",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "replyMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "rxMsg",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "replyMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "rxMsg",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "replyMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "rxMsg",
        "rxMsg",
        "rxMsg",
        "format",
        "ctrlA",
        "ctrlB",
        "ctrlC",
        "ctrlD",
        "ctrlE",
        "chan",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "chan",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "I2C_Addr",
        "Data",
        "I2C_Port",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "I2C_Addr",
        "Data",
        "replyMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "checkI2CAck",
        "FE_CCU_addr",
        "I2C_Port",
        "I2C_Addr",
        "rxMsg",
        "rxMsg",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "I2C_Addr",
        "I2C_Port",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "I2C_Addr",
        "replyMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "checkI2CAck",
        "FE_CCU_addr",
        "I2C_Port",
        "I2C_Addr",
        "rxMsg",
        "rxMsg",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "I2C_Addr",
        "DCU_Ch",
        "writeTRI2Cbyte",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "I2C_Addr",
        "writeTRI2Cbyte",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "I2C_Addr",
        "writeTRI2Cbyte",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "I2C_Addr",
        "DCU_Ch",
        "sleep",
        "readTRI2Cbyte",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "I2C_Addr",
        "readTRI2Cbyte",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "I2C_Addr",
        "shreg",
        "sys",
        "exit",
        "shreg",
        "lreg",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "write",
        "hw",
        "getNode",
        "write",
        "hw",
        "dispatch",
        "hw",
        "getNode",
        "write",
        "hw",
        "dispatch",
        "hw",
        "getNode",
        "write",
        "hw",
        "dispatch",
        "hw",
        "getNode",
        "write",
        "hw",
        "dispatch",
        "hw",
        "getNode",
        "write",
        "hw",
        "getNode",
        "write",
        "hw",
        "getNode",
        "write",
        "hw",
        "getNode",
        "write",
        "hw",
        "getNode",
        "write",
        "hw",
        "getNode",
        "write",
        "hw",
        "getNode",
        "write",
        "hw",
        "dispatch",
        "trVersion",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "getNode",
        "read",
        "hw",
        "dispatch",
        "tra_run",
        "rec_run",
        "link_inited",
        "ctrl0",
        "stat0",
        "stat1",
        "ds",
        "TRstatus",
        "link_inited",
        "sys",
        "exit",
        "RECempty",
        "receiveTRmsg",
        "join",
        "x",
        "x",
        "rxMsg",
        "hw",
        "getNode",
        "write",
        "hw",
        "getNode",
        "write",
        "initFE",
        "FE_CCU_addr",
        "FECaddr",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "replyMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "format",
        "rxMsg",
        "TRstatus",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "replyMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "format",
        "rxMsg",
        "TRstatus",
        "I2C_Port",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "replyMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "format",
        "I2C_Port",
        "rxMsg",
        "TRstatus",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "replyMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "format",
        "I2C_Port",
        "rxMsg",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "sendMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "replyMsg",
        "FE_CCU_addr",
        "FECaddr",
        "Channel",
        "format",
        "I2C_Port",
        "rxMsg",
        "readTRI2Cbyte",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "readTRI2Cbyte",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "readTRI2Cbyte",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "idhreg",
        "idres",
        "idres",
        "idmreg",
        "idres",
        "idres",
        "idlreg",
        "readTRDCU",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "DCU_Ch",
        "readTRDCU",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "DCU_Ch",
        "readTRDCU",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "DCU_Ch",
        "format",
        "idres",
        "temp10",
        "temp20",
        "temp40",
        "dcu_chan",
        "datetime",
        "now",
        "strftime",
        "open",
        "outputFile",
        "f",
        "write",
        "csvHeader",
        "port",
        "dcu_chan",
        "format",
        "port",
        "dcu_chan",
        "readTRDCU",
        "FE_CCU_addr",
        "FECaddr",
        "port",
        "I2C_Addr",
        "dcu_chan",
        "f",
        "write",
        "csvLine",
        "format",
        "port",
        "I2C_Addr",
        "dcu_chan",
        "VFEData",
        "key",
        "VFEData",
        "key",
        "format",
        "key",
        "I2C_Port",
        "I2C_Addr",
        "dcu_chan",
        "VFEData",
        "key",
        "dcu_chan",
        "VFE2dcu10",
        "append",
        "readTRDCU",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "I2C_Addr",
        "dcu_chan",
        "format",
        "I2C_Port",
        "I2C_Addr",
        "dcu_chan",
        "VFE2dcu10",
        "dcu_chan",
        "dcu_chan",
        "VFE2dcu10",
        "append",
        "readTRDCU",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "I2C_Addr",
        "dcu_chan",
        "format",
        "I2C_Port",
        "I2C_Addr",
        "dcu_chan",
        "VFE2dcu10",
        "dcu_chan",
        "e",
        "format",
        "e",
        "TDatime",
        "tt",
        "Branch",
        "timeStamp",
        "count",
        "num_points",
        "timeStamp",
        "format",
        "timeStamp",
        "AsString",
        "dcu",
        "dcus",
        "dcu",
        "addr",
        "dcu",
        "port",
        "dcu_chan",
        "ADCdata",
        "append",
        "readTRDCU",
        "FE_CCU_addr",
        "FECaddr",
        "I2C_Port",
        "I2C_Addr",
        "dcu_chan",
        "dcu_chan",
        "ADCdata",
        "dcu_chan",
        "ADCconv",
        "hex",
        "I2C_Addr",
        "dcu_chan",
        "ADCconv",
        "hex",
        "I2C_Addr",
        "dcu_chan",
        "VREFdata",
        "Rtop",
        "Rbot",
        "Rbot",
        "dcuAddress",
        "dcu",
        "name",
        "ADCdata",
        "dcu_chan",
        "count",
        "tt",
        "Fill",
        "timeStamp",
        "timeStamp",
        "Convert",
        "dT",
        "TDatime",
        "Convert",
        "timeStamp",
        "Convert",
        "time",
        "sleep",
        "rootFile",
        "Write",
        "rootFile",
        "Close",
        "TRstatus"
    ],
    "literals": [
        "'ch1/D:ch2/D:ch3/D:ch4/D:ch5/D:ch6/D:ch7/D'",
        "'dcu1'",
        "'dcu2'",
        "'dcu3'",
        "'vfeDCU9'",
        "'vfeDCU10'",
        "'vfeDCU11'",
        "'vfeDCU12'",
        "'d'",
        "\"DCUdata_2.root\"",
        "\"recreate\"",
        "\"DCUdata\"",
        "\"DCUdata\"",
        "''",
        "'x'",
        "''",
        "''",
        "\"Write a test message to the Token Ring FIFOs and send it then read out the received message. They should be the same\"",
        "'-a'",
        "'--connectionFile'",
        "'glibConnectECAL.xml'",
        "'Connect Address File with connections to the glib_v3 Card'",
        "'-f'",
        "'--file'",
        "'Outputting to {0}'",
        "'file://{0};'",
        "'Using {0} as connection file'",
        "'glib_v3'",
        "\"user_ipb.stat.id\"",
        "\"user_ipb.ver_major\"",
        "\"user_ipb.ver_minor\"",
        "\"user_ipb.ver_build\"",
        "\"user_ipb.firmware_yy\"",
        "\"user_ipb.firmware_mm\"",
        "\"user_ipb.firmware_dd\"",
        "'\\nFirmware Information'",
        "'\\nUser Type: {0}'",
        "'User Version: {0}.{1}.{2} ({3})'",
        "'/'",
        "'B'",
        "'I'",
        "\"user_ipb.tr.stat0.rec_empty\"",
        "\"user_ipb.tr.rec_fifo\"",
        "\"user_ipb.tr.stat0.rec_empty\"",
        "'B'",
        "'dst'",
        "'src'",
        "'len'",
        "'chn'",
        "'trn'",
        "'dat'",
        "'sta'",
        "\"user_ipb.tr.stat0.rec_empty\"",
        "\"ERROR: Timeout waiting for Token Ring message!\\n\"",
        "\"user_ipb.tr.rec_fifo\"",
        "\"user_ipb.tr.stat0.rec_empty\"",
        "'dst'",
        "'src'",
        "'len'",
        "'len'",
        "\"user_ipb.tr.stat0.rec_empty\"",
        "\"ERROR: Timeout waiting for Token Ring message!\\n\"",
        "\"user_ipb.tr.rec_fifo\"",
        "\"user_ipb.tr.stat0.rec_empty\"",
        "'chn'",
        "'trn'",
        "'dat'",
        "'sta'",
        "'msg'",
        "'mgB'",
        "\"user_ipb.tr.ctrl0.en_fec\"",
        "\"user_ipb.tr.ctrl0.send\"",
        "\"user_ipb.tr.ctrl0.sel_ser_out\"",
        "\"user_ipb.tr.ctrl0.sel_ser_in\"",
        "\"user_ipb.tr.ctrl0.rec_clk_pol\"",
        "\"user_ipb.tr.ctrl0.disable_rec\"",
        "\"user_ipb.tr.ctrl0.loopback\"",
        "\"user_ipb.tr.ctrl0.soft_reset\"",
        "\"user_ipb.tr.ctrl0.reset_link_b\"",
        "\"user_ipb.tr.ctrl0.reset_link_a\"",
        "\"user_ipb.tr.stat0.tra_run\"",
        "\"user_ipb.tr.stat0.rec_run\"",
        "\"user_ipb.tr.stat0.ill_send\"",
        "\"user_ipb.tr.stat0.rec_full\"",
        "\"user_ipb.tr.stat0.rec_empty\"",
        "\"user_ipb.tr.stat0.ret_full\"",
        "\"user_ipb.tr.stat0.ret_empty\"",
        "\"user_ipb.tr.stat0.tra_full\"",
        "\"user_ipb.tr.stat0.tra_empty\"",
        "\"user_ipb.tr.stat0.link_inited\"",
        "\"user_ipb.tr.stat0.irq_pend\"",
        "\"user_ipb.tr.stat0.data_to_fec\"",
        "\"user_ipb.tr.stat1.ill_dat\"",
        "\"user_ipb.tr.stat1.ill_seq\"",
        "\"user_ipb.tr.stat1.crc_err\"",
        "\"user_ipb.tr.stat1.data_copied\"",
        "\"user_ipb.tr.stat1.addr_seen\"",
        "\"user_ipb.tr.stat1.err\"",
        "\"user_ipb.tr.stat1.time_out\"",
        "\"user_ipb.tr.stat1.clk_err\"",
        "\"user_ipb.tr.dipstick\"",
        "'Ctrl0: ResetLinkA:{9} ResetLinkB:{8} SoftReset:{7} Loopback:{6} DisableRX:{5} RXClkPol:{4} SelSerIn:{3} SelSerOut:{2}    Send:{1}    EnFEC:{0}'",
        "'Stat0:  DataToFEC:{11}        IRQ:{10}  LinkInit:{9} TRAempty:{8}   TRAfull:{7} RETempty:{6}  RETfull:{5}  RECempty:{4} RECfull:{3}  ILLsend:{2} RECrun:{1} TRArun:{0}'",
        "'DS: {0:>5}'",
        "'                  Stat1:  ClkErr:{7}  TimeOut:{6}       Err:{5} AddrSeen:{4} DataCopy:{3}    CRCerr:{2}  ILLseq:{1}  ILLdata:{0}\\n'",
        "\"Msg to Transmit: \"",
        "' '",
        "\"%08X\"",
        "\"user_ipb.tr.tra_fifo\"",
        "\"user_ipb.tr.ctrl0.send\"",
        "\"user_ipb.tr.ctrl0.send\"",
        "'dst'",
        "'src'",
        "'chn'",
        "'trn'",
        "'dat'",
        "\"ERROR: Returned message mismatch (FEAddr: {0}/CCUchan: {1:02x})\\n\"",
        "'sta'",
        "\"ERROR: Unexpected message status 0x{0:02X} (FEAddr: {1}/CCUchan: {2:02x})\\n\"",
        "'sta'",
        "\"SUCCESS: Message Sent and received by destination\\n\"",
        "\"user_ipb.tr.stat0.irq_pend\"",
        "\"ERROR: Timeout waiting for Token Ring message!\\n\"",
        "\"Msg Received:    \"",
        "' '",
        "\"%08X\"",
        "\"user_ipb.tr.ctrl1.clr_irq\"",
        "\"Msg Dest:{0} Src:{1} Len:{2} Status:{3:#x} Channel:{4} Transaction:{5}\"",
        "'dst'",
        "'src'",
        "'len'",
        "'sta'",
        "'chn'",
        "'trn'",
        "\"Msg Data: \"",
        "' '",
        "\"%02X\"",
        "'dat'",
        "\"\"",
        "\"Msg Received:    \"",
        "' '",
        "\"%08X\"",
        "'msg'",
        "\"user_ipb.tr.ctrl1.clr_irq\"",
        "\"Msg Dest:{0} Src:{1} Len:{2} Status:{3:#x} Channel:{4} Transaction:{5}\"",
        "'dst'",
        "'src'",
        "'len'",
        "'sta'",
        "'chn'",
        "'trn'",
        "\"Msg Data: \"",
        "' '",
        "\"%02X\"",
        "'dat'",
        "'src'",
        "'dst'",
        "'chn'",
        "'trn'",
        "\"ERROR: Reply message mismatch\\n\"",
        "'sta'",
        "\"ERROR: Unexpected message status 0x{0:02X}\\n\"",
        "'sta'",
        "\"SUCCESS: Reply Message received from destination\\n\"",
        "'err'",
        "\"ERROR: I2C (FEAddr: {0} / I2C Port {1} / I2CAddr: 0x{2:02x}) Write failed with status: 0x{3:02x}\"",
        "'dat'",
        "'dat'",
        "'dat'",
        "'dat'",
        "'dat'",
        "'dat'",
        "'dat'",
        "\"Node Ctrl Reg: A:0x{0:02x} B:0x{1:02x} C:0x{2:02x} D:0x{3:02x} E:0x{4:06x}\\n\"",
        "'dat'",
        "'dat'",
        "'dat'",
        "'dat'",
        "\"ERROR: DCU is not is IDLE state when data is read. Extend wait time before read.\"",
        "\"user_ipb.tr.version\"",
        "\"user_ipb.ctrl.tr_reset_oe\"",
        "\"user_ipb.ctrl.tr_reset_o\"",
        "\"user_ipb.ctrl.tr_reset_o\"",
        "\"user_ipb.ctrl.tr_reset_o\"",
        "\"user_ipb.tr.ctrl0.soft_reset\"",
        "\"user_ipb.tr.ctrl0\"",
        "\"user_ipb.tr.ctrl1.clr_irq\"",
        "\"user_ipb.tr.ctrl1.clr_errors\"",
        "\"user_ipb.tr.ctrl0.sel_ser_out\"",
        "\"user_ipb.tr.ctrl0.sel_ser_in\"",
        "\"user_ipb.tr.ctrl0.rec_clk_pol\"",
        "\"user_ipb.tr.ctrl0.en_fec\"",
        "\"mFEC Firmware Version: %02x\"",
        "''",
        "\"user_ipb.tr.stat0.tra_run\"",
        "\"user_ipb.tr.stat0.rec_run\"",
        "\"user_ipb.tr.stat0.link_inited\"",
        "\"user_ipb.tr.stat0.rec_empty\"",
        "\"user_ipb.tr.ctrl0\"",
        "\"user_ipb.tr.stat0\"",
        "\"user_ipb.tr.stat1\"",
        "\"user_ipb.tr.dipstick\"",
        "\"Before start:  TX Run: %d RX Run: %d Link Init: %d  ctrl0: %08x  stat0: %08x  stat1: %08x  dipstick: %08x\\n\"",
        "\"ERROR: Token Ring Link is NOT Initialized. Link may be broken.\"",
        "\"Some data in FIFO. Flushing it.\"",
        "\"Msg Received (?): \"",
        "' '",
        "\"%08X\"",
        "'\\n'",
        "\"user_ipb.tr.ctrl1.clr_irq\"",
        "\"user_ipb.tr.ctrl1.clr_errors\"",
        "\"Stat Reg. A: 0x{0:02X}\\n\"",
        "'dat'",
        "\"Stat Reg. E: {0:02x} {1:02x} {2:02x}\\n\"",
        "'dat'",
        "\"I2C Port {0}: CtrlA {1:#x}\"",
        "'dat'",
        "\"Wrote 2 to I2C CtrlA\"",
        "\"I2C Port {0}: CtrlA {1:#x}\"",
        "'dat'",
        "\"Wrote 0 to I2C CtrlA\"",
        "\"I2C Port {0}: CtrlA {1:#x}\"",
        "'dat'",
        "\"\\n\\n\\n\"",
        "\"DCU I2CAddr Temp(0x10) 0x{0:06x}, {1:04x} / Temp(0x20) {2:04x} / Temp(0x40) {3:04x}\\n\\n\"",
        "'VFE DCU I2CPort, I2CAddr, DCU Channel, ADC Value (hex), ADC Value(dec)\\n'",
        "'{0},0x{1:02x},{2},{3:04x}, {4}\\n'",
        "'%Y-%m-%d-%H:%M:%S'",
        "'w+'",
        "'{0}:{1}'",
        "\"key: {0}, VFE DCU I2CPort {1} I2CAddr 0x{2:02x} Channel {3}: (ADC:{4:04x})\"",
        "\"VFE DCU I2CPort {0} I2CAddr 0x{1:02x} Channel {2}: (ADC:{3:04x})\"",
        "\"VFE DCU I2CPort {0} I2CAddr 0x{1:02x} Channel {2}: (ADC:{3:04x})\"",
        "'Ran into an error reading VFES...{0}'",
        "'0x40'",
        "'0x20'",
        "'0x10'",
        "'timestamp'",
        "\"Starting capture at {0}\"",
        "\"\\nDone!\""
    ],
    "variables": [
        "branch_form",
        "dcunames",
        "num_points",
        "name",
        "addr",
        "port",
        "ch",
        "brch",
        "dcus",
        "dcuAddress",
        "d",
        "dcuAddress",
        "rootFile",
        "tt",
        "register",
        "register",
        "register",
        "register",
        "register",
        "address",
        "reg",
        "val",
        "val",
        "val",
        "val",
        "val",
        "val",
        "parser",
        "args",
        "outputFile",
        "outputFile",
        "connectFile",
        "connFile",
        "manager",
        "hw",
        "client",
        "userID",
        "userVersionMajor",
        "userVersionMinor",
        "userVersionBuild",
        "user_ver_yyyy",
        "user_ver_mm",
        "user_ver_dd",
        "msgB",
        "lenData",
        "composeTRmsg",
        "transnumLast",
        "composeTRmsg",
        "transnum",
        "len4",
        "msgU32",
        "composeTRmsg",
        "transnum",
        "composeTRmsg",
        "transnumLast",
        "msg",
        "maxReads",
        "recMT",
        "rxWord",
        "recMT",
        "msgB",
        "ret",
        "ret",
        "ret",
        "msglen",
        "msgdat",
        "msglen",
        "msgdat",
        "ret",
        "ret",
        "ret",
        "ret",
        "ret",
        "msg",
        "msgB",
        "maxReads",
        "recMT",
        "rxTO",
        "recMT",
        "rxWord",
        "recMT",
        "ret",
        "ret",
        "ret",
        "msglen",
        "msgdat",
        "msglen",
        "msgdat",
        "ret",
        "bytes2read",
        "words2read",
        "rxTO",
        "recMT",
        "rxWord",
        "recMT",
        "ret",
        "ret",
        "ret",
        "ret",
        "ret",
        "ret",
        "ctrl0",
        "ctrl0",
        "ctrl0",
        "ctrl0",
        "ctrl0",
        "ctrl0",
        "ctrl0",
        "ctrl0",
        "ctrl0",
        "ctrl0",
        "ctrl0",
        "stat0",
        "stat0",
        "stat0",
        "stat0",
        "stat0",
        "stat0",
        "stat0",
        "stat0",
        "stat0",
        "stat0",
        "stat0",
        "stat0",
        "stat0",
        "stat1",
        "stat1",
        "stat1",
        "stat1",
        "stat1",
        "stat1",
        "stat1",
        "stat1",
        "stat1",
        "ds",
        "Msg",
        "retMsg",
        "err",
        "err",
        "err",
        "IRQ",
        "IRQ",
        "rxMsg",
        "rxMsgD",
        "rxMsg",
        "rxmsg",
        "err",
        "err",
        "err",
        "rxmsg",
        "Channel",
        "rxMsg",
        "ctrlA",
        "rxMsg",
        "ctrlB",
        "rxMsg",
        "ctrlC",
        "rxMsg",
        "ctrlD",
        "rxMsg",
        "ctrlE",
        "Channel",
        "rxMsg",
        "Channel",
        "rxMsg",
        "shreg",
        "lreg",
        "trVersion",
        "tra_run",
        "rec_run",
        "link_inited",
        "RECempty",
        "ctrl0",
        "stat0",
        "stat1",
        "ds",
        "rxMsg",
        "FECaddr",
        "FE_CCU_addr",
        "Channel",
        "rxMsg",
        "Channel",
        "rxMsg",
        "I2C_Port",
        "Channel",
        "rxMsg",
        "rxMsg",
        "rxMsg",
        "I2C_Port",
        "I2C_Addr",
        "DCU_Ch",
        "idlreg",
        "idmreg",
        "idhreg",
        "idres",
        "temp40",
        "temp20",
        "temp10",
        "I2C_Port",
        "I2C_Addr",
        "VFE2dcu10",
        "csvHeader",
        "csvLine",
        "now",
        "VFEData",
        "f",
        "key",
        "VFEData",
        "key",
        "I2C_Port",
        "I2C_Addr",
        "VFE2dcu10",
        "I2C_Port",
        "I2C_Addr",
        "VFE2dcu10",
        "ADCconv",
        "I2C_Port",
        "count",
        "timeStamp",
        "dT",
        "b",
        "I2C_Addr",
        "I2C_Port",
        "ADCdata",
        "VREFdata",
        "Rbot",
        "Rtop",
        "Vdata",
        "arr",
        "arr",
        "dcu_chan"
    ],
    "comments": [
        "!/usr/bin/env python",
        "Simple converter for full 32 bit strings stored as in int",
        "Defining a function for recording time for repeated measurements",
        "def time_stepper(num_points,delay):",
        "count=0",
        "while count<num_points:",
        "time.sleep(delay)",
        "count+=1",
        "time=count*delay",
        "We're supposed to have the ability to call the Manager's Dispatch function",
        "but it doesn't work, so as a work around I directly call the IPBus Client.",
        "convert passed in character to an 8-bit string of 1's & 0's that is",
        "reversed so that index [0] refers to the rightmost bit in byte",
        "convert passed in character to a uppercase hex byte without '0x'",
        "",
        "From: http://code.activestate.com/recipes/510399-byte-to-hex-and-hex-to-byte-string-conversion/",
        "",
        "",
        "based on: https://mail.python.org/pipermail/tutor/2009-September/071393.html",
        "",
        "if not args.connectionFile:",
        "print 'Please provide a connections file'",
        "exit()",
        "if not args.connectionFile:",
        "connectFile = 'glibConnectECAL.xml'",
        "else:",
        "Create uHal Manager and attempt to connect to the glib",
        "Only show log messages with levels Warning and above",
        "Don't show any log messages",
        "uhal.disableLogging()",
        "print hw.getNodes()",
        "read Board ID, Sys ID, Firmware ID",
        "Send IPbus transactions",
        "Modify any register values after dispatch but before use",
        "",
        "Dest Token Ring node",
        "Source Token Ring node (us)",
        "adding two bytes to data payload",
        "Need 2-byte encoding of length. The msb of first byte gets set to a '1'.",
        "save the last used transaction number",
        "increment transaction number so it is unique",
        "wrap around byte and skip 0",
        "Make length of msgB evenly divisible by 4",
        "return msgB",
        "print(\"%08X\" % ((sb3 << 24) | (sb2 << 16) | (sb1 << 8) | sb0))",
        "For debug -",
        "msgU32.append(0xDEADBEEF)",
        "msgU32.append(0xDEADCABB)",
        "return struct.unpack('<I', msgB)",
        "Now convert from a byte array to a uInt32 array",
        "msgU32 = array.array('l')",
        "struct.pack_into(\"<I\", msgU32, 0, msgB)",
        "init transaction number (do NOT use 0)",
        "The receive FIFO is limited to 1023 words",
        "First check if FIFO has anything",
        "Send IPbus transactions",
        "Read 32-bits words from FIFO until it is empty",
        "Send IPbus transactions",
        "First, convert from 32-bit list to byte array",
        "2-byte length (mFEC firmware does not seem to handle this correctly)",
        "data length",
        "channel number",
        "transaction number",
        "The data",
        "status byte",
        "The receive FIFO is limited to 1023 words",
        "First check if FIFO has anything",
        "Send IPbus transactions",
        "Read the first word to determine the length of the message",
        "Send IPbus transactions",
        "save original word for debug",
        "2-byte length (mFEC firmware does not seem to handle this correctly)",
        "data length",
        "Compute number of 32-bit words left to read out",
        "read the 1 byte status after the data",
        "read any remaining words",
        "Send IPbus transactions",
        "Read the next word",
        "Send IPbus transactions",
        "save original word for debug",
        "channel number",
        "transaction number",
        "The data",
        "status byte",
        "the entire message in words (for debug)",
        "the entire message in bytes (for debug)",
        "Send IPbus transactions",
        "print \"Received Msg: \", [ toHexStr(dat) for dat in Msg ]",
        "print \"Received Msg: \", binascii.hexlify(Msg)",
        "print [hex(x) for x in Msg]",
        "print ''",
        "Write the message words to the transmit fifo",
        "Send IPbus transactions",
        "Send the message (toggle the send bit)",
        "Send IPbus transactions",
        "clear the Send bit (may be able to do this immediately after set it - not sure)",
        "Send IPbus transactions",
        "post the message to the TX FIFO and send it",
        "Wait and get the returned message and check it",
        "check the returned message",
        "wait a little",
        "Attempt to read the Receive FIFO and print what was found",
        ", '\\n'",
        "Then clear the IRQ",
        "Could look at IRQ, but sinc ehave to poll, might as well just poll for RECempty.",
        "Read the Receive FIFO and print what was found",
        ", '\\n'",
        "Then clear any IRQ",
        "Check that the expected source, destination and channel are",
        "correct. Remember that for the reply, the source and destination",
        "are expected to be swapped since the reply is orginating on the",
        "other end.",
        "Check the returned ACK from I2C access",
        "Initialize the front end",
        "According to the CCU ASIC specification, in order to write to",
        "CCU Node Control Reg. E, must write and read all 5 control",
        "registers.",
        "All accesses here are to Channel 0",
        "Write Control Reg. A (resets)",
        "Clear error and Reset All Channels",
        "Wait for resets to complete",
        "Write Control Reg. A (resets)",
        "Write Control Reg. B (alarms)",
        "Write Control Reg. C (redundancy)",
        "",
        "Not sure why, but writing 0 returns a status os 0x80 which",
        "implies that the FE did not accept the write request. So setting",
        "one of the reserved bits high seems to give us a 0xB0 status, as",
        "expected. Hopefully the reserved bit is not a special test bit.",
        "Write Control Reg. D (broadcast)",
        "Write Control Reg. E (Enable Channels)",
        "Enabling All I2C Channels (reduce this, if needed) and All PIO Channels",
        "Left Disabled: JTAG, trigger and memory controllers",
        "Read Ctrl Reg. A",
        "Read Ctrl Reg. B",
        "Read Ctrl Reg. C",
        "Read Ctrl Reg. D",
        "Read Ctrl Reg. E",
        "Now, set up all I2C channels to always return the ACK even if",
        "successful. This makes coding easier if you always know to",
        "expect the response.",
        "",
        "Also setting the clock frequency to 100 KHz (plenty fast for us)",
        "convert I2C_Port number to CCU Channel",
        "return ACK in case it is useful",
        "convert I2C_Port number to CCU Channel",
        "Make sure that (TREG) is 0x10 to turn the bandgap on",
        "",
        "NOTE: Only need to do this once after power on so if can handle",
        "the bookeeping, could keep from having to write this over and",
        "over.",
        "Make sure that (AREG) is 0x00 - it appears to always be after power-on",
        "Write 0x88+DCU_Ch to CREG (0) to start acquition on temperature reading",
        "give time for conversion",
        "Read DCU Control Reg (CREG)",
        "creg = readTRI2Cbyte(FE_CCU_addr, FECaddr, I2C_Port, I2C_Addr | 0)",
        "Read DCU Status/High Data Reg (SHREG)",
        "Read DCU Aux Reg (AREG)",
        "areg = readTRI2Cbyte(FE_CCU_addr, FECaddr, I2C_Port, I2C_Addr | 2)",
        "Read DCU Data Low Reg (LREG)",
        "Read DCU Test Reg (TREG)",
        "treg = readTRI2Cbyte(FE_CCU_addr, FECaddr, I2C_Port, I2C_Addr | 4)",
        "Read DCU ID Low, Medium and High Reg",
        "idlreg = readTRI2Cbyte(FE_CCU_addr, FECaddr, I2C_Port, I2C_Addr | 5)",
        "idmreg = readTRI2Cbyte(FE_CCU_addr, FECaddr, I2C_Port, I2C_Addr | 6)",
        "idhreg = readTRI2Cbyte(FE_CCU_addr, FECaddr, I2C_Port, I2C_Addr | 7)",
        "idres = idhreg",
        "idres <<= 8",
        "idres += idmreg",
        "idres <<= 8",
        "idres += idlreg",
        "idstr = 'id: h:{0},m:{1},l:{2}, combo:{3}'.format(idhreg, idmreg, idlreg, hex(idres))",
        "print idstr",
        "Check mFEC Version",
        "Issue a reset to FE",
        "Send IPbus transactions",
        "Send IPbus transactions",
        "Send IPbus transactions",
        "Issue a soft reset",
        "Send IPbus transactions",
        "Issue a reset_link_a",
        "hw.getNode(\"user_ipb.tr.ctrl0.reset_link_a\").write(1)",
        "hw.dispatch() # Send IPbus transactions",
        "Setup Source Register to be 0",
        "hw.getNode(\"user_ipb.tr.source\").write(0)",
        "Make sure ctrl0 is 0",
        "Clear any errors or IRQs",
        "Select A for serial input and output",
        "Set received clock polarity to '1' (need to experiment to see which works best)",
        "Right now - cannot get Link Initialized if set to '0' even with the long cable",
        "Enable Token Ring",
        "Send IPbus transactions",
        "Check that the link is initialized and that no pending operation is active.",
        "Send IPbus transactions",
        "If Receive FIFO is not empty, then read it out - likely truncated message from power on/reset",
        "Also clear any IRQ or errors",
        "Initialize the front end",
        "Old Test",
        "Read Stat Reg. A",
        "capture the reply",
        "@@@#print \"Actual Length of RX Data: \", len(rxMsg['dat']), \"\\n\"",
        "@@@#print \"Send Data: \", ' '.join( [ \"%02X\" % x for x in Data ] )",
        "Read Stat Reg. E",
        "capture the reply",
        "@@@#print \"Actual Length of RX Data: \", len(rxMsg['dat']), \"\\n\"",
        "@@@#print \"Send Data: \", ' '.join( [ \"%02X\" % x for x in Data ] )",
        "Old Test",
        "I2C Ports start at channel 0x10, so select port 15:",
        "LVRB (not sure if working)",
        "@@@#I2C_Port = 10                             # VFE #2",
        "For LVR DCU's",
        "Read I2C Control Reg. A",
        "Write I2C Control Reg. A (set to 2 for 200 kHz - just a test)",
        "Read I2C Control Reg. A",
        "Write I2C Control Reg. A (set back to 0 for 100 kHz and set FACKW)",
        "Read I2C Control Reg. A",
        "Finally, can now try reading temperature from LVRB / SLVRB DCU 0x10",
        "VFE2dcu10.append(readTRDCU(FE_CCU_addr, FECaddr, I2C_Port, I2C_Addr, dcu_chan))",
        "print \"VFE DCU I2CPort {0} I2CAddr 0x{1:02x} Channel {2}: (ADC:{3:04x})\".format(I2C_Port, I2C_Addr, dcu_chan, VFE2dcu10[dcu_chan])",
        "print",
        "I2C_Port = 11",
        "I2C_Addr = 0x10",
        "VFE2dcu10 = []",
        "for dcu_chan in range(0, 8):",
        "VFE2dcu10.append(readTRDCU(FE_CCU_addr, FECaddr, I2C_Port, I2C_Addr, dcu_chan))",
        "print \"VFE DCU I2CPort {0} I2CAddr 0x{1:02x} Channel {2}: (ADC:{3:04x})\".format(I2C_Port, I2C_Addr, dcu_chan, VFE2dcu10[dcu_chan])",
        "I2C_Port = 10",
        "I2C_Addr = 0x10",
        "VFE2dcu10 = []",
        "for dcu_chan in range(0, 8):",
        "VFE2dcu10.append(readTRDCU(FE_CCU_addr, FECaddr, I2C_Port, I2C_Addr, dcu_chan))",
        "print \"VFE DCU I2CPort {0} I2CAddr 0x{1:02x} Channel {2}: (ADC:{3:04x})\".format(I2C_Port, I2C_Addr, dcu_chan, VFE2dcu10[dcu_chan])",
        "print",
        "I2C_Port = 13",
        "I2C_Addr = 0x10",
        "VFE2dcu10 = []",
        "for dcu_chan in range(0, 8):",
        "VFE2dcu10.append(readTRDCU(FE_CCU_addr, FECaddr, I2C_Port, I2C_Addr, dcu_chan))",
        "print \"VFE DCU I2CPort {0} I2CAddr 0x{1:02x} Channel {2}: (ADC:{3:04x})\".format(I2C_Port, I2C_Addr, dcu_chan, VFE2dcu10[dcu_chan])",
        "print",
        "Dictionary indexed by I2C Address in hexadecimal string. The channel",
        "order is IA0, IA1, IA2, IA3, IA4, IA5. The data is the bottom",
        "resistor followed by the top resistor in the voltage divider. If no",
        "voltage divider, make top tiny compared to bottom.",
        "DCUHeader =  '\\nI2CAddr, DCU Channel, ADC Value(hex), ADC Value(Dec), time\\n'",
        "DCULine = '{0}, {1}, {2}, {3} mV, {4} s\\n'",
        "f.write(DCUHeader)",
        "num_points=500",
        "delay=1",
        "while count<num_points:",
        "for I2C_Addr in (0x10, 0x20, 0x40):",
        "ADCdata = []",
        "for dcu_chan in range(0, 8):",
        "ADCdata.append(readTRDCU(FE_CCU_addr, FECaddr, I2C_Port, I2C_Addr, dcu_chan))",
        "for dcu_chan in range(0, 8):",
        "VREFdata = ((ADCdata[dcu_chan]) / (2.0**12)) * 1250",
        "Rbot = ADCconv[hex(I2C_Addr)][dcu_chan][0]",
        "Rtop = ADCconv[hex(I2C_Addr)][dcu_chan][1]",
        "Vdata = VREFdata * ((Rtop+Rbot)/(Rbot*1.0))",
        "print \"DCU I2CAddr {0:02x} Channel {1}: {2:14.5}mV {3:6.4}mV (ADC:{4:04x}) Time {4}s\".format(I2C_Addr, dcu_chan, Vdata, VREFdata, ADCdata[dcu_chan], time)",
        "f.write(DCULine.format(I2C_Addr, dcu_chan, ADCdata[dcu_chan], Vdata, time))",
        "count+=1",
        "time=delay*count",
        "print",
        "Setup Time Branch, move this to the top of the script after testing",
        "This will set time to the current time",
        "arr[dcu_chan] = Vdata",
        "Replace busy loop with a Timer thread or something more useful",
        "while count<num_points:",
        "for I2C_Addr in (0x10, 0x20, 0x40):",
        "ADCdata = []",
        "for dcu_chan in range(1, 8):",
        "ADCdata.append(readTRDCU(FE_CCU_addr, FECaddr, I2C_Port, I2C_Addr,dcu_chan))",
        "for dcu_chan in range(1, 8):",
        "VREFdata = ((ADCdata[dcu_chan]) / (2.0**12)) * 1250",
        "Rbot = ADCconv[hex(I2C_Addr)][dcu_chan][0]",
        "Rtop = ADCconv[hex(I2C_Addr)][dcu_chan][1]",
        "Vdata = VREFdata * ((Rtop+Rbot)/(Rbot*1.0))",
        "if I2C_Addr == 0x10:",
        "dcu1[dcu_chan]=Vdata",
        "if I2C_Addr == 0x20:",
        "dcu2[dcu_chan]=Vdata",
        "if I2C_Addr == 0x40:",
        "dcu3[dcu_chan]=Vdata",
        "t=delay*count",
        "count+=1",
        "sleep(delay)",
        "tt.Fill()"
    ],
    "docstrings": [
        "\"\"\"\n    Convert a signed integer value of specified width into a byte string.\n    \"\"\"",
        "\"\"\"\n    Convert a signed integer value of specified width into a byte string.\n    \"\"\"",
        "\"\"\"\n    Convert a byte string into a signed integer value of specified width.\n    \"\"\"",
        "\"\"\"\n    Convert a byte string into a signed integer value of specified width.\n    \"\"\""
    ],
    "functions": [
        "regToString",
        "readReg",
        "to8BitStr",
        "toHexStr",
        "int2byteBE",
        "int2byteLE",
        "byte2intBE",
        "byte2intLE",
        "round_figures",
        "composeTRmsg",
        "receiveTRmsgOLD",
        "decomposeTRmsg",
        "word2byte",
        "receiveTRmsg",
        "TRstatus",
        "postMsg",
        "sendMsg",
        "recvMsgOLD",
        "recvMsg",
        "replyMsg",
        "checkI2CAck",
        "initFE",
        "writeTRI2Cbyte",
        "readTRI2Cbyte",
        "readTRDCU"
    ],
    "classes": [
        "dcu"
    ]
}