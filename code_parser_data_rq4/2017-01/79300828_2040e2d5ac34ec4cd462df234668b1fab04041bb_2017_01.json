{
    "identifiers": [
        "com",
        "scandev",
        "utils",
        "java",
        "io",
        "ByteArrayInputStream",
        "java",
        "io",
        "EOFException",
        "java",
        "io",
        "FilterInputStream",
        "java",
        "io",
        "java",
        "io",
        "InputStream",
        "java",
        "io",
        "OutputStream",
        "java",
        "io",
        "SequenceInputStream",
        "java",
        "util",
        "CRC32",
        "java",
        "util",
        "CheckedInputStream",
        "java",
        "util",
        "Inflater",
        "java",
        "util",
        "InflaterInputStream",
        "java",
        "util",
        "ZipException",
        "crc",
        "eos",
        "closed",
        "closed",
        "size",
        "size",
        "usesDefaultInflater",
        "readHeader",
        "buf",
        "off",
        "len",
        "ensureOpen",
        "eos",
        "n",
        "read",
        "buf",
        "off",
        "len",
        "n",
        "readTrailer",
        "eos",
        "read",
        "buf",
        "off",
        "len",
        "crc",
        "update",
        "buf",
        "off",
        "n",
        "n",
        "closed",
        "close",
        "eos",
        "closed",
        "GZIP_MAGIC",
        "FTEXT",
        "FHCRC",
        "FEXTRA",
        "FNAME",
        "FCOMMENT",
        "this_in",
        "this_in",
        "crc",
        "crc",
        "reset",
        "readUShort",
        "GZIP_MAGIC",
        "readUByte",
        "flg",
        "readUByte",
        "skipBytes",
        "n",
        "flg",
        "FEXTRA",
        "FEXTRA",
        "m",
        "readUShort",
        "skipBytes",
        "m",
        "n",
        "m",
        "flg",
        "FNAME",
        "FNAME",
        "n",
        "readUByte",
        "flg",
        "FCOMMENT",
        "FCOMMENT",
        "n",
        "readUByte",
        "flg",
        "FHCRC",
        "FHCRC",
        "v",
        "crc",
        "getValue",
        "readUShort",
        "v",
        "n",
        "crc",
        "reset",
        "n",
        "n",
        "inf",
        "getRemaining",
        "n",
        "buf",
        "len",
        "n",
        "n",
        "readUInt",
        "crc",
        "getValue",
        "readUInt",
        "inf",
        "getBytesWritten",
        "available",
        "n",
        "m",
        "m",
        "readHeader",
        "ze",
        "inf",
        "reset",
        "n",
        "m",
        "inf",
        "setInput",
        "buf",
        "len",
        "n",
        "m",
        "n",
        "m",
        "s",
        "readUShort",
        "readUShort",
        "s",
        "b",
        "readUByte",
        "readUByte",
        "b",
        "b",
        "read",
        "b",
        "b",
        "b",
        "getClass",
        "getName",
        "b",
        "b",
        "tmpbuf",
        "n",
        "n",
        "len",
        "read",
        "tmpbuf",
        "n",
        "tmpbuf",
        "length",
        "n",
        "tmpbuf",
        "length",
        "len",
        "n",
        "len",
        "input",
        "output",
        "count",
        "copyLarge",
        "input",
        "output",
        "count",
        "count",
        "input",
        "output",
        "buffer",
        "count",
        "n1",
        "n",
        "n1",
        "input",
        "read",
        "buffer",
        "count",
        "n1",
        "output",
        "write",
        "buffer",
        "n1",
        "count",
        "input",
        "output",
        "copyLarge",
        "input",
        "output"
    ],
    "literals": [
        "\"Stream closed\"",
        "\"Not in GZIP format\"",
        "\"Unsupported compression method\"",
        "\"Corrupt GZIP header\"",
        "\"Corrupt GZIP trailer\"",
        "\".read() returned value out of range -1..255: \""
    ],
    "variables": [
        "eos",
        "n1"
    ],
    "comments": [
        "Extra text",
        "Header CRC",
        "Extra field",
        "File name",
        "File comment",
        "Check header magic",
        "Check compression method",
        "Read flags",
        "Skip MTIME, XFL, and OS fields",
        "Skip optional extra field",
        "Skip optional file name",
        "Skip optional file comment",
        "Check optional header CRC",
        "Uses left-to-right evaluation order",
        "rfc1952; ISIZE is the input size modulo 2^32",
        "If there are more bytes available in \"in\" or",
        "the leftover in the \"inf\" is > 26 bytes:",
        "this.trailer(8) + next.header.min(10) + next.trailer(8)",
        "try concatenated case",
        "this.trailer",
        "next.header",
        "ignore any malformed, do nothing",
        "Report on this.in, not argument in; see read{Header, Trailer}."
    ],
    "docstrings": [
        "* Created by xietian on 2017/1/19.",
        "* CRC-32 for uncompressed data.",
        "* Indicates end of input stream.",
        "* Check to make sure that this stream has not been closed",
        "* Creates a new input stream with the specified buffer size.\n     * @param in the input stream\n     * @param size the input buffer size\n     *\n     * @exception ZipException if a GZIP format error has occurred or the\n     *                         compression method used is unsupported\n     * @exception IOException if an I/O error has occurred\n     * @exception IllegalArgumentException if {@code size <= 0}",
        "* Creates a new input stream with a default buffer size.\n     * @param in the input stream\n     *\n     * @exception ZipException if a GZIP format error has occurred or the\n     *                         compression method used is unsupported\n     * @exception IOException if an I/O error has occurred",
        "* Reads uncompressed data into an array of bytes. If <code>len</code> is not\n     * zero, the method will block until some input can be decompressed; otherwise,\n     * no bytes are read and <code>0</code> is returned.\n     * @param buf the buffer into which the data is read\n     * @param off the start offset in the destination array <code>b</code>\n     * @param len the maximum number of bytes read\n     * @return  the actual number of bytes read, or -1 if the end of the\n     *          compressed input stream is reached\n     *\n     * @exception  NullPointerException If <code>buf</code> is <code>null</code>.\n     * @exception  IndexOutOfBoundsException If <code>off</code> is negative,\n     * <code>len</code> is negative, or <code>len</code> is greater than\n     * <code>buf.length - off</code>\n     * @exception ZipException if the compressed input data is corrupt.\n     * @exception IOException if an I/O error has occurred.\n     *",
        "* Closes this input stream and releases any system resources associated\n     * with the stream.\n     * @exception IOException if an I/O error has occurred",
        "* GZIP header magic number.",
        "* File header flags.",
        "* Reads GZIP member header and returns the total byte number\n     * of this member header.",
        "* Reads GZIP member trailer and returns true if the eos\n     * reached, false if there are more (concatenated gzip\n     * data set)",
        "* Reads unsigned integer in Intel byte order.",
        "* Reads unsigned short in Intel byte order.",
        "* Reads unsigned byte.",
        "* Skips bytes of input data blocking until all bytes are skipped.\n     * Does not assume that the input stream is capable of seeking."
    ],
    "functions": [
        "ensureOpen",
        "GZIPInputStream",
        "GZIPInputStream",
        "read",
        "close",
        "readHeader",
        "readTrailer",
        "close",
        "readUInt",
        "readUShort",
        "readUByte",
        "skipBytes",
        "copy",
        "copyLarge",
        "copyLarge"
    ],
    "classes": [
        "GZIPInputStream"
    ]
}