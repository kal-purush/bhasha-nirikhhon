{
    "identifiers": [
        "protractor",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "error",
        "webdriver",
        "webdriver",
        "logging",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "getLevel",
        "nameOrValue",
        "webdriver",
        "getLevel",
        "nameOrValue",
        "webdriver",
        "promise",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "all",
        "arr",
        "webdriver",
        "webdriver",
        "asap",
        "value",
        "callback",
        "opt_errback",
        "controlFlow",
        "webdriver",
        "createFlow",
        "callback",
        "flow",
        "webdriver",
        "webdriver",
        "isPromise",
        "value",
        "isGenerator",
        "fn",
        "delayed",
        "ms",
        "webdriver",
        "arr",
        "fn",
        "element",
        "index",
        "array",
        "opt_self",
        "webdriver",
        "arr",
        "webdriver",
        "fn",
        "element",
        "index",
        "array",
        "opt_self",
        "webdriver",
        "defer",
        "webdriver",
        "fulfilled",
        "opt_value",
        "webdriver",
        "arr",
        "fn",
        "element",
        "index",
        "array",
        "opt_self",
        "webdriver",
        "arr",
        "webdriver",
        "fn",
        "element",
        "index",
        "array",
        "opt_self",
        "webdriver",
        "rejected",
        "opt_reason",
        "webdriver",
        "checkedNodeCall",
        "fn",
        "var_args",
        "webdriver",
        "consume",
        "generatorFn",
        "opt_self",
        "var_args",
        "webdriver",
        "when",
        "value",
        "opt_callback",
        "value",
        "opt_errback",
        "error",
        "webdriver",
        "when",
        "value",
        "webdriver",
        "opt_callback",
        "value",
        "opt_errback",
        "error",
        "webdriver",
        "fullyResolved",
        "value",
        "webdriver",
        "setDefaultFlow",
        "flow",
        "webdriver",
        "stacktrace",
        "webdriver",
        "webdriver",
        "format",
        "error",
        "get",
        "webdriver",
        "until",
        "webdriver",
        "ableToSwitchToFrame",
        "frame",
        "webdriver",
        "ableToSwitchToFrame",
        "frame",
        "webdriver",
        "webdriver",
        "ableToSwitchToFrame",
        "frame",
        "webdriver",
        "webdriver",
        "ableToSwitchToFrame",
        "frame",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "ableToSwitchToFrame",
        "frame",
        "webdriver",
        "alertIsPresent",
        "webdriver",
        "webdriver",
        "elementIsDisabled",
        "element",
        "webdriver",
        "webdriver",
        "elementIsEnabled",
        "element",
        "webdriver",
        "webdriver",
        "elementIsNotSelected",
        "element",
        "webdriver",
        "webdriver",
        "elementIsNotVisible",
        "element",
        "webdriver",
        "webdriver",
        "elementIsSelected",
        "element",
        "webdriver",
        "webdriver",
        "elementIsVisible",
        "element",
        "webdriver",
        "webdriver",
        "elementLocated",
        "locator",
        "webdriver",
        "webdriver",
        "webdriver",
        "elementLocated",
        "locator",
        "webdriver",
        "webdriver",
        "elementTextContains",
        "element",
        "webdriver",
        "substr",
        "webdriver",
        "elementTextIs",
        "element",
        "webdriver",
        "text",
        "webdriver",
        "elementTextMatches",
        "element",
        "webdriver",
        "regex",
        "webdriver",
        "elementsLocated",
        "locator",
        "webdriver",
        "webdriver",
        "webdriver",
        "elementsLocated",
        "locator",
        "webdriver",
        "webdriver",
        "stalenessOf",
        "element",
        "webdriver",
        "webdriver",
        "titleContains",
        "substr",
        "webdriver",
        "titleIs",
        "title",
        "webdriver",
        "titleMatches",
        "regex",
        "webdriver",
        "ExpectedConditions",
        "expectedCondition",
        "webdriver",
        "webdriver",
        "fns",
        "webdriver",
        "webdriver",
        "fns",
        "webdriver",
        "webdriver",
        "alertIsPresent",
        "webdriver",
        "elementToBeClickable",
        "element",
        "webdriver",
        "textToBePresentInElement",
        "element",
        "text",
        "webdriver",
        "textToBePresentInElementValue",
        "element",
        "text",
        "webdriver",
        "titleContains",
        "title",
        "webdriver",
        "titleIs",
        "title",
        "webdriver",
        "presenceOf",
        "element",
        "webdriver",
        "stalenessOf",
        "element",
        "webdriver",
        "visibilityOf",
        "element",
        "webdriver",
        "invisibilityOf",
        "element",
        "webdriver",
        "elementToBeSelected",
        "element",
        "webdriver",
        "locator",
        "webdriver",
        "locator",
        "webdriver",
        "webdriver",
        "webdriver",
        "subLocator",
        "webdriver",
        "subLocator",
        "webdriver",
        "selector",
        "selector",
        "webdriver",
        "subLocator",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "expression",
        "value",
        "webdriver",
        "webdriver",
        "index",
        "webdriver",
        "fn",
        "element",
        "index",
        "mapFn",
        "element",
        "index",
        "webdriver",
        "mapFn",
        "element",
        "index",
        "webdriver",
        "filterFn",
        "element",
        "index",
        "reduceFn",
        "acc",
        "element",
        "index",
        "arr",
        "webdriver",
        "initialValue",
        "webdriver",
        "reduceFn",
        "acc",
        "element",
        "index",
        "arr",
        "initialValue",
        "webdriver",
        "webdriver",
        "locator",
        "webdriver",
        "selector",
        "webdriver",
        "expression",
        "value",
        "webdriver",
        "var_args",
        "webdriver",
        "webdriver",
        "cssStyleProperty",
        "webdriver",
        "attributeName",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "index",
        "webdriver",
        "name",
        "webdriver",
        "index",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "webdriver",
        "name",
        "script",
        "name",
        "script",
        "bindingDescriptor",
        "webdriver",
        "bindingDescriptor",
        "webdriver",
        "model",
        "webdriver",
        "searchText",
        "webdriver",
        "searchText",
        "webdriver",
        "repeatDescriptor",
        "cssSelector",
        "searchText",
        "webdriver",
        "optionsDescriptor",
        "webdriver",
        "webdriver",
        "webdriver",
        "locator",
        "webdriver",
        "selector",
        "selector",
        "webdriver",
        "name",
        "script",
        "varArgs",
        "name",
        "script",
        "varArgs",
        "name",
        "destination",
        "opt_timeout",
        "webdriver",
        "opt_timeout",
        "webdriver",
        "url",
        "webdriver",
        "webdriver",
        "opt_debugPort",
        "opt_useSameUrl",
        "opt_copyMockModules",
        "webdriver",
        "wrapDriver",
        "webdriver",
        "webdriver",
        "opt_baseUrl",
        "opt_rootElement",
        "cssLocator",
        "protractor",
        "cssLocator",
        "protractor",
        "protractor",
        "protractor",
        "protractor",
        "protractor",
        "protractor"
    ],
    "literals": [
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "'protractor'"
    ],
    "variables": [
        "Browser",
        "Button",
        "Capability",
        "CommandName",
        "Key",
        "ErrorCode",
        "Type",
        "Level",
        "BROWSER_SUPPORTED",
        "By",
        "browser",
        "by",
        "By",
        "element",
        "$",
        "$$"
    ],
    "comments": [
        "Generated by typings",
        "Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/7de6c3dd94feaeb21f20054b9f30d5dabc5efabd/angular-protractor/angular-protractor.d.ts",
        "Type definitions for Angular Protractor 1.5.0",
        "Project: https://github.com/angular/protractor",
        "Definitions by: Bill Armstrong <https://github.com/BillArmstrong>",
        "Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped",
        "region Wrapped webdriver Items",
        "endregion",
        "Interface for the global browser object."
    ],
    "docstrings": [
        "* Given an array of promises, will return a promise that will be fulfilled\n         * with the fulfillment values of the input array's values. If any of the\n         * input array's promises are rejected, the returned promise will be rejected\n         * with the same reason.\n         *\n         * @param {!Array.<(T|!webdriver.promise.Promise.<T>)>} arr An array of\n         *     promises to wait on.\n         * @return {!webdriver.promise.Promise.<!Array.<T>>} A promise that is\n         *     fulfilled with an array containing the fulfilled values of the\n         *     input array, or rejected with the same reason as the first\n         *     rejected value.\n         * @template T",
        "* Invokes the appropriate callback function as soon as a promised\n         * {@code value} is resolved. This function is similar to\n         * {@link webdriver.promise.when}, except it does not return a new promise.\n         * @param {*} value The value to observe.\n         * @param {Function} callback The function to call when the value is\n         *     resolved successfully.\n         * @param {Function=} opt_errback The function to call when the value is\n         *     rejected.",
        "* @return {!webdriver.promise.ControlFlow} The currently active control flow.",
        "* Creates a new control flow. The provided callback will be invoked as the\n         * first task within the new flow, with the flow as its sole argument. Returns\n         * a promise that resolves to the callback result.\n         * @param {function(!webdriver.promise.ControlFlow)} callback The entry point\n         *     to the newly created flow.\n         * @return {!webdriver.promise.Promise} A promise that resolves to the callback\n         *     result.",
        "* Determines whether a {@code value} should be treated as a promise.\n         * Any object whose \"then\" property is a function will be considered a promise.\n         *\n         * @param {*} value The value to test.\n         * @return {boolean} Whether the value is a promise.",
        "* Tests is a function is a generator.\n         * @param {!Function} fn The function to test.\n         * @return {boolean} Whether the function is a generator.",
        "* Creates a promise that will be resolved at a set time in the future.\n         * @param {number} ms The amount of time, in milliseconds, to wait before\n         *     resolving the promise.\n         * @return {!webdriver.promise.Promise} The promise.",
        "* Calls a function for each element in an array, and if the function returns\n         * true adds the element to a new array.\n         *\n         * <p>If the return value of the filter function is a promise, this function\n         * will wait for it to be fulfilled before determining whether to insert the\n         * element into the new array.\n         *\n         * <p>If the filter function throws or returns a rejected promise, the promise\n         * returned by this function will be rejected with the same reason. Only the\n         * first failure will be reported; all subsequent errors will be silently\n         * ignored.\n         *\n         * @param {!(Array.<TYPE>|webdriver.promise.Promise.<!Array.<TYPE>>)} arr The\n         *     array to iterator over, or a promise that will resolve to said array.\n         * @param {function(this: SELF, TYPE, number, !Array.<TYPE>): (\n         *             boolean|webdriver.promise.Promise.<boolean>)} fn The function\n         *     to call for each element in the array.\n         * @param {SELF=} opt_self The object to be used as the value of 'this' within\n         *     {@code fn}.\n         * @template TYPE, SELF",
        "* Creates a new deferred object.\n         * @return {!webdriver.promise.Deferred} The new deferred object.",
        "* Creates a promise that has been resolved with the given value.\n         * @param {*=} opt_value The resolved value.\n         * @return {!webdriver.promise.Promise} The resolved promise.",
        "* Calls a function for each element in an array and inserts the result into a\n         * new array, which is used as the fulfillment value of the promise returned\n         * by this function.\n         *\n         * <p>If the return value of the mapping function is a promise, this function\n         * will wait for it to be fulfilled before inserting it into the new array.\n         *\n         * <p>If the mapping function throws or returns a rejected promise, the\n         * promise returned by this function will be rejected with the same reason.\n         * Only the first failure will be reported; all subsequent errors will be\n         * silently ignored.\n         *\n         * @param {!(Array.<TYPE>|webdriver.promise.Promise.<!Array.<TYPE>>)} arr The\n         *     array to iterator over, or a promise that will resolve to said array.\n         * @param {function(this: SELF, TYPE, number, !Array.<TYPE>): ?} fn The\n         *     function to call for each element in the array. This function should\n         *     expect three arguments (the element, the index, and the array itself.\n         * @param {SELF=} opt_self The object to be used as the value of 'this' within\n         *     {@code fn}.\n         * @template TYPE, SELF",
        "* Creates a promise that has been rejected with the given reason.\n         * @param {*=} opt_reason The rejection reason; may be any value, but is\n         *     usually an Error or a string.\n         * @return {!webdriver.promise.Promise} The rejected promise.",
        "* Wraps a function that is assumed to be a node-style callback as its final\n         * argument. This callback takes two arguments: an error value (which will be\n         * null if the call succeeded), and the success value as the second argument.\n         * If the call fails, the returned promise will be rejected, otherwise it will\n         * be resolved with the result.\n         * @param {!Function} fn The function to wrap.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved with the\n         *     result of the provided function's callback.",
        "* Consumes a {@code GeneratorFunction}. Each time the generator yields a\n         * promise, this function will wait for it to be fulfilled before feeding the\n         * fulfilled value back into {@code next}. Likewise, if a yielded promise is\n         * rejected, the rejection error will be passed to {@code throw}.\n         *\n         * <p>Example 1: the Fibonacci Sequence.\n         * <pre><code>\n         * webdriver.promise.consume(function* fibonacci() {\n         *   var n1 = 1, n2 = 1;\n         *   for (var i = 0; i < 4; ++i) {\n         *     var tmp = yield n1 + n2;\n         *     n1 = n2;\n         *     n2 = tmp;\n         *   }\n         *   return n1 + n2;\n         * }).then(function(result) {\n         *   console.log(result);  // 13\n         * });\n         * </code></pre>\n         *\n         * <p>Example 2: a generator that throws.\n         * <pre><code>\n         * webdriver.promise.consume(function* () {\n         *   yield webdriver.promise.delayed(250).then(function() {\n         *     throw Error('boom');\n         *   });\n         * }).thenCatch(function(e) {\n         *   console.log(e.toString());  // Error: boom\n         * });\n         * </code></pre>\n         *\n         * @param {!Function} generatorFn The generator function to execute.\n         * @param {Object=} opt_self The object to use as \"this\" when invoking the\n         *     initial generator.\n         * @param {...*} var_args Any arguments to pass to the initial generator.\n         * @return {!webdriver.promise.Promise.<?>} A promise that will resolve to the\n         *     generator's final result.\n         * @throws {TypeError} If the given function is not a generator.",
        "* Registers an observer on a promised {@code value}, returning a new promise\n         * that will be resolved when the value is. If {@code value} is not a promise,\n         * then the return promise will be immediately resolved.\n         * @param {*} value The value to observe.\n         * @param {Function=} opt_callback The function to call when the value is\n         *     resolved successfully.\n         * @param {Function=} opt_errback The function to call when the value is\n         *     rejected.\n         * @return {!webdriver.promise.Promise} A new promise.",
        "* Returns a promise that will be resolved with the input value in a\n         * fully-resolved state. If the value is an array, each element will be fully\n         * resolved. Likewise, if the value is an object, all keys will be fully\n         * resolved. In both cases, all nested arrays and objects will also be\n         * fully resolved.  All fields are resolved in place; the returned promise will\n         * resolve on {@code value} and not a copy.\n         *\n         * Warning: This function makes no checks against objects that contain\n         * cyclical references:\n         *\n         *   var value = {};\n         *   value['self'] = value;\n         *   webdriver.promise.fullyResolved(value);  // Stack overflow.\n         *\n         * @param {*} value The value to fully resolve.\n         * @return {!webdriver.promise.Promise} A promise for a fully resolved version\n         *     of the input value.",
        "* Changes the default flow to use when no others are active.\n         * @param {!webdriver.promise.ControlFlow} flow The new default flow.\n         * @throws {Error} If the default flow is not currently active.",
        "* Formats an error's stack trace.\n         * @param {!(Error|goog.testing.JsUnitException)} error The error to format.\n         * @return {!(Error|goog.testing.JsUnitException)} The formatted error.",
        "* Gets the native stack trace if available otherwise follows the call chain.\n         * The generated trace will exclude all frames up to and including the call to\n         * this function.\n         * @return {!Array.<!webdriver.stacktrace.Frame>} The frames of the stack trace.",
        "* Whether the current browser supports stack traces.\n         *\n         * @type {boolean}\n         * @const",
        "* Creates a condition that will wait until the input driver is able to switch\n         * to the designated frame. The target frame may be specified as:\n         * <ol>\n         *   <li>A numeric index into {@code window.frames} for the currently selected\n         *       frame.\n         *   <li>A {@link webdriver.WebElement}, which must reference a FRAME or IFRAME\n         *       element on the current page.\n         *   <li>A locator which may be used to first locate a FRAME or IFRAME on the\n         *       current page before attempting to switch to it.\n         * </ol>\n         *\n         * <p>Upon successful resolution of this condition, the driver will be left\n         * focused on the new frame.\n         *\n         * @param {!(number|webdriver.WebElement|\n         *           webdriver.Locator|webdriver.By.Hash|\n         *           function(!webdriver.WebDriver): !webdriver.WebElement)} frame\n         *     The frame identifier.\n         * @return {!until.Condition.<boolean>} A new condition.",
        "* Creates a condition that waits for an alert to be opened. Upon success, the\n         * returned promise will be fulfilled with the handle for the opened alert.\n         *\n         * @return {!until.Condition.<!webdriver.Alert>} The new condition.",
        "* Creates a condition that will wait for the given element to be disabled.\n         *\n         * @param {!webdriver.WebElement} element The element to test.\n         * @return {!until.Condition.<boolean>} The new condition.\n         * @see webdriver.WebDriver#isEnabled",
        "* Creates a condition that will wait for the given element to be enabled.\n         *\n         * @param {!webdriver.WebElement} element The element to test.\n         * @return {!until.Condition.<boolean>} The new condition.\n         * @see webdriver.WebDriver#isEnabled",
        "* Creates a condition that will wait for the given element to be deselected.\n         *\n         * @param {!webdriver.WebElement} element The element to test.\n         * @return {!until.Condition.<boolean>} The new condition.\n         * @see webdriver.WebDriver#isSelected",
        "* Creates a condition that will wait for the given element to be in the DOM,\n         * yet not visible to the user.\n         *\n         * @param {!webdriver.WebElement} element The element to test.\n         * @return {!until.Condition.<boolean>} The new condition.\n         * @see webdriver.WebDriver#isDisplayed",
        "* Creates a condition that will wait for the given element to be selected.\n         * @param {!webdriver.WebElement} element The element to test.\n         * @return {!until.Condition.<boolean>} The new condition.\n         * @see webdriver.WebDriver#isSelected",
        "* Creates a condition that will wait for the given element to become visible.\n         *\n         * @param {!webdriver.WebElement} element The element to test.\n         * @return {!until.Condition.<boolean>} The new condition.\n         * @see webdriver.WebDriver#isDisplayed",
        "* Creates a condition that will loop until an element is\n         * {@link webdriver.WebDriver#findElement found} with the given locator.\n         *\n         * @param {!(webdriver.Locator|webdriver.By.Hash|Function)} locator The locator\n         *     to use.\n         * @return {!until.Condition.<!webdriver.WebElement>} The new condition.",
        "* Creates a condition that will wait for the given element's\n         * {@link webdriver.WebDriver#getText visible text} to contain the given\n         * substring.\n         *\n         * @param {!webdriver.WebElement} element The element to test.\n         * @param {string} substr The substring to search for.\n         * @return {!until.Condition.<boolean>} The new condition.\n         * @see webdriver.WebDriver#getText",
        "* Creates a condition that will wait for the given element's\n         * {@link webdriver.WebDriver#getText visible text} to match the given\n         * {@code text} exactly.\n         *\n         * @param {!webdriver.WebElement} element The element to test.\n         * @param {string} text The expected text.\n         * @return {!until.Condition.<boolean>} The new condition.\n         * @see webdriver.WebDriver#getText",
        "* Creates a condition that will wait for the given element's\n         * {@link webdriver.WebDriver#getText visible text} to match a regular\n         * expression.\n         *\n         * @param {!webdriver.WebElement} element The element to test.\n         * @param {!RegExp} regex The regular expression to test against.\n         * @return {!until.Condition.<boolean>} The new condition.\n         * @see webdriver.WebDriver#getText",
        "* Creates a condition that will loop until at least one element is\n         * {@link webdriver.WebDriver#findElement found} with the given locator.\n         *\n         * @param {!(webdriver.Locator|webdriver.By.Hash|Function)} locator The locator\n         *     to use.\n         * @return {!until.Condition.<!Array.<!webdriver.WebElement>>} The new\n         *     condition.",
        "* Creates a condition that will wait for the given element to become stale. An\n         * element is considered stale once it is removed from the DOM, or a new page\n         * has loaded.\n         *\n         * @param {!webdriver.WebElement} element The element that should become stale.\n         * @return {!until.Condition.<boolean>} The new condition.",
        "* Creates a condition that will wait for the current page's title to contain\n         * the given substring.\n         *\n         * @param {string} substr The substring that should be present in the page\n         *     title.\n         * @return {!until.Condition.<boolean>} The new condition.",
        "* Creates a condition that will wait for the current page's title to match the\n         * given value.\n         *\n         * @param {string} title The expected page title.\n         * @return {!until.Condition.<boolean>} The new condition.",
        "* Creates a condition that will wait for the current page's title to match the\n         * given regular expression.\n         *\n         * @param {!RegExp} regex The regular expression to test against.\n         * @return {!until.Condition.<boolean>} The new condition.",
        "* Negates the result of a promise.\n         *\n         * @param {webdriver.until.Condition<boolean>} expectedCondition\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns the negated value.",
        "* Chain a number of expected conditions using logical_and, short circuiting at the\n         * first expected condition that evaluates to false.\n         *\n         * @param {...webdriver.until.Condition<boolean>[]} fns An array of expected conditions to 'and' together.\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise which evaluates\n         * to the result of the logical and.",
        "* Chain a number of expected conditions using logical_or, short circuiting at the\n         * first expected condition that evaluates to true.\n         *\n         * @param {...webdriver.until.Condition<boolean>[]} fns An array of expected conditions to 'or' together.\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise which\n         * evaluates to the result of the logical or.",
        "* Expect an alert to be present.\n         *\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise representing\n         * whether an alert is present.",
        "* An Expectation for checking an element is visible and enabled such that you can click it.\n         *\n         * @param {ElementFinder} element The element to check\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise representing\n         * whether the element is clickable.",
        "* An expectation for checking if the given text is present in the element.\n         * Returns false if the elementFinder does not find an element.\n         *\n         * @param {ElementFinder} element The element to check\n         * @param {string} text The text to verify against\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise representing\n         * whether the text is present in the element.",
        "* An expectation for checking if the given text is present in the elementâ€™s value.\n         * Returns false if the elementFinder does not find an element.\n         *\n         * @param {ElementFinder} element The element to check\n         * @param {string} text The text to verify against\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise representing\n         * whether the text is present in the element's value.",
        "* An expectation for checking that the title contains a case-sensitive substring.\n         *\n         * @param {string} title The fragment of title expected\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise representing\n         * whether the title contains the string.",
        "* An expectation for checking the title of a page.\n         *\n         * @param {string} title The expected title, which must be an exact match.\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise representing\n         * whether the title equals the string.",
        "* An expectation for checking that an element is present on the DOM of a page. This does not necessarily\n         * mean that the element is visible. This is the opposite of 'stalenessOf'.\n         *\n         * @param {ElementFinder} elementFinder The element to check\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise\n         * representing whether the element is present.",
        "* An expectation for checking that an element is not attached to the DOM of a page.\n         * This is the opposite of 'presenceOf'.\n         *\n         * @param {ElementFinder} elementFinder The element to check\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise representing\n         * whether the element is stale.",
        "* An expectation for checking that an element is present on the DOM of a page and visible.\n         * Visibility means that the element is not only displayed but also has a height and width that is\n         * greater than 0. This is the opposite of 'invisibilityOf'.\n         *\n         * @param {ElementFinder} elementFinder The element to check\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise representing\n         * whether the element is visible.",
        "* An expectation for checking that an element is present on the DOM of a page. This does not necessarily\n         * mean that the element is visible. This is the opposite of 'stalenessOf'.\n         *\n         * @param {ElementFinder} elementFinder The element to check\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise representing\n         * whether the element is invisible.",
        "* An expectation for checking the selection is selected.\n         *\n         * @param {ElementFinder} elementFinder The element to check\n         * @return {!webdriver.until.Condition<boolean>} An expected condition that returns a promise representing\n         * whether the element is selected.",
        "* Use as: element(locator)\n    *\n    * The ElementFinder can be treated as a WebElement for most purposes, in\n    * particular, you may perform actions (i.e. click, getText) on them as you\n    * would a WebElement. ElementFinders extend Promise, and once an action\n    * is performed on an ElementFinder, the latest result from the chain can be\n    * accessed using then. Unlike a WebElement, an ElementFinder will wait for\n    * angular to settle before performing finds or actions.\n    *\n    * ElementFinder can be used to build a chain of locators that is used to find\n    * an element. An ElementFinder does not actually attempt to find the element\n    * until an action is called, which means they can be set up in helper files\n    * before the page is available.\n    *\n    * @param {webdriver.Locator} locator An element locator.\n    * @return {ElementFinder}",
        "* ElementArrayFinder is used for operations on an array of elements (as opposed\n          * to a single element).\n          *\n          * @param {webdriver.Locator} locator An element locator.\n          * @return {ElementArrayFinder}",
        "* Calls to element may be chained to find elements within a parent.\n        *\n        * @alias element(locator).element(locator)\n        * @view\n        * <div class=\"parent\">\n        *   <div class=\"child\">\n        *     Child text\n        *     <div>{{person.phone}}</div>\n        *   </div>\n        * </div>\n        *\n        * @example\n        * // Chain 2 element calls.\n        * var child = element(by.css('.parent')).\n        *     element(by.css('.child'));\n        * expect(child.getText()).toBe('Child text\\n555-123-4567');\n        *\n        * // Chain 3 element calls.\n        * var triple = element(by.css('.parent')).\n        *     element(by.css('.child')).\n        *     element(by.binding('person.phone'));\n        * expect(triple.getText()).toBe('555-123-4567');\n        *\n        * @param {webdriver.Locator} subLocator\n        * @return {ElementFinder}",
        "* Calls to element may be chained to find an array of elements within a parent.\n        *\n        * @alias element(locator).all(locator)\n        * @view\n        * <div class=\"parent\">\n        *   <ul>\n        *     <li class=\"one\">First</li>\n        *     <li class=\"two\">Second</li>\n        *     <li class=\"three\">Third</li>\n        *   </ul>\n        * </div>\n        *\n        * @example\n        * var items = element(by.css('.parent')).all(by.tagName('li'))\n        *\n        * @param {webdriver.Locator} subLocator\n        * @return {ElementArrayFinder}",
        "* Shortcut for querying the document directly with css.\n        *\n        * @alias $(cssSelector)\n        * @view\n        * <div class=\"count\">\n        *   <span class=\"one\">First</span>\n        *   <span class=\"two\">Second</span>\n        * </div>\n        *\n        * @example\n        * var item = $('.count .two');\n        * expect(item.getText()).toBe('Second');\n        *\n        * @param {string} selector A css selector\n        * @return {ElementFinder} which identifies the located\n        *     {@link webdriver.WebElement}",
        "* Shortcut for querying the document directly with css.\n        *\n        * @alias $$(cssSelector)\n        * @view\n        * <div class=\"count\">\n        *   <span class=\"one\">First</span>\n        *   <span class=\"two\">Second</span>\n        * </div>\n        *\n        * @example\n        * // The following protractor expressions are equivalent.\n        * var list = element.all(by.css('.count span'));\n        * expect(list.count()).toBe(2);\n        *\n        * list = $$('.count span');\n        * expect(list.count()).toBe(2);\n        * expect(list.get(0).getText()).toBe('First');\n        * expect(list.get(1).getText()).toBe('Second');\n        *\n        * @param {string} selector a css selector\n        * @return {ElementArrayFinder} which identifies the\n        *     array of the located {@link webdriver.WebElement}s.",
        "* Determine whether the element is present on the page.\n        *\n        * @view\n        * <span>{{person.name}}</span>\n        *\n        * @example\n        * // Element exists.\n        * expect(element(by.binding('person.name')).isPresent()).toBe(true);\n        *\n        * // Element not present.\n        * expect(element(by.binding('notPresent')).isPresent()).toBe(false);\n        *\n        * @return {ElementFinder} which resolves to whether\n        *     the element is present on the page.",
        "* Override for WebElement.prototype.isElementPresent so that protractor waits\n        * for Angular to settle before making the check.\n        *\n        * @see ElementFinder.isPresent\n        *\n        * @param {webdriver.Locator} subLocator Locator for element to look for.\n        * @return {ElementFinder} which resolves to whether\n        *     the element is present on the page.",
        "* @see ElementArrayFinder.prototype.locator\n        *\n        * @return {webdriver.Locator}",
        "* Returns the WebElement represented by this ElementFinder.\n        * Throws the WebDriver error if the element doesn't exist.\n        *\n        * @example\n        *  The following three expressions are equivalent.\n        *  element(by.css('.parent')).getWebElement();\n        *  browser.waitForAngular(); browser.driver.findElement(by.css('.parent'));\n        *  browser.findElement(by.css('.parent'));\n        *\n        * @alias element(locator).getWebElement()\n        * @return {webdriver.WebElement}",
        "* Evaluates the input as if it were on the scope of the current element.\n        * @see ElementArrayFinder.evaluate\n        *\n        * @param {string} expression\n        *\n        * @return {ElementFinder} which resolves to the evaluated expression.",
        "* @see ElementArrayFinder.prototype.allowAnimations.\n        * @param {string} value\n        *\n        * @return {ElementFinder} which resolves to whether animation is allowed.",
        "* Create a shallow copy of ElementFinder.\n        *\n        * @return {!ElementFinder} A shallow copy of this.",
        "* Returns the elements as an array of WebElements.",
        "* Get an element within the ElementArrayFinder by index. The index starts at 0.\n        * Negative indices are wrapped (i.e. -i means ith element from last)\n        * This does not actually retrieve the underlying element.\n        *\n        * @alias element.all(locator).get(index)\n        * @view\n        * <ul class=\"items\">\n        *   <li>First</li>\n        *   <li>Second</li>\n        *   <li>Third</li>\n        * </ul>\n        *\n        * @example\n        * var list = element.all(by.css('.items li'));\n        * expect(list.get(0).getText()).toBe('First');\n        * expect(list.get(1).getText()).toBe('Second');\n        *\n        * @param {number} index Element index.\n        * @return {ElementFinder} finder representing element at the given index.",
        "* Get the first matching element for the ElementArrayFinder. This does not\n        * actually retrieve the underlying element.\n        *\n        * @alias element.all(locator).first()\n        * @view\n        * <ul class=\"items\">\n        *   <li>First</li>\n        *   <li>Second</li>\n        *   <li>Third</li>\n        * </ul>\n        *\n        * @example\n        * var first = element.all(by.css('.items li')).first();\n        * expect(first.getText()).toBe('First');\n        *\n        * @return {ElementFinder} finder representing the first matching element",
        "* Get the last matching element for the ElementArrayFinder. This does not\n        * actually retrieve the underlying element.\n        *\n        * @alias element.all(locator).last()\n        * @view\n        * <ul class=\"items\">\n        *   <li>First</li>\n        *   <li>Second</li>\n        *   <li>Third</li>\n        * </ul>\n        *\n        * @example\n        * var last = element.all(by.css('.items li')).last();\n        * expect(last.getText()).toBe('Third');\n        *\n        * @return {ElementFinder} finder representing the last matching element",
        "* Count the number of elements represented by the ElementArrayFinder.\n        *\n        * @alias element.all(locator).count()\n        * @view\n        * <ul class=\"items\">\n        *   <li>First</li>\n        *   <li>Second</li>\n        *   <li>Third</li>\n        * </ul>\n        *\n        * @example\n        * var list = element.all(by.css('.items li'));\n        * expect(list.count()).toBe(3);\n        *\n        * @return {!webdriver.promise.Promise} A promise which resolves to the\n        *     number of elements matching the locator.",
        "* Calls the input function on each ElementFinder represented by the ElementArrayFinder.\n        *\n        * @alias element.all(locator).each(eachFunction)\n        * @view\n        * <ul class=\"items\">\n        *   <li>First</li>\n        *   <li>Second</li>\n        *   <li>Third</li>\n        * </ul>\n        *\n        * @example\n        * element.all(by.css('.items li')).each(function(element) {\n        *   // Will print First, Second, Third.\n        *   element.getText().then(console.log);\n        * });\n        *\n        * @param {function(ElementFinder)} fn Input function",
        "* Apply a map function to each element within the ElementArrayFinder. The\n        * callback receives the ElementFinder as the first argument and the index as\n        * a second arg.\n        *\n        * @alias element.all(locator).map(mapFunction)\n        * @view\n        * <ul class=\"items\">\n        *   <li class=\"one\">First</li>\n        *   <li class=\"two\">Second</li>\n        *   <li class=\"three\">Third</li>\n        * </ul>\n        *\n        * @example\n        * var items = element.all(by.css('.items li')).map(function(elm, index) {\n        *   return {\n        *     index: index,\n        *     text: elm.getText(),\n        *     class: elm.getAttribute('class')\n        *   };\n        * });\n        * expect(items).toEqual([\n        *   {index: 0, text: 'First', class: 'one'},\n        *   {index: 1, text: 'Second', class: 'two'},\n        *   {index: 2, text: 'Third', class: 'three'}\n        * ]);\n        *\n        * @param {function(ElementFinder, number)} mapFn Map function that\n        *     will be applied to each element.\n        * @return {!webdriver.promise.Promise} A promise that resolves to an array\n        *     of values returned by the map function.",
        "* Apply a filter function to each element within the ElementArrayFinder. Returns\n        * a new ElementArrayFinder with all elements that pass the filter function. The\n        * filter function receives the ElementFinder as the first argument\n        * and the index as a second arg.\n        * This does not actually retrieve the underlying list of elements, so it can\n        * be used in page objects.\n        *\n        * @alias element.all(locator).filter(filterFn)\n        * @view\n        * <ul class=\"items\">\n        *   <li class=\"one\">First</li>\n        *   <li class=\"two\">Second</li>\n        *   <li class=\"three\">Third</li>\n        * </ul>\n        *\n        * @example\n        * element.all(by.css('.items li')).filter(function(elem, index) {\n        *   return elem.getText().then(function(text) {\n        *     return text === 'Third';\n        *   });\n        * }).then(function(filteredElements) {\n        *   filteredElements[0].click();\n        * });\n        *\n        * @param {function(ElementFinder, number): webdriver.WebElement.Promise} filterFn\n        *     Filter function that will test if an element should be returned.\n        *     filterFn can either return a boolean or a promise that resolves to a boolean.\n        * @return {!ElementArrayFinder} A ElementArrayFinder that represents an array\n        *     of element that satisfy the filter function.",
        "* Apply a reduce function against an accumulator and every element found\n        * using the locator (from left-to-right). The reduce function has to reduce\n        * every element into a single value (the accumulator). Returns promise of\n        * the accumulator. The reduce function receives the accumulator, current\n        * ElementFinder, the index, and the entire array of ElementFinders,\n        * respectively.\n        *\n        * @alias element.all(locator).reduce(reduceFn)\n        * @view\n        * <ul class=\"items\">\n        *   <li class=\"one\">First</li>\n        *   <li class=\"two\">Second</li>\n        *   <li class=\"three\">Third</li>\n        * </ul>\n        *\n        * @example\n        * var value = element.all(by.css('.items li')).reduce(function(acc, elem) {\n        *   return elem.getText().then(function(text) {\n        *     return acc + text + ' ';\n        *   });\n        * });\n        *\n        * expect(value).toEqual('First Second Third ');\n        *\n        * @param {function(number, ElementFinder, number, Array.<ElementFinder>)}\n        *     reduceFn Reduce function that reduces every element into a single value.\n        * @param {*} initialValue Initial value of the accumulator.\n        * @return {!webdriver.promise.Promise} A promise that resolves to the final\n        *     value of the accumulator.",
        "* Represents the ElementArrayFinder as an array of ElementFinders.\n        *\n        * @return {Array.<ElementFinder>} Return a promise, which resolves to a list\n        *     of ElementFinders specified by the locator.",
        "* Create a shallow copy of ElementArrayFinder.\n        *\n        * @return {!ElementArrayFinder} A shallow copy of this.",
        "* Calls to ElementArrayFinder may be chained to find an array of elements\n        * using the current elements in this ElementArrayFinder as the starting point.\n        * This function returns a new ElementArrayFinder which would contain the\n        * children elements found (and could also be empty).\n        *\n        * @alias element.all(locator).all(locator)\n        * @view\n        * <div id='id1' class=\"parent\">\n        *   <ul>\n        *     <li class=\"foo\">1a</li>\n        *     <li class=\"baz\">1b</li>\n        *   </ul>\n        * </div>\n        * <div id='id2' class=\"parent\">\n        *   <ul>\n        *     <li class=\"foo\">2a</li>\n        *     <li class=\"bar\">2b</li>\n        *   </ul>\n        * </div>\n        *\n        * @example\n        * var foo = element.all(by.css('.parent')).all(by.css('.foo'))\n        * expect(foo.getText()).toEqual(['1a', '2a'])\n        * var baz = element.all(by.css('.parent')).all(by.css('.baz'))\n        * expect(baz.getText()).toEqual(['1b'])\n        * var nonexistent = element.all(by.css('.parent')).all(by.css('.NONEXISTENT'))\n        * expect(nonexistent.getText()).toEqual([''])\n        *\n        * @param {webdriver.Locator} subLocator\n        * @return {ElementArrayFinder}",
        "* Shorthand function for finding arrays of elements by css.\n        *\n        * @type {function(string): ElementArrayFinder}",
        "* Returns an ElementFinder representation of ElementArrayFinder. It ensures\n        * that the ElementArrayFinder resolves to one and only one underlying element.\n        *\n        * @return {ElementFinder} An ElementFinder representation\n        * @private",
        "* Returns the most relevant locator.\n        *\n        * @example\n        * $('#ID1').locator() // returns by.css('#ID1')\n        * $('#ID1').$('#ID2').locator() // returns by.css('#ID2')\n        * $$('#ID1').filter(filterFn).get(0).click().locator() // returns by.css('#ID1')\n        *\n        * @return {webdriver.Locator}",
        "* Evaluates the input as if it were on the scope of the current underlying\n         * elements.\n         *\n         * @view\n         * <span id=\"foo\">{{variableInScope}}</span>\n         *\n         * @example\n         * var value = element(by.id('foo')).evaluate('variableInScope');\n         *\n         * @param {string} expression\n         *\n         * @return {ElementArrayFinder} which resolves to the\n         *     evaluated expression for each underlying element.\n         *     The result will be resolved as in\n         *     {@link webdriver.WebDriver.executeScript}. In summary - primitives will\n         *     be resolved as is, functions will be converted to string, and elements\n         *     will be returned as a WebElement.",
        "* Determine if animation is allowed on the current underlying elements.\n         * @param {string} value\n         *\n         * @example\n         * // Turns off ng-animate animations for all elements in the <body>\n         * element(by.css('body')).allowAnimations(false);\n         *\n         * @return {ElementArrayFinder} which resolves to whether animation is allowed.",
        "* Schedules a command to click on this element.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved when\n         *     the click command has completed.",
        "* Schedules a command to type a sequence on the DOM element represented by this\n         * instance.\n         * <p/>\n         * Modifier keys (SHIFT, CONTROL, ALT, META) are stateful; once a modifier is\n         * processed in the keysequence, that key state is toggled until one of the\n         * following occurs:\n         * <ul>\n         * <li>The modifier key is encountered again in the sequence. At this point the\n         * state of the key is toggled (along with the appropriate keyup/down events).\n         * </li>\n         * <li>The {@code webdriver.Key.NULL} key is encountered in the sequence. When\n         * this key is encountered, all modifier keys current in the down state are\n         * released (with accompanying keyup events). The NULL key can be used to\n         * simulate common keyboard shortcuts:\n         * <code>\n         *     element.sendKeys(\"text was\",\n         *                      webdriver.Key.CONTROL, \"a\", webdriver.Key.NULL,\n         *                      \"now text is\");\n         *     // Alternatively:\n         *     element.sendKeys(\"text was\",\n         *                      webdriver.Key.chord(webdriver.Key.CONTROL, \"a\"),\n         *                      \"now text is\");\n         * </code></li>\n         * <li>The end of the keysequence is encountered. When there are no more keys\n         * to type, all depressed modifier keys are released (with accompanying keyup\n         * events).\n         * </li>\n         * </ul>\n         * <strong>Note:</strong> On browsers where native keyboard events are not yet\n         * supported (e.g. Firefox on OS X), key events will be synthesized. Special\n         * punctionation keys will be synthesized according to a standard QWERTY en-us\n         * keyboard layout.\n         *\n         * @param {...string} var_args The sequence of keys to\n         *     type. All arguments will be joined into a single sequence (var_args is\n         *     permitted for convenience).\n         * @return {!webdriver.promise.Promise} A promise that will be resolved when all\n         *     keys have been typed.",
        "* Schedules a command to query for the tag/node name of this element.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved with the\n         *     element's tag name.",
        "* Schedules a command to query for the computed style of the element\n         * represented by this instance. If the element inherits the named style from\n         * its parent, the parent will be queried for its value.  Where possible, color\n         * values will be converted to their hex representation (e.g. #00ff00 instead of\n         * rgb(0, 255, 0)).\n         * <p/>\n         * <em>Warning:</em> the value returned will be as the browser interprets it, so\n         * it may be tricky to form a proper assertion.\n         *\n         * @param {string} cssStyleProperty The name of the CSS style property to look\n         *     up.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved with the\n         *     requested CSS value.",
        "* Schedules a command to query for the value of the given attribute of the\n         * element. Will return the current value even if it has been modified after the\n         * page has been loaded. More exactly, this method will return the value of the\n         * given attribute, unless that attribute is not present, in which case the\n         * value of the property with the same name is returned. If neither value is\n         * set, null is returned. The \"style\" attribute is converted as best can be to a\n         * text representation with a trailing semi-colon. The following are deemed to\n         * be \"boolean\" attributes and will be returned as thus:\n         *\n         * <p>async, autofocus, autoplay, checked, compact, complete, controls, declare,\n         * defaultchecked, defaultselected, defer, disabled, draggable, ended,\n         * formnovalidate, hidden, indeterminate, iscontenteditable, ismap, itemscope,\n         * loop, multiple, muted, nohref, noresize, noshade, novalidate, nowrap, open,\n         * paused, pubdate, readonly, required, reversed, scoped, seamless, seeking,\n         * selected, spellcheck, truespeed, willvalidate\n         *\n         * <p>Finally, the following commonly mis-capitalized attribute/property names\n         * are evaluated as expected:\n         * <ul>\n         *   <li>\"class\"\n         *   <li>\"readonly\"\n         * </ul>\n         * @param {string} attributeName The name of the attribute to query.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved with the\n         *     attribute's value.",
        "* Get the visible (i.e. not hidden by CSS) innerText of this element, including\n         * sub-elements, without any leading or trailing whitespace.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved with the\n         *     element's visible text.",
        "* Schedules a command to compute the size of this element's bounding box, in\n         * pixels.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved with the\n         *     element's size as a {@code {width:number, height:number}} object.",
        "* Schedules a command to compute the location of this element in page space.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved to the\n         *     element's location as a {@code {x:number, y:number}} object.",
        "* Schedules a command to query whether the DOM element represented by this\n         * instance is enabled, as dicted by the {@code disabled} attribute.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved with\n         *     whether this element is currently enabled.",
        "* Schedules a command to query whether this element is selected.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved with\n         *     whether this element is currently selected.",
        "* Schedules a command to submit the form containing this element (or this\n         * element if it is a FORM element). This command is a no-op if the element is\n         * not contained in a form.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved when\n         *     the form has been submitted.",
        "* Schedules a command to clear the {@code value} of this element. This command\n         * has no effect if the underlying DOM element is neither a text INPUT element\n         * nor a TEXTAREA element.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved when\n         *     the element has been cleared.",
        "* Schedules a command to test whether this element is currently displayed.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved with\n         *     whether this element is currently visible on the page.",
        "* Schedules a command to retrieve the outer HTML of this element.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved with\n         *     the element's outer HTML.",
        "* @return {!webdriver.promise.Promise.<webdriver.WebElement.Id>} A promise\n         *     that resolves to this element's JSON representation as defined by the\n         *     WebDriver wire protocol.\n         * @see http://code.google.com/p/selenium/wiki/JsonWireProtocol",
        "* Schedules a command to retrieve the inner HTML of this element.\n         * @return {!webdriver.promise.Promise} A promise that will be resolved with the\n         *     element's inner HTML.",
        "* webdriver's By is an enum of locator functions, so we must set it to\n         * a prototype before inheriting from it.",
        "* Add a locator to this instance of ProtractorBy. This locator can then be\n         * used with element(by.locatorName(args)).\n         *\n         * @view\n         * <button ng-click=\"doAddition()\">Go!</button>\n         *\n         * @example\n         * // Add the custom locator.\n         * by.addLocator('buttonTextSimple',\n         *     function(buttonText, opt_parentElement, opt_rootSelector) {\n         *   // This function will be serialized as a string and will execute in the\n         *   // browser. The first argument is the text for the button. The second\n         *   // argument is the parent element, if any.\n         *   var using = opt_parentElement,\n         *       buttons = using.querySelectorAll('button');\n         *\n         *   // Return an array of buttons with the text.\n         *   return Array.prototype.filter.call(buttons, function(button) {\n         *     return button.textContent === buttonText;\n         *   });\n         * });\n         *\n         * // Use the custom locator.\n         * element(by.buttonTextSimple('Go!')).click();\n         *\n         * @alias by.addLocator(locatorName, functionOrScript)\n         * @param {string} name The name of the new locator.\n         * @param {Function|string} script A script to be run in the context of\n         *     the browser. This script will be passed an array of arguments\n         *     that contains any args passed into the locator followed by the\n         *     element scoping the search and the css selector for the root angular\n         *     element. It should return an array of elements.",
        "* Find an element by binding.\n         *\n         * @view\n         * <span>{{person.name}}</span>\n         * <span ng-bind=\"person.email\"></span>\n         *\n         * @example\n         * var span1 = element(by.binding('person.name'));\n         * expect(span1.getText()).toBe('Foo');\n         *\n         * var span2 = element(by.binding('person.email'));\n         * expect(span2.getText()).toBe('foo@bar.com');\n         *\n         * @param {string} bindingDescriptor\n         * @return {{findElementsOverride: findElementsOverride, toString: Function|string}}",
        "* Find an element by exact binding.\n         *\n         * @view\n         * <span>{{ person.name }}</span>\n         * <span ng-bind=\"person-email\"></span>\n         * <span>{{person_phone|uppercase}}</span>\n         *\n         * @example\n         * expect(element(by.exactBinding('person.name')).isPresent()).toBe(true);\n         * expect(element(by.exactBinding('person-email')).isPresent()).toBe(true);\n         * expect(element(by.exactBinding('person')).isPresent()).toBe(false);\n         * expect(element(by.exactBinding('person_phone')).isPresent()).toBe(true);\n         * expect(element(by.exactBinding('person_phone|uppercase')).isPresent()).toBe(true);\n         * expect(element(by.exactBinding('phone')).isPresent()).toBe(false);\n         *\n         * @param {string} bindingDescriptor\n         * @return {{findElementsOverride: findElementsOverride, toString: Function|string}}",
        "* Find an element by ng-model expression.\n         *\n         * @alias by.model(modelName)\n         * @view\n         * <input type=\"text\" ng-model=\"person.name\"/>\n         *\n         * @example\n         * var input = element(by.model('person.name'));\n         * input.sendKeys('123');\n         * expect(input.getAttribute('value')).toBe('Foo123');\n         *\n         * @param {string} model ng-model expression.",
        "* Find a button by text.\n         *\n         * @view\n         * <button>Save</button>\n         *\n         * @example\n         * element(by.buttonText('Save'));\n         *\n         * @param {string} searchText\n         * @return {{findElementsOverride: findElementsOverride, toString: Function|string}}",
        "* Find a button by partial text.\n         *\n         * @view\n         * <button>Save my file</button>\n         *\n         * @example\n         * element(by.partialButtonText('Save'));\n         *\n         * @param {string} searchText\n         * @return {{findElementsOverride: findElementsOverride, toString: Function|string}}",
        "* Find elements inside an ng-repeat.\n         *\n         * @view\n         * <div ng-repeat=\"cat in pets\">\n         *   <span>{{cat.name}}</span>\n         *   <span>{{cat.age}}</span>\n         * </div>\n         *\n         * <div class=\"book-img\" ng-repeat-start=\"book in library\">\n         *   <span>{{$index}}</span>\n         * </div>\n         * <div class=\"book-info\" ng-repeat-end>\n         *   <h4>{{book.name}}</h4>\n         *   <p>{{book.blurb}}</p>\n         * </div>\n         *\n         * @example\n         * // Returns the DIV for the second cat.\n         * var secondCat = element(by.repeater('cat in pets').row(1));\n         *\n         * // Returns the SPAN for the first cat's name.\n         * var firstCatName = element(by.repeater('cat in pets').\n         *     row(0).column('{{cat.name}}'));\n         *\n         * // Returns a promise that resolves to an array of WebElements from a column\n         * var ages = element.all(\n         *     by.repeater('cat in pets').column('{{cat.age}}'));\n         *\n         * // Returns a promise that resolves to an array of WebElements containing\n         * // all top level elements repeated by the repeater. For 2 pets rows resolves\n         * // to an array of 2 elements.\n         * var rows = element.all(by.repeater('cat in pets'));\n         *\n         * // Returns a promise that resolves to an array of WebElements containing all\n         * // the elements with a binding to the book's name.\n         * var divs = element.all(by.repeater('book in library').column('book.name'));\n         *\n         * // Returns a promise that resolves to an array of WebElements containing\n         * // the DIVs for the second book.\n         * var bookInfo = element.all(by.repeater('book in library').row(1));\n         *\n         * // Returns the H4 for the first book's name.\n         * var firstBookName = element(by.repeater('book in library').\n         *     row(0).column('{{book.name}}'));\n         *\n         * // Returns a promise that resolves to an array of WebElements containing\n         * // all top level elements repeated by the repeater. For 2 books divs\n         * // resolves to an array of 4 elements.\n         * var divs = element.all(by.repeater('book in library'));",
        "* Find elements by CSS which contain a certain string.\n         *\n         * @view\n         * <ul>\n         *   <li class=\"pet\">Dog</li>\n         *   <li class=\"pet\">Cat</li>\n         * </ul>\n         *\n         * @example\n         * // Returns the DIV for the dog, but not cat.\n         * var dog = element(by.cssContainingText('.pet', 'Dog'));",
        "* Find an element by ng-options expression.\n         *\n         * @alias by.options(optionsDescriptor)\n         * @view\n         * <select ng-model=\"color\" ng-options=\"c for c in colors\">\n         *   <option value=\"0\" selected=\"selected\">red</option>\n         *   <option value=\"1\">green</option>\n         * </select>\n         *\n         * @example\n         * var allOptions = element.all(by.options('c for c in colors'));\n         * expect(allOptions.count()).toEqual(2);\n         * var firstOption = allOptions.first();\n         * expect(firstOption.getText()).toEqual('red');\n         *\n         * @param {string} optionsDescriptor ng-options expression.",
        "* The wrapped webdriver instance. Use this to interact with pages that do\n        * not contain Angular (such as a log-in screen).\n        *\n        * @type {webdriver.WebDriver}",
        "* Helper function for finding elements.\n        *\n        * @type {function(webdriver.Locator): ElementFinder}",
        "* Shorthand function for finding elements by css.\n        *\n        * @type {function(string): ElementFinder}",
        "* Shorthand function for finding arrays of elements by css.\n        *\n        * @type {function(string): ElementArrayFinder}",
        "* All get methods will be resolved against this base URL. Relative URLs are =\n        * resolved the way anchor tags resolve.\n        *\n        * @type {string}",
        "* The css selector for an element on which to find Angular. This is usually\n        * 'body' but if your ng-app is on a subsection of the page it may be\n        * a subelement.\n        *\n        * @type {string}",
        "* If true, Protractor will not attempt to synchronize with the page before\n        * performing actions. This can be harmful because Protractor will not wait\n        * until $timeouts and $http calls have been processed, which can cause\n        * tests to become flaky. This should be used only when necessary, such as\n        * when a page continuously polls an API using $timeout.\n        *\n        * @type {boolean}",
        "* Timeout in milliseconds to wait for pages to load when calling `get`.\n        *\n        * @type {number}",
        "* An object that holds custom test parameters.\n        *\n        * @type {Object}",
        "* The reset URL to use between page loads.\n        *\n        * @type {string}",
        "* Instruct webdriver to wait until Angular has finished rendering and has\n         * no outstanding $http calls before continuing.\n         *\n         * @return {!webdriver.promise.Promise} A promise that will resolve to the\n         *    scripts return value.",
        "* Add a module to load before Angular whenever Protractor.get is called.\n         * Modules will be registered after existing modules already on the page,\n         * so any module registered here will override preexisting modules with the same\n         * name.\n         *\n         * @example\n         * browser.addMockModule('modName', function() {\n         *   angular.module('modName', []).value('foo', 'bar');\n         * });\n         *\n         * @param {!string} name The name of the module to load or override.\n         * @param {!string|Function} script The JavaScript to load the module.\n         * @param {...*} varArgs Any additional arguments will be provided to\n         *     the script and may be referenced using the `arguments` object.",
        "* Clear the list of registered mock modules.",
        "* Remove a registered mock module.\n         *\n         * @example\n         * browser.removeMockModule('modName');\n         *\n         * @param {!string} name The name of the module to remove.",
        "* @see webdriver.WebDriver.get\n         *\n         * Navigate to the given destination and loads mock modules before\n         * Angular. Assumes that the page being loaded uses Angular.\n         * If you need to access a page which does not have Angular on load, use\n         * the wrapped webdriver directly.\n         *\n         * @param {string} destination Destination URL.\n         * @param {number=} opt_timeout Number of milliseconds to wait for Angular to\n         *     start.",
        "* See webdriver.WebDriver.refresh\n         *\n         * Makes a full reload of the current page and loads mock modules before\n         * Angular. Assumes that the page being loaded uses Angular.\n         * If you need to access a page which does not have Angular on load, use\n         * the wrapped webdriver directly.\n         *\n         * @param {number=} opt_timeout Number of seconds to wait for Angular to start.",
        "* Browse to another page using in-page navigation.\n         *\n         * @param {string} url In page URL using the same syntax as $location.url()\n         * @returns {!webdriver.promise.Promise} A promise that will resolve once\n         *    page has been changed.",
        "* Returns the current absolute url from AngularJS.",
        "* Pauses the test and injects some helper functions into the browser, so that\n         * debugging may be done in the browser console.\n         *\n         * This should be used under node in debug mode, i.e. with\n         * protractor debug <configuration.js>\n         *\n         * @example\n         * While in the debugger, commands can be scheduled through webdriver by\n         * entering the repl:\n         *   debug> repl\n         *   Press Ctrl + C to leave rdebug repl\n         *   > ptor.findElement(protractor.By.input('user').sendKeys('Laura'));\n         *   > ptor.debugger();\n         *   debug> c\n         *\n         * This will run the sendKeys command as the next task, then re-enter the\n         * debugger.",
        "* Beta (unstable) pause function for debugging webdriver tests. Use\n         * browser.pause() in your test to enter the protractor debugger from that\n         * point in the control flow.\n         * Does not require changes to the command line (no need to add 'debug').\n         *\n         * @example\n         * element(by.id('foo')).click();\n         * browser.pause();\n         * // Execution will stop before the next click action.\n         * element(by.id('bar')).click();\n         *\n         * @param {number=} opt_debugPort Optional port to use for the debugging process",
        "* Fork another instance of protractor for use in interactive tests.\n        *\n        * @param {boolean} opt_useSameUrl Whether to navigate to current url on creation\n        * @param {boolean} opt_copyMockModules Whether to apply same mock modules on creation\n        * @return {Protractor} a protractor instance.",
        "* Get the processed configuration object that is currently being run. This will contain\n        * the specs and capabilities properties of the current runner instance.\n        *\n        * Set by the runner.\n        *\n        * @return {webdriver.promise.Promise<any>} A promise which resolves to the capabilities object.",
        "* Create a new instance of Protractor by wrapping a webdriver instance.\n     *\n     * @param {webdriver.WebDriver} webdriver The configured webdriver instance.\n     * @param {string=} opt_baseUrl A URL to prepend to relative gets.\n     * @return {Protractor}"
    ],
    "functions": [],
    "classes": [
        "ActionSequence",
        "Builder",
        "Capabilities",
        "Command",
        "EventEmitter",
        "Session",
        "WebDriver",
        "WebElement",
        "WebElementPromise",
        "Preferences",
        "Entry",
        "Thenable",
        "Deferred",
        "ControlFlow",
        "CancellationError",
        "Frame",
        "Snapshot",
        "Condition"
    ]
}