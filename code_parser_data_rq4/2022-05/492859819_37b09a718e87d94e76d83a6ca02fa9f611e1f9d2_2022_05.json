{
    "identifiers": [],
    "literals": [],
    "variables": [],
    "comments": [
        "declare class TokenRequest {\n  client_id: string;\n  redirect_uri: string;\n  grant_type: string;\n  code?: string;\n}\n\nclass TokenResponse {\n  accessToken: string;\n  tokenType: TokenType;\n  expiresIn: number | undefined;\n  refreshToken: string | undefined;\n  scope: string | undefined;\n  idToken: string | undefined;\n  issuedAt: number;\n\n  constructor(response: TokenResponseJson) {\n    this.accessToken = response.access_token;\n    this.tokenType = response.token_type || 'bearer';\n    if (response.expires_in) {\n      this.expiresIn = parseInt(response.expires_in, 10);\n    }\n    this.refreshToken = response.refresh_token;\n    this.scope = response.scope;\n    this.idToken = response.id_token;\n    this.issuedAt = response.issued_at || nowInSeconds();\n  }\n\n  toJson(): TokenResponseJson {\n    return {\n      access_token: this.accessToken,\n      id_token: this.idToken,\n      refresh_token: this.refreshToken,\n      scope: this.scope,\n      token_type: this.tokenType,\n      issued_at: this.issuedAt,\n      expires_in: this.expiresIn?.toString()\n    };\n  }\n\n  isValid(buffer: number = AUTH_EXPIRY_BUFFER): boolean {\n    if (this.expiresIn) {\n      let now = nowInSeconds();\n      return now < this.issuedAt + this.expiresIn + buffer;\n    }\n    else {\n      return true;\n    }\n  }\n}\n\ninterface TokenResponseJson {\n  access_token: string;\n  token_type?: TokenType;\n  expires_in?: string;\n  refresh_token?: string;\n  scope?: string;\n  id_token?: string;\n  issued_at?: number;\n}\nconst AUTH_EXPIRY_BUFFER = 10 //60 //-1;  // 10 mins in seconds\nconst nowInSeconds = () => Math.round(new Date().getTime() / 1000);\ndeclare type TokenType = 'bearer' | 'mac';\ndeclare type ErrorType = 'invalid_request' | 'invalid_client' | 'invalid_grant' | 'unauthorized_client' | 'unsupported_grant_type' | 'invalid_scope';\ninterface AuthorizationServiceConfigurationJson {\n  authorization_endpoint: string;\n  token_endpoint: string;\n  revocation_endpoint: string;\n  end_session_endpoint?: string;\n  userinfo_endpoint?: string;\n}\n\ndeclare class AuthorizationServiceConfiguration {\n  authorizationEndpoint: string;\n  tokenEndpoint: string;\n  revocationEndpoint: string;\n  userInfoEndpoint?: string;\n  endSessionEndpoint?: string;\n  constructor(request: AuthorizationServiceConfigurationJson);\n  toJson(): {\n    authorization_endpoint: string;\n    token_endpoint: string;\n    revocation_endpoint: string;\n    end_session_endpoint: string | undefined;\n    userinfo_endpoint: string | undefined;\n  };\n  static fetchFromIssuer(openIdIssuerUrl: string, requestor?: XMLHttpRequest): Promise<AuthorizationServiceConfiguration>;\n}\n\nclass AppAuthError {\n  constructor(public message: string, public extras?: any) { }\n}\n\n\nconst SIZE = 10;  // 10 bytes\nconst newState = function (crypto: Crypto): string {\n  return crypto.generateRandom(SIZE);\n};\n\nconst HAS_CRYPTO = typeof window !== 'undefined' && !!(window.crypto as any);\nconst HAS_SUBTLE_CRYPTO = HAS_CRYPTO && !!(window.crypto.subtle as any);\nconst CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\nfunction bufferToString(buffer: Uint8Array) {\n  let state = [];\n  for (let i = 0; i < buffer.byteLength; i += 1) {\n    let index = buffer[i] % CHARSET.length;\n    state.push(CHARSET[index]);\n  }\n  return state.join('');\n}\n\nfunction textEncodeLite(str: string) {\n  const buf = new ArrayBuffer(str.length);\n  const bufView = new Uint8Array(buf);\n\n  for (let i = 0; i < str.length; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n  return bufView;\n}\n\nexport interface Crypto {\n  //\n   //Generate a random string\n   //\n  generateRandom(size: number): string;\n  //\n   //Compute the SHA256 of a given code.\n   //This is useful when using PKCE.\n   //\n  // deriveChallenge(code: string): Promise<string>;\n}\n\n//\n //The default implementation of the `Crypto` interface.\n //This uses the capabilities of the browser.\n //\nexport class DefaultCrypto implements Crypto {\n  generateRandom(size: number) {\n    const buffer = new Uint8Array(size);\n    if (HAS_CRYPTO) {\n      window.crypto.getRandomValues(buffer);\n    } else {\n      // fall back to Math.random() if nothing else is available\n      for (let i = 0; i < size; i += 1) {\n        buffer[i] = (Math.random() * CHARSET.length) | 0;\n      }\n    }\n    return bufferToString(buffer);\n  }\n\n  // deriveChallenge(code: string): Promise<string> {\n  //   if (code.length < 43 || code.length > 128) {\n  //     return Promise.reject(new AppAuthError('Invalid code length.'));\n  //   }\n  //   if (!HAS_SUBTLE_CRYPTO) {\n  //     return Promise.reject(new AppAuthError('window.crypto.subtle is unavailable.'));\n  //   }\n\n  //   return new Promise((resolve, reject) => {\n  //     crypto.subtle.digest('SHA-256', textEncodeLite(code)).then(buffer => {\n  //       return resolve(urlSafe(new Uint8Array(buffer)));\n  //     }, error => reject(error));\n  //   });\n  // }\n}\n\ninterface AuthorizationRequestJson {\n  response_type: string;\n  client_id: string;\n  redirect_uri: string;\n  scope: string;\n  state?: string;\n  extras?: StringMap;\n  internal?: StringMap;\n}\n\n//\n //Represents the AuthorizationRequest.\n //For more information look at\n //https://tools.ietf.org/html/rfc6749#section-4.1.1\n //\nclass AuthorizationRequest {\n  static RESPONSE_TYPE_TOKEN = 'token';\n  static RESPONSE_TYPE_CODE = 'code';\n\n  // NOTE:\n  // Both redirect_uri and state are actually optional.\n  // However AppAuth is more opionionated, and requires you to use both.\n\n  clientId: string;\n  redirectUri: string;\n  scope: string;\n  responseType: string;\n  state: string;\n  extras?: StringMap;\n  internal?: StringMap;\n  //\n   //Constructs a new AuthorizationRequest.\n   //Use a `undefined` value for the `state` parameter, to generate a random\n   //state for CSRF protection.\n   //\n  constructor(\n    request: AuthorizationRequestJson,\n    private crypto: Crypto = new DefaultCrypto(),\n    private usePkce: boolean = true) {\n    this.clientId = request.client_id;\n    this.redirectUri = request.redirect_uri;\n    this.scope = request.scope;\n    this.responseType = request.response_type || AuthorizationRequest.RESPONSE_TYPE_CODE;\n    this.state = request.state || newState(crypto);\n    this.extras = request.extras;\n    // read internal properties if available\n    this.internal = request.internal;\n  }\n\n  setupCodeVerifier(): Promise<void> {\n    return Promise.resolve();\n    // if (!this.usePkce) {\n    //   return Promise.resolve();\n    // } else {\n    //   const codeVerifier = this.crypto.generateRandom(128);\n    //   const challenge: Promise<string|undefined> =\n    //       this.crypto.deriveChallenge(codeVerifier).catch(error => {\n    //         // log('Unable to generate PKCE challenge. Not using PKCE', error);\n    //         return undefined;\n    //       });\n    //   return challenge.then(result => {\n    //     if (result) {\n    //       // keep track of the code used.\n    //       this.internal = this.internal || {};\n    //       this.internal['code_verifier'] = codeVerifier;\n    //       this.extras = this.extras || {};\n    //       this.extras['code_challenge'] = result;\n    //       // We always use S256. Plain is not good enough.\n    //       this.extras['code_challenge_method'] = 'S256';\n    //     }\n    //   });\n    // }\n  }\n\n  //\n   //Serializes the AuthorizationRequest to a JavaScript Object.\n   //\n  toJson(): Promise<AuthorizationRequestJson> {\n    // Always make sure that the code verifier is setup when toJson() is called.\n    return this.setupCodeVerifier().then(() => {\n      return {\n        response_type: this.responseType,\n        client_id: this.clientId,\n        redirect_uri: this.redirectUri,\n        scope: this.scope,\n        state: this.state,\n        extras: this.extras,\n        internal: this.internal\n      };\n    });\n  }\n}\n\ninterface StringMap {\n  [key: string]: string;\n}\n\n//\n //Represents a window.location like object.\n //\ninterface LocationLike {\n  hash: string;\n  host: string;\n  origin: string;\n  hostname: string;\n  pathname: string;\n  port: string;\n  protocol: string;\n  search: string;\n  assign(url: string): void;\n}\n\n//\n //Query String Utilities.\n //\ninterface QueryStringUtils {\n  stringify(input: StringMap): string;\n  parse(query: LocationLike, useHash?: boolean): StringMap;\n  parseQueryString(query: string): StringMap;\n}\n\nclass BasicQueryStringUtils implements QueryStringUtils {\n  parse(input: LocationLike, useHash?: boolean) {\n    if (useHash) {\n      return this.parseQueryString(input.hash);\n    } else {\n      return this.parseQueryString(input.search);\n    }\n  }\n\n  parseQueryString(query: string): StringMap {\n    let result: StringMap = {};\n    // if anything starts with ?, # or & remove it\n    query = query.trim().replace(/^(\\?|#|&)/, '');\n    let params = query.split('&');\n    for (let i = 0; i < params.length; i += 1) {\n      let param = params[i];  // looks something like a=b\n      let parts = param.split('=');\n      if (parts.length >= 2) {\n        let key = decodeURIComponent(parts.shift()!);\n        let value = parts.length > 0 ? parts.join('=') : null;\n        if (value) {\n          result[key] = decodeURIComponent(value);\n        }\n      }\n    }\n    return result;\n  }\n\n  stringify(input: StringMap) {\n    let encoded: string[] = [];\n    for (let key in input) {\n      if (input.hasOwnProperty(key) && input[key]) {\n        encoded.push(`${encodeURIComponent(key)}=${encodeURIComponent(input[key])}`)\n      }\n    }\n    return encoded.join('&');\n  }\n}\n\n//\n//Defines the interface which is capable of handling an authorization request\n//using various methods (iframe / popup / different process etc.).\n//\nabstract class AuthorizationRequestHandler {\n  constructor(public utils: QueryStringUtils, protected crypto: Crypto) { }\n\n  // notifier send the response back to the client.\n  protected notifier: AuthorizationNotifier | null = null;\n\n  //\n  //A utility method to be able to build the authorization request URL.\n  //\n  protected buildRequestUrl(\n    configuration: AuthorizationServiceConfiguration,\n    request: AuthorizationRequest) {\n    // build the query string\n    // coerce to any type for convenience\n    let requestMap: StringMap = {\n      'redirect_uri': request.redirectUri,\n      'client_id': request.clientId,\n      'response_type': request.responseType,\n      'state': request.state,\n      'scope': request.scope\n    };\n\n    // copy over extras\n    // if (request.extras) {\n    //   for (let extra in request.extras) {\n    //     if (request.extras.hasOwnProperty(extra)) {\n    //       // check before inserting to requestMap\n    //       if (BUILT_IN_PARAMETERS.indexOf(extra) < 0) {\n    //         requestMap[extra] = request.extras[extra];\n    //       }\n    //     }\n    //   }\n    // }\n\n    let query = this.utils.stringify(requestMap);\n    let baseUrl = configuration.authorizationEndpoint;\n    let url = `${baseUrl}?${query}`;\n    return url;\n  }\n\n  //\n  //Completes the authorization request if necessary & when possible.\n  //\n  completeAuthorizationRequestIfPossible(): Promise<void> {\n    // call complete authorization if possible to see there might\n    // be a response that needs to be delivered.\n    //log(`Checking to see if there is an authorization response to be delivered.`);\n    if (!this.notifier) {\n      //log(`Notifier is not present on AuthorizationRequest handler.No delivery of result will be possible`)\n    }\n    return this.completeAuthorizationRequest().then(result => {\n      if (!result) {\n        //log(`No result is available yet.`);\n      }\n      if (result && this.notifier) {\n        this.notifier.onAuthorizationComplete(result.request, result.response, result.error);\n      }\n    });\n  }\n\n  //\n  //Sets the default Authorization Service notifier.\n  //\n  setAuthorizationNotifier(notifier: AuthorizationNotifier): AuthorizationRequestHandler {\n    this.notifier = notifier;\n    return this;\n  };\n\n  //\n  //Makes an authorization request.\n  //\n  abstract performAuthorizationRequest(\n    configuration: AuthorizationServiceConfiguration,\n    request: AuthorizationRequest): void;\n\n  //\n  //Checks if an authorization flow can be completed, and completes it.\n  //The handler returns a `Promise<AuthorizationRequestResponse>` if ready, or a `Promise<null>`\n  //if not ready.\n  //\n  protected abstract completeAuthorizationRequest(): Promise<AuthorizationRequestResponse | null>;\n}\n\ninterface UnderlyingStorage {\n  readonly length: number;\n  clear(): void;\n  getItem(key: string): string | null;\n  removeItem(key: string): void;\n  setItem(key: string, data: string): void;\n}\n\n//\n //Asynchronous storage APIs. All methods return a `Promise`.\n //All methods take the `DOMString`\n //IDL type (as it is the lowest common denominator).\n //\nabstract class StorageBackend {\n  //\n   //When passed a key `name`, will return that key's value.\n   //\n  public abstract getItem(name: string): Promise<string | null>;\n\n  //\n   //When passed a key `name`, will remove that key from the storage.\n   //\n  public abstract removeItem(name: string): Promise<void>;\n\n  //\n   //When invoked, will empty all keys out of the storage.\n   //\n  public abstract clear(): Promise<void>;\n\n  //\n   //The setItem() method of the `StorageBackend` interface,\n   //when passed a key name and value, will add that key to the storage,\n   //or update that key's value if it already exists.\n   //\n  public abstract setItem(name: string, value: string): Promise<void>;\n}\n\n//\n //A `StorageBackend` backed by `localstorage`.\n //\nclass LocalStorageBackend extends StorageBackend {\n  private storage: UnderlyingStorage;\n  constructor(storage?: UnderlyingStorage) {\n    super();\n    this.storage = storage || window.localStorage;\n  }\n\n  public getItem(name: string): Promise<string | null> {\n    return new Promise<string | null>((resolve, reject) => {\n      const value = this.storage.getItem(name);\n      if (value) {\n        resolve(value);\n      } else {\n        resolve(null);\n      }\n    });\n  }\n\n  public removeItem(name: string): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.storage.removeItem(name);\n      resolve();\n    });\n  }\n\n  public clear(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.storage.clear();\n      resolve();\n    });\n  }\n\n  public setItem(name: string, value: string): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.storage.setItem(name, value);\n      resolve();\n    });\n  }\n}\n\n//\n //Represents the AuthorizationResponse as a JSON object.\n //\ninterface AuthorizationResponseJson {\n  code: string;\n  state: string;\n}\n\n//\n //Represents the AuthorizationError as a JSON object.\n //\ninterface AuthorizationErrorJson {\n  error: string;\n  error_description?: string;\n  error_uri?: string;\n  state?: string;\n}\n\n//\n //Represents the Authorization Response type.\n //For more information look at\n //https://tools.ietf.org/html/rfc6749#section-4.1.2\n //\nclass AuthorizationResponse {\n  code: string;\n  state: string;\n\n  constructor(response: AuthorizationResponseJson) {\n    this.code = response.code;\n    this.state = response.state;\n  }\n\n  toJson(): AuthorizationResponseJson {\n    return { code: this.code, state: this.state };\n  }\n}\n\n//\n //Represents the Authorization error response.\n //For more information look at:\n //https://tools.ietf.org/html/rfc6749#section-4.1.2.1\n //\nclass AuthorizationError {\n  error: string;\n  errorDescription?: string;\n  errorUri?: string;\n  state?: string;\n\n  constructor(error: AuthorizationErrorJson) {\n    this.error = error.error;\n    this.errorDescription = error.error_description;\n    this.errorUri = error.error_uri;\n    this.state = error.state;\n  }\n\n  toJson(): AuthorizationErrorJson {\n    return {\n      error: this.error,\n      error_description: this.errorDescription,\n      error_uri: this.errorUri,\n      state: this.state\n    };\n  }\n}\n\n// key for authorization request. //\nconst authorizationRequestKey =\n  (handle: string) => {\n    return `${handle}_appauth_authorization_request`;\n  }\n\n// key for authorization service configuration //\nconst authorizationServiceConfigurationKey =\n  (handle: string) => {\n    return `${handle}_appauth_authorization_service_configuration`;\n  }\n\n// key in local storage which represents the current authorization request. //\nconst AUTHORIZATION_REQUEST_HANDLE_KEY = 'appauth_current_authorization_request';\n\n//\n //Represents an AuthorizationRequestHandler which uses a standard\n //redirect based code flow.\n //\nclass RedirectRequestHandler extends AuthorizationRequestHandler {\n  constructor(\n    // use the provided storage backend\n    // or initialize local storage with the default storage backend which\n    // uses window.localStorage\n    public storageBackend: StorageBackend = new LocalStorageBackend(),\n    utils = new BasicQueryStringUtils(),\n    public locationLike: LocationLike = window.location,\n    crypto: Crypto = new DefaultCrypto()) {\n    super(utils, crypto);\n  }\n\n  performAuthorizationRequest(\n    configuration: AuthorizationServiceConfiguration,\n    request: AuthorizationRequest) {\n    const handle = this.crypto.generateRandom(10);\n\n    // before you make request, persist all request related data in local storage.\n    const persisted = Promise.all([\n      this.storageBackend.setItem(AUTHORIZATION_REQUEST_HANDLE_KEY, handle),\n      // Calling toJson() adds in the code & challenge when possible\n      request.toJson().then(result => {\n        this.storageBackend.setItem(authorizationRequestKey(handle), JSON.stringify(result))\n      }),\n      this.storageBackend.setItem(authorizationServiceConfigurationKey(handle), JSON.stringify(configuration.toJson())),\n    ]);\n\n    persisted.then(() => {\n      // make the redirect request\n      let url = this.buildRequestUrl(configuration, request);\n      // log('Making a request to ', request, url);\n      this.locationLike.assign(url);\n    });\n  }\n\n  //\n   //Attempts to introspect the contents of storage backend and completes the\n   //request.\n   //\n  protected completeAuthorizationRequest(): Promise<AuthorizationRequestResponse | null> {\n    // TODO(rahulrav@): handle authorization errors.\n    return this.storageBackend.getItem(AUTHORIZATION_REQUEST_HANDLE_KEY).then(handle => {\n      if (handle) {\n        // we have a pending request.\n        // fetch authorization request, and check state\n        return this.storageBackend\n          .getItem(authorizationRequestKey(handle))\n          // requires a corresponding instance of result\n          // TODO(rahulrav@): check for inconsitent state here\n          .then(result => JSON.parse(result!))\n          .then(json => new AuthorizationRequest(json))\n          .then(request => {\n            // check redirect_uri and state\n            let currentUri = `${this.locationLike.origin}${this.locationLike.pathname}`;\n            let queryParams = this.utils.parse(this.locationLike, true) ///use hash //);\n            let state: string | undefined = queryParams['state'];\n            let code: string | undefined = queryParams['code'];\n            let error: string | undefined = queryParams['error'];\n            // log('Potential authorization request ', currentUri, queryParams, state, code, error);\n            let shouldNotify = state === request.state;\n            let authorizationResponse: AuthorizationResponse | null = null;\n            let authorizationError: AuthorizationError | null = null;\n            if (shouldNotify) {\n              if (error) {\n                // get additional optional info.\n                let errorUri = queryParams['error_uri'];\n                let errorDescription = queryParams['error_description'];\n                authorizationError = new AuthorizationError({\n                  error: error,\n                  error_description: errorDescription,\n                  error_uri: errorUri,\n                  state: state\n                });\n              } else {\n                authorizationResponse = new AuthorizationResponse({ code: code, state: state });\n              }\n              // cleanup state\n              return Promise\n                .all([\n                  this.storageBackend.removeItem(AUTHORIZATION_REQUEST_HANDLE_KEY),\n                  this.storageBackend.removeItem(authorizationRequestKey(handle)),\n                  this.storageBackend.removeItem(authorizationServiceConfigurationKey(handle))\n                ])\n                .then(() => {\n                  // log('Delivering authorization response');\n                  return {\n                    request: request,\n                    response: authorizationResponse,\n                    error: authorizationError\n                  } as AuthorizationRequestResponse;\n                });\n            } else {\n              // log('Mismatched request (state and request_uri) dont match.');\n              return Promise.resolve(null);\n            }\n          });\n      } else {\n        return null;\n      }\n    });\n  }\n}\n\n//\n //This type represents a lambda that can take an AuthorizationRequest,\n //and an AuthorizationResponse as arguments.\n //\ntype AuthorizationListener =\n  (request: AuthorizationRequest,\n    response: AuthorizationResponse | null,\n    error: AuthorizationError | null) => void;\n\n//\n//Represents a structural type holding both authorization request and response.\n//\ninterface AuthorizationRequestResponse {\n  request: AuthorizationRequest;\n  response: AuthorizationResponse | null;\n  error: AuthorizationError | null;\n}\n\n//\n//Authorization Service notifier.\n//This manages the communication of the AuthorizationResponse to the 3p client.\n//\nclass AuthorizationNotifier {\n  private listener: AuthorizationListener | null = null;\n\n  setAuthorizationListener(listener: AuthorizationListener) {\n    this.listener = listener;\n  }\n\n  //\n  //The authorization complete callback.\n  //\n  onAuthorizationComplete(\n    request: AuthorizationRequest,\n    response: AuthorizationResponse | null,\n    error: AuthorizationError | null): void {\n    if (this.listener) {\n      // complete authorization request\n      this.listener(request, response, error);\n    }\n  }\n}\n\n///built in parameters. //\nconst BUILT_IN_PARAMETERS = ['redirect_uri', 'client_id', 'response_type', 'state', 'scope'];\n\nclass OAuthAuthentication {\n  private readonly _authorizationServiceConfiguration: AuthorizationServiceConfiguration;\n  private readonly _redirectRequestHandler: RedirectRequestHandler = new RedirectRequestHandler;\n  private readonly _issuerEndpoint: string;\n  constructor(protected readonly issuerEndpoint: string, protected readonly authorizationEndpoint: string, protected readonly tokenEndpoint: string, protected readonly revocationEndpoint: string) {\n    this._issuerEndpoint = issuerEndpoint;\n    this._authorizationServiceConfiguration = new AuthorizationServiceConfiguration({\n      authorization_endpoint: authorizationEndpoint,\n      token_endpoint: tokenEndpoint,\n      revocation_endpoint: revocationEndpoint\n    });\n  }\n\n  public async Authorize(clientId: string, scopes: string[]): Promise<TokenResponse> {\n    const redirectUrl = new URL(window.location.toString());\n    let authorizationRequest = new AuthorizationRequest({\n      client_id: clientId,\n      redirect_uri: redirectUrl.toString(),\n      scope: scopes.join(' '),\n      response_type: AuthorizationRequest.RESPONSE_TYPE_CODE\n    });\n    // await authorizationRequest.setupCodeVerifier(); // use pkce\n    this._redirectRequestHandler.performAuthorizationRequest(this._authorizationServiceConfiguration, authorizationRequest);\n    return await this.GetToken(clientId);\n  }\n\n  private async GetToken(clientId: string): Promise<TokenResponse> {\n    const authorizationNotifier = new AuthorizationNotifier();\n    this._redirectRequestHandler.setAuthorizationNotifier(authorizationNotifier);\n\n    await this._redirectRequestHandler.completeAuthorizationRequestIfPossible();\n    let tokenRequest: any;\n    authorizationNotifier.setAuthorizationListener((request, response, error) => {\n      // response object returns code which is in URL i.e. response.code\n      // request object returns code_verifier i.e request.internal.code_verifier\n      // you will need to add here token request process\n\n      // Exchange for an access token and return tokenResponse\n      tokenRequest = new TokenRequest();\n      tokenRequest.client_id = clientId;\n      tokenRequest.redirect_uri = this._issuerEndpoint;\n      tokenRequest.grant_type = 'authorization_code';\n      tokenRequest.code = response?.code;\n    });\n    return await this.RequestToken(this._authorizationServiceConfiguration, tokenRequest);\n  }\n\n  private async RequestToken(configuration: AuthorizationServiceConfiguration, request: TokenRequest): Promise<TokenResponse> {\n    let headers: [string, string][] = [];\n    headers.push(['Content-Type', 'application/json; charset=utf-8']);\n    headers.push(['X-Requested-With', 'XMLHttpRequest']);\n    headers.push(['Cache-Control', 'no-cache, no-store, must-revalidate']);\n\n    return new Promise<TokenResponse>(\n      (resolve, reject) => {\n        const xhr: XMLHttpRequest = new XMLHttpRequest();\n        xhr.withCredentials = true;\n        xhr.onload = () => {\n          const reponse = xhr.responseText;\n          //resolve()\n        };\n        for (let i: number = 0; i < headers.length; i++) {\n          const header: [string, string] = headers[i];\n          xhr.setRequestHeader(header[0], this.EnsureASCII(header[1]));\n        }\n        xhr.open('POST', configuration.tokenEndpoint, true);\n        xhr.send(JSON.stringify(request));\n      }\n    );\n  }\n\n  private EnsureASCII(data: string): string {\n    if (this.HasUnicode(data))\n      return (this.ConvertToASCII(data));\n    return (data);\n  }\n\n  private HasUnicode(data: string): boolean {\n    for (let i = 0; i < data.length; i++) {\n      const char: string = data[i];\n      const index: number = char.charCodeAt(0);\n      if (index > 127)\n        return (true);\n    }\n    return (false);\n  }\n\n  private ConvertToASCII(data: string): string {\n    let encoded: string = '';\n    for (let i = 0; i < data.length; i++) {\n      const char: string = data[i];\n      const index: number = char.charCodeAt(0);\n      encoded += '\\\\u' + index.toString(16).toUpperCase();\n    }\n    return (encoded);\n  }\n}"
    ],
    "docstrings": [],
    "functions": [],
    "classes": []
}