{
    "identifiers": [
        "Option",
        "Some",
        "ensureFunction",
        "elements",
        "arg",
        "fn",
        "Stackable",
        "Some",
        "arg",
        "arg",
        "arg",
        "fn",
        "ensureFunction",
        "fn",
        "QueueLike",
        "fn",
        "StackLike",
        "Some",
        "Stackable",
        "arg",
        "fn",
        "ensureFunction",
        "fn",
        "StackLike",
        "fn",
        "Some",
        "arg",
        "arg",
        "QueueLike",
        "Some",
        "args",
        "QueueLike",
        "args",
        "args",
        "StackLike",
        "args"
    ],
    "literals": [
        "\"./Option\"",
        "\"./common\"",
        "\"map argument must be a function\"",
        "\"map argument must be a function\""
    ],
    "variables": [],
    "comments": [],
    "docstrings": [
        "* Returns if is empty\n   *\n   * ```ts\n   * Queue().isEmpty() // true\n   * Queue([1,2]).isEmpty() // false\n   * Stack().isEmpty() // true\n   * Stack([1,2]).isEmpty() // false\n   * ```\n   *\n   * @returns {boolean}\n   * @memberof Stackable",
        "*\n   *\n   * @abstract\n   * @template Fn\n   * @template U\n   * @param {Fn} fn\n   * @returns {Stackable<U>}\n   * @memberof Stackable",
        "* Returns current size\n   *\n   * ```ts\n   * Queue().size() // 0\n   * Stack().size() // 0\n   * Queue([1,2]).size() // 2\n   * Stack([1,2,3]).size() // 3\n   * ```\n   *\n   * @returns {number}\n   * @memberof Stackable",
        "* Returns nearest element to be removed from the pile\n   *\n   * ```ts\n   * Queue([1,2,3]).top() // 1\n   * Stack([1,2,3]).top() // 3\n   * ```\n   *\n   * @abstract\n   * @returns {Option<T>}\n   * @memberof Stackable",
        "* Returns added elements\n   *\n   * @returns {T[]}\n   * @memberof Stackable",
        "* Dequeues the oldest enqueued element, returning an `Option<T>` representing its value. If the queue is empty, a `None` will be returned\n   *\n   * ```ts\n   * const q = Queue([1,2,3]);\n   *\n   * q.dequeue() // Option(1);\n   * q.dequeue() // Option(2);\n   * q.dequeue() // Option(3);\n   * q.dequeue() // None();\n   * ```\n   *\n   * @returns {Option<T>}\n   * @memberof QueueLike",
        "* Enqueues an element `T`, returning current `Queuelike<T>`\n   *\n   * ```ts\n   * Queue<number>()\n   *  .enqueue(1)\n   *  .enqueue(2)\n   *  .enqueue(3)\n   * ```\n   *\n   * @param {T} arg\n   * @returns {QueueLike<T>}\n   * @memberof QueueLike",
        "* Maps a `Queue<T>` to a `Queue<U>` applying a function `Fn` to every enqueued element.\n   *\n   * ```ts\n   * Queue([1,2,3]).map(arg => arg * 2) // Queue([2, 4, 6])\n   * ```\n   *\n   * @template Fn\n   * @param {Fn} fn\n   * @returns {QueueLike<ReturnType<Fn>>}\n   * @memberof QueueLike",
        "* Converts a `Queue<T>` to a `Stack<T>`\n   *\n   * ```ts\n   * Queue([1]).stack() // Stack([1])\n   * ```\n   *\n   * @returns {StackLike<T>}\n   * @memberof QueueLike",
        "* Returns oldest enqueued element `T` as an `Option<T>`. If the queue is empty, it returns `None`.\n   *\n   * ```ts\n   * Queue([1,2,3]).top() // Option(1)\n   * ```\n   *\n   * @returns {Option<T>}\n   * @memberof QueueLike",
        "* Maps a `Stack<T>` to a `Stack<U>` applying a function `Fn` to every stacked element.\n   *\n   * ```ts\n   * Stack([1,2,3]).map(arg => arg * 2) // Stack([2, 4, 6])\n   * ```\n   * @template Fn\n   * @param {Fn} fn\n   * @returns {StackLike<ReturnType<Fn>>}\n   * @memberof StackLike",
        "* Pops latest pushed element to the Stack, returning an `Option<T>` if the stack is not empty or a `None` if the stack is empty.\n   *\n   * ```ts\n   * const s = Stack([1,2,3]);\n   * s.pop() // Option(3)\n   * s.pop() // Option(2)\n   * s.pop() // Option(1)\n   * s.pop() // None()\n   * ```\n   *\n   * @returns {Option<T>}\n   * @memberof StackLike",
        "* Pushes an element to the Stack, returning `Stacklike<T>`\n   *\n   * ```ts\n   * const s = Stack();\n   *\n   * s.push(1); // Stack([1])\n   * s.push(2); // Stack([1, 2])\n   * s.push(3); // Stack([1, 2, 3])\n   * ```\n   *\n   * @param {T} arg\n   * @returns {StackLike<T>}\n   * @memberof StackLike",
        "* Converts a `StackLike<T>` to a `QueueLike<T>`\n   *\n   * ```ts\n   * Stack(['hello']).queue() // Queue(['hello'])\n   * ```\n   *\n   * @returns {QueueLike<T>}\n   * @memberof StackLike",
        "* Returns latests pushed element as an `Option<T>` if the Stack is not empty, otherwise returns `None`\n   *\n   * ```ts\n   * Stack([1,2,3]).top() // Option(3)\n   * Stack([1,2]).top() // Option(2)\n   * Stack([1]).top() // Option(1)\n   * Stack().top() // None()\n   * ```\n   *\n   * @returns {Option<T>}\n   * @memberof StackLike",
        "* Represents a Queue data type",
        "* Represents a Stack data type\n *\n * Stack is a linear data structure in which addition or removal of element follows LIFO (last in, first out).\n *\n * ```ts\n * import { Queue, Stack } from 'stack';\n *\n * const q = Queue();\n * const s = Stack();\n *\n * s.push(10);\n * s.push(20);\n * s.push(30);\n *\n * s.length // 3\n *\n * s.top() // 30\n *\n * q.enqueue('foo');\n * q.enqueue('bar');\n * q.enqueue('baz');\n *\n * q.length // 3\n *\n * q.top() // 'foo'\n * ```",
        "* Represents a Queue data type\n *\n * @export\n * @template T\n * @param {T[]} [args=[]]\n * @returns {Queue<T>}",
        "* Represents a Stack data type\n *\n * @export\n * @template T\n * @param {T[]} [args=[]]\n * @returns {Stack<T>}"
    ],
    "functions": [
        "isEmpty",
        "size",
        "value",
        "dequeue",
        "enqueue",
        "stack",
        "top",
        "pop",
        "push",
        "queue",
        "top"
    ],
    "classes": [
        "QueueLike",
        "StackLike"
    ]
}