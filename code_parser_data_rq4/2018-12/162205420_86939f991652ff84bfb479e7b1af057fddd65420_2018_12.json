{
    "identifiers": [
        "random",
        "copy",
        "tiles",
        "tiles",
        "Board",
        "__eq__",
        "goal",
        "a",
        "len",
        "tiles",
        "goal",
        "a",
        "tiles",
        "a",
        "cont",
        "cont",
        "tiles",
        "index",
        "x_index",
        "x_index",
        "x_index",
        "x_index",
        "move_to",
        "move_to",
        "x_index",
        "move_to",
        "limit",
        "moves",
        "append",
        "move_to",
        "move_to",
        "limit",
        "moves",
        "append",
        "move_to",
        "column",
        "limit",
        "moves",
        "append",
        "move_to",
        "column",
        "limit",
        "moves",
        "append",
        "move_to",
        "create_neighbors",
        "moves",
        "moves",
        "tiles",
        "index",
        "value",
        "moves",
        "copy",
        "copy",
        "tiles",
        "temp",
        "value",
        "neighbors",
        "append",
        "Board",
        "temp",
        "neighbors",
        "other",
        "tiles",
        "other",
        "tiles",
        "hash",
        "tiles",
        "tiles",
        "tiles",
        "tiles",
        "tiles",
        "tiles",
        "state",
        "cost",
        "state",
        "cost",
        "state",
        "tiles",
        "cost",
        "state",
        "tiles",
        "cost",
        "initial_state",
        "initial_state",
        "Node",
        "initial_state",
        "initial_state",
        "heuristic",
        "frontier",
        "a",
        "len",
        "frontier",
        "frontier",
        "a",
        "cost",
        "current_cost",
        "cost",
        "frontier",
        "a",
        "a",
        "frontier",
        "pop",
        "cont",
        "current_node",
        "state",
        "get_neighbors",
        "current_node",
        "cost",
        "current_node",
        "state",
        "heuristic",
        "path_cost",
        "neighbor",
        "neighbors",
        "new_node_cost",
        "neighbor",
        "heuristic",
        "is_neighbor_in_frontier",
        "neighbor",
        "frontier",
        "get_frontier_index",
        "neighbor",
        "new_node_cost",
        "node",
        "cost",
        "current_node",
        "new_node_cost",
        "neighbor",
        "explored",
        "Node",
        "neighbor",
        "new_node_cost",
        "current_node",
        "frontier",
        "append",
        "new_node",
        "new_node_cost",
        "neighbor",
        "heuristic",
        "neighbor",
        "index",
        "len",
        "frontier",
        "frontier",
        "index",
        "state",
        "neighbor",
        "index",
        "neighbor",
        "node",
        "frontier",
        "node",
        "state",
        "neighbor",
        "node",
        "node",
        "parent",
        "state",
        "initial_state",
        "node_list",
        "append",
        "initial_state",
        "node_list",
        "append",
        "node",
        "state",
        "node_list",
        "get_path",
        "node",
        "parent",
        "node_list",
        "append",
        "node",
        "state",
        "node_list",
        "len",
        "frontier",
        "choose_from_frontier",
        "explored",
        "add",
        "current_node",
        "state",
        "current_node",
        "state",
        "is_goal",
        "current_node",
        "update_frontier",
        "Board",
        "tiles",
        "AStar",
        "initial_state",
        "astar",
        "search",
        "astar",
        "get_path",
        "final_node",
        "state",
        "path",
        "state",
        "print_board",
        "len",
        "path"
    ],
    "literals": [
        "\"x\"",
        "\"x\"",
        "\"x\"",
        "\"line_above\"",
        "\"line_below\"",
        "\"left_column\"",
        "\"right_column\"",
        "\"left\"",
        "\"left_column\"",
        "\"right\"",
        "\"right_column\"",
        "\"up\"",
        "\"down\"",
        "\"sides\"",
        "\"line_above\"",
        "\"up\"",
        "\"line_above\"",
        "\"line_below\"",
        "\"down\"",
        "\"line_below\"",
        "\"left\"",
        "\"sides\"",
        "\"left_column\"",
        "\"right\"",
        "\"sides\"",
        "\"right_column\"",
        "\"x\"",
        "\"x\"",
        "\" - \"",
        "\" - \"",
        "\"__main__\"",
        "\"x\"",
        "\"caminho\"",
        "\"---\""
    ],
    "variables": [
        "tiles",
        "goal",
        "goal",
        "cont",
        "moves",
        "x_index",
        "move_to",
        "column",
        "limit",
        "neighbors",
        "x_index",
        "temp",
        "temp",
        "x_index",
        "temp",
        "value",
        "state",
        "cost",
        "parent",
        "initial_state",
        "frontier",
        "explored",
        "current_node",
        "current_cost",
        "cont",
        "current_cost",
        "cont",
        "neighbors",
        "path_cost",
        "new_node_cost",
        "node",
        "node",
        "parent",
        "node",
        "cost",
        "new_node",
        "new_node",
        "parent",
        "node_list",
        "node_list",
        "current_node",
        "tiles",
        "initial_state",
        "astar",
        "final_node",
        "path"
    ],
    "comments": [
        "",
        "",
        "Este é o exercício da 1a avaliação da disciplina de IA.",
        "",
        "O código traz um esqueleto para a implementação da busca A* para",
        "resolver o problema do quebra-cabeça de 8 números.",
        "",
        "O Objetivo do exercício é implementar o que falta da busca no código abaixo.",
        "Os métodos que precisam ser implementados estão com a marcação \"TODO\" seguida",
        "de uma descrição do que precisa ser feito.",
        "",
        "Leia atentamente todo os comentários no código.",
        "",
        "Se o programa estiver executando corretamente, ele deve exibir todas as",
        "configurações do tabuleiro do quebra cabeça dos 8 números para sair do estado",
        "final até chegar ao objetivo.",
        "",
        "",
        "TODO: este método verifica se o tabuleiro atual é uma solução",
        "do problema. O metódo deve retornar True se o tabuleiro for uma",
        "solução e False se não for.",
        "TODO: este método calcula a função heurística para o estado",
        "representado pelo tabuleiro. A heurística usada deve retornar o",
        "valor da contagem de quantos números estão na posição errada em",
        "relação ao objetivo. Por exemplo, o estado",
        "[2, 1, 3, 4, 5, 6, 7, 8, \"x\"] tem valor 2 para heurística, pois",
        "o número \"1\" está na posição errada e o número \"2\" também.",
        "Este método deve retornar o valor da função heurística.",
        "TODO: Este método deve retornar uma lista com os vizinhos do estado",
        "representado pelo tabuleiro. Os vizinhos são os possíveis novos",
        "tabuleiros resultantes da movimentação das peças do tabuleiro atual.",
        "A lista retornada é uma lista de objetos da classe Board.",
        "Novo: Este método recebe como parâmetro os possíveis movimentos de x",
        "o retorno desse método deve ser uma lista com os vizinhos de Board",
        "Os métodos a seguir dessa classe não devem ser modificados",
        "TODO: Este método remove e retorna o nó com menor custo da",
        "fronteira.",
        "TODO: Este método é executado após ser escolhido um estado da",
        "fronteira. No método search (encontrado mais abaixo), o estado",
        "selecionado é atribuido a variável self.current_node. Assim,",
        "esse método deve atualizar a fronteira com os vizinhos do estado",
        "contido em self.current_node.",
        "",
        "Ao adicionar um nó na fronteira, lembre-se do cálculo do seu custo,",
        "de gravar a referência para o nó pai e das regras existentes para",
        "adicionar ou não um novo nó.",
        "",
        "Este método não precisa retornar a fronteira, já que ela pode ser",
        "acessada em toda classe através da variável self.frontier.",
        "Novo: esse metodo recebe como parâmetro um vizinho e encontra o nó da fronteira",
        "com o estado igual ao vizinho.",
        "O retorno desse metodo deve ser o índice do nó cujo estado é igual ao vizinho",
        "recebido como parâmetro",
        "TODO: Este método retorna o caminho feito do estado inicial até o",
        "nó passado como parâmetro (node).",
        "",
        "O retorno deve ser uma lista, que começa com o estado inicial e",
        "termina com o estado do nó passado como parâmetro (node).",
        "",
        "Por exemplo, se a partir de um nó A, para chegar a um nó D, o",
        "o algoritmo passou pelos nós B e C, então o retorno deve ser a lista",
        "[A, B, C, D].",
        "",
        "Passando o nó objetivo encontrado pela busca como parâmetro dessa",
        "função, tem-se como resultado o caminho completo para sair do estado",
        "inicial e chegar no objetivo.",
        "Para testar o algoritmo, o quebra-cabeça pode ser iniciado",
        "de forma aleatória ou com um tabuleiro fixo.",
        "",
        "Abaixo temos as duas opções. Comente ou descomente as linhas",
        "correspondentes para usar a opção desejada.",
        "",
        "Para testes iniciais, aconselho usar o tabuleiro fixo, pois",
        "essa é uma configuração que temos certeza que tem solução.",
        "Iniciando o quebra-cabeça de forma aleatória",
        "tiles = [1, 2, 3, 4, 5, 6, 7, 8, \"x\"]",
        "random.shuffle(tiles)",
        "print(tiles)",
        "Iniciando o quebra-cabeça com um tabuleiro fixo",
        "tiles = [1, 2, 3, 4, 5, 6, 7, 8, \"x\"]",
        "tiles = [1,2,3,4,\"x\",6,7,5,8]",
        "tiles = [1,\"x\",3,4,2,6,7,5,8]",
        "tiles = [1,3,6,4,\"x\",2,7,5,8]",
        "tiles = [\"x\",1,6,4,3,2,7,5,8]",
        "tiles = [2,7,8,6,\"x\",4,5,3,1]",
        "tiles = [3, 1, 4, 2, 'x', 7, 5, 8, 6]",
        "tiles = [3, 2, 4, 'x', 7, 6, 5, 1, 8]"
    ],
    "docstrings": [
        "\"\"\"\n    Esta classe representa uma configuração do tabuleiro do\n    quebra-cabeça. O tabuleiro é um estado no problema de busca.\n    \n    O tabuleiro tem 9 posições (em inglês tiles), sendo 8 posições dedicadas\n    aos números de 1 até 8 e uma posição especial \"x\" que representa a posição\n    vazia.\n \n    O tabuleiro é representado de forma linear, por exemplo,\n    [1, 2, 3, 4, 5, 6, 7, 8, \"x\"], que visualmente representa o tabuleiro:\n\n                                   1  2  3\n                                   4  5  6\n                                   7  8  x\n    \"\"\"",
        "\"\"\"\n        Construtor.\n\n        tiles é uma lista com as posições do tabuleiro, por exemplo,\n        [1, 2, 3, 4, 5, 6, 7, 8, \"x\"].\n        \"\"\"",
        "\"\"\"\n    Esta classe representa um nó na busca. Cada nó contém um estado (tabuleiro),\n    um custo e o pai do nó, este último é a referência para um outro nó.\n\n    Esta classe não deve ser modificada.\n    \"\"\"",
        "\"\"\"\n        Construtor.\n\n        state é um objeto da classe Board.\n        cost é um número que representa o custo do nó.\n        \"\"\"",
        "\"\"\"\n    Esta classe é responsável por fazer a busca A*. Ela recebe um estado\n    inicial no construtor indicando a configuração inicial do tabuleiro do\n    quebra cabeça.\n    \"\"\"",
        "\"\"\"\n        Construtor.\n\n        initial_state é o estado inicial, ou seja, a configuração inicial do\n        tabuleiro.\n\n        No construtor também é iniciada a fronteira e o conjunto dos\n        explorados. Note que a fronteira é uma lista de objetos da classe Node.\n        \"\"\"",
        "\"\"\"\n        Este método avalia se algum nó da fronteira contém o estado (neighbor).\n        Você pode utilizar este método para implementar o update_frontier.\n        \"\"\"",
        "\"\"\"\n        Este método executa a busca A* para resolver o problema do\n        quebra-cabeça de 8 números.\n\n        Atenção: Para algumas configurações de tabuleiro, a solução pode ser\n        impossível, causando um loop infinito.\n        \"\"\""
    ],
    "functions": [
        "is_goal",
        "heuristic",
        "get_neighbors",
        "create_neighbors",
        "__eq__",
        "__hash__",
        "__str__",
        "__repr__",
        "print_board",
        "__str__",
        "__repr__",
        "choose_from_frontier",
        "update_frontier",
        "get_frontier_index",
        "is_neighbor_in_frontier",
        "get_path",
        "search"
    ],
    "classes": [
        "Board",
        "Node",
        "AStar"
    ]
}