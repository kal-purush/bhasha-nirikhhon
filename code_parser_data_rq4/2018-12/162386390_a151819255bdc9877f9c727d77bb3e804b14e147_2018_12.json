{
    "identifiers": [
        "sys",
        "file",
        "open",
        "file",
        "f",
        "f",
        "readline",
        "line",
        "f",
        "readlines",
        "line",
        "strip",
        "content",
        "append",
        "line",
        "k",
        "content",
        "content",
        "k",
        "content",
        "x",
        "content",
        "x",
        "pivot",
        "right",
        "append",
        "x",
        "left",
        "append",
        "x",
        "pivot",
        "right",
        "len",
        "right",
        "len_R",
        "k",
        "pivot",
        "len_R",
        "k",
        "get_K",
        "right",
        "k",
        "get_K",
        "left",
        "k",
        "len_R",
        "readfromtxt",
        "input_file",
        "i",
        "k",
        "result",
        "append",
        "get_K",
        "content",
        "i",
        "join",
        "result",
        "end"
    ],
    "literals": [
        "'evaluate.txt'",
        "'r'",
        "'__main__'",
        "','",
        "''"
    ],
    "variables": [
        "input_file",
        "content",
        "k",
        "line",
        "pivot",
        "right",
        "left",
        "right",
        "len_R",
        "k",
        "content",
        "result"
    ],
    "comments": [
        "获得输入的文件参数",
        "input_file = sys.argv[1]",
        "print(input_file)",
        "============================================",
        "最快方式读取文件内容返回内容和top k值",
        "读取方式",
        "1.一次性读取文件返回行的list 最快",
        "print(K)",
        "获得每行数值，以.作为分隔符分别存储",
        "2. 使用numpy包读入",
        "lines = np.loadtxt(file, dtype='str')",
        "k = lines[0].astype('int')",
        "content = lines[1:].astype('float')",
        "===========================================",
        "普通快排算法",
        "1. 从list中跳出一个元素，称之“基准”",
        "2. 分区: 重新排列list，所有元素比基准小的放右边，大的放右边。结束后，基准处于中间位置",
        "3. 递归把小于基准的子列和大于基准的子列排序",
        "时间复杂度O(nlogn)， 空间复杂度O(n)",
        "基于该算法，改进，只找到前k个数，就不用对所有子序列排序，找到第前k大的数",
        "1. 切分后的右边长度 > k, 说明基准太小，前k个数包含在右序列里",
        "2. 切分后的右边长度 = k，则右边这个序列就是要找的前k个数",
        "3. 切分后的右边 < k，说明基准太大，左边有要找的前k数",
        "直到找到长度刚好等于k，说明此时的基准就是要找的k，可以返回",
        "以此前序列的最后一个元素作为基准",
        "right = [pivot]",
        "把大于基准的放右边，小于基准的放左边",
        "把基准放在左边，在第二种情况下要继续递归，不能放右边，会一直以该基准作为基准，要注意。",
        "right.extend(temp)",
        "判断右序列是否刚好包含前k大元素",
        "当相同时说明right序列包含了前k数，且此时基准最小",
        "当len大说明right序列过长，必包含前k，继续递归",
        "当len小说明right序列太短，必包含大于此时k的前k中的某几个，在左边找出剩下的，减掉此时找到的数",
        "print(k)",
        "print(content)",
        "得到每个前K值"
    ],
    "docstrings": [],
    "functions": [
        "readfromtxt",
        "get_K"
    ],
    "classes": []
}