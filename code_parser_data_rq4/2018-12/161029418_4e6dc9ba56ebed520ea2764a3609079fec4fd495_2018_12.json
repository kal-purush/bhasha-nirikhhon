{
    "identifiers": [
        "index1",
        "index2",
        "arr",
        "arr",
        "index1",
        "arr",
        "index1",
        "arr",
        "index2",
        "arr",
        "index2",
        "temp",
        "arr",
        "a",
        "a",
        "i",
        "i",
        "i",
        "a",
        "i",
        "a",
        "j",
        "a",
        "j",
        "a",
        "i",
        "a",
        "arr",
        "i",
        "arr",
        "i",
        "i",
        "arr",
        "i",
        "n",
        "i",
        "n",
        "i",
        "newArr",
        "i",
        "shuffle",
        "newArr",
        "newArr",
        "arr",
        "data",
        "i",
        "arr",
        "i",
        "data",
        "i",
        "arr",
        "i",
        "data",
        "chart",
        "newData",
        "chart",
        "newData",
        "chart",
        "arr",
        "arr",
        "i",
        "n",
        "i",
        "arr",
        "i",
        "arr",
        "i",
        "arr",
        "swap",
        "i",
        "i",
        "arr",
        "swapped",
        "n",
        "swapped",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "arr",
        "arr",
        "swapped",
        "swapped",
        "i",
        "arr",
        "i",
        "arr",
        "i",
        "arr",
        "i",
        "arr",
        "swap",
        "i",
        "i",
        "arr",
        "swapped",
        "swapped",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "swapped",
        "arr",
        "i",
        "i",
        "arr",
        "i",
        "arr",
        "i",
        "arr",
        "swap",
        "i",
        "i",
        "arr",
        "swapped",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "arr",
        "arr",
        "sorted",
        "sorted",
        "i",
        "arr",
        "i",
        "arr",
        "i",
        "arr",
        "i",
        "arr",
        "swap",
        "i",
        "i",
        "arr",
        "sorted",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "i",
        "arr",
        "i",
        "arr",
        "i",
        "arr",
        "i",
        "arr",
        "swap",
        "i",
        "i",
        "arr",
        "sorted",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "arr",
        "arr",
        "pos",
        "arr",
        "pos",
        "arr",
        "gnomeSort",
        "arr",
        "pos",
        "arr",
        "arr",
        "upperBound",
        "curPos",
        "arr",
        "curPos",
        "arr",
        "curPos",
        "arr",
        "swap",
        "curPos",
        "curPos",
        "arr",
        "curPos",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "arr",
        "arr",
        "arr",
        "n",
        "j",
        "j",
        "j",
        "i",
        "i",
        "arr",
        "i",
        "arr",
        "maxIn",
        "maxIn",
        "i",
        "maxIn",
        "j",
        "arr",
        "swap",
        "maxIn",
        "j",
        "arr",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "arr",
        "arr",
        "i",
        "arr",
        "i",
        "j",
        "j",
        "arr",
        "j",
        "arr",
        "j",
        "arr",
        "swap",
        "j",
        "j",
        "arr",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "arr",
        "arr",
        "iLeft",
        "iRight",
        "iEnd",
        "result",
        "k",
        "iEnd",
        "k",
        "i",
        "iRight",
        "j",
        "iEnd",
        "arr",
        "i",
        "arr",
        "j",
        "result",
        "k",
        "arr",
        "i",
        "i",
        "result",
        "k",
        "arr",
        "j",
        "j",
        "result",
        "arr",
        "arr",
        "arr",
        "width",
        "n",
        "width",
        "i",
        "n",
        "i",
        "i",
        "width",
        "arrB",
        "merge",
        "arr",
        "i",
        "i",
        "width",
        "n",
        "i",
        "width",
        "n",
        "arrB",
        "i",
        "n",
        "i",
        "arr",
        "i",
        "arrB",
        "i",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "arr",
        "arr",
        "arr",
        "sorted",
        "gap",
        "gap",
        "k",
        "gap",
        "gap",
        "sorted",
        "i",
        "gap",
        "arr",
        "i",
        "arr",
        "i",
        "arr",
        "i",
        "gap",
        "arr",
        "swap",
        "i",
        "i",
        "gap",
        "arr",
        "sorted",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "arr",
        "a",
        "n",
        "r",
        "n",
        "r",
        "count",
        "output",
        "i",
        "a",
        "i",
        "a",
        "i",
        "r",
        "n",
        "r",
        "count",
        "digitAI",
        "i",
        "radix",
        "i",
        "count",
        "i",
        "count",
        "i",
        "a",
        "i",
        "i",
        "a",
        "i",
        "r",
        "n",
        "r",
        "count",
        "digitAI",
        "output",
        "count",
        "digitAI",
        "a",
        "i",
        "newData",
        "buildScatterPlotData",
        "output",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "output",
        "arr",
        "m",
        "i",
        "digits",
        "i",
        "arr",
        "countSort",
        "arr",
        "i",
        "radix",
        "arr",
        "arr",
        "a",
        "i",
        "a",
        "i",
        "j",
        "j",
        "a",
        "j",
        "a",
        "j",
        "a",
        "swap",
        "j",
        "j",
        "a",
        "a",
        "i",
        "arr",
        "i",
        "buckets",
        "el",
        "arr",
        "buckets",
        "el",
        "el",
        "bucket",
        "buckets",
        "bucket",
        "insertionSort",
        "bucket",
        "retArr",
        "buckets",
        "newData",
        "buildScatterPlotData",
        "retArr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "retArr",
        "a",
        "l",
        "h",
        "a",
        "l",
        "l",
        "h",
        "i",
        "a",
        "i",
        "pivot",
        "j",
        "a",
        "j",
        "pivot",
        "i",
        "j",
        "j",
        "a",
        "a",
        "swap",
        "i",
        "j",
        "a",
        "arr",
        "low",
        "high",
        "low",
        "high",
        "partition",
        "arr",
        "low",
        "high",
        "objs",
        "arr",
        "objs",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "arr",
        "quickSort",
        "arr",
        "low",
        "p",
        "arr",
        "quickSort",
        "arr",
        "p",
        "high",
        "arr",
        "arr",
        "isSorted",
        "arr",
        "arr",
        "shuffle",
        "arr",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "arr",
        "arr",
        "i",
        "j",
        "arr",
        "i",
        "arr",
        "j",
        "arr",
        "swap",
        "i",
        "j",
        "arr",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "j",
        "i",
        "j",
        "i",
        "arr",
        "stoogeSort",
        "arr",
        "i",
        "j",
        "t",
        "arr",
        "stoogeSort",
        "arr",
        "i",
        "t",
        "j",
        "arr",
        "stoogeSort",
        "arr",
        "i",
        "j",
        "t",
        "arr",
        "arr",
        "i",
        "j",
        "i",
        "j",
        "arr",
        "i",
        "j",
        "arr",
        "slowSort",
        "arr",
        "i",
        "m",
        "arr",
        "slowSort",
        "arr",
        "m",
        "j",
        "arr",
        "j",
        "arr",
        "m",
        "arr",
        "swap",
        "j",
        "m",
        "arr",
        "newData",
        "buildScatterPlotData",
        "arr",
        "setTimeout",
        "updateScatterPlot",
        "myChart",
        "newData",
        "arr",
        "slowSort",
        "arr",
        "i",
        "j",
        "arr",
        "Chart",
        "ctx",
        "initList",
        "generateRandomList",
        "initData",
        "buildScatterPlotData",
        "initList",
        "updateScatterPlot",
        "myChart",
        "initData",
        "currentSortType",
        "bubbleSort",
        "initList",
        "selectionSort",
        "initList",
        "bogoSort",
        "initList",
        "insertionSort",
        "initList",
        "mergeSort",
        "initList",
        "cocktailSort",
        "initList",
        "oddEvenSort",
        "initList",
        "optGnomeSort",
        "initList",
        "combSort",
        "initList",
        "radixSort",
        "initList",
        "bucketSort",
        "initList",
        "quickSort",
        "initList",
        "initList",
        "stoogeSort",
        "initList",
        "initList",
        "slowSort",
        "initList",
        "initList",
        "alert",
        "currentSortType",
        "initList",
        "generateRandomList",
        "initData",
        "buildScatterPlotData",
        "initList",
        "updateScatterPlot",
        "myChart",
        "initData",
        "currentSortType",
        "initList",
        "generateRandomList",
        "initData",
        "buildScatterPlotData",
        "initList",
        "updateScatterPlot",
        "myChart",
        "initData",
        "currentSortType",
        "initList",
        "generateRandomList",
        "initData",
        "buildScatterPlotData",
        "initList",
        "updateScatterPlot",
        "myChart",
        "initData",
        "initList",
        "generateRandomList",
        "initData",
        "buildScatterPlotData",
        "initList",
        "updateScatterPlot",
        "myChart",
        "initData",
        "ev",
        "currentSortType",
        "codeExplanations",
        "currentSortType",
        "initList",
        "generateRandomList",
        "initData",
        "buildScatterPlotData",
        "initList",
        "updateScatterPlot",
        "myChart",
        "initData",
        "currentSortType",
        "initList",
        "generateRandomList",
        "initData",
        "buildScatterPlotData",
        "initList",
        "updateScatterPlot",
        "myChart",
        "initData",
        "currentSortType",
        "initList",
        "generateRandomList",
        "initData",
        "buildScatterPlotData",
        "initList",
        "updateScatterPlot",
        "myChart",
        "initData"
    ],
    "literals": [
        "'myChart'",
        "\"scatter\"",
        "\"Dataset\"",
        "\"#f00\"",
        "\"Value\"",
        "\"Index\"",
        "'linear'",
        "\"bubble\"",
        "<p>Worst-case Complexity: O(n<sup>2</sup>)<br><br>\nExplanation: Not real good tbh<br><br>\nCode: \n<pre><code>function bubbleSort(arr) {\n    let n = arr.length;\n    while (true) {\n        let swapped = false;\n        for (let i = 0; i < n; i++) {\n            if (arr[i] > arr[i + 1]) {\n                arr = swap(i, i + 1, arr);\n                swapped = true;\n            }\n        }\n        n--;\n        if (!swapped) {\n            break;\n        }\n    }\n    return arr;\n}</code></pre></p>",
        "<p>Worst-case Complexity: O(n<sup>2</sup>)<br><br>\nExplanation: Just a more complicated bubble sort for no reason whatsoever<br><br>\nCode: \n<pre><code>function cocktailSort(arr) {\n    let swapped = true;\n    while (swapped) {\n        swapped = false;\n        for (let i = 0; i < arr.length - 2; i++) {\n            if (arr[i] > arr[i + 1]) {\n                arr = swap(i, i + 1, arr);\n                swapped = true;\n            }\n        }\n        if (!swapped) {\n            break;\n        }\n        swapped = false;\n        for (let i = arr.length - 2; i > 0; i--) {\n            if (arr[i] > arr[i + 1]) {\n                arr = swap(i, i + 1, arr);\n                swapped = true;\n            }\n        }\n    }\n    return arr;\n}</code></pre></p>",
        "<p>Worst-case Complexity: O(n<sup>2</sup>)<br><br>\nExplanation: This algorithm actually isn't that bad, it basically sorts the odd and even indices of the array seperately which is pretty good, assuming that you're utilising parallel processing. (Note: because this is a single-processor algorithm it's incredibly slow and works on a smaller array)<br><br>\nCode: \n<pre><code>function oddEvenSort(arr) {\n    let sorted = false;\n    while (!sorted) {\n        sorted = true;\n        for (let i = 1; i < arr.length - 1; i += 2) {\n            if (arr[i] > arr[i + 1]) {\n                arr = swap(i, i + 1, arr);\n                sorted = false;\n            }\n        }\n        for (let i = 0; i < arr.length - 1; i += 2) {\n            if (arr[i] > arr[i + 1]) {\n                arr = swap(i, i + 1, arr);\n                sorted = false;\n            }\n        }\n    }\n    return arr;\n}</code></pre></p>",
        "<p>Worst-case Complexity: O(n<sup>2</sup>)<br><br>\nExplanation: The Gnome sort (originally known as the Stupid sort) is a variation of the Bubble sort that is largely used because of its name, the version implemented here is optimised by recalling the upper bound of the algorithm, making it technically a variant of an Insertion sort<br><br>\nCode: \n<pre><code>function optGnomeSort(arr) {\n    for (let pos = 1; pos < arr.length; pos++) {\n        arr = gnomeSort(arr, pos);\n    }\n    return arr;\n}\nfunction gnomeSort(arr, upperBound) {\n    let curPos = upperBound;\n    while (curPos > 0 && arr[curPos - 1] > arr[curPos]) {\n        arr = swap(curPos, curPos - 1, arr);\n        curPos--;\n    }\n    return arr;\n}</code></pre></p>",
        "<p>Worst-case Complexity: O(n<sup>2</sup>)<br><br>\nExplanation: Still quite bad in all honesty<br><br>\nCode: \n<pre><code>function selectionSort(arr) {\n    let n = arr.length;\n    for (let j = n - 1; j > 0; j--) {\n        let maxIn = j;\n        for (let i = j - 1; i > -1; i--) {\n            if (arr[i] > arr[maxIn]) {\n                maxIn = i;\n            }\n        }\n        if (maxIn != j) {\n            arr = swap(maxIn, j, arr);\n        }\n    }\n    return arr;\n}</code></pre></p>",
        "<p>Worst-case Complexity: O(n<sup>2</sup>)<br><br>\nExplanation: Not great, but I like its style<br><br>\nCode: \n<pre><code>function insertionSort(arr) {\n    for (let i = 1; i < arr.length; i++) {\n        for (let j = i; j > 0; j--) {\n            if (arr[j - 1] > arr[j]) {\n                arr = swap(j, j - 1, arr);\n            } else {\n                break;\n            }\n        }\n    }\n    return arr;\n}</code></pre></p>",
        "<p>Worst-case Complexity: O(n<sup>2</sup>)<br><br>\nExplanation: Comb sort is actually quite an interesting algorithm tbh, (Note: The display of this algorithm has been significantly slowed down so that you are able to clearly see what is happening)<br><br>\nCode: \n<pre><code>function combSort(arr) {\n    let gap = arr.length;\n    let k = 1.3;\n    let sorted = false;\n    while (!sorted) {\n        gap = Math.floor(gap / k);\n        if (gap <= 1) {\n            gap = 1;\n            sorted = true;\n        }\n        for (let i = 0; i + gap < arr.length; i++) {\n            if (arr[i] > arr[i + gap]) {\n                arr = swap(i, i + gap, arr);\n                sorted = false;\n            }\n        }\n    }\n}</code></pre></p>",
        "<p>Worst-case Complexity: O(nlogn)<br><br>\nExplanation: Very cool sorting algorithm, I only vaguely understand how it works. The version implemented here is the Bottom-Up Merge Sort. (Note: The display of this algorithm has been significantly slowed down so that you are able to clearly see what is happening)<br><br>\nCode: \n<pre><code>function merge(arr, iLeft, iRight, iEnd, result) {\n    let i = iLeft\n    let j = iRight\n    for (let k = iLeft; k < iEnd; k++) {\n        if (i < iRight && (j >= iEnd || arr[i] <= arr[j])) {\n            result[k] = arr[i];\n            i++;\n        } else {\n            result[k] = arr[j];\n            j++;\n        }\n    }\n    return result;\n}\nfunction mergeSort(arr){\n    let n = arr.length;\n    let arrB = new Array(arr.length);\n    for (let width = 1; width < n; width *= 2) {\n        for (let i = 0; i < n; i = i + 2 * width) {\n            arrB = merge(arr, i, Math.min(i + width, n),\n                                 Math.min(i + 2 * width, n), \n                         arrB);\n        }\n        for (let i = 0; i < n; i++) {\n            arr[i] = arrB[i];    \n        }   \n    }\n    return arr;\n}</code></pre></p>",
        "<p>Worst-case Complexity: O(wn)<br><br>\nExplanation: Look, I'm not even going to pretend to understand this one, but I don't have to understand it to implement it (Note: The display of this algorithm has been significantly slowed down so that you are able to clearly see what is happening)<br><br>\nCode: \n<pre><code>function radixSort(arr) {\n    function countSort(a, n, r) {\n        let output = new Array(n);\n        let count = new Array(r);\n        count.fill(0); output.fill(0);\n        for (let i = 0; i < a.length; i++) {\n            let digitAI = Math.trunc((a[i] / r ** n) % r);\n            count[digitAI]++;\n        }\n        for (let i = 1; i < radix; i++) {\n            count[i] += count[i - 1];\n        }\n        for (let i = a.length - 1; i >= 0; i--) {\n            let digitAI = Math.trunc((a[i] / r ** n) % r);\n            count[digitAI]--;\n            output[count[digitAI]] = a[i];\n        }\n        return output;\n    }\n    let radix = 10;\n    let m = Math.max.apply(null, arr);\n    let digits = Math.floor(Math.log10(m) + 1);\n    for (let i = 0; i < digits; i++) {\n        arr = countSort(arr, i, radix);\n    }\n    return arr;\n}\n</code></pre></p>",
        "<p>Worst-case Complexity: O(n<sup>2</sup>)<br><br>\nExplanation: Basically works by breaking up the elements to be sorted into buckets that are then themselves sorted and added to a result array<br><br>\nCode: \n<pre><code>function bucketSort(arr) {\n    // define innersort\n    function insertionSort(a) {\n        for (let i = 1; i < a.length; i++) {\n            for (let j = i; j > 0; j--) {\n                if (a[j - 1] > a[j]) {\n                    a = swap(j, j - 1, a);\n                } else {\n                    break;\n                }\n            }\n        }\n        return a;\n    }\n    // create the buckets & end result\n    let buckets = new Array();\n    let retArr = new Array();\n    for (let i = 0; i <= Math.floor(Math.max.apply(null, arr) / 10); i++) {\n        buckets.push(new Array());\n    }\n    // place numbers in the relevant buckets\n    for (let el of arr) {\n        buckets[Math.floor(el / 10)].push(el);\n    }\n    // sort the elements within the buckets\n    for (let bucket of buckets) {\n        bucket = insertionSort(bucket);\n        retArr = buckets.flat();\n    }\n    return retArr;\n}</code></pre></p>",
        "<p>Worst-case Complexity: O(n<sup>2</sup>)<br><br>\nExplanation: One of the most well-known and used of the sorting algorithms, this implementation utilises Hoare's orginal algorithm and uses the left-most index as its pivot point.<br><br>\nCode: \n<pre><code>function partition(a, l, h) {\n    let pivot = a[l];\n    let i = l - 1;\n    let j = h + 1;\n    while (true) {\n        do {\n            i++;\n        } while (a[i] < pivot)\n        do {\n            j--;\n        } while (a[j] > pivot)\n        if (i >= j) {\n            return [j, a];\n        }\n        a = swap(i, j, a);\n    }\n}\nfunction quickSort(arr, low, high) {\n    if (low < high) {\n        let objs = partition(arr, low, high);\n        let p = objs[0];\n        arr = objs[1];\n        arr = quickSort(arr, low, p);\n        arr = quickSort(arr, p + 1, high);\n    }\n    return arr;\n}</code></pre></p>",
        "<p>Worst-case Complexity: O(âˆž)<br><br>\nExplanation: Literally the greatest sort of all time<br><br>\nCode: \n<pre><code>function bogoSort(arr) {\n    while (!isSorted(arr)) {\n        arr = shuffle(arr);\n    }\n    return arr;\n}</code></pre></p>",
        "<p>Worst-case Complexity: O(n<sup>log<sub>e</sub>3/log<sub>e</sub>1.5</sup>)<br><br>\nExplanation: Just a real bad sort (Note: the stooge sort implementation here is automatically set to use a much smaller list than the other sorts, this is because it is a truly terrible sort.)<br><br>\nCode: \n<pre><code>function stoogeSort(arr, i, j) {\n    if (arr[i] > arr[j]) {\n        arr = swap(i, j, arr);\n    }\n    if ((j - i + 1) > 2) {\n        let t = Math.trunc((j - i + 1) / 3);\n        arr = stoogeSort(arr, i, j - t);\n        arr = stoogeSort(arr, i + t, j);\n        arr = stoogeSort(arr, i, j - t);\n    }\n    return arr;\n}</code></pre></p>",
        "<p>Worst-case Complexity: O(>n<sup>2</sup>)<br><br>\nExplanation: Just a really, really bad sort (Note: the slow sort implementation here is automatically set to use a much smaller list than the other sorts, this is because it is a truly terrible sort.)<br><br>\nCode: \n<pre><code>function slowSort(arr, i, j) {\n    if (i >= j) {\n        return arr;\n    }\n    let m = Math.floor((i + j) / 2);\n    arr = slowSort(arr, i, m);\n    arr = slowSort(arr, m + 1, j);\n    if (arr[j] < arr[m]) {\n        arr = swap(j, m, arr);\n    }\n    arr = slowSort(arr, i, j - 1);\n    return arr;\n}</code></pre></p>",
        "'typeSet'",
        "'bubble'",
        "'beginSort'",
        "'bubble'",
        "'selection'",
        "'bogo'",
        "'insertion'",
        "'merge'",
        "'cocktail'",
        "'oddEven'",
        "'gnome'",
        "'comb'",
        "'radix'",
        "'bucket'",
        "'quick'",
        "'stooge'",
        "'slow'",
        "\"That algorithm does not exist\"",
        "'randomiseList'",
        "'stooge'",
        "\"slow\"",
        "\"oddEven\"",
        "'typeSet'",
        "'typeSet'",
        "'description'",
        "'typeSet'",
        "'stooge'",
        "\"slow\"",
        "\"oddEven\""
    ],
    "variables": [
        "temp",
        "i",
        "j",
        "i",
        "newArr",
        "i",
        "i",
        "n",
        "swapped",
        "i",
        "swapped",
        "i",
        "i",
        "sorted",
        "i",
        "i",
        "pos",
        "curPos",
        "upperBound",
        "n",
        "j",
        "maxIn",
        "j",
        "i",
        "i",
        "j",
        "i",
        "i",
        "iLeft",
        "j",
        "iRight",
        "k",
        "iLeft",
        "n",
        "arrB",
        "width",
        "i",
        "i",
        "gap",
        "k",
        "sorted",
        "i",
        "output",
        "count",
        "i",
        "digitAI",
        "i",
        "i",
        "digitAI",
        "radix",
        "m",
        "digits",
        "i",
        "i",
        "j",
        "i",
        "buckets",
        "retArr",
        "i",
        "pivot",
        "i",
        "j",
        "objs",
        "p",
        "t",
        "m",
        "ctx",
        "myChart",
        "currentSortType",
        "codeExplanations"
    ],
    "comments": [
        "convert an array to an array of objects that Chart.js can understand",
        "chart.reset();",
        "recursive merge sort, really difficult to figure out how to display\nfunction merge(left, right) {\n    let result = new Array();\n\n    while (left.length != 0 && right.length != 0) {\n        if (left[0] <= right[0]) {\n            result.push(left[0]);\n            left.splice(0, 1);\n        } else {\n            result.push(right[0]);\n            right.splice(0, 1);\n        }\n    }\n\n    while (left.length != 0) {\n        result.push(left[0]);\n        left.splice(0, 1);\n    }\n    while (right.length != 0) {\n        result.push(right[0]);\n        right.splice(0, 1);\n    }\n\n    return result;\n}\n\nfunction mergeSort(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n\n    let left = new Array();\n    let right = new Array();\n    for (let i = 0; i < arr.length; i++) {\n        if (i < (arr.length / 2)) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n\n    left = mergeSort(left);    \n    right = mergeSort(right);\n\n    return merge(left, right);\n}",
        "define innersort",
        "create the buckets & end result",
        "place numbers in the relevant buckets",
        "sort the elements within the buckets",
        "console.log(t);",
        "get the canvas context that we will draw the chart in",
        "create the chart itself"
    ],
    "docstrings": [],
    "functions": [
        "swap",
        "shuffle",
        "isSorted",
        "generateRandomList",
        "buildScatterPlotData",
        "updateScatterPlot",
        "bubbleSort",
        "cocktailSort",
        "oddEvenSort",
        "optGnomeSort",
        "gnomeSort",
        "selectionSort",
        "insertionSort",
        "merge",
        "mergeSort",
        "combSort",
        "radixSort",
        "countSort",
        "bucketSort",
        "insertionSort",
        "partition",
        "quickSort",
        "bogoSort",
        "stoogeSort",
        "slowSort"
    ],
    "classes": []
}