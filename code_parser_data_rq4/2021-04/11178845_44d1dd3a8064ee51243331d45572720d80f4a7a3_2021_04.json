{
    "identifiers": [
        "numpy",
        "np",
        "numba",
        "njit",
        "jit",
        "numpy",
        "cross",
        "numpy",
        "linalg",
        "norm",
        "poliastro",
        "core",
        "elements",
        "coe_rotation_matrix",
        "rv2coe",
        "rv_pqw",
        "jit",
        "k",
        "rv",
        "r_f",
        "rv2coe",
        "k",
        "rv",
        "norm",
        "cross",
        "rv",
        "h_i",
        "k",
        "rv_pqw",
        "k",
        "p_i",
        "ecc",
        "nu",
        "norm",
        "r_i",
        "norm",
        "v_i",
        "r_i",
        "r_f",
        "np",
        "sqrt",
        "k",
        "r_i",
        "k",
        "a_trans",
        "v_i",
        "np",
        "sqrt",
        "k",
        "r_f",
        "np",
        "sqrt",
        "k",
        "r_f",
        "k",
        "a_trans",
        "np",
        "array",
        "dv_a",
        "np",
        "array",
        "dv_b",
        "coe_rotation_matrix",
        "inc",
        "raan",
        "argp",
        "rot_matrix",
        "dv_a",
        "rot_matrix",
        "dv_b",
        "np",
        "pi",
        "np",
        "sqrt",
        "a_trans",
        "k",
        "dv_a",
        "dv_b",
        "t_trans",
        "jit",
        "k",
        "r_b",
        "r_f",
        "rv",
        "rv2coe",
        "k",
        "rv",
        "norm",
        "cross",
        "rv",
        "h_i",
        "k",
        "rv_pqw",
        "k",
        "p_i",
        "ecc",
        "nu",
        "norm",
        "r_i",
        "norm",
        "v_i",
        "r_i",
        "r_b",
        "r_b",
        "r_f",
        "np",
        "sqrt",
        "k",
        "r_i",
        "k",
        "a_trans1",
        "v_i",
        "np",
        "sqrt",
        "k",
        "r_b",
        "k",
        "a_trans2",
        "np",
        "sqrt",
        "k",
        "r_b",
        "k",
        "a_trans1",
        "np",
        "sqrt",
        "k",
        "r_f",
        "np",
        "sqrt",
        "k",
        "r_f",
        "k",
        "a_trans2",
        "np",
        "array",
        "dv_a",
        "np",
        "array",
        "dv_b",
        "np",
        "array",
        "dv_c",
        "coe_rotation_matrix",
        "inc",
        "raan",
        "argp",
        "rot_matrix",
        "dv_a",
        "rot_matrix",
        "dv_b",
        "rot_matrix",
        "dv_c",
        "np",
        "pi",
        "np",
        "sqrt",
        "a_trans1",
        "k",
        "np",
        "pi",
        "np",
        "sqrt",
        "a_trans2",
        "k",
        "dv_a",
        "dv_b",
        "dv_c",
        "t_trans1",
        "t_trans2",
        "jit",
        "k",
        "R",
        "J2",
        "max_delta_r",
        "v",
        "a",
        "inc",
        "ecc",
        "a",
        "ecc",
        "k",
        "a",
        "n",
        "R",
        "J2",
        "p",
        "np",
        "sin",
        "inc",
        "ecc",
        "max_delta_r",
        "delta_w",
        "a",
        "ecc",
        "ecc",
        "delta_w",
        "abs",
        "delta_w",
        "dw",
        "n",
        "a",
        "ecc",
        "abs",
        "delta_w",
        "v",
        "norm",
        "v",
        "delta_v",
        "delta_t",
        "vf_"
    ],
    "literals": [
        "r\"\"\"Calculate the Hohmann maneuver velocities and the duration of the maneuver.\n\n    By defining the relationship between orbit radius:\n\n    .. math::\n        a_{trans} = \\frac{r_{i} + r_{f}}{2}\n\n    The Hohmann maneuver velocities can be expressed as:\n\n    .. math::\n        \\begin{align}\n            \\Delta v_{a} &= \\sqrt{\\frac{2\\mu}{r_{i}} - \\frac{\\mu}{a_{trans}}} - v_{i}\\\\\n            \\Delta v_{b} &= \\sqrt{\\frac{\\mu}{r_{f}}} - \\sqrt{\\frac{2\\mu}{r_{f}} - \\frac{\\mu}{a_{trans}}}\n        \\end{align}\n\n    The time that takes to complete the maneuver can be computed as:\n\n    .. math::\n        \\tau_{trans} = \\pi \\sqrt{\\frac{(a_{trans})^{3}}{\\mu}}\n\n    Parameters\n    ----------\n    k : float\n        Standard Gravitational parameter\n    rv: ~np.array, ~np.array\n        Position and velocity vectors\n    r_f: float\n        Final altitude of the orbit\n\n    \"\"\"",
        "r\"\"\"Calculate the increments in the velocities and the time of flight of the maneuver\n\n    The bielliptic maneuver employs two Hohmann transfers, therefore two\n    intermediate orbits are established. We define the different radius\n    relationships as follows:\n\n    .. math::\n        \\begin{align}\n            a_{trans1} &= \\frac{r_{i} + r_{b}}{2}\\\\\n            a_{trans2} &= \\frac{r_{b} + r_{f}}{2}\\\\\n        \\end{align}\n\n    The increments in the velocity are:\n\n    .. math::\n        \\begin{align}\n            \\Delta v_{a} &= \\sqrt{\\frac{2\\mu}{r_{i}} - \\frac{\\mu}{a_{trans1}}} - v_{i}\\\\\n            \\Delta v_{b} &= \\sqrt{\\frac{2\\mu}{r_{b}} - \\frac{\\mu}{a_{trans2}}} - \\sqrt{\\frac{2\\mu}{r_{b}} - \\frac{\\mu}{a_trans{1}}}\\\\\n            \\Delta v_{c} &= \\sqrt{\\frac{\\mu}{r_{f}}} - \\sqrt{\\frac{2\\mu}{r_{f}} - \\frac{\\mu}{a_{trans2}}}\\\\\n        \\end{align}\n\n    The time of flight for this maneuver is the addition of the time needed for both transition orbits, following the same formula as\n    Hohmann:\n\n    .. math::\n        \\begin{align}\n            \\tau_{trans1} &= \\pi \\sqrt{\\frac{a_{trans1}^{3}}{\\mu}}\\\\\n            \\tau_{trans2} &= \\pi \\sqrt{\\frac{a_{trans2}^{3}}{\\mu}}\\\\\n        \\end{align}\n\n    Parameters\n    ----------\n    k: float\n        Standard Gravitational parameter\n    r_b: float\n        Altitude of the intermediate orbit\n    r_f: float\n        Final altitude of the orbit\n    rv: ~np.array, ~np.array\n        Position and velocity vectors\n\n    \"\"\""
    ],
    "variables": [
        "_",
        "ecc",
        "inc",
        "raan",
        "argp",
        "nu",
        "h_i",
        "p_i",
        "r_i",
        "v_i",
        "r_i",
        "v_i",
        "a_trans",
        "dv_a",
        "dv_b",
        "dv_a",
        "dv_b",
        "rot_matrix",
        "dv_a",
        "dv_b",
        "t_trans",
        "_",
        "ecc",
        "inc",
        "raan",
        "argp",
        "nu",
        "h_i",
        "p_i",
        "r_i",
        "v_i",
        "r_i",
        "v_i",
        "a_trans1",
        "a_trans2",
        "dv_a",
        "dv_b",
        "dv_c",
        "dv_a",
        "dv_b",
        "dv_c",
        "rot_matrix",
        "dv_a",
        "dv_b",
        "dv_c",
        "t_trans1",
        "t_trans2",
        "p",
        "n",
        "dw",
        "delta_w",
        "delta_t",
        "delta_v",
        "vf_"
    ],
    "comments": [],
    "docstrings": [
        "\"\"\" Low level manuever implementations \"\"\"",
        "\"\"\"Calculates the time before burning and the velocity vector in direction of the burn.\n\n    Parameters\n    ----------\n    k: float\n        Standard Gravitational parameter\n    R: float\n        Radius of the attractor\n    J2: float\n        Oblateness factor\n    max_delta_r: float\n        Maximum satellite’s geocentric distance\n    v: ~np.array\n        Velocity vector\n    a: float\n        Semi-major axis\n    inc: float\n        Inclination\n    ecc: float\n        Eccentricity\n\n    Notes\n    -----\n    The algorithm was obtained from \"Fundamentals of Astrodynamics and Applications, 4th ed (2013)\" by David A.\n    Vallado, page 885.\n    Given a max_delta_r, we determine the maximum perigee drift before we do an orbit-adjustment burn\n    to restore the perigee to its nominal value. We estimate the time until this burn using the allowable drift\n    delta_w and the drift rate :math:`|dw|`.\n    For positive delta_v, the change in the eccentricity is positive for perigee burns and negative for apogee burns.\n    The opposite holds for a delta_v applied against the velocity vector, which decreases the satellite’s velocity.\n    Perigee drift are mainly due to the zonal harmonics, which cause variations in the altitude by changing the\n    argument of perigee.\n    Please note that ecc ≈ 0.001, so the error incurred by assuming a small eccentricity is on the order of 0.1%.\n    This is smaller than typical variations in thruster performance between burns.\n\n    \"\"\""
    ],
    "functions": [
        "hohmann",
        "bielliptic",
        "correct_pericenter"
    ],
    "classes": []
}