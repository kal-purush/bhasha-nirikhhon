{
    "identifiers": [
        "logging",
        "math",
        "numpy",
        "np",
        "qiskit",
        "quantum_info",
        "Pauli",
        "qiskit",
        "aqua",
        "operators",
        "WeightedPauliOperator",
        "logging",
        "getLogger",
        "values",
        "weights",
        "max_weight",
        "len",
        "values",
        "len",
        "weights",
        "ValueError",
        "v",
        "v",
        "values",
        "w",
        "w",
        "weights",
        "ValueError",
        "all",
        "v",
        "v",
        "values",
        "ValueError",
        "max_weight",
        "ValueError",
        "math",
        "log",
        "max_weight",
        "max_weight",
        "len",
        "values",
        "n",
        "y_size",
        "np",
        "sum",
        "values",
        "i",
        "n",
        "j",
        "n",
        "weights",
        "i",
        "weights",
        "j",
        "M",
        "_get_pauli_op",
        "num_values",
        "j",
        "pauli_list",
        "append",
        "coefficient",
        "pauli_op",
        "shift",
        "coefficient",
        "_get_pauli_op",
        "num_values",
        "i",
        "pauli_list",
        "append",
        "coefficient",
        "pauli_op",
        "shift",
        "coefficient",
        "coefficient",
        "_get_pauli_op",
        "num_values",
        "i",
        "j",
        "pauli_list",
        "append",
        "coefficient",
        "pauli_op",
        "shift",
        "coefficient",
        "i",
        "y_size",
        "j",
        "y_size",
        "i",
        "j",
        "M",
        "_get_pauli_op",
        "num_values",
        "n",
        "j",
        "pauli_list",
        "append",
        "coefficient",
        "pauli_op",
        "shift",
        "coefficient",
        "_get_pauli_op",
        "num_values",
        "n",
        "i",
        "pauli_list",
        "append",
        "coefficient",
        "pauli_op",
        "shift",
        "coefficient",
        "coefficient",
        "_get_pauli_op",
        "num_values",
        "n",
        "i",
        "n",
        "j",
        "pauli_list",
        "append",
        "coefficient",
        "pauli_op",
        "shift",
        "coefficient",
        "i",
        "n",
        "max_weight",
        "weights",
        "i",
        "M",
        "_get_pauli_op",
        "num_values",
        "i",
        "pauli_list",
        "append",
        "coefficient",
        "pauli_op",
        "shift",
        "coefficient",
        "j",
        "y_size",
        "max_weight",
        "j",
        "M",
        "_get_pauli_op",
        "num_values",
        "n",
        "j",
        "pauli_list",
        "append",
        "coefficient",
        "pauli_op",
        "shift",
        "coefficient",
        "i",
        "n",
        "j",
        "y_size",
        "weights",
        "i",
        "j",
        "M",
        "_get_pauli_op",
        "num_values",
        "n",
        "j",
        "pauli_list",
        "append",
        "coefficient",
        "pauli_op",
        "shift",
        "coefficient",
        "_get_pauli_op",
        "num_values",
        "i",
        "pauli_list",
        "append",
        "coefficient",
        "pauli_op",
        "shift",
        "coefficient",
        "coefficient",
        "_get_pauli_op",
        "num_values",
        "i",
        "n",
        "j",
        "pauli_list",
        "append",
        "coefficient",
        "pauli_op",
        "shift",
        "coefficient",
        "i",
        "n",
        "values",
        "i",
        "_get_pauli_op",
        "num_values",
        "i",
        "pauli_list",
        "append",
        "coefficient",
        "pauli_op",
        "shift",
        "coefficient",
        "WeightedPauliOperator",
        "paulis",
        "pauli_list",
        "shift",
        "x",
        "values",
        "x",
        "len",
        "values",
        "solution",
        "values",
        "weights",
        "np",
        "sum",
        "solution",
        "values",
        "np",
        "sum",
        "solution",
        "weights",
        "value",
        "weight",
        "num_values",
        "indexes",
        "np",
        "zeros",
        "num_values",
        "dtype",
        "np",
        "np",
        "zeros",
        "num_values",
        "dtype",
        "np",
        "i",
        "indexes",
        "pauli_z",
        "i",
        "Pauli",
        "pauli_z",
        "pauli_x"
    ],
    "literals": [
        "\"The values and weights must have the same length\"",
        "\"The values and weights cannot be negative\"",
        "\"The values cannot all be 0\"",
        "\"max_weight cannot be negative\""
    ],
    "variables": [
        "logger",
        "y_size",
        "n",
        "num_values",
        "pauli_list",
        "shift",
        "M",
        "coefficient",
        "pauli_op",
        "pauli_op",
        "coefficient",
        "pauli_op",
        "coefficient",
        "pauli_op",
        "pauli_op",
        "coefficient",
        "pauli_op",
        "coefficient",
        "pauli_op",
        "coefficient",
        "pauli_op",
        "coefficient",
        "pauli_op",
        "pauli_op",
        "coefficient",
        "pauli_op",
        "coefficient",
        "pauli_op",
        "value",
        "weight",
        "pauli_x",
        "pauli_z",
        "pauli_z",
        "i"
    ],
    "comments": [
        "-*- coding: utf-8 -*-",
        "This code is part of Qiskit.",
        "",
        "(C) Copyright IBM 2020.",
        "",
        "This code is licensed under the Apache License, Version 2.0. You may",
        "obtain a copy of this license in the LICENSE.txt file in the root directory",
        "of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.",
        "",
        "Any modifications or derivative works of this code must retain this",
        "copyright notice, and modified files need to carry a notice indicating",
        "that they have been altered from the originals.",
        "pylint: disable=invalid-name",
        "term for sum(x_i*w_i)**2",
        "term for sum(2**j*y_j)**2",
        "term for -2*W_max*sum(x_i*w_i)",
        "term for -2*W_max*sum(2**j*y_j)",
        "term for sum(x_i*v_i)"
    ],
    "docstrings": [
        "\"\"\"\nConvert knapsack parameters instances into Pauli list\nThe parameters are a list of values a list of weights and a maximum weight of the knapsack.\n\nIn the Knapsack Problem we are given a list of objects that each has a weight and a value.\nWe are also given a maximum weight we can carry. We need to pick a subset of the objects\nso as to maximize the total value without going over the maximum weight.\n\nIf we have the weights w[i], the values v[i] and the maximum weight W_max.\nWe express the solution as a binary array x[i]\nwhere we have a 1 for the items we take in the solution set.\nWe need to maximize sum(x[i]*v[i]) while respecting W_max >= sum(x[i]*w[i])\n\n\"\"\"",
        "\"\"\"\n    Generate Hamiltonian for the knapsack problem.\n\n    Notes:\n        To build the cost function for the Hamiltonian we add a term S\n        that will vary with our solution. In order to make it change wit the solution\n        we enhance X with a number of additional bits X' = [x_0,..x_{n-1},y_{n}..y_{n+m-1}].\n        The bytes y[i] will be the binary representation of S.\n        In this way the optimizer will be able to optimize S as well as X.\n\n        The cost function is\n        $$C(X') = M(W_{max} - \\\\sum_{i=0}^{n-1} x_{i}w_{i} - S)^2 - \\\\sum_{i}^{n-1} x_{i}v_{i}$$\n        where S = sum(2**j * y[j]), j goes from n to n+log(W_max).\n        M is a number large enough to dominate the sum of values.\n\n        Because S can only be positive, when W_max >= sum(x[i]*w[i])\n        the optimizer can find an S (or better the y[j] that compose S)\n        so that it will take the first term to 0.\n        This way the function is dominated by the sum of values.\n        If W_max < sum(x[i]*w[i]) then the first term can never be 0\n        and, multiplied by a large M, will always dominate the function.\n\n        The minimum value of the function will be that where the constraint is respected\n        and the sum of values is maximized.\n\n    Args:\n        values (list of non-negative integers) : a list of values\n        weights (list of non-negative integers) : a list of weights\n        max_weight (non negative integer) : the maximum weight the knapsack can carry\n\n    Returns:\n        WeightedPauliOperator: operator for the Hamiltonian\n        float: a constant shift for the obj function.\n\n    Raises:\n        ValueError: values and weights have different lengths\n        ValueError: A value or a weight is negative\n        ValueError: All values are zero\n        ValueError: max_weight is negative\n\n    \"\"\"",
        "\"\"\"\n    Get the solution to the knapsack problem\n    from the bitstring that represents\n    to the ground state of the Hamiltonian\n\n    Args:\n        x (numpy.ndarray): the ground state of the Hamiltonian.\n        values (numpy.ndarray): the list of values\n\n    Returns:\n        numpy.ndarray: a bit string that has a '1' at the indexes\n         corresponding to values that have been taken in the knapsack.\n         i.e. if the solution has a '1' at index i then\n         the value values[i] has been taken in the knapsack\n    \"\"\"",
        "\"\"\"\n    Get the total wight and value of the items taken in the knapsack.\n\n    Args:\n        solution (numpy.ndarray) : binary string that represents the solution to the problem.\n        values (numpy.ndarray) : the list of values\n        weights (numpy.ndarray) : the list of weights\n\n    Returns:\n        tuple: the total value and weight of the items in the knapsack\n    \"\"\""
    ],
    "functions": [
        "get_operator",
        "get_solution",
        "knapsack_value_weight",
        "_get_pauli_op"
    ],
    "classes": []
}