{
    "identifiers": [
        "net",
        "fabricmc",
        "loader",
        "lib",
        "gson",
        "java",
        "io",
        "Closeable",
        "java",
        "io",
        "EOFException",
        "java",
        "io",
        "java",
        "io",
        "Reader",
        "java",
        "util",
        "Arrays",
        "MIN_INCOMPLETE_INTEGER",
        "MIN_VALUE",
        "PEEKED_NONE",
        "PEEKED_BEGIN_OBJECT",
        "PEEKED_END_OBJECT",
        "PEEKED_BEGIN_ARRAY",
        "PEEKED_END_ARRAY",
        "PEEKED_TRUE",
        "PEEKED_FALSE",
        "PEEKED_NULL",
        "PEEKED_SINGLE_QUOTED",
        "PEEKED_DOUBLE_QUOTED",
        "PEEKED_UNQUOTED",
        "PEEKED_BUFFERED",
        "PEEKED_SINGLE_QUOTED_NAME",
        "PEEKED_DOUBLE_QUOTED_NAME",
        "PEEKED_UNQUOTED_NAME",
        "PEEKED_LONG",
        "PEEKED_NUMBER",
        "PEEKED_EOF",
        "NUMBER_CHAR_NONE",
        "NUMBER_CHAR_SIGN",
        "NUMBER_CHAR_DIGIT",
        "NUMBER_CHAR_DECIMAL",
        "NUMBER_CHAR_FRACTION_DIGIT",
        "NUMBER_CHAR_EXP_E",
        "NUMBER_CHAR_EXP_SIGN",
        "NUMBER_CHAR_EXP_DIGIT",
        "lenient",
        "buffer",
        "pos",
        "limit",
        "lineNumber",
        "lineStart",
        "peeked",
        "PEEKED_NONE",
        "peekedLong",
        "peekedNumberLength",
        "peekedString",
        "stack",
        "stackSize",
        "stack",
        "stackSize",
        "JsonScope",
        "EMPTY_DOCUMENT",
        "pathNames",
        "pathIndices",
        "lenient",
        "lenient",
        "lenient",
        "lenient",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "p",
        "PEEKED_BEGIN_ARRAY",
        "push",
        "JsonScope",
        "EMPTY_ARRAY",
        "pathIndices",
        "stackSize",
        "peeked",
        "PEEKED_NONE",
        "peek",
        "locationString",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "p",
        "PEEKED_END_ARRAY",
        "stackSize",
        "pathIndices",
        "stackSize",
        "peeked",
        "PEEKED_NONE",
        "peek",
        "locationString",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "p",
        "PEEKED_BEGIN_OBJECT",
        "push",
        "JsonScope",
        "EMPTY_OBJECT",
        "peeked",
        "PEEKED_NONE",
        "peek",
        "locationString",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "p",
        "PEEKED_END_OBJECT",
        "stackSize",
        "pathNames",
        "stackSize",
        "pathIndices",
        "stackSize",
        "peeked",
        "PEEKED_NONE",
        "peek",
        "locationString",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "p",
        "PEEKED_END_OBJECT",
        "p",
        "PEEKED_END_ARRAY",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "p",
        "PEEKED_BEGIN_OBJECT",
        "JsonToken",
        "BEGIN_OBJECT",
        "PEEKED_END_OBJECT",
        "JsonToken",
        "END_OBJECT",
        "PEEKED_BEGIN_ARRAY",
        "JsonToken",
        "BEGIN_ARRAY",
        "PEEKED_END_ARRAY",
        "JsonToken",
        "END_ARRAY",
        "PEEKED_SINGLE_QUOTED_NAME",
        "PEEKED_DOUBLE_QUOTED_NAME",
        "PEEKED_UNQUOTED_NAME",
        "JsonToken",
        "NAME",
        "PEEKED_TRUE",
        "PEEKED_FALSE",
        "JsonToken",
        "BOOLEAN",
        "PEEKED_NULL",
        "JsonToken",
        "NULL",
        "PEEKED_SINGLE_QUOTED",
        "PEEKED_DOUBLE_QUOTED",
        "PEEKED_UNQUOTED",
        "PEEKED_BUFFERED",
        "JsonToken",
        "STRING",
        "PEEKED_LONG",
        "PEEKED_NUMBER",
        "JsonToken",
        "NUMBER",
        "PEEKED_EOF",
        "JsonToken",
        "END_DOCUMENT",
        "peekStack",
        "stack",
        "stackSize",
        "peekStack",
        "JsonScope",
        "EMPTY_ARRAY",
        "stack",
        "stackSize",
        "JsonScope",
        "NONEMPTY_ARRAY",
        "peekStack",
        "JsonScope",
        "NONEMPTY_ARRAY",
        "c",
        "nextNonWhitespace",
        "c",
        "peeked",
        "PEEKED_END_ARRAY",
        "checkLenient",
        "syntaxError",
        "peekStack",
        "JsonScope",
        "EMPTY_OBJECT",
        "peekStack",
        "JsonScope",
        "NONEMPTY_OBJECT",
        "stack",
        "stackSize",
        "JsonScope",
        "DANGLING_NAME",
        "peekStack",
        "JsonScope",
        "NONEMPTY_OBJECT",
        "c",
        "nextNonWhitespace",
        "c",
        "peeked",
        "PEEKED_END_OBJECT",
        "checkLenient",
        "syntaxError",
        "c",
        "nextNonWhitespace",
        "c",
        "peeked",
        "PEEKED_DOUBLE_QUOTED_NAME",
        "checkLenient",
        "peeked",
        "PEEKED_SINGLE_QUOTED_NAME",
        "peekStack",
        "JsonScope",
        "NONEMPTY_OBJECT",
        "peeked",
        "PEEKED_END_OBJECT",
        "syntaxError",
        "checkLenient",
        "pos",
        "isLiteral",
        "c",
        "peeked",
        "PEEKED_UNQUOTED_NAME",
        "syntaxError",
        "peekStack",
        "JsonScope",
        "DANGLING_NAME",
        "stack",
        "stackSize",
        "JsonScope",
        "NONEMPTY_OBJECT",
        "c",
        "nextNonWhitespace",
        "c",
        "checkLenient",
        "pos",
        "limit",
        "fillBuffer",
        "buffer",
        "pos",
        "pos",
        "syntaxError",
        "peekStack",
        "JsonScope",
        "EMPTY_DOCUMENT",
        "lenient",
        "consumeNonExecutePrefix",
        "stack",
        "stackSize",
        "JsonScope",
        "NONEMPTY_DOCUMENT",
        "peekStack",
        "JsonScope",
        "NONEMPTY_DOCUMENT",
        "c",
        "nextNonWhitespace",
        "c",
        "peeked",
        "PEEKED_EOF",
        "checkLenient",
        "pos",
        "peekStack",
        "JsonScope",
        "CLOSED",
        "c",
        "nextNonWhitespace",
        "c",
        "peekStack",
        "JsonScope",
        "EMPTY_ARRAY",
        "peeked",
        "PEEKED_END_ARRAY",
        "peekStack",
        "JsonScope",
        "EMPTY_ARRAY",
        "peekStack",
        "JsonScope",
        "NONEMPTY_ARRAY",
        "checkLenient",
        "pos",
        "peeked",
        "PEEKED_NULL",
        "syntaxError",
        "checkLenient",
        "peeked",
        "PEEKED_SINGLE_QUOTED",
        "peeked",
        "PEEKED_DOUBLE_QUOTED",
        "peeked",
        "PEEKED_BEGIN_ARRAY",
        "peeked",
        "PEEKED_BEGIN_OBJECT",
        "pos",
        "result",
        "peekKeyword",
        "result",
        "PEEKED_NONE",
        "result",
        "result",
        "peekNumber",
        "result",
        "PEEKED_NONE",
        "result",
        "isLiteral",
        "buffer",
        "pos",
        "syntaxError",
        "checkLenient",
        "peeked",
        "PEEKED_UNQUOTED",
        "c",
        "buffer",
        "pos",
        "keyword",
        "keywordUpper",
        "peeking",
        "c",
        "c",
        "keyword",
        "keywordUpper",
        "peeking",
        "PEEKED_TRUE",
        "c",
        "c",
        "keyword",
        "keywordUpper",
        "peeking",
        "PEEKED_FALSE",
        "c",
        "c",
        "keyword",
        "keywordUpper",
        "peeking",
        "PEEKED_NULL",
        "PEEKED_NONE",
        "length",
        "keyword",
        "length",
        "i",
        "i",
        "length",
        "i",
        "pos",
        "i",
        "limit",
        "fillBuffer",
        "i",
        "PEEKED_NONE",
        "c",
        "buffer",
        "pos",
        "i",
        "c",
        "keyword",
        "charAt",
        "i",
        "c",
        "keywordUpper",
        "charAt",
        "i",
        "PEEKED_NONE",
        "pos",
        "length",
        "limit",
        "fillBuffer",
        "length",
        "isLiteral",
        "buffer",
        "pos",
        "length",
        "PEEKED_NONE",
        "pos",
        "length",
        "peeked",
        "peeking",
        "buffer",
        "buffer",
        "p",
        "pos",
        "l",
        "limit",
        "value",
        "negative",
        "fitsInLong",
        "last",
        "NUMBER_CHAR_NONE",
        "i",
        "charactersOfNumber",
        "i",
        "p",
        "i",
        "l",
        "i",
        "buffer",
        "length",
        "PEEKED_NONE",
        "fillBuffer",
        "i",
        "p",
        "pos",
        "l",
        "limit",
        "c",
        "buffer",
        "p",
        "i",
        "c",
        "last",
        "NUMBER_CHAR_NONE",
        "negative",
        "last",
        "NUMBER_CHAR_SIGN",
        "last",
        "NUMBER_CHAR_EXP_E",
        "last",
        "NUMBER_CHAR_EXP_SIGN",
        "PEEKED_NONE",
        "last",
        "NUMBER_CHAR_EXP_E",
        "last",
        "NUMBER_CHAR_EXP_SIGN",
        "PEEKED_NONE",
        "last",
        "NUMBER_CHAR_DIGIT",
        "last",
        "NUMBER_CHAR_FRACTION_DIGIT",
        "last",
        "NUMBER_CHAR_EXP_E",
        "PEEKED_NONE",
        "last",
        "NUMBER_CHAR_DIGIT",
        "last",
        "NUMBER_CHAR_DECIMAL",
        "PEEKED_NONE",
        "c",
        "c",
        "isLiteral",
        "c",
        "charactersOfNumber",
        "PEEKED_NONE",
        "last",
        "NUMBER_CHAR_SIGN",
        "last",
        "NUMBER_CHAR_NONE",
        "value",
        "c",
        "last",
        "NUMBER_CHAR_DIGIT",
        "last",
        "NUMBER_CHAR_DIGIT",
        "value",
        "PEEKED_NONE",
        "newValue",
        "value",
        "c",
        "fitsInLong",
        "value",
        "MIN_INCOMPLETE_INTEGER",
        "value",
        "MIN_INCOMPLETE_INTEGER",
        "newValue",
        "value",
        "value",
        "newValue",
        "last",
        "NUMBER_CHAR_DECIMAL",
        "last",
        "NUMBER_CHAR_FRACTION_DIGIT",
        "last",
        "NUMBER_CHAR_EXP_E",
        "last",
        "NUMBER_CHAR_EXP_SIGN",
        "last",
        "NUMBER_CHAR_EXP_DIGIT",
        "last",
        "NUMBER_CHAR_DIGIT",
        "fitsInLong",
        "value",
        "MIN_VALUE",
        "negative",
        "value",
        "negative",
        "peekedLong",
        "negative",
        "value",
        "value",
        "pos",
        "i",
        "peeked",
        "PEEKED_LONG",
        "last",
        "NUMBER_CHAR_DIGIT",
        "last",
        "NUMBER_CHAR_FRACTION_DIGIT",
        "last",
        "NUMBER_CHAR_EXP_DIGIT",
        "peekedNumberLength",
        "i",
        "peeked",
        "PEEKED_NUMBER",
        "PEEKED_NONE",
        "c",
        "c",
        "checkLenient",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "result",
        "p",
        "PEEKED_UNQUOTED_NAME",
        "result",
        "nextUnquotedValue",
        "p",
        "PEEKED_SINGLE_QUOTED_NAME",
        "result",
        "nextQuotedValue",
        "p",
        "PEEKED_DOUBLE_QUOTED_NAME",
        "result",
        "nextQuotedValue",
        "peek",
        "locationString",
        "peeked",
        "PEEKED_NONE",
        "pathNames",
        "stackSize",
        "result",
        "result",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "result",
        "p",
        "PEEKED_UNQUOTED",
        "result",
        "nextUnquotedValue",
        "p",
        "PEEKED_SINGLE_QUOTED",
        "result",
        "nextQuotedValue",
        "p",
        "PEEKED_DOUBLE_QUOTED",
        "result",
        "nextQuotedValue",
        "p",
        "PEEKED_BUFFERED",
        "result",
        "peekedString",
        "peekedString",
        "p",
        "PEEKED_LONG",
        "result",
        "toString",
        "peekedLong",
        "p",
        "PEEKED_NUMBER",
        "result",
        "buffer",
        "pos",
        "peekedNumberLength",
        "pos",
        "peekedNumberLength",
        "peek",
        "locationString",
        "peeked",
        "PEEKED_NONE",
        "pathIndices",
        "stackSize",
        "result",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "p",
        "PEEKED_TRUE",
        "peeked",
        "PEEKED_NONE",
        "pathIndices",
        "stackSize",
        "p",
        "PEEKED_FALSE",
        "peeked",
        "PEEKED_NONE",
        "pathIndices",
        "stackSize",
        "peek",
        "locationString",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "p",
        "PEEKED_NULL",
        "peeked",
        "PEEKED_NONE",
        "pathIndices",
        "stackSize",
        "peek",
        "locationString",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "p",
        "PEEKED_LONG",
        "peeked",
        "PEEKED_NONE",
        "pathIndices",
        "stackSize",
        "peekedLong",
        "p",
        "PEEKED_NUMBER",
        "peekedString",
        "buffer",
        "pos",
        "peekedNumberLength",
        "pos",
        "peekedNumberLength",
        "p",
        "PEEKED_SINGLE_QUOTED",
        "p",
        "PEEKED_DOUBLE_QUOTED",
        "peekedString",
        "nextQuotedValue",
        "p",
        "PEEKED_SINGLE_QUOTED",
        "p",
        "PEEKED_UNQUOTED",
        "peekedString",
        "nextUnquotedValue",
        "p",
        "PEEKED_BUFFERED",
        "peek",
        "locationString",
        "peeked",
        "PEEKED_BUFFERED",
        "result",
        "parseDouble",
        "peekedString",
        "lenient",
        "isNaN",
        "result",
        "isInfinite",
        "result",
        "result",
        "locationString",
        "peekedString",
        "peeked",
        "PEEKED_NONE",
        "pathIndices",
        "stackSize",
        "result",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "p",
        "PEEKED_LONG",
        "peeked",
        "PEEKED_NONE",
        "pathIndices",
        "stackSize",
        "peekedLong",
        "p",
        "PEEKED_NUMBER",
        "peekedString",
        "buffer",
        "pos",
        "peekedNumberLength",
        "pos",
        "peekedNumberLength",
        "p",
        "PEEKED_SINGLE_QUOTED",
        "p",
        "PEEKED_DOUBLE_QUOTED",
        "p",
        "PEEKED_UNQUOTED",
        "p",
        "PEEKED_UNQUOTED",
        "peekedString",
        "nextUnquotedValue",
        "peekedString",
        "nextQuotedValue",
        "p",
        "PEEKED_SINGLE_QUOTED",
        "result",
        "parseLong",
        "peekedString",
        "peeked",
        "PEEKED_NONE",
        "pathIndices",
        "stackSize",
        "result",
        "ignored",
        "peek",
        "locationString",
        "peeked",
        "PEEKED_BUFFERED",
        "asDouble",
        "parseDouble",
        "peekedString",
        "result",
        "asDouble",
        "result",
        "asDouble",
        "peekedString",
        "locationString",
        "peekedString",
        "peeked",
        "PEEKED_NONE",
        "pathIndices",
        "stackSize",
        "result",
        "quote",
        "buffer",
        "buffer",
        "builder",
        "p",
        "pos",
        "l",
        "limit",
        "start",
        "p",
        "p",
        "l",
        "c",
        "buffer",
        "p",
        "c",
        "quote",
        "pos",
        "p",
        "len",
        "p",
        "start",
        "builder",
        "buffer",
        "start",
        "len",
        "builder",
        "append",
        "buffer",
        "start",
        "len",
        "builder",
        "toString",
        "c",
        "pos",
        "p",
        "len",
        "p",
        "start",
        "builder",
        "estimatedLength",
        "len",
        "builder",
        "max",
        "estimatedLength",
        "builder",
        "append",
        "buffer",
        "start",
        "len",
        "builder",
        "append",
        "readEscapeCharacter",
        "p",
        "pos",
        "l",
        "limit",
        "start",
        "p",
        "c",
        "lineNumber",
        "lineStart",
        "p",
        "builder",
        "estimatedLength",
        "p",
        "start",
        "builder",
        "max",
        "estimatedLength",
        "builder",
        "append",
        "buffer",
        "start",
        "p",
        "start",
        "pos",
        "p",
        "fillBuffer",
        "syntaxError",
        "SuppressWarnings",
        "builder",
        "i",
        "findNonLiteralCharacter",
        "pos",
        "i",
        "limit",
        "i",
        "buffer",
        "pos",
        "i",
        "checkLenient",
        "findNonLiteralCharacter",
        "i",
        "buffer",
        "length",
        "fillBuffer",
        "i",
        "builder",
        "builder",
        "max",
        "i",
        "builder",
        "append",
        "buffer",
        "pos",
        "i",
        "pos",
        "i",
        "i",
        "fillBuffer",
        "result",
        "builder",
        "buffer",
        "pos",
        "i",
        "builder",
        "append",
        "buffer",
        "pos",
        "i",
        "toString",
        "pos",
        "i",
        "result",
        "quote",
        "buffer",
        "buffer",
        "p",
        "pos",
        "l",
        "limit",
        "p",
        "l",
        "c",
        "buffer",
        "p",
        "c",
        "quote",
        "pos",
        "p",
        "c",
        "pos",
        "p",
        "readEscapeCharacter",
        "p",
        "pos",
        "l",
        "limit",
        "c",
        "lineNumber",
        "lineStart",
        "p",
        "pos",
        "p",
        "fillBuffer",
        "syntaxError",
        "i",
        "pos",
        "i",
        "limit",
        "i",
        "buffer",
        "pos",
        "i",
        "checkLenient",
        "pos",
        "i",
        "pos",
        "i",
        "fillBuffer",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "result",
        "p",
        "PEEKED_LONG",
        "result",
        "peekedLong",
        "peekedLong",
        "result",
        "peekedLong",
        "locationString",
        "peeked",
        "PEEKED_NONE",
        "pathIndices",
        "stackSize",
        "result",
        "p",
        "PEEKED_NUMBER",
        "peekedString",
        "buffer",
        "pos",
        "peekedNumberLength",
        "pos",
        "peekedNumberLength",
        "p",
        "PEEKED_SINGLE_QUOTED",
        "p",
        "PEEKED_DOUBLE_QUOTED",
        "p",
        "PEEKED_UNQUOTED",
        "p",
        "PEEKED_UNQUOTED",
        "peekedString",
        "nextUnquotedValue",
        "peekedString",
        "nextQuotedValue",
        "p",
        "PEEKED_SINGLE_QUOTED",
        "result",
        "parseInt",
        "peekedString",
        "peeked",
        "PEEKED_NONE",
        "pathIndices",
        "stackSize",
        "result",
        "ignored",
        "peek",
        "locationString",
        "peeked",
        "PEEKED_BUFFERED",
        "asDouble",
        "parseDouble",
        "peekedString",
        "result",
        "asDouble",
        "result",
        "asDouble",
        "peekedString",
        "locationString",
        "peekedString",
        "peeked",
        "PEEKED_NONE",
        "pathIndices",
        "stackSize",
        "result",
        "peeked",
        "PEEKED_NONE",
        "stack",
        "JsonScope",
        "CLOSED",
        "stackSize",
        "close",
        "count",
        "p",
        "peeked",
        "p",
        "PEEKED_NONE",
        "p",
        "doPeek",
        "p",
        "PEEKED_BEGIN_ARRAY",
        "push",
        "JsonScope",
        "EMPTY_ARRAY",
        "count",
        "p",
        "PEEKED_BEGIN_OBJECT",
        "push",
        "JsonScope",
        "EMPTY_OBJECT",
        "count",
        "p",
        "PEEKED_END_ARRAY",
        "stackSize",
        "count",
        "p",
        "PEEKED_END_OBJECT",
        "stackSize",
        "count",
        "p",
        "PEEKED_UNQUOTED_NAME",
        "p",
        "PEEKED_UNQUOTED",
        "skipUnquotedValue",
        "p",
        "PEEKED_SINGLE_QUOTED",
        "p",
        "PEEKED_SINGLE_QUOTED_NAME",
        "skipQuotedValue",
        "p",
        "PEEKED_DOUBLE_QUOTED",
        "p",
        "PEEKED_DOUBLE_QUOTED_NAME",
        "skipQuotedValue",
        "p",
        "PEEKED_NUMBER",
        "pos",
        "peekedNumberLength",
        "peeked",
        "PEEKED_NONE",
        "count",
        "pathIndices",
        "stackSize",
        "pathNames",
        "stackSize",
        "newTop",
        "stackSize",
        "stack",
        "length",
        "newLength",
        "stackSize",
        "stack",
        "Arrays",
        "copyOf",
        "stack",
        "newLength",
        "pathIndices",
        "Arrays",
        "copyOf",
        "pathIndices",
        "newLength",
        "pathNames",
        "Arrays",
        "copyOf",
        "pathNames",
        "newLength",
        "stack",
        "stackSize",
        "newTop",
        "minimum",
        "buffer",
        "buffer",
        "lineStart",
        "pos",
        "limit",
        "pos",
        "limit",
        "pos",
        "arraycopy",
        "buffer",
        "pos",
        "buffer",
        "limit",
        "limit",
        "pos",
        "total",
        "total",
        "read",
        "buffer",
        "limit",
        "buffer",
        "length",
        "limit",
        "limit",
        "total",
        "lineNumber",
        "lineStart",
        "limit",
        "buffer",
        "pos",
        "lineStart",
        "minimum",
        "limit",
        "minimum",
        "throwOnEof",
        "buffer",
        "buffer",
        "p",
        "pos",
        "l",
        "limit",
        "p",
        "l",
        "pos",
        "p",
        "fillBuffer",
        "p",
        "pos",
        "l",
        "limit",
        "c",
        "buffer",
        "p",
        "c",
        "lineNumber",
        "lineStart",
        "p",
        "c",
        "c",
        "c",
        "c",
        "pos",
        "p",
        "p",
        "l",
        "pos",
        "charsLoaded",
        "fillBuffer",
        "pos",
        "charsLoaded",
        "c",
        "checkLenient",
        "peek",
        "buffer",
        "pos",
        "peek",
        "pos",
        "skipTo",
        "syntaxError",
        "p",
        "pos",
        "l",
        "limit",
        "pos",
        "skipToEndOfLine",
        "p",
        "pos",
        "l",
        "limit",
        "c",
        "c",
        "pos",
        "p",
        "checkLenient",
        "skipToEndOfLine",
        "p",
        "pos",
        "l",
        "limit",
        "pos",
        "p",
        "c",
        "throwOnEof",
        "locationString",
        "lenient",
        "syntaxError",
        "pos",
        "limit",
        "fillBuffer",
        "c",
        "buffer",
        "pos",
        "c",
        "lineNumber",
        "lineStart",
        "pos",
        "c",
        "toFind",
        "length",
        "toFind",
        "length",
        "outer",
        "pos",
        "length",
        "limit",
        "fillBuffer",
        "length",
        "pos",
        "buffer",
        "pos",
        "lineNumber",
        "lineStart",
        "pos",
        "c",
        "c",
        "length",
        "c",
        "buffer",
        "pos",
        "c",
        "toFind",
        "charAt",
        "c",
        "outer",
        "Override",
        "getClass",
        "getSimpleName",
        "locationString",
        "line",
        "lineNumber",
        "column",
        "pos",
        "lineStart",
        "line",
        "column",
        "getPath",
        "result",
        "append",
        "i",
        "size",
        "stackSize",
        "i",
        "size",
        "i",
        "stack",
        "i",
        "JsonScope",
        "EMPTY_ARRAY",
        "JsonScope",
        "NONEMPTY_ARRAY",
        "result",
        "append",
        "append",
        "pathIndices",
        "i",
        "append",
        "JsonScope",
        "EMPTY_OBJECT",
        "JsonScope",
        "DANGLING_NAME",
        "JsonScope",
        "NONEMPTY_OBJECT",
        "result",
        "append",
        "pathNames",
        "i",
        "result",
        "append",
        "pathNames",
        "i",
        "JsonScope",
        "NONEMPTY_DOCUMENT",
        "JsonScope",
        "EMPTY_DOCUMENT",
        "JsonScope",
        "CLOSED",
        "result",
        "toString",
        "pos",
        "limit",
        "fillBuffer",
        "syntaxError",
        "escaped",
        "buffer",
        "pos",
        "escaped",
        "pos",
        "limit",
        "fillBuffer",
        "syntaxError",
        "result",
        "i",
        "pos",
        "end",
        "i",
        "i",
        "end",
        "i",
        "c",
        "buffer",
        "i",
        "result",
        "c",
        "c",
        "result",
        "c",
        "c",
        "c",
        "result",
        "c",
        "c",
        "c",
        "result",
        "c",
        "buffer",
        "pos",
        "pos",
        "result",
        "lineNumber",
        "lineStart",
        "pos",
        "escaped",
        "syntaxError",
        "message",
        "message",
        "locationString",
        "nextNonWhitespace",
        "pos",
        "p",
        "pos",
        "p",
        "limit",
        "fillBuffer",
        "buf",
        "buffer",
        "buf",
        "p",
        "buf",
        "p",
        "buf",
        "p",
        "buf",
        "p",
        "buf",
        "p",
        "pos",
        "lineNumber",
        "pos",
        "lineStart"
    ],
    "literals": [
        "\"in == null\"",
        "\"Expected BEGIN_ARRAY but was \"",
        "\"Expected END_ARRAY but was \"",
        "\"Expected BEGIN_OBJECT but was \"",
        "\"Expected END_OBJECT but was \"",
        "\"Unterminated array\"",
        "\"Unterminated object\"",
        "\"Expected name\"",
        "\"Expected name\"",
        "\"Expected ':'\"",
        "\"JsonReader is closed\"",
        "\"Unexpected value\"",
        "\"Expected value\"",
        "\"true\"",
        "\"TRUE\"",
        "\"false\"",
        "\"FALSE\"",
        "\"null\"",
        "\"NULL\"",
        "\"Expected a name but was \"",
        "\"Expected a string but was \"",
        "\"Expected a boolean but was \"",
        "\"Expected null but was \"",
        "\"Expected a double but was \"",
        "\"JSON forbids NaN and infinities: \"",
        "\"Expected a long but was \"",
        "\"Expected a long but was \"",
        "\"Unterminated string\"",
        "\"fallthrough\"",
        "\"Unterminated string\"",
        "\"Expected an int but was \"",
        "\"Expected an int but was \"",
        "\"Expected an int but was \"",
        "\"null\"",
        "\"*/\"",
        "\"Unterminated comment\"",
        "\"End of input\"",
        "\"Use JsonReader.setLenient(true) to accept malformed JSON\"",
        "\" at line \"",
        "\" column \"",
        "\" path \"",
        "\"Unterminated escape sequence\"",
        "\"Unterminated escape sequence\"",
        "\"\\\\u\"",
        "\"Invalid escape sequence\""
    ],
    "variables": [
        "in",
        "peekedLong",
        "peekedNumberLength",
        "peekedString",
        "keyword",
        "keywordUpper",
        "peeking",
        "result",
        "result",
        "result",
        "total"
    ],
    "comments": [
        "Free the last path name so that it can be garbage collected!",
        "Look for a comma before the next element.",
        "fall-through",
        "Look for a comma before the next element.",
        "fall-through",
        "Don't consume the first character in an unquoted string.",
        "Look for a colon before the value.",
        "fall-through to handle \",]\"",
        "In lenient mode, a 0-length literal in an array means 'null'.",
        "Don't consume the first character in a literal value.",
        "Figure out which keyword we're matching against by its first character.",
        "Confirm that chars [1..length) match the keyword.",
        "Don't match trues, falsey or nullsoft!",
        "We've found the keyword followed either by EOF or by a non-literal character.",
        "Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.",
        "Negative to accommodate Long.MIN_VALUE more easily.",
        "Though this looks like a well-formed number, it's too long to continue reading. Give up",
        "and let the application handle this as an unquoted literal.",
        "Leading '0' prefix is not allowed (since it could be octal).",
        "We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.",
        "fall-through",
        "don't catch this NumberFormatException.",
        "Fall back to parse as a double below.",
        "don't catch this NumberFormatException.",
        "Make sure no precision was lost casting to 'long'.",
        "Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.",
        "fall-through",
        "Attempt to load the entire literal into the buffer at once.",
        "use a StringBuilder when the value is too long. This is too long to be a number!",
        "Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.",
        "fall-through",
        "Make sure no precision was lost casting to 'int'.",
        "Fall back to parse as a double below.",
        "don't catch this NumberFormatException.",
        "Make sure no precision was lost casting to 'int'.",
        "if this is the first read, consume an optional byte order mark (BOM) if it exists",
        "push back '/' so it's still in the buffer when this method returns",
        "consume the '/' again",
        "skip a /* c-style comment */",
        "skip a // end-of-line comment",
        "Fabric - Make location string public for error context",
        "Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);",
        "fall-through",
        "throw error when none of the above cases are matched",
        "fast forward through the leading whitespace",
        "not a security token!",
        "we consumed a security token!",
        "Fabric - added methods for warning messages"
    ],
    "docstrings": [
        "* Copyright (C) 2010 Google Inc.\n * Copyright (c) 2020 FabricMC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * This file has been modified by the Fabric project (repackage, minor changes).",
        "* Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>)\n * encoded value as a stream of tokens. This stream includes both literal\n * values (strings, numbers, booleans, and nulls) as well as the begin and\n * end delimiters of objects and arrays. The tokens are traversed in\n * depth-first order, the same order that they appear in the JSON document.\n * Within JSON objects, name/value pairs are represented by a single token.\n *\n * <h3>Parsing JSON</h3>\n * To create a recursive descent parser for your own JSON streams, first create\n * an entry point method that creates a {@code JsonReader}.\n *\n * <p>Next, create handler methods for each structure in your JSON text. You'll\n * need a method for each object type and for each array type.\n * <ul>\n *   <li>Within <strong>array handling</strong> methods, first call {@link\n *       #beginArray} to consume the array's opening bracket. Then create a\n *       while loop that accumulates values, terminating when {@link #hasNext}\n *       is false. Finally, read the array's closing bracket by calling {@link\n *       #endArray}.\n *   <li>Within <strong>object handling</strong> methods, first call {@link\n *       #beginObject} to consume the object's opening brace. Then create a\n *       while loop that assigns values to local variables based on their name.\n *       This loop should terminate when {@link #hasNext} is false. Finally,\n *       read the object's closing brace by calling {@link #endObject}.\n * </ul>\n * <p>When a nested object or array is encountered, delegate to the\n * corresponding handler method.\n *\n * <p>When an unknown name is encountered, strict parsers should fail with an\n * exception. Lenient parsers should call {@link #skipValue()} to recursively\n * skip the value's nested tokens, which may otherwise conflict.\n *\n * <p>If a value may be null, you should first check using {@link #peek()}.\n * Null literals can be consumed using either {@link #nextNull()} or {@link\n * #skipValue()}.\n *\n * <h3>Example</h3>\n * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code\n * [\n *   {\n *     \"id\": 912345678901,\n *     \"text\": \"How do I read a JSON stream in Java?\",\n *     \"geo\": null,\n *     \"user\": {\n *       \"name\": \"json_newb\",\n *       \"followers_count\": 41\n *      }\n *   },\n *   {\n *     \"id\": 912345678902,\n *     \"text\": \"@json_newb just use JsonReader!\",\n *     \"geo\": [50.454722, -104.606667],\n *     \"user\": {\n *       \"name\": \"jesse\",\n *       \"followers_count\": 2\n *     }\n *   }\n * ]}</pre>\n * This code implements the parser for the above structure: <pre>   {@code\n *\n *   public List<Message> readJsonStream(InputStream in) throws IOException {\n *     JsonReader reader = new JsonReader(new InputStreamReader(in, \"UTF-8\"));\n *     try {\n *       return readMessagesArray(reader);\n *     } finally {\n *       reader.close();\n *     }\n *   }\n *\n *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {\n *     List<Message> messages = new ArrayList<Message>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       messages.add(readMessage(reader));\n *     }\n *     reader.endArray();\n *     return messages;\n *   }\n *\n *   public Message readMessage(JsonReader reader) throws IOException {\n *     long id = -1;\n *     String text = null;\n *     User user = null;\n *     List<Double> geo = null;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"id\")) {\n *         id = reader.nextLong();\n *       } else if (name.equals(\"text\")) {\n *         text = reader.nextString();\n *       } else if (name.equals(\"geo\") && reader.peek() != JsonToken.NULL) {\n *         geo = readDoublesArray(reader);\n *       } else if (name.equals(\"user\")) {\n *         user = readUser(reader);\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new Message(id, text, user, geo);\n *   }\n *\n *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {\n *     List<Double> doubles = new ArrayList<Double>();\n *\n *     reader.beginArray();\n *     while (reader.hasNext()) {\n *       doubles.add(reader.nextDouble());\n *     }\n *     reader.endArray();\n *     return doubles;\n *   }\n *\n *   public User readUser(JsonReader reader) throws IOException {\n *     String username = null;\n *     int followersCount = -1;\n *\n *     reader.beginObject();\n *     while (reader.hasNext()) {\n *       String name = reader.nextName();\n *       if (name.equals(\"name\")) {\n *         username = reader.nextString();\n *       } else if (name.equals(\"followers_count\")) {\n *         followersCount = reader.nextInt();\n *       } else {\n *         reader.skipValue();\n *       }\n *     }\n *     reader.endObject();\n *     return new User(username, followersCount);\n *   }}</pre>\n *\n * <h3>Number Handling</h3>\n * This reader permits numeric values to be read as strings and string values to\n * be read as numbers. For example, both elements of the JSON array {@code\n * [1, \"1\"]} may be read using either {@link #nextInt} or {@link #nextString}.\n * This behavior is intended to prevent lossy numeric conversions: double is\n * JavaScript's only numeric type and very large values like {@code\n * 9007199254740993} cannot be represented exactly on that platform. To minimize\n * precision loss, extremely large values should be written and read as strings\n * in JSON.\n *\n * <a id=\"nonexecuteprefix\"/><h3>Non-Execute Prefix</h3>\n * Web servers that serve private data using JSON may be vulnerable to <a\n * href=\"http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery\">Cross-site\n * request forgery</a> attacks. In such an attack, a malicious site gains access\n * to a private JSON file by executing it with an HTML {@code <script>} tag.\n *\n * <p>Prefixing JSON files with <code>\")]}'\\n\"</code> makes them non-executable\n * by {@code <script>} tags, disarming the attack. Since the prefix is malformed\n * JSON, strict parsing fails when it is encountered. This class permits the\n * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is\n * enabled.\n *\n * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances\n * of this class are not thread safe.\n *\n * @author Jesse Wilson\n * @since 1.6",
        "When this is returned, the string value is stored in peekedString.",
        "When this is returned, the integer value is stored in peekedLong.",
        "State machine when parsing numbers",
        "The input JSON.",
        "True to accept non-spec compliant JSON",
        "* Use a manual buffer to easily read and unread upcoming characters, and\n\t * also so we can create strings without an intermediate StringBuilder.\n\t * We decode literals directly out of this buffer, so it must be at least as\n\t * long as the longest token that can be reported as a number.",
        "* A peeked value that was composed entirely of digits with an optional\n\t * leading dash. Positive values may not have a leading 0.",
        "* The number of characters in a peeked number literal. Increment 'pos' by\n\t * this after reading a number.",
        "* A peeked string that should be parsed on the next double, long or string.\n\t * This is populated before a numeric value is parsed and used if that parsing\n\t * fails.",
        "* The nesting stack. Using a manual array rather than an ArrayList saves 20%.",
        "* The path members. It corresponds directly to stack: At indices where the\n\t * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n\t * pathNames contains the name at this scope. Where it contains an array\n\t * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n\t * that array. Otherwise the value is undefined, and we take advantage of that\n\t * by incrementing pathIndices when doing so isn't useful.",
        "* Creates a new instance that reads a JSON-encoded stream from {@code in}.",
        "* Configure this parser to be liberal in what it accepts. By default,\n\t * this parser is strict and only accepts JSON as specified by <a\n\t * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n\t * parser to lenient causes it to ignore the following syntax errors:\n\t *\n\t * <ul>\n\t *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n\t *       prefix</a>, <code>\")]}'\\n\"</code>.\n\t *   <li>Streams that include multiple top-level values. With strict parsing,\n\t *       each stream must contain exactly one top-level value.\n\t *   <li>Top-level values of any type. With strict parsing, the top-level\n\t *       value must be an object or an array.\n\t *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n\t *       Double#isInfinite() infinities}.\n\t *   <li>End of line comments starting with {@code //} or {@code #} and\n\t *       ending with a newline character.\n\t *   <li>C-style comments starting with {@code /*} and ending with\n\t *       {@code *}{@code /}. Such comments may not be nested.\n\t *   <li>Names that are unquoted or {@code 'single quoted'}.\n\t *   <li>Strings that are unquoted or {@code 'single quoted'}.\n\t *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n\t *   <li>Unnecessary array separators. These are interpreted as if null\n\t *       was the omitted value.\n\t *   <li>Names and values separated by {@code =} or {@code =>} instead of\n\t *       {@code :}.\n\t *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n\t * </ul>",
        "* Returns true if this parser is liberal in what it accepts.",
        "* Consumes the next token from the JSON stream and asserts that it is the\n\t * beginning of a new array.",
        "* Consumes the next token from the JSON stream and asserts that it is the\n\t * end of the current array.",
        "* Consumes the next token from the JSON stream and asserts that it is the\n\t * beginning of a new object.",
        "* Consumes the next token from the JSON stream and asserts that it is the\n\t * end of the current object.",
        "* Returns true if the current array or object has another element.",
        "* Returns the type of the next token without consuming it.",
        "* Returns the next token, a {@link JsonToken#NAME property name}, and\n\t * consumes it.\n\t *\n\t * @throws IOException if the next token in the stream is not a property\n\t *     name.",
        "* Returns the {@link JsonToken#STRING string} value of the next token,\n\t * consuming it. If the next token is a number, this method will return its\n\t * string form.\n\t *\n\t * @throws IllegalStateException if the next token is not a string or if\n\t *     this reader is closed.",
        "* Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n\t * consuming it.\n\t *\n\t * @throws IllegalStateException if the next token is not a boolean or if\n\t *     this reader is closed.",
        "* Consumes the next token from the JSON stream and asserts that it is a\n\t * literal null.\n\t *\n\t * @throws IllegalStateException if the next token is not null or if this\n\t *     reader is closed.",
        "* Returns the {@link JsonToken#NUMBER double} value of the next token,\n\t * consuming it. If the next token is a string, this method will attempt to\n\t * parse it as a double using {@link Double#parseDouble(String)}.\n\t *\n\t * @throws IllegalStateException if the next token is not a literal value.\n\t * @throws NumberFormatException if the next literal value cannot be parsed\n\t *     as a double, or is non-finite.",
        "* Returns the {@link JsonToken#NUMBER long} value of the next token,\n\t * consuming it. If the next token is a string, this method will attempt to\n\t * parse it as a long. If the next token's numeric value cannot be exactly\n\t * represented by a Java {@code long}, this method throws.\n\t *\n\t * @throws IllegalStateException if the next token is not a literal value.\n\t * @throws NumberFormatException if the next literal value cannot be parsed\n\t *     as a number, or exactly represented as a long.",
        "* Returns the string up to but not including {@code quote}, unescaping any\n\t * character escape sequences encountered along the way. The opening quote\n\t * should have already been read. This consumes the closing quote, but does\n\t * not include it in the returned string.\n\t *\n\t * @param quote either ' or \".\n\t * @throws NumberFormatException if any unicode escape sequences are\n\t *     malformed.",
        "the index of the first character not yet appended to the builder.",
        "* Returns an unquoted value as a string.",
        "the index of the first character not yet appended to the builder.",
        "* Returns the {@link JsonToken#NUMBER int} value of the next token,\n\t * consuming it. If the next token is a string, this method will attempt to\n\t * parse it as an int. If the next token's numeric value cannot be exactly\n\t * represented by a Java {@code int}, this method throws.\n\t *\n\t * @throws IllegalStateException if the next token is not a literal value.\n\t * @throws NumberFormatException if the next literal value cannot be parsed\n\t *     as a number, or exactly represented as an int.",
        "* Closes this JSON reader and the underlying {@link Reader}.",
        "* Skips the next value recursively. If it is an object or array, all nested\n\t * elements are skipped. This method is intended for use when the JSON token\n\t * stream contains unrecognized or unhandled values.",
        "* Returns true once {@code limit - pos >= minimum}. If the data is\n\t * exhausted before that many characters are available, this returns\n\t * false.",
        "* Returns the next character in the stream that is neither whitespace nor a\n\t * part of a comment. When this returns, the returned character is always at\n\t * {@code buffer[pos-1]}; this means the caller can always push back the\n\t * returned character by decrementing {@code pos}.",
        "* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n\t\t * and 'limit' fields respectively. Using locals rather than fields saves\n\t\t * a few field reads for each whitespace character in a pretty-printed\n\t\t * document, resulting in a 5% speedup. We need to flush 'p' to its field\n\t\t * before any (potentially indirect) call to fillBuffer() and reread both\n\t\t * 'p' and 'l' after any (potentially indirect) call to the same method.",
        "* Skip a # hash end-of-line comment. The JSON RFC doesn't\n\t\t\t\t * specify this behaviour, but it's required to parse\n\t\t\t\t * existing documents. See http://b/2571423.",
        "* Advances the position until after the next newline character. If the line\n\t * is terminated by \"\\r\\n\", the '\\n' must be consumed as whitespace by the\n\t * caller.",
        "* @param toFind a string to search for. Must not contain a newline.",
        "* Returns a <a href=\"http://goessner.net/articles/JsonPath/\">JsonPath</a> to\n\t * the current location in the JSON value.",
        "* Unescapes the character identified by the character or characters that\n\t * immediately follow a backslash. The backslash '\\' should have already\n\t * been read. This supports both unicode escapes \"u000A\" and two-character\n\t * escapes \"\\n\".\n\t *\n\t * @throws NumberFormatException if any unicode escape sequences are\n\t *     malformed.",
        "* Throws a new IO exception with the given message and a context snippet\n\t * with this reader's content.",
        "* Consumes the non-execute prefix if it exists."
    ],
    "functions": [
        "JsonReader",
        "setLenient",
        "isLenient",
        "beginArray",
        "endArray",
        "beginObject",
        "endObject",
        "hasNext",
        "JsonToken",
        "peek",
        "doPeek",
        "peekKeyword",
        "peekNumber",
        "isLiteral",
        "nextName",
        "nextString",
        "nextBoolean",
        "nextNull",
        "nextDouble",
        "nextLong",
        "nextQuotedValue",
        "nextUnquotedValue",
        "skipQuotedValue",
        "skipUnquotedValue",
        "nextInt",
        "close",
        "skipValue",
        "push",
        "fillBuffer",
        "nextNonWhitespace",
        "checkLenient",
        "skipToEndOfLine",
        "skipTo",
        "toString",
        "locationString",
        "getPath",
        "readEscapeCharacter",
        "syntaxError",
        "consumeNonExecutePrefix",
        "getLineNumber",
        "getColumn"
    ],
    "classes": [
        "JsonReader"
    ]
}