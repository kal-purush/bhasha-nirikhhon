{
    "identifiers": [
        "eu",
        "dariolucia",
        "ccsds",
        "sle",
        "utl",
        "si",
        "com",
        "beanit",
        "jasn1",
        "ber",
        "types",
        "BerInteger",
        "com",
        "beanit",
        "jasn1",
        "ber",
        "types",
        "BerNull",
        "com",
        "beanit",
        "jasn1",
        "ber",
        "types",
        "BerType",
        "eu",
        "dariolucia",
        "ccsds",
        "sle",
        "generated",
        "ccsds",
        "sle",
        "transfer",
        "service",
        "common",
        "pdus",
        "eu",
        "dariolucia",
        "ccsds",
        "sle",
        "generated",
        "ccsds",
        "sle",
        "transfer",
        "service",
        "common",
        "types",
        "Credentials",
        "eu",
        "dariolucia",
        "ccsds",
        "sle",
        "utl",
        "config",
        "PeerConfiguration",
        "eu",
        "dariolucia",
        "ccsds",
        "sle",
        "utl",
        "config",
        "ServiceInstanceConfiguration",
        "eu",
        "dariolucia",
        "ccsds",
        "sle",
        "utl",
        "encdec",
        "CommonEncDec",
        "java",
        "io",
        "java",
        "time",
        "Instant",
        "java",
        "util",
        "java",
        "util",
        "Timer",
        "java",
        "util",
        "TimerTask",
        "java",
        "util",
        "concurrent",
        "atomic",
        "AtomicReference",
        "java",
        "util",
        "concurrent",
        "locks",
        "Condition",
        "java",
        "util",
        "concurrent",
        "locks",
        "ReentrantLock",
        "java",
        "util",
        "logging",
        "Level",
        "java",
        "util",
        "logging",
        "Logger",
        "LOG",
        "Logger",
        "getLogger",
        "getName",
        "FRAME_QUALITY_GOOD",
        "FRAME_QUALITY_ERRED",
        "FRAME_QUALITY_UNDETERMINED",
        "latencyLimit",
        "minReportingCycle",
        "returnTimeoutPeriod",
        "transferBufferSize",
        "deliveryMode",
        "reportingCycle",
        "startTime",
        "endTime",
        "statusMutex",
        "frameSyncLockStatus",
        "LockStatusEnum",
        "OUT_OF_LOCK",
        "symbolSyncLockStatus",
        "LockStatusEnum",
        "OUT_OF_LOCK",
        "subcarrierLockStatus",
        "LockStatusEnum",
        "OUT_OF_LOCK",
        "carrierLockStatus",
        "LockStatusEnum",
        "OUT_OF_LOCK",
        "productionStatus",
        "ProductionStatusEnum",
        "HALTED",
        "encDec",
        "reportingScheduler",
        "bufferMutex",
        "bufferChangedCondition",
        "bufferMutex",
        "newCondition",
        "bufferUnderConstruction",
        "bufferUnderTransmission",
        "bufferActive",
        "latencyTimer",
        "pendingLatencyTimeout",
        "apiConfiguration",
        "serviceInstanceConfiguration",
        "encoderDecoder",
        "apiConfiguration",
        "serviceInstanceConfiguration",
        "encDec",
        "encoderDecoder",
        "deliveryMode",
        "getConfiguredDeliveryMode",
        "Override",
        "registerPduReceptionHandler",
        "handleRafStopInvocation",
        "registerPduReceptionHandler",
        "handleRafScheduleStatusReportInvocation",
        "doCustomSetup",
        "time",
        "carrier",
        "subCarrier",
        "symbol",
        "frame",
        "productionStatus",
        "previousProductionStatus",
        "previousFrameLockStatus",
        "statusMutex",
        "previousProductionStatus",
        "productionStatus",
        "previousFrameLockStatus",
        "frameSyncLockStatus",
        "carrierLockStatus",
        "carrier",
        "subcarrierLockStatus",
        "subCarrier",
        "symbolSyncLockStatus",
        "symbol",
        "frameSyncLockStatus",
        "frame",
        "productionStatus",
        "productionStatus",
        "statusMutex",
        "unlock",
        "currentBufferActive",
        "bufferMutex",
        "currentBufferActive",
        "bufferActive",
        "bufferMutex",
        "unlock",
        "previousFrameLockStatus",
        "LockStatusEnum",
        "IN_LOCK",
        "frame",
        "LockStatusEnum",
        "IN_LOCK",
        "currentBufferActive",
        "deliveryMode",
        "DeliveryModeEnum",
        "OFFLINE",
        "sendLossFrameNotification",
        "time",
        "carrier",
        "subCarrier",
        "symbol",
        "previousProductionStatus",
        "productionStatus",
        "currentBufferActive",
        "deliveryMode",
        "DeliveryModeEnum",
        "OFFLINE",
        "sendProductionStatusChangeNotification",
        "productionStatus",
        "productionStatus",
        "bufferMutex",
        "bufferActive",
        "checkBuffer",
        "addProductionStatusChangeNotification",
        "productionStatus",
        "checkBuffer",
        "bufferChangedCondition",
        "signalAll",
        "bufferMutex",
        "unlock",
        "time",
        "carrierLockStatus",
        "subcarrierLockStatus",
        "symbolSyncLockStatus",
        "bufferMutex",
        "bufferActive",
        "checkBuffer",
        "addLossFrameSyncNotification",
        "time",
        "carrierLockStatus",
        "subcarrierLockStatus",
        "symbolSyncLockStatus",
        "checkBuffer",
        "bufferMutex",
        "unlock",
        "bufferMutex",
        "bufferActive",
        "checkBuffer",
        "addDataDiscardedNotification",
        "checkBuffer",
        "bufferMutex",
        "unlock",
        "bufferMutex",
        "bufferActive",
        "checkBuffer",
        "addEndOfDataNotification",
        "checkBuffer",
        "bufferMutex",
        "unlock",
        "spaceDataUnit",
        "quality",
        "linkContinuity",
        "earthReceiveTime",
        "isPico",
        "antennaId",
        "globalAntennaId",
        "privateAnnotations",
        "bufferMutex",
        "bufferActive",
        "checkBuffer",
        "result",
        "checkAndAddTransferData",
        "spaceDataUnit",
        "quality",
        "linkContinuity",
        "earthReceiveTime",
        "isPico",
        "antennaId",
        "globalAntennaId",
        "privateAnnotations",
        "result",
        "checkBuffer",
        "result",
        "bufferMutex",
        "unlock",
        "spaceDataUnit",
        "quality",
        "linkContinuity",
        "earthReceiveTime",
        "isPico",
        "antennaId",
        "globalAntennaId",
        "privateAnnotations",
        "forceSend",
        "bufferActive",
        "isCurrentBufferEmpty",
        "bufferUnderConstruction",
        "getCurrentBufferItems",
        "bufferUnderConstruction",
        "transferBufferSize",
        "forceSend",
        "stopLatencyTimer",
        "bufferToSend",
        "bufferUnderConstruction",
        "bufferUnderConstruction",
        "createCurrentBuffer",
        "discarded",
        "trySendBuffer",
        "bufferToSend",
        "discarded",
        "addDataDiscardedNotification",
        "startLatencyTimer",
        "bufferChangedCondition",
        "signalAll",
        "bufferUnderConstruction",
        "bufferUnderConstruction",
        "latencyLimit",
        "stopLatencyTimer",
        "pendingLatencyTimeout",
        "Override",
        "pendingLatencyTimeout",
        "get",
        "latencyElapsed",
        "latencyTimer",
        "schedule",
        "pendingLatencyTimeout",
        "get",
        "latencyLimit",
        "bufferMutex",
        "checkBuffer",
        "bufferMutex",
        "unlock",
        "pendingLatencyTimeout",
        "get",
        "pendingLatencyTimeout",
        "get",
        "cancel",
        "pendingLatencyTimeout",
        "bufferToSend",
        "getConfiguredDeliveryMode",
        "DeliveryModeEnum",
        "TIMELY_ONLINE",
        "bufferUnderTransmission",
        "bufferActive",
        "bufferUnderTransmission",
        "bufferChangedCondition",
        "await",
        "e",
        "interrupted",
        "bufferActive",
        "bufferUnderTransmission",
        "dispatchFromProvider",
        "doHandleTransferBufferInvocation",
        "bufferToSend",
        "bufferMutex",
        "bufferUnderTransmission",
        "bufferChangedCondition",
        "signalAll",
        "bufferMutex",
        "unlock",
        "bufferToSend",
        "productionStatus",
        "time",
        "carrierLockStatus",
        "subcarrierLockStatus",
        "symbolSyncLockStatus",
        "startTime",
        "stopTime",
        "startTime",
        "startTime",
        "endTime",
        "stopTime",
        "bufferMutex",
        "bufferActive",
        "bufferUnderTransmission",
        "bufferUnderConstruction",
        "createCurrentBuffer",
        "bufferChangedCondition",
        "signalAll",
        "bufferMutex",
        "unlock",
        "invocation",
        "dispatchFromProvider",
        "doHandleRafStopInvocation",
        "invocation",
        "invocation",
        "clearError",
        "currentState",
        "ServiceInstanceBindingStateEnum",
        "ACTIVE",
        "setError",
        "currentState",
        "notifyStateUpdate",
        "peerAbort",
        "PeerAbortReasonEnum",
        "PROTOCOL_ERROR",
        "authenticate",
        "invocation",
        "getInvokerCredentials",
        "AuthenticationModeEnum",
        "ALL",
        "disconnect",
        "notifyPduReceived",
        "invocation",
        "SleOperationNames",
        "STOP_NAME",
        "getLastPduReceived",
        "notifyStateUpdate",
        "pdu",
        "pdu",
        "setInvokeId",
        "invocation",
        "getInvokeId",
        "pdu",
        "setResult",
        "pdu",
        "getResult",
        "setPositiveResult",
        "creds",
        "generateCredentials",
        "getInitiatorIdentifier",
        "AuthenticationModeEnum",
        "ALL",
        "creds",
        "notifyPduSentError",
        "pdu",
        "SleOperationNames",
        "STOP_RETURN_NAME",
        "notifyStateUpdate",
        "pdu",
        "setCredentials",
        "creds",
        "bufferMutex",
        "bufferActive",
        "bufferChangedCondition",
        "signalAll",
        "bufferMutex",
        "unlock",
        "dispatchFromProvider",
        "resultOk",
        "encodeAndSend",
        "pdu",
        "SleOperationNames",
        "STOP_RETURN_NAME",
        "resultOk",
        "stopLatencyTimer",
        "bufferMutex",
        "bufferActive",
        "bufferUnderTransmission",
        "bufferUnderConstruction",
        "bufferChangedCondition",
        "signalAll",
        "bufferMutex",
        "unlock",
        "setServiceInstanceState",
        "ServiceInstanceBindingStateEnum",
        "READY",
        "resetStartArgumentsOnStop",
        "startTime",
        "endTime",
        "notifyPduSent",
        "pdu",
        "SleOperationNames",
        "STOP_RETURN_NAME",
        "getLastPduSent",
        "notifyStateUpdate",
        "invocation",
        "dispatchFromProvider",
        "doHandleRafScheduleStatusReportInvocation",
        "invocation",
        "invocation",
        "clearError",
        "currentState",
        "ServiceInstanceBindingStateEnum",
        "READY",
        "currentState",
        "ServiceInstanceBindingStateEnum",
        "ACTIVE",
        "setError",
        "currentState",
        "notifyStateUpdate",
        "peerAbort",
        "PeerAbortReasonEnum",
        "PROTOCOL_ERROR",
        "authenticate",
        "invocation",
        "getInvokerCredentials",
        "AuthenticationModeEnum",
        "ALL",
        "disconnect",
        "notifyPduReceived",
        "invocation",
        "SleOperationNames",
        "SCHEDULE_STATUS_REPORT_NAME",
        "getLastPduReceived",
        "notifyStateUpdate",
        "pdu",
        "pdu",
        "setInvokeId",
        "invocation",
        "getInvokeId",
        "pdu",
        "setResult",
        "invocation",
        "getReportRequestType",
        "getImmediately",
        "sendStatusReport",
        "pdu",
        "getResult",
        "setPositiveResult",
        "invocation",
        "getReportRequestType",
        "getStop",
        "reportingScheduler",
        "get",
        "stopStatusReport",
        "pdu",
        "getResult",
        "setPositiveResult",
        "pdu",
        "getResult",
        "setNegativeResult",
        "pdu",
        "getResult",
        "getNegativeResult",
        "setSpecific",
        "invocation",
        "getReportRequestType",
        "getPeriodically",
        "period",
        "invocation",
        "getReportRequestType",
        "getPeriodically",
        "intValue",
        "minReportingCycle",
        "period",
        "minReportingCycle",
        "startStatusReport",
        "period",
        "pdu",
        "getResult",
        "setPositiveResult",
        "pdu",
        "getResult",
        "setNegativeResult",
        "pdu",
        "getResult",
        "getNegativeResult",
        "setSpecific",
        "creds",
        "generateCredentials",
        "getInitiatorIdentifier",
        "AuthenticationModeEnum",
        "ALL",
        "creds",
        "notifyPduSentError",
        "pdu",
        "SleOperationNames",
        "SCHEDULE_STATUS_REPORT_RETURN_NAME",
        "notifyStateUpdate",
        "pdu",
        "setPerformerCredentials",
        "creds",
        "resultOk",
        "encodeAndSend",
        "pdu",
        "SleOperationNames",
        "SCHEDULE_STATUS_REPORT_RETURN_NAME",
        "resultOk",
        "notifyPduSent",
        "pdu",
        "SleOperationNames",
        "SCHEDULE_STATUS_REPORT_RETURN_NAME",
        "getLastPduSent",
        "notifyStateUpdate",
        "period",
        "LOG",
        "isLoggable",
        "Level",
        "INFO",
        "LOG",
        "info",
        "format",
        "getServiceInstanceIdentifier",
        "period",
        "reportingCycle",
        "period",
        "reportingScheduler",
        "reportingScheduler",
        "get",
        "schedule",
        "Override",
        "reportingScheduler",
        "get",
        "dispatchFromProvider",
        "sendStatusReport",
        "period",
        "LOG",
        "isLoggable",
        "Level",
        "INFO",
        "LOG",
        "info",
        "format",
        "getServiceInstanceIdentifier",
        "reportingCycle",
        "reportingScheduler",
        "get",
        "cancel",
        "reportingScheduler",
        "immediate",
        "immediate",
        "reportingScheduler",
        "get",
        "pdu",
        "buildStatusReportPdu",
        "pdu",
        "resultOk",
        "encodeAndSend",
        "pdu",
        "SleOperationNames",
        "STATUS_REPORT_NAME",
        "resultOk",
        "notifyPduSent",
        "pdu",
        "SleOperationNames",
        "STATUS_REPORT_NAME",
        "getLastPduSent",
        "notifyStateUpdate",
        "Override",
        "pdu",
        "encDec",
        "decode",
        "pdu",
        "Override",
        "pdu",
        "encDec",
        "encode",
        "pdu",
        "Override",
        "version",
        "encDec",
        "useSleVersion",
        "version",
        "Override",
        "stopLatencyTimer",
        "bufferMutex",
        "bufferActive",
        "bufferUnderTransmission",
        "bufferUnderConstruction",
        "bufferChangedCondition",
        "signalAll",
        "bufferMutex",
        "unlock",
        "doResetState",
        "startTime",
        "endTime",
        "reportingCycle",
        "statusMutex",
        "frameSyncLockStatus",
        "LockStatusEnum",
        "UNKNOWN",
        "symbolSyncLockStatus",
        "LockStatusEnum",
        "UNKNOWN",
        "subcarrierLockStatus",
        "LockStatusEnum",
        "UNKNOWN",
        "carrierLockStatus",
        "LockStatusEnum",
        "UNKNOWN",
        "productionStatus",
        "ProductionStatusEnum",
        "UNKNOWN",
        "statusMutex",
        "unlock",
        "Override"
    ],
    "literals": [
        "\"Stop received from user, but service instance is in state \"",
        "\"Stop invocation received, but wrong credentials\"",
        "\"Schedule status report received from user, but service instance is in state \"",
        "\"Schedule status report received, but wrong credentials\"",
        "\"%s: Scheduling status report with period %d\"",
        "\"%s: Stopping status report\""
    ],
    "variables": [
        "latencyLimit",
        "minReportingCycle",
        "returnTimeoutPeriod",
        "transferBufferSize",
        "encDec",
        "previousProductionStatus",
        "previousFrameLockStatus",
        "currentBufferActive"
    ],
    "comments": [
        "Read from configuration, retrieved via GET_PARAMETER",
        "NULL if offline, otherwise a value",
        "Updated via START and GET_PARAMETER",
        "NULL if off, otherwise a value",
        "NOSONAR no manipulation expected",
        "NOSONAR no manipulation expected",
        "Requested via STATUS_REPORT, updated externally (therefore they are protected via separate lock)",
        "Encoder/decoder",
        "Status report scheduler",
        "Transfer buffer under construction",
        "Latency timer",
        "Register handlers",
        "We lost the frame lock, we need to send a notification",
        "We changed production status, we need to send a notification",
        "If the state is not correct, say bye",
        "Here we check immediately if the buffer is full: if so, we send it",
        "Add the PDU to the buffer, there must be free space by algorithm implementation",
        "We send it immediately",
        "If the state is not correct, say bye",
        "Here we check immediately if the buffer is full: if so, we send it",
        "Add the PDU to the buffer, there must be free space by algorithm implementation",
        "We send it immediately",
        "If the state is not correct, say bye",
        "Here we check immediately if the buffer is full: if so, we send it",
        "Add the PDU to the buffer, there must be free space by algorithm implementation",
        "No need to send it immediately",
        "If the state is not correct, say bye",
        "Here we check immediately if the buffer is full: if so, we send it",
        "Add the PDU to the buffer, there must be free space by algorithm implementation",
        "We send it immediately",
        "NOSONAR: creation of an additional object is avoided for performance reasons",
        "If the state is not correct, say bye",
        "Here we check immediately if the buffer is full: if so, we send it",
        "Under sync on this.bufferMutex",
        "NOSONAR for performance reasons, creation of a single argument object is avoided",
        "Under sync on this.bufferMutex",
        "No data, nothing to do",
        "Stop the latency timer",
        "Try to send the buffer: replace the buffer with a new one",
        "If discarded, add a sync notification about it",
        "I do not call this recursively, we are under lock: if there transfer buffer is set with 1 item, anyway go out",
        "and at the next call, it will be sent ... or not",
        "Start the latency timer",
        "Signal the change",
        "No timer",
        "Elapsed, send the buffer if needed",
        "Add the PDU to the buffer, there must be free space by algorithm implementation",
        "Under sync on this.bufferMutex",
        "Here we check the delivery mode",
        "Timely mode: if there is a buffer in transmission, you have to discard the buffer",
        "Complete mode: wait",
        "NOSONAR: sorry to say, but this rule is pointless, to be disabled in the profile",
        "Buffer discarded",
        "Set transmission flag",
        "Send the buffer",
        "Not discarded",
        "Under sync on this.bufferMutex",
        "Under sync on this.bufferMutex",
        "Under sync on this.bufferMutex",
        "Under sync on this.bufferMutex",
        "To be called in the start handling method",
        "Set times",
        "Activate capability to send frames and notifications",
        "Validate state",
        "Process the STOP",
        "Validate credentials",
        "From the API configuration (remote peers) and SI configuration (remote peer),",
        "check remote peer and check if authentication must be used.",
        "If so, verify credentials.",
        "Add credentials",
        "From the API configuration (remote peers) and SI configuration (responder",
        "id), check remote peer and check if authentication must be used.",
        "Error while generating credentials, set by generateCredentials()",
        "Stop the ability to add transfer frames: pending buffers in the executor queue will still be processed",
        "and sent. As soon as the STOP-RETURN is sent, the state will go to READY and pending buffers will be discarded.",
        "Stop the latency timer",
        "Schedule this last part in the management thread",
        "If all fine, transition to new state: READY and notify PDU sent",
        "Set the requested frame quality",
        "Set times",
        "Notify PDU",
        "Generate state and notify update",
        "Validate state",
        "Process the SCHEDULE-STATUS-REPORT",
        "Validate credentials",
        "From the API configuration (remote peers) and SI configuration (remote peer),",
        "check remote peer and check if authentication must be used.",
        "If so, verify credentials.",
        "Already stopped",
        "Invalid reporting cycle",
        "Add credentials",
        "From the API configuration (remote peers) and SI configuration (responder",
        "id), check remote peer and check if authentication must be used.",
        "Error while generating credentials, set by generateCredentials()",
        "Notify PDU",
        "Generate state and notify update",
        "Notify PDU",
        "Generate state and notify update",
        "buildCurrentState is type-dependant",
        "Read from configuration, updated via GET_PARAMETER",
        "Updated via START and GET_PARAMETER",
        "NULL if off, otherwise a value",
        "Updated via STATUS_REPORT"
    ],
    "docstrings": [
        "*   Copyright (c) 2019 Dario Lucia (https://www.dariolucia.eu)\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *        http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.",
        "* One object of this class represents an return Service Instance (provider role)."
    ],
    "functions": [
        "ReturnServiceInstanceProvider",
        "setup",
        "doCustomSetup",
        "updateProductionStatus",
        "sendProductionStatusChangeNotification",
        "sendLossFrameNotification",
        "dataDiscarded",
        "endOfData",
        "transferData",
        "checkAndAddTransferData",
        "checkBuffer",
        "K",
        "createCurrentBuffer",
        "getCurrentBufferItems",
        "isCurrentBufferEmpty",
        "startLatencyTimer",
        "run",
        "latencyElapsed",
        "stopLatencyTimer",
        "trySendBuffer",
        "clearBufferTransmissionFlag",
        "doHandleTransferBufferInvocation",
        "DeliveryModeEnum",
        "getConfiguredDeliveryMode",
        "addProductionStatusChangeNotification",
        "addDataDiscardedNotification",
        "addLossFrameSyncNotification",
        "addEndOfDataNotification",
        "initialiseTransferBufferActivation",
        "handleRafStopInvocation",
        "doHandleRafStopInvocation",
        "resetStartArgumentsOnStop",
        "handleRafScheduleStatusReportInvocation",
        "doHandleRafScheduleStatusReportInvocation",
        "startStatusReport",
        "run",
        "stopStatusReport",
        "sendStatusReport",
        "BerType",
        "buildStatusReportPdu",
        "decodePdu",
        "encodePdu",
        "updateHandlersForVersion",
        "resetState",
        "doResetState",
        "isUserSide"
    ],
    "classes": [
        "ReturnServiceInstanceProvider"
    ]
}