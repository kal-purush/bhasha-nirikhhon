{
    "identifiers": [
        "BrokerConfigType",
        "Quote",
        "ccxt",
        "getConfig",
        "getLogger",
        "toQuote",
        "getConfig",
        "process",
        "process",
        "keys",
        "process",
        "process",
        "keys",
        "envs",
        "ccxt",
        "envs",
        "config",
        "BrokerAdapterImpl",
        "config",
        "getLogger",
        "main",
        "keys",
        "config",
        "keys",
        "demoMode",
        "config",
        "process",
        "symbol",
        "response",
        "orderBooksResponse",
        "orderBooksResponse",
        "asks",
        "q",
        "toQuote",
        "q",
        "q",
        "orderBooksResponse",
        "bids",
        "q",
        "toQuote",
        "q",
        "q",
        "mappedAsks",
        "mappedBids",
        "balance"
    ],
    "literals": [
        "\"../config\"",
        "\"../types\"",
        "\"ccxt\"",
        "\"dotenv/config\"",
        "\"../config/configLoader\"",
        "\"../logger\"",
        "\"../util\"",
        "\"Bitbank\"",
        "${this.broker}Adapter",
        "${this.broker} is enabled but it doesn't have TOKEN and/or SECRET!",
        "\"Ask\"",
        "\"Bid\""
    ],
    "variables": [
        "keys",
        "response",
        "asks",
        "mappedAsks",
        "bids",
        "mappedBids",
        "balance"
    ],
    "comments": [
        "eslint-disable-next-line new-cap",
        "implements BrokerAdapter",
        "async send(order: Order): Promise<void> {\n    if(order.broker !== this.broker){\n      throw new Error();\n    }\n    const strategy = this.strategyMap.get(order.cashMarginType);\n    if(strategy === undefined){\n      throw new Error(`Unable to find a strategy for ${order.cashMarginType}.`);\n    }\n    await strategy.send(order);\n  }\n\n  async cancel(order: Order): Promise<void> {\n    const orderId = order.brokerOrderId;\n    const reply = await this.api.cancelOrder(orderId);\n    if(!reply.success){\n      throw new Error(`Cancel ${orderId} failed.`);\n    }\n    order.lastUpdated = new Date();\n    order.status = \"Canceled\";\n  }\n\n  async refresh(order: Order): Promise<void> {\n    const reply = await this.api.getOpenOrders();\n    const brokerOrder = _.find(reply.orders, o => o.id === order.brokerOrderId);\n    if(brokerOrder !== undefined){\n      if(brokerOrder.pending_amount === undefined || brokerOrder.pending_amount === 0){\n        throw new Error(\"Unexpected reply returned.\");\n      }\n      order.filledSize = eRound(order.size - brokerOrder.pending_amount);\n      if(order.filledSize > 0){\n        order.status = \"PartiallyFilled\";\n      }\n      order.lastUpdated = new Date();\n      return;\n    }\n    const from = addMinutes(order.creationTime, -1);\n    const transactions = (await this.api.getTransactionsWithStartDate(from)).filter(\n      x => x.order_id === order.brokerOrderId\n    );\n    if(transactions.length === 0){\n      logger.warn(\"The order is not found in pending orders and historical orders.\");\n      return;\n    }\n    order.executions = transactions.map(x => {\n      const execution = toExecution(order);\n      execution.execTime = x.created_at;\n      execution.price = x.rate;\n      execution.size = Math.abs(x.funds.btc);\n      return execution as Execution;\n    });\n    order.filledSize = eRound(_.sumBy(order.executions, x => x.size));\n    order.status = almostEqual(order.filledSize, order.size, 1) ? \"Filled\" : \"Canceled\";\n    order.lastUpdated = new Date();\n  }"
    ],
    "docstrings": [],
    "functions": [
        "main",
        "create",
        "fetchQuotes",
        "mapToQuote",
        "getBtcPosition"
    ],
    "classes": [
        "BrokerAdapterImpl"
    ]
}