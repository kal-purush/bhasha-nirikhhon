{
    "identifiers": [
        "logger",
        "redisConnection",
        "supabase_service",
        "Sentry",
        "withAuth",
        "getACUC",
        "setCachedACUC",
        "redis",
        "BATCH_LOCK_KEY",
        "LOCK_TIMEOUT",
        "result",
        "acquired",
        "logger",
        "acquired",
        "redis",
        "BATCH_LOCK_KEY",
        "logger",
        "acquireLock",
        "operations",
        "BATCH_SIZE",
        "redis",
        "BATCH_KEY",
        "op",
        "operations",
        "op",
        "operations",
        "logger",
        "logger",
        "operations",
        "op",
        "operations",
        "op",
        "op",
        "op",
        "groupedOperations",
        "key",
        "groupedOperations",
        "key",
        "op",
        "op",
        "op",
        "groupedOperations",
        "key",
        "group",
        "op",
        "group",
        "op",
        "groupedOperations",
        "logger",
        "group",
        "group",
        "group",
        "group",
        "group",
        "group",
        "group",
        "group",
        "group",
        "logger",
        "group",
        "withAuth",
        "supaBillTeam",
        "group",
        "group",
        "group",
        "logger",
        "group",
        "logger",
        "group",
        "group",
        "error",
        "logger",
        "group",
        "Sentry",
        "error",
        "group",
        "group",
        "logger",
        "error",
        "logger",
        "Sentry",
        "error",
        "releaseLock",
        "NodeJS",
        "batchInterval",
        "logger",
        "batchInterval",
        "setInterval",
        "redisConnection",
        "BATCH_KEY",
        "logger",
        "queueLength",
        "processBillingBatch",
        "BATCH_TIMEOUT",
        "batchInterval",
        "team_id",
        "subscription_id",
        "credits",
        "is_extract",
        "team_id",
        "team_id",
        "logger",
        "team_id",
        "logger",
        "team_id",
        "subscription_id",
        "redis",
        "BATCH_KEY",
        "operation",
        "redis",
        "BATCH_KEY",
        "logger",
        "queueLength",
        "startBillingBatchProcessing",
        "queueLength",
        "BATCH_SIZE",
        "logger",
        "processBillingBatch",
        "error",
        "logger",
        "Sentry",
        "error",
        "team_id",
        "subscription_id",
        "credits",
        "__logger",
        "is_extract",
        "__logger",
        "logger",
        "team_id",
        "subscription_id",
        "team_id",
        "team_id",
        "_logger",
        "team_id",
        "credits",
        "supabase_service",
        "team_id",
        "subscription_id",
        "subscription_id",
        "is_extract",
        "error",
        "Sentry",
        "error",
        "_logger",
        "apiKey",
        "data",
        "x",
        "x",
        "setCachedACUC",
        "apiKey",
        "acuc",
        "acuc",
        "acuc",
        "acuc",
        "credits",
        "acuc",
        "credits",
        "acuc",
        "credits",
        "error",
        "_logger",
        "process",
        "batchInterval",
        "clearInterval",
        "batchInterval",
        "batchInterval",
        "logger",
        "processBillingBatch"
    ],
    "literals": [
        "\"../../lib/logger\"",
        "\"../queue-service\"",
        "\"../supabase\"",
        "\"@sentry/node\"",
        "\"bullmq\"",
        "\"../../lib/withAuth\"",
        "\"../../controllers/auth\"",
        "\"billing_batch\"",
        "\"billing_batch_lock\"",
        "string",
        "string",
        "string",
        "string",
        "string",
        "\"1\"",
        "\"PX\"",
        "\"NX\"",
        "\"OK\"",
        "\"ðŸ”’ Acquired billing batch processing lock\"",
        "\"ðŸ”“ Released billing batch processing lock\"",
        "\"No billing operations to process in batch\"",
        "ðŸ“¦ Processing batch of ${operations.length} billing operations",
        "string",
        "${op.team_id}:${op.subscription_id ?? 'null'}:${op.is_extract}",
        "'null'",
        "ðŸ”„ Billing team ${group.team_id} for ${group.total_credits} credits",
        "\"preview\"",
        "\"preview_\"",
        "Skipping billing for preview team ${group.team_id}",
        "\"No DB, bypassed.\"",
        "âœ… Successfully billed team ${group.team_id} for ${group.total_credits} credits",
        "âŒ Failed to bill team ${group.team_id}",
        "\"batch_billing\"",
        "\"âœ… Billing batch processing completed successfully\"",
        "\"Error processing billing batch\"",
        "\"batch_billing_process\"",
        "\"ðŸ”„ Starting periodic billing batch processing\"",
        "Checking billing batch queue (${queueLength} items pending)",
        "string",
        "string",
        "\"preview\"",
        "\"preview_\"",
        "Skipping billing queue for preview team ${team_id}",
        "\"Preview team, no credits used\"",
        "Queueing billing operation for team ${team_id}",
        "ðŸ“¥ Added billing operation to queue (${queueLength} total pending)",
        "\"ðŸ”„ Billing queue reached batch size, triggering immediate processing\"",
        "\"Error queueing billing operation\"",
        "\"queue_billing\"",
        "string",
        "string",
        "\"credit_billing\"",
        "\"supaBillTeam\"",
        "\"preview\"",
        "\"preview_\"",
        "\"Preview team, no credits used\"",
        "Batch billing team ${team_id} for ${credits} credits",
        "\"bill_team_w_extract_3\"",
        "\"Failed to bill team.\"",
        "\"Failed to update cached credits\"",
        "\"beforeExit\"",
        "\"Stopped periodic billing batch processing\""
    ],
    "variables": [
        "BATCH_KEY",
        "BATCH_LOCK_KEY",
        "BATCH_SIZE",
        "BATCH_TIMEOUT",
        "LOCK_TIMEOUT",
        "redis",
        "redisConnection",
        "result",
        "acquired",
        "redis",
        "redisConnection",
        "redis",
        "redisConnection",
        "operations",
        "op",
        "groupedOperations",
        "key",
        "group",
        "key",
        "group",
        "batchInterval",
        "queueLength",
        "operation",
        "redis",
        "redisConnection",
        "queueLength",
        "_logger"
    ],
    "comments": [
        "Configuration constants",
        "Batch size for processing",
        "15 seconds processing interval",
        "30 seconds lock timeout",
        "Define interfaces for billing operations",
        "Grouped billing operations for batch processing",
        "Function to acquire a lock for batch processing",
        "Set lock with NX (only if it doesn't exist) and PX (millisecond expiry)",
        "Function to release the lock",
        "Main function to process the billing batch",
        "Try to acquire lock",
        "Get all operations from Redis list",
        "Group operations by team_id and subscription_id",
        "Process each group of operations",
        "Skip billing for preview teams",
        "Execute the actual billing",
        "Start periodic batch processing",
        "Unref to not keep process alive",
        "Add a billing operation to the queue",
        "Skip queuing for preview teams",
        "Add operation to Redis list",
        "Start batch processing if not already started",
        "If we have enough items, trigger immediate processing",
        "TODO is there a better way to do this?",
        "Update cached credits used immediately to provide accurate feedback to users",
        "This is optimistic - actual billing happens in batch",
        "Should we add this?",
        "I guess batch is fast enough that it's fine",
        "if (process.env.USE_DB_AUTHENTICATION === \"true\") {",
        "(async () => {",
        "// Get API keys for this team to update in cache",
        "const { data } = await supabase_service",
        ".from(\"api_keys\")",
        ".select(\"key\")",
        ".eq(\"team_id\", team_id);",
        "for (const apiKey of (data ?? []).map(x => x.key)) {",
        "await setCachedACUC(apiKey, (acuc) =>",
        "acuc",
        "? {",
        "...acuc,",
        "credits_used: acuc.credits_used + credits,",
        "adjusted_credits_used: acuc.adjusted_credits_used + credits,",
        "remaining_credits: acuc.remaining_credits - credits,",
        "}",
        ": null,",
        ");",
        "}",
        "})().catch(error => {",
        "logger.error(\"Failed to update cached credits\", { error, team_id });",
        "});",
        "}",
        "Modified version of the billing function for batch operations",
        "Perform the actual database operation",
        "Update cached ACUC to reflect the new credit usage",
        "Cleanup on exit"
    ],
    "docstrings": [],
    "functions": [
        "acquireLock",
        "releaseLock",
        "processBillingBatch",
        "startBillingBatchProcessing",
        "queueBillingOperation",
        "supaBillTeam"
    ],
    "classes": []
}