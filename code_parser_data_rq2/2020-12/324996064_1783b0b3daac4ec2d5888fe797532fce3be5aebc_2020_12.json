{
    "identifiers": [
        "cv2",
        "numpy",
        "np",
        "img",
        "cv2",
        "threshold",
        "img",
        "cv2",
        "THRESH_BINARY",
        "cv2",
        "THRESH_OTSU",
        "img_bin",
        "np",
        "array",
        "img",
        "shape",
        "cv2",
        "getStructuringElement",
        "cv2",
        "MORPH_RECT",
        "kernel_len",
        "cv2",
        "getStructuringElement",
        "cv2",
        "MORPH_RECT",
        "kernel_len",
        "cv2",
        "getStructuringElement",
        "cv2",
        "MORPH_RECT",
        "cv2",
        "erode",
        "img_bin",
        "ver_kernel",
        "iterations",
        "cv2",
        "dilate",
        "image_1",
        "ver_kernel",
        "iterations",
        "cv2",
        "erode",
        "img_bin",
        "hor_kernel",
        "iterations",
        "cv2",
        "dilate",
        "image_2",
        "hor_kernel",
        "iterations",
        "cv2",
        "addWeighted",
        "vertical_lines",
        "horizontal_lines",
        "cv2",
        "erode",
        "img_vh",
        "kernel",
        "iterations",
        "cv2",
        "threshold",
        "img_vh",
        "cv2",
        "THRESH_BINARY",
        "cv2",
        "THRESH_OTSU",
        "cv2",
        "bitwise_xor",
        "img",
        "img_vh",
        "cv2",
        "bitwise_not",
        "bitxor",
        "cv2",
        "findContours",
        "img_vh",
        "cv2",
        "RETR_TREE",
        "cv2",
        "CHAIN_APPROX_SIMPLE",
        "cnts",
        "method",
        "method",
        "method",
        "method",
        "method",
        "cv2",
        "boundingRect",
        "c",
        "c",
        "cnts",
        "sorted",
        "cnts",
        "boundingBoxes",
        "key",
        "b",
        "b",
        "i",
        "reverse",
        "reverse",
        "cnts",
        "boundingBoxes",
        "contours",
        "area_threshold",
        "c",
        "contours",
        "cv2",
        "boundingRect",
        "c",
        "w",
        "h",
        "area_threshold",
        "boxes",
        "append",
        "x",
        "y",
        "w",
        "h",
        "boxes",
        "img",
        "boxes",
        "origin",
        "color",
        "stroke",
        "img",
        "copy",
        "box",
        "boxes",
        "box",
        "x",
        "origin",
        "y",
        "origin",
        "cv2",
        "rectangle",
        "new_img",
        "x",
        "y",
        "x",
        "w",
        "y",
        "h",
        "color",
        "stroke",
        "new_img",
        "img",
        "threshold",
        "cv2",
        "cvtColor",
        "img",
        "cv2",
        "COLOR_BGR2GRAY",
        "threshold",
        "ValueError",
        "img",
        "shape",
        "img",
        "shape",
        "get_table_contours",
        "img_gray",
        "sort_contours",
        "contours",
        "method",
        "contours_to_boxes",
        "contours",
        "img_area",
        "threshold",
        "boxes",
        "cv2",
        "imread",
        "file",
        "recognize_bordered_table",
        "img",
        "cv2",
        "imshow",
        "draw_boxes",
        "img",
        "boxes",
        "cv2",
        "waitKey"
    ],
    "literals": [
        "\"left-to-right\"",
        "\"right-to-left\"",
        "\"bottom-to-top\"",
        "\"top-to-bottom\"",
        "\"bottom-to-top\"",
        "'Threshold should be a value between 0 and 1'",
        "\"top-to-bottom\"",
        "'__main__'",
        "r'images_2/49.PNG'",
        "'i'"
    ],
    "variables": [
        "thresh",
        "img_bin",
        "img_bin",
        "kernel_len",
        "ver_kernel",
        "hor_kernel",
        "kernel",
        "image_1",
        "vertical_lines",
        "image_2",
        "horizontal_lines",
        "img_vh",
        "img_vh",
        "thresh",
        "img_vh",
        "bitxor",
        "bitnot",
        "reverse",
        "i",
        "reverse",
        "i",
        "boundingBoxes",
        "cnts",
        "boundingBoxes",
        "boxes",
        "x",
        "y",
        "w",
        "h",
        "new_img",
        "x",
        "y",
        "w",
        "h",
        "img_gray",
        "img_area",
        "contours",
        "hierarchy",
        "contours",
        "boundingBoxes",
        "boxes",
        "file",
        "img",
        "boxes"
    ],
    "comments": [
        "thresholding the image to a binary image",
        "inverting the image",
        "Length(width) of kernel as 100th of total width",
        "Defining a vertical kernel to detect all vertical lines of image",
        "Defining a horizontal kernel to detect all horizontal lines of image",
        "A kernel of 2x2",
        "Combine horizontal and vertical lines in a new third image, with both having same weight.",
        "Eroding and thesholding the image",
        "initialize the reverse flag and sort index",
        "handle if we need to sort in reverse",
        "handle if we are sorting against the y-coordinate rather than",
        "the x-coordinate of the bounding box",
        "construct the list of bounding boxes and sort them from top to",
        "bottom",
        "return the list of sorted contours and bounding boxes",
        "image = cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2)",
        "Sort all the contours by top to bottom.",
        "read your file",
        "#Creating a list of heights for all detected boxes",
        "heights = [boundingBoxes[i][3] for i in range(len(boundingBoxes))]",
        "#Get mean of heights",
        "mean = np.mean(heights)",
        "#Creating two lists to define row and column in which cell is located",
        "row=[]",
        "column=[]",
        "j=0",
        "#Sorting the boxes to their respective row and column",
        "for i in range(len(box)):",
        "if(i==0):",
        "column.append(box[i])",
        "previous=box[i]",
        "else:",
        "if(box[i][1]<=previous[1]+mean/2):",
        "column.append(box[i])",
        "previous=box[i]",
        "if(i==len(box)-1):",
        "row.append(column)",
        "else:",
        "row.append(column)",
        "column=[]",
        "previous = box[i]",
        "column.append(box[i])",
        "print(column)",
        "print(row)",
        "#calculating maximum number of cells",
        "countcol = 0",
        "for i in range(len(row)):",
        "countcol = len(row[i])",
        "if countcol > countcol:",
        "countcol = countcol",
        "#Retrieving the center of each column",
        "center = [int(row[i][j][0]+row[i][j][2]/2) for j in range(len(row[i])) if row[0]]",
        "center=np.array(center)",
        "center.sort()",
        "#Regarding the distance to the columns center, the boxes are arranged in respective order",
        "finalboxes = []",
        "for i in range(len(row)):",
        "lis=[]",
        "for k in range(countcol):",
        "lis.append([])",
        "for j in range(len(row[i])):",
        "diff = abs(center-(row[i][j][0]+row[i][j][2]/4))",
        "minimum = min(diff)",
        "indexing = list(diff).index(minimum)",
        "lis[indexing].append(row[i][j])",
        "finalboxes.append(lis)",
        "cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 2)"
    ],
    "docstrings": [],
    "functions": [
        "get_table_contours",
        "sort_contours",
        "contours_to_boxes",
        "draw_boxes",
        "recognize_bordered_table"
    ],
    "classes": []
}