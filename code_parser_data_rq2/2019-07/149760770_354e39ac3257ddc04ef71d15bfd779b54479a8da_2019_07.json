{
    "identifiers": [
        "Lint",
        "isTypeFlagSet",
        "ts",
        "Lint",
        "Lint",
        "Lint",
        "OPTION_IGNORE_ARROW_FUNCTION_SHORTHAND",
        "OPTION_IGNORE_PATTERNS",
        "OPTION_IGNORE_PATTERNS",
        "OPTION_IGNORE_ARROW_FUNCTION_SHORTHAND",
        "OPTION_IGNORE_PATTERNS",
        "OPTION_IGNORE_PATTERNS",
        "Lint",
        "sourceFile",
        "ts",
        "program",
        "ts",
        "Lint",
        "OPTION_IGNORE_ARROW_FUNCTION_SHORTHAND",
        "OPTION_IGNORE_PATTERNS",
        "ignorePatterns",
        "arg",
        "arg",
        "arg",
        "OPTION_IGNORE_PATTERNS",
        "sourceFile",
        "walk",
        "program",
        "OPTION_IGNORE_ARROW_FUNCTION_SHORTHAND",
        "OPTION_IGNORE_PATTERNS",
        "ctx",
        "Lint",
        "checker",
        "ts",
        "ts",
        "sourceFile",
        "forEachChildWalker",
        "node",
        "ts",
        "isPossiblyVoidExpression",
        "node",
        "isParentAllowedVoid",
        "node",
        "isTypeFlagSet",
        "checker",
        "node",
        "ts",
        "ignorePatterns",
        "p",
        "p",
        "node",
        "ctx",
        "node",
        "Rule",
        "ts",
        "node",
        "forEachChildWalker",
        "node",
        "ts",
        "node",
        "ts",
        "ts",
        "ignoreArrowFunctionShorthand",
        "ts",
        "isParentAllowedVoid",
        "node",
        "ts",
        "node",
        "ts",
        "node",
        "ts",
        "ts",
        "ts"
    ],
    "literals": [
        "\"tslint\"",
        "\"tsutils\"",
        "\"typescript\"",
        "\"ignore-arrow-function-shorthand\"",
        "\"ignore-patterns\"",
        "\"no-void-expression-smart\"",
        "\"Requires expressions of type `void` to appear in statement position.\"",
        "If \\`${OPTION_IGNORE_ARROW_FUNCTION_SHORTHAND}\\` is provided, \\`() => returnsVoid()\\` will be allowed.\n            Otherwise, it must be written as \\`() => { returnsVoid(); }\\`.\n            You can provide \\`${OPTION_IGNORE_PATTERNS}\\` option as array of regex patterns to skip linting for\n            particular code, f.e. \\`{ \"${OPTION_IGNORE_PATTERNS}\": [\"\\(\\) => skipMe\\(\\)\"] }\\",
        "\"list\"",
        "\"string\"",
        "\"object\"",
        "\"array\"",
        "\"string\"",
        "It's misleading returning the results of an expression whose type is \\`void\\`.\n            Attempting to do so is likely a symptom of expecting a different return type from a function.\n            For example, the following code will log \\`undefined\\` but looks like it logs a value:\n            \\`\\`\\`\n            const performWork = (): void => {\n                workFirst();\n                workSecond();\n            };\n            console.log(performWork());\n            \\`\\`\\`",
        "\"functionality\"",
        "\"Expression has type `void`. Put it on its own line as a statement.\"",
        "string",
        "string",
        "string"
    ],
    "variables": [
        "OPTION_IGNORE_ARROW_FUNCTION_SHORTHAND",
        "OPTION_IGNORE_PATTERNS",
        "ignoreArrowFunctionShorthand",
        "ctx"
    ],
    "comments": [
        "This is a copy of `no-void-expression` rule \n  extended with `ignore-patterns` option.",
        "Something like \"x && console.log(x)\".",
        "Something like \"!!cond ? console.log(true) : console.log(false)\""
    ],
    "docstrings": [],
    "functions": [
        "applyWithProgram",
        "walk",
        "forEachChildWalker",
        "isParentAllowedVoid",
        "isPossiblyVoidExpression"
    ],
    "classes": [
        "Rule"
    ]
}