{
    "identifiers": [
        "Gloss",
        "GlossState",
        "PostBulkGlossesRequestBody",
        "createRoute",
        "z",
        "authorize",
        "Prisma",
        "client",
        "createRoute",
        "z",
        "z",
        "z",
        "z",
        "z",
        "z",
        "GlossState",
        "authorize",
        "req",
        "req",
        "req",
        "res",
        "client",
        "req",
        "language",
        "res",
        "req",
        "gloss",
        "GlossState",
        "state",
        "gloss",
        "state",
        "entriesToPatch",
        "client",
        "tx",
        "tx",
        "language",
        "entriesToPatch",
        "wordId",
        "data",
        "wordId",
        "data",
        "tx",
        "Prisma",
        "entriesToPatch",
        "Prisma",
        "language",
        "wordId",
        "gloss",
        "state",
        "oldGlosses",
        "wordId",
        "GlossState",
        "patchedGlosses",
        "tx",
        "Prisma",
        "patchedGlosses",
        "patchedGloss",
        "oldGlosses",
        "patchedGloss",
        "Prisma",
        "language",
        "req",
        "patchedGloss",
        "patchedGloss",
        "oldGloss",
        "patchedGloss",
        "oldGloss",
        "res"
    ],
    "literals": [
        "'@translation/api-types'",
        "'../../../../../shared/Route'",
        "'zod'",
        "'../../../../../shared/access-control/authorize'",
        "'../../../../../shared/db'",
        "string",
        "'translate'",
        "'Language'",
        "''",
        "INSERT INTO \"Gloss\"(\"languageId\", \"wordId\", \"gloss\", \"state\") VALUES ${Prisma.join(\n              entriesToPatch.map(\n                ({ wordId, gloss, state }) =>\n                  Prisma.sql`(${language.id}::uuid, ${wordId}, ${gloss}, ${\n                    state ?? oldGlosses[wordId]?.state ?? GlossState.Unapproved\n                  }::\"GlossState\")`\n              )\n            )}\n            ON CONFLICT (\"languageId\", \"wordId\")\n                DO UPDATE SET \n                    \"gloss\" = COALESCE(EXCLUDED.\"gloss\", \"Gloss\".\"gloss\"),\n                    \"state\" = COALESCE(EXCLUDED.\"state\", \"Gloss\".\"state\")\n            RETURNING *;",
        "(${language.id}::uuid, ${wordId}, ${gloss}, ${\n                    state ?? oldGlosses[wordId]?.state ?? GlossState.Unapproved\n                  }::\"GlossState\")",
        "INSERT INTO \"GlossHistoryEntry\"(\"languageId\", \"userId\", \"wordId\", \"gloss\", \"state\", \"source\") \n            VALUES ${Prisma.join(\n              patchedGlosses.map((patchedGloss) => {\n                const oldGloss = oldGlosses[patchedGloss.wordId];\n                return Prisma.sql`\n                    (${language.id}::uuid, \n                    ${req.session?.user?.id}::uuid, \n                    ${patchedGloss.wordId}, \n                    NULLIF(${patchedGloss.gloss}, ${oldGloss?.gloss}), \n                    NULLIF(${patchedGloss.state}, ${oldGloss?.state})::\"GlossState\", \n                    'USER')`;\n              })\n            )}",
        "(${language.id}::uuid, \n                    ${req.session?.user?.id}::uuid, \n                    ${patchedGloss.wordId}, \n                    NULLIF(${patchedGloss.gloss}, ${oldGloss?.gloss}), \n                    NULLIF(${patchedGloss.state}, ${oldGloss?.state})::\"GlossState\", \n                    'USER')"
    ],
    "variables": [
        "language",
        "entriesToPatch",
        "wordId",
        "oldGlosses",
        "patchedGlosses",
        "oldGloss"
    ],
    "comments": [
        "If the gloss is empty, the state should be unapproved",
        "If the gloss is undefined and the state is undefined, nothing will be updated, making the entry useless.",
        "We can't use execute raw because we need the returned rows. See https://stackoverflow.com/questions/75191559/using-prisma-how-can-i-insert-using-executeraw-function-and-return-the-values"
    ],
    "docstrings": [],
    "functions": [
        "handler"
    ],
    "classes": []
}