{
    "identifiers": [
        "torch",
        "pina",
        "utils",
        "check_consistency",
        "torch",
        "nn",
        "Module",
        "input_dimension",
        "periods",
        "output_dimension",
        "check_consistency",
        "periods",
        "check_consistency",
        "input_dimension",
        "output_dimension",
        "check_consistency",
        "output_dimension",
        "torch",
        "nn",
        "Linear",
        "input_dimension",
        "output_dimension",
        "torch",
        "nn",
        "Identity",
        "isinstance",
        "periods",
        "all",
        "isinstance",
        "dim",
        "isinstance",
        "period",
        "dim",
        "period",
        "periods",
        "items",
        "periods",
        "k",
        "periods",
        "k",
        "input_dimension",
        "x",
        "torch",
        "stack",
        "torch",
        "pi",
        "torch",
        "tensor",
        "val",
        "device",
        "x",
        "device",
        "val",
        "_period",
        "values",
        "dim",
        "_get_vars",
        "x",
        "_period",
        "keys",
        "_layer",
        "torch",
        "cat",
        "torch",
        "ones_like",
        "x",
        "torch",
        "cos",
        "omega",
        "x",
        "torch",
        "sin",
        "omega",
        "x",
        "dim",
        "x",
        "indeces",
        "isinstance",
        "indeces",
        "x",
        "extract",
        "indeces",
        "AttributeError",
        "RuntimeError",
        "isinstance",
        "indeces",
        "x",
        "indeces",
        "RuntimeError",
        "property",
        "_period"
    ],
    "literals": [
        "r\"\"\"\n    Imposing hard constraint periodic boundary conditions by embedding the\n    input. \n    \n    A periodic function :math:`u:\\mathbb{R}^{\\rm{in}}\n    \\rightarrow\\mathbb{R}^{\\rm{out}}` periodic in the spatial\n    coordinates :math:`\\mathbf{x}` with periods :math:`\\mathbf{L}` is such that:\n\n    .. math::\n        u(\\mathbf{x})  = u(\\mathbf{x} + n \\mathbf{L})\\;\\;\n        \\forall n\\in\\mathbb{N}.\n\n    The :meth:`PeriodicBoundaryEmbedding` augments the input such that the periodic conditons\n    is guarantee. The input is augmented by the following formula:\n\n    .. math::\n        \\mathbf{x} \\rightarrow \\tilde{\\mathbf{x}} = \\left[1,\n        \\cos\\left(\\frac{2\\pi}{L_1} x_1 \\right),\n        \\sin\\left(\\frac{2\\pi}{L_1}x_1\\right), \\cdots,\n        \\cos\\left(\\frac{2\\pi}{L_{\\rm{in}}}x_{\\rm{in}}\\right),\n        \\sin\\left(\\frac{2\\pi}{L_{\\rm{in}}}x_{\\rm{in}}\\right)\\right],\n\n    where :math:`\\text{dim}(\\tilde{\\mathbf{x}}) = 3\\text{dim}(\\mathbf{x})`.\n\n    .. seealso::\n        **Original reference**: \n            1.  Dong, Suchuan, and Naxian Ni (2021). *A method for representing\n                periodic functions and enforcing exactly periodic boundary\n                conditions with deep neural networks*. Journal of Computational\n                Physics 435, 110242.\n                DOI: `10.1016/j.jcp.2021.110242.\n                <https://doi.org/10.1016/j.jcp.2021.110242>`_\n            2.  Wang, S., Sankaran, S., Wang, H., & Perdikaris, P. (2023). *An\n                expert's guide to training physics-informed neural networks*.\n                DOI: `arXiv preprint arXiv:2308.0846.\n                <https://arxiv.org/abs/2308.08468>`_\n    .. warning::\n        The embedding is a truncated fourier expansion, and only ensures\n        function PBC and not for its derivatives. Ensuring approximate\n        periodicity in\n        the derivatives of :math:`u` can be done, and extensive\n        tests have shown (also in the reference papers) that this implementation\n        can correctly compute the PBC on the derivatives up to the order\n        :math:`\\sim 2,3`, while it is not guarantee the periodicity for\n        :math:`>3`. The PINA code is tested only for function PBC and not for\n        its derivatives.\n    \"\"\"",
        "'In dictionary periods, keys must be integers'",
        "' or strings, and values must be float or int.'",
        "'Not possible to extract input variables from tensor.'",
        "' Ensure that the passed tensor is a LabelTensor or'",
        "' pass list of integers to extract variables. For'",
        "' more information refer to warning in the documentation.'",
        "'Not able to extract right indeces for tensor.'",
        "' For more information refer to warning in the documentation.'"
    ],
    "variables": [
        "_layer",
        "_layer",
        "_period",
        "_period",
        "omega",
        "x"
    ],
    "comments": [
        "check input consistency",
        "checks on the periods"
    ],
    "docstrings": [
        "\"\"\" Periodic Boundary Embedding modulus. \"\"\"",
        "\"\"\"\n        :param int input_dimension: The dimension of the input tensor, it can\n            be checked with `tensor.ndim` method.\n        :param float | int | dict periods: The periodicity in each dimension for\n            the input data. If ``float`` or ``int`` is passed,\n            the period is assumed constant for all the dimensions of the data.\n            If a ``dict`` is passed the `dict.values` represent periods,\n            while the ``dict.keys`` represent the dimension where the\n            periodicity is applied. The `dict.keys` can either be `int`\n            if working with ``torch.Tensor`` or ``str`` if\n            working with ``LabelTensor``.\n        :param int output_dimension: The dimension of the output after the\n            fourier embedding. If not ``None`` a ``torch.nn.Linear`` layer\n            is applied to the fourier embedding output to match the desired\n            dimensionality, default ``None``.\n        \"\"\"",
        "\"\"\"\n        Forward pass to compute the periodic boundary conditions embedding.\n\n        :param torch.Tensor x: Input tensor.\n        :return: Fourier embeddings of the input.\n        :rtype: torch.Tensor\n        \"\"\"",
        "\"\"\"\n        Get variables from input tensor ordered by specific indeces.\n\n        :param torch.Tensor x: The input tensor to extract.\n        :param list[int] | list[str] indeces: List of indeces to extract.\n        :return: The extracted tensor given the indeces.\n        :rtype: torch.Tensor\n        \"\"\"",
        "\"\"\"\n        The period of the periodic function to approximate.\n        \"\"\""
    ],
    "functions": [
        "forward",
        "_get_vars",
        "period"
    ],
    "classes": [
        "PeriodicBoundaryEmbedding"
    ]
}