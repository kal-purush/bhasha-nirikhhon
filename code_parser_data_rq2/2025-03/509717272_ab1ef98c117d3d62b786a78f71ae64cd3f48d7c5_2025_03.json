{
    "identifiers": [
        "com",
        "google",
        "inject",
        "com",
        "google",
        "common",
        "Preconditions",
        "checkState",
        "com",
        "google",
        "inject",
        "spi",
        "Dependency",
        "java",
        "lang",
        "invoke",
        "MethodHandle",
        "java",
        "lang",
        "invoke",
        "MutableCallSite",
        "java",
        "util",
        "IdentityHashMap",
        "java",
        "util",
        "Supplier",
        "CONSTRUCTING",
        "linkingFactories",
        "options",
        "options",
        "options",
        "options",
        "options",
        "source",
        "dependency",
        "factory",
        "previous",
        "linkingFactories",
        "putIfAbsent",
        "source",
        "CONSTRUCTING",
        "handleType",
        "InternalMethodHandles",
        "makeFactoryType",
        "dependency",
        "previous",
        "CONSTRUCTING",
        "previous",
        "InternalMethodHandles",
        "OBJECT_FACTORY_TYPE",
        "linkingFactories",
        "put",
        "source",
        "previous",
        "previous",
        "previous",
        "dynamicInvoker",
        "asType",
        "handleType",
        "checkState",
        "previous",
        "previous",
        "handle",
        "factory",
        "get",
        "previous",
        "linkingFactories",
        "remove",
        "source",
        "checkState",
        "previous",
        "previous",
        "CONSTRUCTING",
        "callSite",
        "previous",
        "callSite",
        "setTarget",
        "handle",
        "asType",
        "InternalMethodHandles",
        "OBJECT_FACTORY_TYPE",
        "MutableCallSite",
        "syncAll",
        "callSite",
        "handle",
        "asType",
        "handleType"
    ],
    "literals": [
        "\"Unexpected previous value: %s\"",
        "\"construction state was cleared already?\""
    ],
    "variables": [
        "options"
    ],
    "comments": [
        "Values are either `CONSTRUCTING` or a `MutableCallSite` instance.",
        "We are the first to 're-enter' this factory, so we need to create a MutableCallSite that",
        "will be used to resolve the cycle.",
        "We are re-entering the same factory, so we can just return the dynamic invoker and rely on",
        "the original invocation to finish the construction and call setTarget to finalize the",
        "callsite."
    ],
    "docstrings": [
        "* Copyright (C) 2025 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.",
        "* Linkage context allows circular factories to bind to themselves recursively when needed.\n *\n * <p>Guice can resolve cycles at provisioning time via the `InternalContext` protocol, this\n * provides similar functionality at 'linkage-time' which is when we are building MethodHandles. If\n * an InternalFactory delegates partially to another InternalFactory, then it is possible to link\n * back to itself. This class provides a way to detect that and resolve the cycle by returning a\n * lazily resolved MethodHandle that points back to instance generated by the first invocation.",
        "* Creates a MethodHandle for a 'circular' factory in a way that resolve cycles.\n   *\n   * <p>If constructing a MethodHandle requires invoking other InternalFactories, then it is\n   * possible that there will be a cycle. This method will detect that and resolve it by returning a\n   * handle that calls the originally constructed handle.\n   *\n   * <p>In theory this can lead to us generating a MethodHandle that will always throw a\n   * StackOverFlowError, but the callers should call this in places where there is runtime cycle\n   * detection. Finally, we could also potentially resolve the cycle with a MethodHandle that always\n   * throws and `InternalProvisionException`, but it isn't clear that that is sufficient and would\n   * only be reasonable in places that we cannot resovle cycles with proxies, and those cases have\n   * already been well optimized, so the only actual win would be if we could eliminate all runtime\n   * cycle detection but it is not clear that that is even feasible.\n   *\n   * @param source the factory that is calling this method\n   * @param dependency the dependency that is being injected, used to ensure the returned handle has\n   *     the correct signature\n   * @param factory a supplier of the method handle to be invoked\n   * @return a method handle that will invoke the given factory, resolving cycles as needed"
    ],
    "functions": [
        "LinkageContext",
        "options",
        "MethodHandle",
        "makeHandle"
    ],
    "classes": [
        "LinkageContext"
    ]
}