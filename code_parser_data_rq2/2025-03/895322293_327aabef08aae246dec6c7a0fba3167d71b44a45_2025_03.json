{
    "identifiers": [
        "THREE",
        "THREE",
        "patchFragment",
        "shader",
        "shader",
        "shader",
        "definesTarget",
        "defines",
        "shader",
        "shader",
        "multiProbeTarget",
        "multiProbe",
        "shader",
        "shader",
        "progAlphaTarget",
        "progAlpha",
        "shader",
        "shader",
        "lightmapTarget",
        "lightmapContent",
        "shader"
    ],
    "literals": [
        "\"../vthree/VTHREE\"",
        "void main()",
        "#ifndef V_FRAG_DEFINES_GUARD\n#define V_FRAG_DEFINES_GUARD\n\n#if defined(USE_LIGHTMAP_TRANSITION) || defined(USE_PROGRESSIVE_ALPHA)\nuniform float progress;\n#endif //!USE_LIGHTMAP_TRANSITION || USE_PROGRESSIVE_ALPHA\n\n#ifdef USE_LIGHTMAP_TRANSITION\nuniform sampler2D lightmapTo;\n#endif //!USE_LIGHTMAP_TRANSITION\n\n#ifdef USE_PROGRESSIVE_ALPHA\n  uniform vec3 dissolveOrigin;\n  uniform float dissolveMaxDist;\n  uniform bool dissolveDirection;\n\n  float progressiveAlpha(float progress, float x, float xMin, float xMax) {\n    float mid = mix(xMin, xMax, 0.5); // Midpoint of xMin and xMax\n    float factor = abs(x - mid) / max(xMax - mid, 0.0001); // 0으로 나누는 문제 방지\n    return clamp(1.0 - 4.0 * progress * factor, 0.0, 1.0);\n  }\n#endif //!USE_PROGRESSIVE_ALPHA\n\n// 라이트맵대비는 라이트맵을 사용할 때만 정의됨\n#ifdef USE_LIGHTMAP\n  #ifdef USE_LIGHTMAP_CONTRAST \n    uniform float lightMapContrast;\n  #endif //!USE_LIGHTMAP_CONTRAST\n#endif //!USE_LIGHTMAP\n\n#if defined(PROBE_COUNT) || defined(USE_PROGRESSIVE_ALPHA)\nvarying vec3 vWorldPosition;\n#endif //!V_ENV_MAP || USE_PROGRESSIVE_ALPHA\n\n#ifdef PROBE_COUNT\n  struct Probe {\n      vec3 center;\n      vec3 size;\n      // samplerCube cubeTexture;\n      // sampler2D envTexture;\n  };\n  struct Wall {\n      vec3 start;\n      vec3 end;\n      int index; // 프로브 인덱스, 0부터 PROBE_COUNT-1까지\n  };\n  uniform Probe uProbe[PROBE_COUNT];\n  uniform samplerCube uProbeTextures[PROBE_COUNT];\n  uniform float uProbeIntensity;\n\n  #ifdef WALL_COUNT\n    uniform Wall uWall[WALL_COUNT];\n    uniform float uProbeBlendDist;\n  #endif //!V_ENV_MAP_FLOOR\n\n  #define lengthSquared(v) (dot((v), (v)))\n\n  /////////////////////////////////////////////////////////////////////\n// pmrem texture as a cube map\n#ifndef V_ENVMAP_TYPE_CUBE_UV\n#define textureCubeUV textureCube // PMREM텍스쳐 아니면 기존의 textureCube 사용\n#endif //!V_ENVMAP_TYPE_CUBE_UV\n\n#ifdef V_ENVMAP_TYPE_CUBE_UV\n\n\t#define v_cubeUV_minMipLevel 4.0\n\t#define v_cubeUV_minTileSize 16.0\n\n\t// These shader functions convert between the UV coordinates of a single face of\n\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n\t// sampling a textureCube (not generally normalized ).\n\n\tfloat getFace( vec3 direction ) {\n\n\t\tvec3 absDirection = abs( direction );\n\n\t\tfloat face = - 1.0;\n\n\t\tif ( absDirection.x > absDirection.z ) {\n\n\t\t\tif ( absDirection.x > absDirection.y )\n\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t} else {\n\n\t\t\tif ( absDirection.z > absDirection.y )\n\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t}\n\n\t\treturn face;\n\n\t}\n\n\t// RH coordinate system; PMREM face-indexing convention\n\tvec2 getUV( vec3 direction, float face ) {\n\n\t\tvec2 uv;\n\n\t\tif ( face == 0.0 ) {\n\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n\t\t} else if ( face == 1.0 ) {\n\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n\t\t} else if ( face == 2.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n\t\t} else if ( face == 3.0 ) {\n\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n\t\t} else if ( face == 4.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n\t\t} else {\n\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n\t\t}\n\n\t\treturn 0.5 * ( uv + 1.0 );\n\n\t}\n\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n\t\tfloat face = getFace( direction );\n\n\t\tfloat filterInt = max( v_cubeUV_minMipLevel - mipInt, 0.0 );\n\n\t\tmipInt = max( mipInt, v_cubeUV_minMipLevel );\n\n\t\tfloat faceSize = exp2( mipInt );\n\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0; // #25071\n\n\t\tif ( face > 2.0 ) {\n\n\t\t\tuv.y += faceSize;\n\n\t\t\tface -= 3.0;\n\n\t\t}\n\n\t\tuv.x += face * faceSize;\n\n\t\tuv.x += filterInt * 3.0 * v_cubeUV_minTileSize;\n\n\t\tuv.y += 4.0 * ( exp2( V_CUBEUV_MAX_MIP ) - faceSize );\n\n\t\tuv.x *= V_CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= V_CUBEUV_TEXEL_HEIGHT;\n\n\t\t#ifdef texture2DGradEXT\n\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering\n\n\t\t#else\n\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\n\t\t#endif\n\n\t}\n\n\t// These defines must match with PMREMGenerator\n\t#define v_cubeUV_r0 1.0\n\t#define v_cubeUV_m0 - 2.0\n\t#define v_cubeUV_r1 0.8\n\t#define v_cubeUV_m1 - 1.0\n\t#define v_cubeUV_r4 0.4\n\t#define v_cubeUV_m4 2.0\n\t#define v_cubeUV_r5 0.305\n\t#define v_cubeUV_m5 3.0\n\t#define v_cubeUV_r6 0.21\n\t#define v_cubeUV_m6 4.0\n\n\tfloat roughnessToMip( float roughness ) {\n\n\t\tfloat mip = 0.0;\n\n\t\tif ( roughness >= v_cubeUV_r1 ) {\n\n\t\t\tmip = ( v_cubeUV_r0 - roughness ) * ( v_cubeUV_m1 - v_cubeUV_m0 ) / ( v_cubeUV_r0 - v_cubeUV_r1 ) + v_cubeUV_m0;\n\n\t\t} else if ( roughness >= v_cubeUV_r4 ) {\n\n\t\t\tmip = ( v_cubeUV_r1 - roughness ) * ( v_cubeUV_m4 - v_cubeUV_m1 ) / ( v_cubeUV_r1 - v_cubeUV_r4 ) + v_cubeUV_m1;\n\n\t\t} else if ( roughness >= v_cubeUV_r5 ) {\n\n\t\t\tmip = ( v_cubeUV_r4 - roughness ) * ( v_cubeUV_m5 - v_cubeUV_m4 ) / ( v_cubeUV_r4 - v_cubeUV_r5 ) + v_cubeUV_m4;\n\n\t\t} else if ( roughness >= v_cubeUV_r6 ) {\n\n\t\t\tmip = ( v_cubeUV_r5 - roughness ) * ( v_cubeUV_m6 - v_cubeUV_m5 ) / ( v_cubeUV_r5 - v_cubeUV_r6 ) + v_cubeUV_m5;\n\n\t\t} else {\n\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\n\t\t}\n\n\t\treturn mip;\n\n\t}\n\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n\t\tfloat mip = clamp( roughnessToMip( roughness ), v_cubeUV_m0, V_CUBEUV_MAX_MIP );\n\n\t\tfloat mipF = fract( mip );\n\n\t\tfloat mipInt = floor( mip );\n\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\n\t\tif ( mipF == 0.0 ) {\n\n\t\t\treturn vec4( color0, 1.0 );\n\n\t\t} else {\n\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\n\t\t}\n\n\t}\n\n#endif //! V_ENVMAP_TYPE_CUBE_UV\n\n/////////////////////////////////////////////////////////////////////\n// multiprobe\n\n  vec3 parallaxCorrectNormal( vec3 v, vec3 cubeSize, vec3 cubePos ) {\n      vec3 nDir = normalize( v );\n\n      vec3 rbmax = ( .5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n      vec3 rbmin = ( -.5 * cubeSize + cubePos - vWorldPosition ) / nDir;\n\n      vec3 rbminmax;\n\n      rbminmax.x = ( nDir.x > 0. ) ? rbmax.x : rbmin.x;\n      rbminmax.y = ( nDir.y > 0. ) ? rbmax.y : rbmin.y;\n      rbminmax.z = ( nDir.z > 0. ) ? rbmax.z : rbmin.z;\n\n      // 월드좌표의 반사벡터가 박스에서 얼마만한 강도로 반사될 지 정해주는 계수\n      float correction = min( min( rbminmax.x, rbminmax.y ), rbminmax.z );\n      vec3 boxIntersection = vWorldPosition + nDir * correction;\n      // vec3 boxIntersection = vWorldPosition + nDir;\n      \n      vec3 retval = boxIntersection - cubePos;\n      // retval.x = -retval.x;\n\n      return retval;\n  }\n\n  float distanceToAABB(vec3 point, vec3 boxCenter, vec3 boxSize) {\n      vec3 boxMin = boxCenter - boxSize * 0.5;\n      vec3 boxMax = boxCenter + boxSize * 0.5;\n      \n      vec3 closestPoint = clamp(point, boxMin, boxMax);\n      return lengthSquared(point - closestPoint);\n  }\n\n  vec4 probeColor(vec3 worldReflectVec, int i, float roughness) {\n      \n      vec3 probeCenter = uProbe[i].center;\n      vec3 probeSize = uProbe[i].size;\n\n      mat3 _envMapRotation = mat3(1.0);\n      vec3 localReflectVec = _envMapRotation * parallaxCorrectNormal( worldReflectVec, probeSize, probeCenter );\n\n\n      vec4 envMapColor = vec4(0.0);\n\n      if(i == 0){\n\n          envMapColor += textureCubeUV( uProbeTextures[0], localReflectVec, roughness );\n\n      }\n      #if PROBE_COUNT > 1\n      else if( i == 1){\n\n          envMapColor += textureCubeUV( uProbeTextures[1], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 2\n      else if( i == 2){\n\n          envMapColor += textureCubeUV( uProbeTextures[2], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 3\n      else if( i == 3){\n\n          envMapColor += textureCubeUV( uProbeTextures[3], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 4\n      else if( i == 4){\n\n          envMapColor += textureCubeUV( uProbeTextures[4], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 5\n      else if( i == 5){\n\n          envMapColor += textureCubeUV( uProbeTextures[5], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 6\n      else if( i == 6){\n\n          envMapColor += textureCubeUV( uProbeTextures[6], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 7\n      else if( i == 7){\n\n          envMapColor += textureCubeUV( uProbeTextures[7], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 8\n      else if( i == 8){\n\n          envMapColor += textureCubeUV( uProbeTextures[8], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 9\n      else if( i == 9){\n\n          envMapColor += textureCubeUV( uProbeTextures[9], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 10\n      else if( i == 10){\n\n          envMapColor += textureCubeUV( uProbeTextures[10], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 11\n      else if( i == 11){\n\n          envMapColor += textureCubeUV( uProbeTextures[11], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 12\n      else if( i == 12){\n\n          envMapColor += textureCubeUV( uProbeTextures[12], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 13\n      else if( i == 13){\n\n          envMapColor += textureCubeUV( uProbeTextures[13], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 14\n      else if( i == 14){\n\n          envMapColor += textureCubeUV( uProbeTextures[14], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 15\n      else if( i == 15){\n\n          envMapColor += textureCubeUV( uProbeTextures[15], localReflectVec, roughness );\n\n      }\n      #endif\n      #if PROBE_COUNT > 16\n      else if( i == 16){\n\n          envMapColor += textureCubeUV( uProbeTextures[16], localReflectVec, roughness );\n\n      }\n      #endif\n      // WebGL GLSL스펙 상 최대 텍스쳐 갯수는 16이므로 여기서 끝\n      else {\n\n          envMapColor = vec4(0.0);\n      }\n      return envMapColor;\n  }\n\n  #ifdef WALL_COUNT\n    bool intersectRaySegment(vec2 p1, vec2 p2, vec2 ro, vec2 rd, out vec2 intersection) {\n      vec2 v1 = ro - p1;\n      vec2 v2 = p2 - p1;\n      vec2 v3 = vec2(-rd.y, rd.x); // 광선의 법선 벡터\n\n      float dotProduct = dot(v2, v3);\n      if(abs(dotProduct) < 1e-6f)\n          return false; // 광선과 선이 평행함\n\n      float t1 = (v2.x * v1.y - v2.y * v1.x) / dotProduct;\n      float t2 = dot(v1, v3) / dotProduct;\n\n      if(t1 >= 0.0f && t2 >= 0.0f && t2 <= 1.0f) {\n          intersection = ro + t1 * rd;\n          return true;\n      }\n      return false;\n    }\n  #endif //!V_ENV_MAP_FLOOR\n\n\n#endif //!V_ENV_MAP\n\nvoid main()\n\n#endif //!V_FRAG_DEFINES_GUARD",
        "#include <lights_fragment_end>",
        "#ifndef V_FRAG_MULTIPROBE_GUARD\n#define V_FRAG_MULTIPROBE_GUARD\n\n#ifdef PROBE_COUNT\n\nfloat roughness = material.roughness;\n\nfloat weights[PROBE_COUNT];\nfloat wTotal = 0.0;\n\n// 표면에서 반사되는 벡터를 월드좌표계에서 본 것\nvec3 worldReflectVec = reflect( - geometryViewDir, geometryNormal );\nworldReflectVec = normalize(worldReflectVec);\nworldReflectVec = inverseTransformDirection( worldReflectVec, viewMatrix );\n\nfloat reflectWeight = 1.0;\nfloat distWeight = 1.0;\n\nfloat dists[PROBE_COUNT];\nfloat distTotal = 0.0;\n\n////////////////////////////////////////////////\n// 각 프로브까지의 거리를 계산\n#pragma unroll_loop_start\nfor (int i = 0; i < PROBE_COUNT; i++) {\n  vec3 probeCenter = uProbe[i].center;\n  vec3 probeSize = uProbe[i].size;\n\n  float distFromCenter = lengthSquared(vWorldPosition-probeCenter);\n  float distFromBox = distanceToAABB(vWorldPosition, probeCenter, probeSize);\n  \n  dists[i] = distFromBox;\n  \n  distTotal += dists[i];\n}\n#pragma unroll_loop_end\n\n////////////////////////////////////////////////\n// 가장 가까운 프로브 고르기\nint minIndex = -1;\nfloat minDist = 100000.0;\n#pragma unroll_loop_start\nfor (int i = 0; i < PROBE_COUNT; i++) {\n  if (dists[i] < minDist) {\n    minDist = dists[i];\n    minIndex = i;\n  }\n}\n#pragma unroll_loop_end\n\n////////////////////////////////////////////////\n// 프로브로부터 얻은 색상 반영\nvec4 envMapColor = vec4(0.0);\n\n////////////////////////////////////////////////\n// case 1. 바닥\n#ifdef WALL_COUNT\n  vec3 localReflectVec = parallaxCorrectNormal( worldReflectVec, uProbe[minIndex].size, uProbe[minIndex].center );\n\n  int closestWallIndex = -1;\n  int closestProbeIndex = minIndex;\n  float maxDist = uProbeBlendDist * uProbeBlendDist;\n\n  float closestWallDist = maxDist;\n\n  #pragma unroll_loop_start\n  for (int i = 0; i < WALL_COUNT; ++i) {\n      vec2 start = uWall[i].start.xz;\n      vec2 end = uWall[i].end.xz;\n      int probeIndex = uWall[i].index;\n\n      vec2 origin = vWorldPosition.xz;\n      vec2 ray = worldReflectVec.xz;\n      vec2 intersection = vec2(0.0);\n\n      if(intersectRaySegment(start, end, origin, ray, intersection)){\n          \n      float dist = lengthSquared(intersection - origin);\n\n          if(dist < closestWallDist){\n              closestWallDist = dist;\n              closestWallIndex = i;\n              closestProbeIndex = probeIndex;\n          }\n      }\n  }    \n  #pragma unroll_loop_end\n\n  envMapColor = probeColor(worldReflectVec, closestProbeIndex, roughness);\n\n#else // ifndef V_ENV_MAP_FLOOR\n\n  ////////////////////////////////////////////////\n  // case2. 바닥이 아닌 여러 개의 프로브가 적용되는 경우\n  // 그냥 제일 가까운 프로브 반사\n  envMapColor = probeColor(worldReflectVec, minIndex, roughness);\n  // envMapColor = vec4(1.0, 0.0, 0.0, 1.0);\n      \n#endif //!V_ENV_MAP_FLOOR\n\nradiance += clamp(envMapColor.rgb, 0.0, 1.0) * uProbeIntensity;\n\n#endif //!V_ENV_MAP\n\n#include <lights_fragment_end>\n\n#endif //!V_FRAG_MULTIPROBE_GUARD",
        "#include <dithering_fragment>",
        "#include <dithering_fragment>\n#ifndef V_FRAG_PROG_ALPHA_GUARD\n#define V_FRAG_PROG_ALPHA_GUARD\n\n#ifdef USE_PROGRESSIVE_ALPHA\n  float distance = distance(vWorldPosition.xyz, dissolveOrigin );\n  float falloffRange = dissolveMaxDist * 0.01;\n  float distToBorder = (dissolveMaxDist + falloffRange) * abs(progress);\n  float falloff = step( distToBorder-falloffRange, distance );\n  float glowFalloff;\n  if ( dissolveDirection ) {\n    falloff = 1.0 - falloff;\n    glowFalloff = 1.0 - smoothstep(distToBorder-falloffRange*5.0, distToBorder+falloffRange*4.0, distance);\n  }\n  else {\n    glowFalloff = max(smoothstep(distToBorder-falloffRange, distToBorder, distance), 0.0001);\n  }\n  gl_FragColor.a *= falloff;\n  vec3 glowColor = vec3(1.0);\n  gl_FragColor.rgb = mix(glowColor, gl_FragColor.rgb, glowFalloff);\n\n  // gl_FragColor = vec4(1.0);\n  // gl_FragColor.rgb = vec3(dissolveDirection ? (1.0-progress) : (progress));\n#endif //!USE_PROGRESSIVE_ALPHA\n\n#endif //!V_FRAG_PROG_ALPHA_GUARD",
        "#include <lights_fragment_maps>",
        "// <lights_fragment_maps>을 복사해와서 중간 부분을 수정\n#ifndef V_FRAG_LIGHTMAP_CONTRAST_GUARD\n#define V_FRAG_LIGHTMAP_CONTRAST_GUARD\n\n#if defined( RE_IndirectDiffuse )\n\n  #ifdef USE_LIGHTMAP\n\n    #ifdef USE_LIGHTMAP_TRANSITION\n    vec4 lightMapTexel = mix(\n      texture2D(lightMap, vLightMapUv),\n      texture2D(lightMapTo, vLightMapUv),\n      progress\n    );\n    #else\n    vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n    #endif //!USE_LIGHTMAP_TRANSITION\n\n\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\n    // <lights_fragment_maps>에서 추가된 부분\n\t\t#ifdef USE_LIGHTMAP_CONTRAST\n      lightMapIrradiance = pow(lightMapIrradiance, vec3(lightMapContrast));\n    #endif  //!USE_LIGHTMAP_CONTRAST\n\n    irradiance += lightMapIrradiance;\n  #endif\n\n  #if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n    iblIrradiance += getIBLIrradiance( geometryNormal );\n\n  #endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n  #ifdef USE_ANISOTROPY\n\n    radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\n  #else\n\n    radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\n  #endif\n\n  #ifdef USE_CLEARCOAT\n\n    clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\n  #endif\n\n#endif\n\n#endif //!V_FRAG_LIGHTMAP_CONTRAST_GUARD"
    ],
    "variables": [
        "definesTarget",
        "defines",
        "multiProbeTarget",
        "multiProbe",
        "progAlphaTarget",
        "progAlpha",
        "lightmapTarget",
        "lightmapContent",
        "patchFragment",
        "v_env_frag_shaders"
    ],
    "comments": [
        "",
        "glsl",
        "glsl",
        "",
        "glsl",
        "glsl",
        "glsl",
        "glsl",
        "glsl",
        "glsl",
        "1. defines",
        "2. multiprobe",
        "3. progressive alpha",
        "4. lightmap transition & contrast"
    ],
    "docstrings": [
        "* 공통으로 쓰이는 변수\n * 1. progress\n *      - USE_LIGHTMAP_TRANSITION || USE_PROGRESSIVE_ALPHA\n * \n * 2. vWorldPosition\n *      - V_ENV_MAP || USE_PROGRESSIVE_ALPHA"
    ],
    "functions": [],
    "classes": []
}