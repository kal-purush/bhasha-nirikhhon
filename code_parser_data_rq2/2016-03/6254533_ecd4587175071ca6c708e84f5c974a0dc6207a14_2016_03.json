{
    "identifiers": [
        "lxml",
        "html",
        "lxml",
        "etree",
        "_patterns",
        "FORWARD_LINE",
        "FORWARD_STYLES",
        "MULTIPLE_WHITESPACE_RE",
        "element",
        "include_element",
        "element",
        "parent_el",
        "element",
        "iterancestors",
        "el",
        "element",
        "include_element",
        "el",
        "getnext",
        "el",
        "el",
        "el",
        "getnext",
        "parent_el",
        "remove",
        "remove_el",
        "parent_el",
        "element",
        "include_element",
        "element",
        "parent_el",
        "element",
        "iterancestors",
        "el",
        "element",
        "include_element",
        "el",
        "getprevious",
        "el",
        "tail",
        "el",
        "el",
        "el",
        "getprevious",
        "parent_el",
        "remove",
        "remove_el",
        "parent_el",
        "lines",
        "slice_tuple",
        "line",
        "line",
        "line",
        "strip",
        "slice_tuple",
        "slice_tuple",
        "slice_start",
        "slice_end",
        "len",
        "lines",
        "slice_start",
        "slice_end",
        "_empty",
        "lines",
        "slice_start",
        "slice_start",
        "slice_end",
        "slice_start",
        "_empty",
        "lines",
        "slice_end",
        "slice_end",
        "slice_start",
        "slice_end",
        "element",
        "el",
        "element",
        "iter",
        "is_indentation_element",
        "el",
        "el",
        "attrib",
        "clear",
        "tree",
        "start_refs",
        "end_refs",
        "slice_tuple",
        "html_copy",
        "slice_tuple",
        "slice_tuple",
        "slice_start",
        "slice_start",
        "len",
        "start_refs",
        "slice_end",
        "slice_end",
        "get_html_tree",
        "slice_start",
        "slice_end",
        "len",
        "start_refs",
        "slice_start",
        "start_refs",
        "slice_start",
        "slice_end",
        "slice_end",
        "len",
        "end_refs",
        "end_refs",
        "slice_end",
        "lxml",
        "etree",
        "ElementTree",
        "tree",
        "html_copy",
        "get_html_tree",
        "html_copy",
        "start_ref",
        "et",
        "getelementpath",
        "start_ref",
        "trim_tree_before",
        "new_tree",
        "find",
        "selector",
        "include_element",
        "start_ref",
        "BEGIN",
        "end_ref",
        "et",
        "getelementpath",
        "end_ref",
        "trim_tree_after",
        "new_tree",
        "find",
        "selector",
        "include_element",
        "end_ref",
        "END",
        "tree",
        "start_ref",
        "trim_tree_before",
        "start_ref",
        "include_element",
        "start_ref",
        "BEGIN",
        "end_ref",
        "trim_tree_after",
        "end_ref",
        "include_element",
        "end_ref",
        "END",
        "new_tree",
        "html",
        "lxml",
        "html",
        "HTMLParser",
        "encoding",
        "html",
        "encode",
        "lxml",
        "html",
        "fromstring",
        "html",
        "parser",
        "parser",
        "lxml",
        "etree",
        "lxml",
        "html",
        "fromstring",
        "tree",
        "tag",
        "lxml",
        "html",
        "defs",
        "top_level_tags",
        "html",
        "lxml",
        "html",
        "fromstring",
        "html",
        "parser",
        "parser",
        "tree",
        "html",
        "html",
        "startswith",
        "html",
        "endswith",
        "html",
        "html",
        "tree",
        "strip_wrapping",
        "lxml",
        "html",
        "tostring",
        "tree",
        "element",
        "isinstance",
        "element",
        "tag",
        "basestring",
        "element",
        "tag",
        "lower",
        "el",
        "indentation_level",
        "isinstance",
        "el",
        "tag",
        "basestring",
        "el",
        "tag",
        "lower",
        "is_indentation_element",
        "el",
        "is_indentation",
        "indentation_level",
        "el",
        "BEGIN",
        "indentation_level",
        "el",
        "text",
        "child",
        "el",
        "iterchildren",
        "token",
        "tree_token_generator",
        "child",
        "indentation_level",
        "token",
        "is_indentation",
        "indentation_level",
        "el",
        "END",
        "indentation_level",
        "el",
        "tail",
        "el",
        "max_lines",
        "text",
        "MULTIPLE_WHITESPACE_RE",
        "sub",
        "text",
        "strip",
        "token",
        "tree_token_generator",
        "el",
        "token",
        "isinstance",
        "token",
        "token",
        "el",
        "tag",
        "lower",
        "tag_name",
        "state",
        "BEGIN",
        "tag_name",
        "INLINE_TAGS",
        "is_block",
        "state",
        "BEGIN",
        "el",
        "attrib",
        "get",
        "FORWARD_STYLES",
        "is_block",
        "line_break",
        "_trim_spaces",
        "line",
        "line",
        "line_break",
        "is_forward",
        "el",
        "state",
        "start_ref",
        "end_ref",
        "start_indentation_level",
        "line",
        "is_forward",
        "end_ref",
        "end_ref",
        "start_indentation_level",
        "FORWARD_LINE",
        "line",
        "el",
        "state",
        "indentation_level",
        "isinstance",
        "token",
        "basestring",
        "line",
        "token",
        "RuntimeError",
        "format",
        "token",
        "_trim_spaces",
        "line",
        "line",
        "line",
        "el",
        "max_lines",
        "tree_line_generator",
        "el",
        "max_lines",
        "start_ref",
        "end_ref",
        "indentation_level",
        "line",
        "gen",
        "line",
        "startswith",
        "line",
        "start_ref",
        "end_ref",
        "indentation_level",
        "line",
        "tree",
        "max_lines",
        "indented_tree_line_generator",
        "tree",
        "max_lines",
        "max_lines",
        "line_gen",
        "line_gen_result",
        "line_gen_result"
    ],
    "literals": [
        "'a'",
        "'b'",
        "'em'",
        "'i'",
        "'strong'",
        "'span'",
        "'font'",
        "'q'",
        "'object'",
        "'bdo'",
        "'sub'",
        "'sup'",
        "'center'",
        "'begin'",
        "'end'",
        "'>'",
        "'div'",
        "''",
        "'utf-8'",
        "'utf8'",
        "'<div></div>'",
        "'<div>%s</div>'",
        "'<div>'",
        "'</div>'",
        "'blockquote'",
        "' '",
        "''",
        "'br'",
        "'style'",
        "''",
        "'invalid token: {}'",
        "'>'",
        "'\\\\'",
        "'> '"
    ],
    "variables": [
        "INLINE_TAGS",
        "BEGIN",
        "END",
        "el",
        "el",
        "tail",
        "el",
        "remove_el",
        "el",
        "el",
        "el",
        "parent_el",
        "text",
        "el",
        "parent_el",
        "text",
        "remove_el",
        "el",
        "el",
        "slice_start",
        "slice_end",
        "slice_start",
        "slice_end",
        "el",
        "tag",
        "start_ref",
        "end_ref",
        "slice_start",
        "slice_end",
        "slice_start",
        "slice_end",
        "slice_start",
        "slice_end",
        "start_ref",
        "end_ref",
        "et",
        "new_tree",
        "selector",
        "selector",
        "new_tree",
        "parser",
        "html",
        "tree",
        "tree",
        "html",
        "tree",
        "html",
        "tag_name",
        "is_indentation",
        "line",
        "start_ref",
        "start_indentation_level",
        "el",
        "state",
        "indentation_level",
        "tag_name",
        "line_break",
        "is_block",
        "is_forward",
        "line",
        "end_ref",
        "line",
        "start_ref",
        "start_indentation_level",
        "line",
        "gen",
        "line",
        "line_gen",
        "line_gen_result"
    ],
    "comments": [
        "HTML utils",
        "Trim from beginning",
        "Trim from end",
        "E.g. empty document. Use dummy <div>",
        "If the document doesn't start with a top level tag, wrap it with a <div>",
        "that will be later stripped out for consistent behavior.",
        "Buffer for the current line.",
        "The reference tuple (element, position) for the start of the line.",
        "The indentation level at the start of the line.",
        "Simulate forward",
        "Escape line"
    ],
    "docstrings": [
        "\"\"\"\n    Removes the document tree following the given element. If include_element\n    is True, the given element is kept in the tree, otherwise it is removed.\n    \"\"\"",
        "\"\"\"\n    Removes the document tree preceding the given element. If include_element\n    is True, the given element is kept in the tree, otherwise it is removed.\n    \"\"\"",
        "\"\"\"\n    Trim a slice tuple (begin, end) so it starts at the first non-empty line\n    (obtained via indented_tree_line_generator / get_line_info) and ends at the\n    last non-empty line within the slice. Returns the new slice.\n    \"\"\"",
        "\"\"\"\n    Removes the outermost indent. For example, the tree\n    \"<div>A<blockqote>B<div>C<blockquote>D</blockquote>E</div>F</blockquote>G</div>\"\n    is transformed to\n    \"<div>A<div>B<div>C<blockquote>D</blockquote>E</div>F</div>G</div>\"\n    \"\"\"",
        "\"\"\"\n    Slices the HTML tree with the given start_refs and end_refs (obtained via\n    get_line_info) at the given slice_tuple, a tuple (start, end) containing\n    the start and end of the slice (or None, to start from the start / end at\n    the end of the tree). If html_copy is specified, a new tree is constructed\n    from the given HTML (which must be the equal to the original tree's HTML*).\n    The resulting tree is returned.\n\n    *) The reason we have to specify the HTML is that we can't reliably\n       construct a copy of the tree using copy.copy() (see bug\n       https://bugs.launchpad.net/lxml/+bug/1562550).\n    \"\"\"",
        "\"\"\"\n    Given the HTML string, returns a LXML tree object. The tree is wrapped in\n    <div> elements if it doesn't have a top level tag or parsing would\n    otherwise result in an error. The wrapping can be later removed with\n    strip_wrapping().\n    \"\"\"",
        "\"\"\"\n    Removes the wrapping that might have resulted when using get_html_tree().\n    \"\"\"",
        "\"\"\"\n    Renders the given HTML tree, and strips any wrapping that was applied in\n    get_html_tree().\n    \"\"\"",
        "\"\"\"\n    Internal generator that yields tokens for the given HTML element as\n    follows:\n\n    - A tuple (LXML element, BEGIN, indentation_level)\n    - Text right after the start of the tag, or None.\n    - Recursively calls the token generator for all child objects\n    - A tuple (LXML element, END, indentation_level)\n    - Text right after the end of the tag, or None.\n    \"\"\"",
        "\"\"\"\n    Internal generator that iterates through an LXML tree and yields a tuple\n    per line. In this context, lines are blocks of text separated by <br> tags\n    or by block elements. The tuples contain the following elements:\n\n    - A tuple with the element reference (element, position) for the start\n      of the line. The tuple consists of:\n        - The LXML HTML element which references the line\n        - Whether the text starts at the beginning of the referenced element,\n          or after the closing tag\n    - A similar tuple indicating the ending of the line.\n    - The email indentation level, if detected.\n    - The plain (non-HTML) text of the line\n\n    If max_lines is specified, the generator stops after yielding the given\n    amount of lines.\n\n    For example, the HTML tree \"<div>foo <span>bar</span><br>baz</div>\" yields:\n\n    - ((<Element div>, 'begin'), (<Element br>, 'begin'), 0, 'foo bar')\n    - ((<Element br>, 'end'), (<Element div>, 'end'), 0, 'baz').\n\n    To illustrate the indentation level, the HTML tree\n    '<div><blockquote>hi</blockquote>world</div>' yields:\n\n    - ((<Element blockquote>, 'begin'), (<Element blockquote>, 'end'), 1, 'hi')\n    - ((<Element blockquote>, 'end'), (<Element div>, 'end'), 0, 'world')\n    \"\"\"",
        "\"\"\"\n    Like tree_line_generator, but yields tuples (start_ref, end_ref, line),\n    where the line already takes the indentation into account by having \"> \"\n    prepended. If a line already starts with \">\", it is escaped (\"\\\\>\"). This\n    makes it possible to reliably use methods that analyze plain text to detect\n    quoting.\n    \"\"\"",
        "\"\"\"\n    Shortcut for indented_tree_line_generator() that returns an array of\n    start references, an array of corresponding end references (see\n    tree_line_generator() docs), and an array of corresponding lines.\n    \"\"\""
    ],
    "functions": [
        "trim_tree_after",
        "trim_tree_before",
        "trim_slice",
        "_empty",
        "unindent_tree",
        "slice_tree",
        "get_html_tree",
        "strip_wrapping",
        "render_html_tree",
        "is_indentation_element",
        "tree_token_generator",
        "tree_line_generator",
        "_trim_spaces",
        "indented_tree_line_generator",
        "get_line_info"
    ],
    "classes": []
}