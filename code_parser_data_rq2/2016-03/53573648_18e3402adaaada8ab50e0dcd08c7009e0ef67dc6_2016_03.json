{
    "identifiers": [
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "isUndefined",
        "isDefined",
        "CSS_PREFIX",
        "TRANSITION_PROP",
        "TRANSITIONEND_EVENT",
        "TRANSITION_PROP",
        "TRANSITIONEND_EVENT",
        "isUndefined",
        "isDefined",
        "CSS_PREFIX",
        "ANIMATION_PROP",
        "ANIMATIONEND_EVENT",
        "ANIMATION_PROP",
        "ANIMATIONEND_EVENT",
        "ANIMATION_PROP",
        "DELAY_KEY",
        "ANIMATION_PROP",
        "DURATION_KEY",
        "TRANSITION_PROP",
        "DELAY_KEY",
        "TRANSITION_PROP",
        "DURATION_KEY",
        "p",
        "p",
        "p",
        "angular",
        "arg",
        "name",
        "reason",
        "arg",
        "ngMinErr",
        "name",
        "reason",
        "arg",
        "a",
        "b",
        "a",
        "b",
        "a",
        "b",
        "b",
        "a",
        "isArray",
        "a",
        "a",
        "a",
        "isArray",
        "b",
        "b",
        "b",
        "a",
        "b",
        "options",
        "options",
        "options",
        "options",
        "styles",
        "options",
        "styles",
        "options",
        "styles",
        "classes",
        "fix",
        "isPrefix",
        "classes",
        "isArray",
        "classes",
        "classes",
        "classes",
        "isString",
        "classes",
        "classes",
        "classes",
        "forEach",
        "classes",
        "klass",
        "i",
        "klass",
        "klass",
        "className",
        "i",
        "className",
        "isPrefix",
        "fix",
        "klass",
        "klass",
        "fix",
        "className",
        "arr",
        "val",
        "arr",
        "val",
        "val",
        "arr",
        "index",
        "element",
        "element",
        "jqLite",
        "element",
        "element",
        "ELEMENT_NODE",
        "element",
        "jqLite",
        "extractElementNode",
        "element",
        "element",
        "ELEMENT_NODE",
        "jqLite",
        "element",
        "element",
        "element",
        "element",
        "i",
        "element",
        "i",
        "element",
        "i",
        "elm",
        "ELEMENT_NODE",
        "elm",
        "$$jqLite",
        "element",
        "className",
        "forEach",
        "element",
        "elm",
        "$$jqLite",
        "elm",
        "className",
        "$$jqLite",
        "element",
        "className",
        "forEach",
        "element",
        "elm",
        "$$jqLite",
        "elm",
        "className",
        "$$jqLite",
        "element",
        "options",
        "options",
        "$$addClass",
        "$$jqLite",
        "element",
        "options",
        "options",
        "options",
        "$$removeClass",
        "$$jqLite",
        "element",
        "options",
        "options",
        "options",
        "options",
        "options",
        "options",
        "options",
        "noop",
        "options",
        "options",
        "domOperation",
        "domOperation",
        "noop",
        "options",
        "options",
        "element",
        "options",
        "applyAnimationFromStyles",
        "element",
        "options",
        "applyAnimationToStyles",
        "element",
        "options",
        "element",
        "options",
        "options",
        "element",
        "options",
        "options",
        "element",
        "options",
        "options",
        "element",
        "options",
        "options",
        "element",
        "oldAnimation",
        "newAnimation",
        "oldAnimation",
        "newAnimation",
        "target",
        "newOptions",
        "target",
        "newOptions",
        "resolveElementClasses",
        "element",
        "toAdd",
        "toRemove",
        "newOptions",
        "target",
        "concatWithSpace",
        "newOptions",
        "target",
        "newOptions",
        "target",
        "noop",
        "target",
        "extend",
        "target",
        "newOptions",
        "realDomOperation",
        "target",
        "realDomOperation",
        "classes",
        "target",
        "classes",
        "target",
        "classes",
        "target",
        "classes",
        "target",
        "oldAnimation",
        "target",
        "oldAnimation",
        "target",
        "target",
        "existing",
        "toAdd",
        "toRemove",
        "existing",
        "splitClassesToLookup",
        "existing",
        "toAdd",
        "splitClassesToLookup",
        "toAdd",
        "forEach",
        "toAdd",
        "value",
        "key",
        "flags",
        "key",
        "ADD_CLASS",
        "toRemove",
        "splitClassesToLookup",
        "toRemove",
        "forEach",
        "toRemove",
        "value",
        "key",
        "flags",
        "key",
        "flags",
        "key",
        "ADD_CLASS",
        "REMOVE_CLASS",
        "forEach",
        "flags",
        "val",
        "klass",
        "val",
        "ADD_CLASS",
        "prop",
        "allow",
        "existing",
        "klass",
        "val",
        "REMOVE_CLASS",
        "prop",
        "allow",
        "existing",
        "klass",
        "allow",
        "classes",
        "prop",
        "classes",
        "prop",
        "classes",
        "prop",
        "klass",
        "classes",
        "isString",
        "classes",
        "classes",
        "classes",
        "forEach",
        "classes",
        "klass",
        "klass",
        "obj",
        "klass",
        "obj",
        "classes",
        "element",
        "element",
        "angular",
        "element",
        "element",
        "element",
        "options",
        "classes",
        "pendClasses",
        "EVENT_CLASS_PREFIX",
        "options",
        "classes",
        "concatWithSpace",
        "classes",
        "pendClasses",
        "options",
        "ADD_CLASS_SUFFIX",
        "options",
        "classes",
        "concatWithSpace",
        "classes",
        "pendClasses",
        "options",
        "REMOVE_CLASS_SUFFIX",
        "classes",
        "options",
        "classes",
        "element",
        "classes",
        "element",
        "options",
        "options",
        "element",
        "options",
        "options",
        "options",
        "element",
        "options",
        "options",
        "node",
        "duration",
        "duration",
        "duration",
        "applyInlineStyle",
        "node",
        "TRANSITION_DELAY_PROP",
        "value",
        "TRANSITION_DELAY_PROP",
        "value",
        "node",
        "applyBlock",
        "applyBlock",
        "ANIMATION_PROP",
        "ANIMATION_PLAYSTATE_KEY",
        "applyInlineStyle",
        "node",
        "key",
        "value",
        "key",
        "value",
        "node",
        "styleTuple",
        "styleTuple",
        "styleTuple",
        "node",
        "prop",
        "value",
        "a",
        "b",
        "a",
        "b",
        "b",
        "a",
        "a",
        "b",
        "$$rAF",
        "tasks",
        "queue",
        "queue",
        "tasks",
        "nextTick",
        "queue",
        "scheduler",
        "scheduler",
        "fn",
        "cancelFn",
        "cancelFn",
        "cancelFn",
        "$$rAF",
        "cancelFn",
        "fn",
        "nextTick",
        "scheduler",
        "queue",
        "queue",
        "i",
        "items",
        "i",
        "items",
        "i",
        "cancelFn",
        "$$rAF",
        "cancelFn",
        "nextTick",
        "$interpolate",
        "scope",
        "element",
        "attrs",
        "attrs",
        "angular",
        "val",
        "val",
        "element",
        "NG_ANIMATE_CHILDREN_DATA",
        "setData",
        "$interpolate",
        "val",
        "scope",
        "attrs",
        "setData",
        "value",
        "value",
        "value",
        "value",
        "element",
        "NG_ANIMATE_CHILDREN_DATA",
        "value",
        "TRANSITION_DURATION_PROP",
        "TRANSITION_DELAY_PROP",
        "TRANSITION_PROP",
        "PROPERTY_KEY",
        "ANIMATION_DURATION_PROP",
        "ANIMATION_DELAY_PROP",
        "ANIMATION_PROP",
        "ANIMATION_ITERATION_COUNT_KEY",
        "TRANSITION_DURATION_PROP",
        "TRANSITION_DELAY_PROP",
        "ANIMATION_DURATION_PROP",
        "ANIMATION_DELAY_PROP",
        "duration",
        "ANIMATION_DURATION_PROP",
        "duration",
        "delay",
        "isKeyframeAnimation",
        "isKeyframeAnimation",
        "ANIMATION_DELAY_PROP",
        "TRANSITION_DELAY_PROP",
        "prop",
        "delay",
        "$window",
        "element",
        "properties",
        "$window",
        "element",
        "forEach",
        "properties",
        "formalStyleName",
        "actualStyleName",
        "detectedStyles",
        "formalStyleName",
        "val",
        "val",
        "c",
        "c",
        "c",
        "val",
        "parseMaxTime",
        "val",
        "val",
        "val",
        "styles",
        "actualStyleName",
        "val",
        "styles",
        "forEach",
        "values",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "parseFloat",
        "value",
        "maxValue",
        "maxValue",
        "value",
        "maxValue",
        "value",
        "maxValue",
        "val",
        "val",
        "val",
        "duration",
        "applyOnlyDuration",
        "duration",
        "applyOnlyDuration",
        "style",
        "DURATION_KEY",
        "value",
        "style",
        "value",
        "cache",
        "key",
        "cache",
        "key",
        "entry",
        "entry",
        "key",
        "cache",
        "key",
        "entry",
        "entry",
        "key",
        "value",
        "cache",
        "key",
        "cache",
        "key",
        "value",
        "cache",
        "key",
        "backup",
        "node",
        "properties",
        "forEach",
        "properties",
        "prop",
        "backup",
        "prop",
        "isDefined",
        "backup",
        "prop",
        "backup",
        "prop",
        "node",
        "prop",
        "$animateProvider",
        "createLocalCacheLookup",
        "createLocalCacheLookup",
        "$window",
        "$$jqLite",
        "$$AnimateRunner",
        "$timeout",
        "$$forceReflow",
        "$sniffer",
        "$$rAFScheduler",
        "$$animateQueue",
        "applyAnimationClassesFactory",
        "$$jqLite",
        "node",
        "extraClasses",
        "node",
        "parentNode",
        "KEY",
        "parentNode",
        "KEY",
        "parentCounter",
        "parentID",
        "node",
        "extraClasses",
        "node",
        "className",
        "cacheKey",
        "properties",
        "gcsLookup",
        "cacheKey",
        "timings",
        "timings",
        "computeCssStyles",
        "$window",
        "node",
        "properties",
        "timings",
        "timings",
        "gcsLookup",
        "cacheKey",
        "timings",
        "timings",
        "node",
        "className",
        "cacheKey",
        "properties",
        "gcsLookup",
        "cacheKey",
        "stagger",
        "gcsStaggerLookup",
        "cacheKey",
        "stagger",
        "pendClasses",
        "className",
        "$$jqLite",
        "node",
        "staggerClassName",
        "stagger",
        "computeCssStyles",
        "$window",
        "node",
        "properties",
        "stagger",
        "stagger",
        "stagger",
        "stagger",
        "$$jqLite",
        "node",
        "staggerClassName",
        "gcsStaggerLookup",
        "cacheKey",
        "stagger",
        "stagger",
        "callback",
        "rafWaitQueue",
        "callback",
        "$$rAFScheduler",
        "gcsLookup",
        "gcsStaggerLookup",
        "$$forceReflow",
        "i",
        "rafWaitQueue",
        "i",
        "rafWaitQueue",
        "i",
        "pageWidth",
        "rafWaitQueue",
        "node",
        "className",
        "cacheKey",
        "computeCachedCssStyles",
        "node",
        "className",
        "cacheKey",
        "DETECT_CSS_PROPERTIES",
        "timings",
        "timings",
        "timings",
        "aD",
        "tD",
        "aD",
        "tD",
        "aD",
        "tD",
        "timings",
        "timings",
        "timings",
        "timings",
        "timings",
        "init",
        "element",
        "initialOptions",
        "initialOptions",
        "options",
        "options",
        "prepareAnimationOptions",
        "copy",
        "options",
        "getDomNode",
        "element",
        "node",
        "node",
        "$$animateQueue",
        "closeAndReturnNoopAnimator",
        "element",
        "packageStyles",
        "options",
        "options",
        "$sniffer",
        "$sniffer",
        "closeAndReturnNoopAnimator",
        "options",
        "isArray",
        "options",
        "options",
        "options",
        "method",
        "options",
        "isStructural",
        "structuralClassName",
        "pendClasses",
        "method",
        "EVENT_CLASS_PREFIX",
        "method",
        "structuralClassName",
        "method",
        "options",
        "addRemoveClassName",
        "pendClasses",
        "options",
        "ADD_CLASS_SUFFIX",
        "options",
        "addRemoveClassName",
        "addRemoveClassName",
        "addRemoveClassName",
        "pendClasses",
        "options",
        "REMOVE_CLASS_SUFFIX",
        "options",
        "addRemoveClassName",
        "applyAnimationClasses",
        "element",
        "options",
        "structuralClassName",
        "addRemoveClassName",
        "classes",
        "preparationClasses",
        "pendClasses",
        "preparationClasses",
        "ACTIVE_CLASS_SUFFIX",
        "styles",
        "styles",
        "options",
        "containsKeyframeAnimation",
        "hasToStyles",
        "preparationClasses",
        "closeAndReturnNoopAnimator",
        "options",
        "parseFloat",
        "options",
        "stagger",
        "staggerVal",
        "staggerVal",
        "cacheKey",
        "gcsHashFn",
        "node",
        "fullClassName",
        "stagger",
        "computeCachedCssStaggerStyles",
        "node",
        "preparationClasses",
        "cacheKey",
        "DETECT_STAGGER_CSS_PROPERTIES",
        "options",
        "$$jqLite",
        "element",
        "preparationClasses",
        "options",
        "TRANSITION_PROP",
        "options",
        "applyInlineStyle",
        "node",
        "transitionStyle",
        "temporaryStyles",
        "transitionStyle",
        "options",
        "applyOnlyDuration",
        "node",
        "TRANSITION_PROP",
        "getCssTransitionDurationStyle",
        "options",
        "applyOnlyDuration",
        "applyInlineStyle",
        "node",
        "durationStyle",
        "temporaryStyles",
        "durationStyle",
        "options",
        "ANIMATION_PROP",
        "options",
        "applyInlineStyle",
        "node",
        "keyframeStyle",
        "temporaryStyles",
        "keyframeStyle",
        "stagger",
        "options",
        "options",
        "gcsLookup",
        "cacheKey",
        "itemIndex",
        "isFirst",
        "options",
        "blockTransitions",
        "node",
        "SAFE_FAST_FORWARD_DURATION_VALUE",
        "computeTimings",
        "node",
        "fullClassName",
        "cacheKey",
        "timings",
        "maxDelay",
        "relativeDelay",
        "maxDuration",
        "timings",
        "flags",
        "timings",
        "flags",
        "timings",
        "flags",
        "flags",
        "timings",
        "flags",
        "hasToStyles",
        "flags",
        "flags",
        "flags",
        "flags",
        "flags",
        "options",
        "flags",
        "flags",
        "truthyTimingValue",
        "options",
        "flags",
        "flags",
        "flags",
        "truthyTimingValue",
        "options",
        "flags",
        "flags",
        "addRemoveClassName",
        "flags",
        "flags",
        "maxDuration",
        "options",
        "parseFloat",
        "options",
        "maxDuration",
        "flags",
        "flags",
        "timings",
        "maxDuration",
        "applyOnlyDuration",
        "node",
        "TRANSITION_PROP",
        "PROPERTY_KEY",
        "temporaryStyles",
        "getCssTransitionDurationStyle",
        "maxDuration",
        "applyOnlyDuration",
        "flags",
        "flags",
        "timings",
        "maxDuration",
        "temporaryStyles",
        "getCssKeyframeDurationStyle",
        "maxDuration",
        "maxDuration",
        "flags",
        "closeAndReturnNoopAnimator",
        "options",
        "options",
        "delayStyle",
        "parseFloat",
        "options",
        "maxDelay",
        "delayStyle",
        "flags",
        "temporaryStyles",
        "getCssDelayStyle",
        "delayStyle",
        "flags",
        "temporaryStyles",
        "getCssDelayStyle",
        "delayStyle",
        "options",
        "timings",
        "flags",
        "flags",
        "isFirst",
        "maxDelayTime",
        "maxDelay",
        "ONE_SECOND",
        "maxDurationTime",
        "maxDuration",
        "ONE_SECOND",
        "options",
        "flags",
        "timings",
        "flags",
        "timings",
        "stagger",
        "stagger",
        "options",
        "options",
        "registerRestorableStyles",
        "restoreStyles",
        "node",
        "options",
        "applyAnimationFromStyles",
        "element",
        "options",
        "flags",
        "flags",
        "applyBlocking",
        "maxDuration",
        "options",
        "blockTransitions",
        "node",
        "endFn",
        "animationClosed",
        "runnerHost",
        "endFn",
        "cancelFn",
        "runner",
        "$$AnimateRunner",
        "runnerHost",
        "waitUntilQuiet",
        "start",
        "runner",
        "close",
        "close",
        "rejected",
        "animationClosed",
        "animationCompleted",
        "animationPaused",
        "animationClosed",
        "animationPaused",
        "options",
        "$$jqLite",
        "element",
        "preparationClasses",
        "$$jqLite",
        "element",
        "activeClasses",
        "blockKeyframeAnimations",
        "node",
        "blockTransitions",
        "node",
        "forEach",
        "temporaryStyles",
        "entry",
        "node",
        "entry",
        "applyAnimationClasses",
        "element",
        "options",
        "applyAnimationStyles",
        "element",
        "options",
        "restoreStyles",
        "forEach",
        "restoreStyles",
        "value",
        "prop",
        "value",
        "node",
        "prop",
        "value",
        "node",
        "prop",
        "options",
        "options",
        "events",
        "events",
        "element",
        "events",
        "onAnimationProgress",
        "element",
        "ANIMATE_TIMER_KEY",
        "animationTimerData",
        "$timeout",
        "animationTimerData",
        "element",
        "ANIMATE_TIMER_KEY",
        "runner",
        "runner",
        "rejected",
        "duration",
        "flags",
        "blockTransitions",
        "node",
        "duration",
        "flags",
        "blockKeyframeAnimations",
        "node",
        "duration",
        "runner",
        "$$AnimateRunner",
        "endFn",
        "cancelFn",
        "waitUntilQuiet",
        "noop",
        "close",
        "runner",
        "endFn",
        "ev",
        "parseFloat",
        "ev",
        "ELAPSED_TIME_MAX_DECIMAL_PLACES",
        "timeStamp",
        "startTime",
        "maxDelayTime",
        "elapsedTime",
        "maxDuration",
        "animationCompleted",
        "close",
        "animationClosed",
        "node",
        "close",
        "playAnimation",
        "animationCompleted",
        "animationPaused",
        "playAnimation",
        "timings",
        "blockKeyframeAnimations",
        "node",
        "animationPaused",
        "animationPaused",
        "temporaryStyles",
        "value",
        "removeFromArray",
        "temporaryStyles",
        "value",
        "animationPaused",
        "playAnimation",
        "animationPaused",
        "close",
        "itemIndex",
        "timings",
        "stagger",
        "timings",
        "stagger",
        "stagger",
        "stagger",
        "maxStagger",
        "$timeout",
        "triggerAnimationStart",
        "maxStagger",
        "itemIndex",
        "ONE_SECOND",
        "triggerAnimationStart",
        "runnerHost",
        "playPause",
        "runnerHost",
        "playPause",
        "animationClosed",
        "applyBlocking",
        "forEach",
        "temporaryStyles",
        "entry",
        "entry",
        "entry",
        "node",
        "key",
        "value",
        "applyAnimationClasses",
        "element",
        "options",
        "$$jqLite",
        "element",
        "activeClasses",
        "flags",
        "fullClassName",
        "node",
        "preparationClasses",
        "cacheKey",
        "gcsHashFn",
        "node",
        "fullClassName",
        "timings",
        "computeTimings",
        "node",
        "fullClassName",
        "cacheKey",
        "relativeDelay",
        "timings",
        "maxDelay",
        "relativeDelay",
        "maxDuration",
        "timings",
        "maxDuration",
        "close",
        "flags",
        "timings",
        "flags",
        "timings",
        "flags",
        "relativeDelay",
        "options",
        "truthyTimingValue",
        "options",
        "parseFloat",
        "options",
        "relativeDelay",
        "maxDelay",
        "relativeDelay",
        "timings",
        "relativeDelay",
        "delayStyle",
        "getCssDelayStyle",
        "relativeDelay",
        "temporaryStyles",
        "delayStyle",
        "node",
        "delayStyle",
        "delayStyle",
        "maxDelayTime",
        "maxDelay",
        "ONE_SECOND",
        "maxDurationTime",
        "maxDuration",
        "ONE_SECOND",
        "options",
        "options",
        "flags",
        "easeProp",
        "TRANSITION_PROP",
        "TIMING_KEY",
        "temporaryStyles",
        "easeProp",
        "easeVal",
        "node",
        "easeProp",
        "easeVal",
        "flags",
        "easeProp",
        "ANIMATION_PROP",
        "TIMING_KEY",
        "temporaryStyles",
        "easeProp",
        "easeVal",
        "node",
        "easeProp",
        "easeVal",
        "timings",
        "events",
        "TRANSITIONEND_EVENT",
        "timings",
        "events",
        "ANIMATIONEND_EVENT",
        "startTime",
        "maxDelayTime",
        "CLOSING_TIME_BUFFER",
        "maxDurationTime",
        "startTime",
        "timerTime",
        "element",
        "ANIMATE_TIMER_KEY",
        "animationsData",
        "animationsData",
        "setupFallbackTimer",
        "endTime",
        "currentTimerData",
        "setupFallbackTimer",
        "$timeout",
        "currentTimerData",
        "animationsData",
        "close",
        "setupFallbackTimer",
        "$timeout",
        "onAnimationExpired",
        "timerTime",
        "animationsData",
        "timer",
        "endTime",
        "animationsData",
        "close",
        "element",
        "ANIMATE_TIMER_KEY",
        "animationsData",
        "events",
        "element",
        "events",
        "onAnimationProgress",
        "options",
        "options",
        "registerRestorableStyles",
        "restoreStyles",
        "node",
        "options",
        "applyAnimationToStyles",
        "element",
        "options",
        "element",
        "ANIMATE_TIMER_KEY",
        "animationsData",
        "i",
        "animationsData",
        "i",
        "animationsData",
        "i",
        "element",
        "ANIMATE_TIMER_KEY",
        "$$animationProvider",
        "$$animationProvider",
        "node",
        "node",
        "node",
        "$animateCss",
        "$rootScope",
        "$$AnimateRunner",
        "$rootElement",
        "$sniffer",
        "$$jqLite",
        "$document",
        "$sniffer",
        "$sniffer",
        "noop",
        "$document",
        "getDomNode",
        "$rootElement",
        "jqLite",
        "isDocumentFragment",
        "rootNode",
        "bodyNode",
        "rootNode",
        "rootNode",
        "bodyNode",
        "applyAnimationClassesFactory",
        "$$jqLite",
        "initDriverFn",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "prepareFromToAnchorAnimation",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "prepareRegularAnimation",
        "animationDetails",
        "classes",
        "classes",
        "a",
        "b",
        "isString",
        "a",
        "a",
        "a",
        "isString",
        "b",
        "b",
        "b",
        "a",
        "val",
        "b",
        "val",
        "classes",
        "outAnchor",
        "inAnchor",
        "jqLite",
        "getDomNode",
        "outAnchor",
        "filterCssClasses",
        "getClassVal",
        "clone",
        "outAnchor",
        "NG_ANIMATE_SHIM_CLASS_NAME",
        "inAnchor",
        "NG_ANIMATE_SHIM_CLASS_NAME",
        "clone",
        "NG_ANIMATE_ANCHOR_CLASS_NAME",
        "rootBodyElement",
        "clone",
        "prepareOutAnimation",
        "animatorOut",
        "animatorIn",
        "prepareInAnimation",
        "animatorIn",
        "end",
        "animatorOut",
        "animatorIn",
        "startingAnimator",
        "currentAnimation",
        "currentAnimation",
        "animatorIn",
        "animatorIn",
        "prepareInAnimation",
        "animatorIn",
        "currentAnimation",
        "animatorIn",
        "currentAnimation",
        "currentAnimation",
        "end",
        "runner",
        "currentAnimation",
        "end",
        "runner",
        "runner",
        "$$AnimateRunner",
        "endFn",
        "endFn",
        "runner",
        "currentAnimation",
        "currentAnimation",
        "anchor",
        "getDomNode",
        "anchor",
        "forEach",
        "key",
        "coords",
        "key",
        "key",
        "value",
        "bodyNode",
        "value",
        "bodyNode",
        "styles",
        "key",
        "value",
        "styles",
        "$animateCss",
        "clone",
        "NG_OUT_ANCHOR_CLASS_NAME",
        "calculateAnchorStyles",
        "outAnchor",
        "animator",
        "animator",
        "element",
        "element",
        "filterCssClasses",
        "getClassVal",
        "inAnchor",
        "getUniqueValues",
        "endingClasses",
        "startingClasses",
        "getUniqueValues",
        "startingClasses",
        "endingClasses",
        "$animateCss",
        "clone",
        "calculateAnchorStyles",
        "inAnchor",
        "NG_IN_ANCHOR_CLASS_NAME",
        "toAdd",
        "NG_OUT_ANCHOR_CLASS_NAME",
        "toRemove",
        "animator",
        "animator",
        "clone",
        "outAnchor",
        "NG_ANIMATE_SHIM_CLASS_NAME",
        "inAnchor",
        "NG_ANIMATE_SHIM_CLASS_NAME",
        "to",
        "classes",
        "anchors",
        "prepareRegularAnimation",
        "noop",
        "prepareRegularAnimation",
        "to",
        "noop",
        "forEach",
        "anchors",
        "anchor",
        "anchor",
        "anchor",
        "prepareAnchoredAnimation",
        "classes",
        "outElement",
        "inElement",
        "animator",
        "anchorAnimations",
        "animator",
        "fromAnimation",
        "toAnimation",
        "anchorAnimations",
        "fromAnimation",
        "animationRunners",
        "fromAnimation",
        "toAnimation",
        "animationRunners",
        "toAnimation",
        "forEach",
        "anchorAnimations",
        "animation",
        "animationRunners",
        "animation",
        "$$AnimateRunner",
        "endFn",
        "endFn",
        "$$AnimateRunner",
        "animationRunners",
        "status",
        "runner",
        "status",
        "runner",
        "forEach",
        "animationRunners",
        "runner",
        "runner",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "options",
        "animationDetails",
        "options",
        "options",
        "animationDetails",
        "options",
        "options",
        "options",
        "options",
        "concatWithSpace",
        "options",
        "options",
        "$animateCss",
        "element",
        "options",
        "animator",
        "animator",
        "$animateProvider",
        "$injector",
        "$$AnimateRunner",
        "$$jqLite",
        "applyAnimationClassesFactory",
        "$$jqLite",
        "element",
        "classes",
        "options",
        "arguments",
        "isObject",
        "classes",
        "options",
        "classes",
        "classes",
        "options",
        "prepareAnimationOptions",
        "options",
        "classes",
        "classes",
        "element",
        "options",
        "classes",
        "options",
        "options",
        "classes",
        "options",
        "options",
        "options",
        "lookupAnimations",
        "classes",
        "animations",
        "beforeFn",
        "afterFn",
        "beforeFn",
        "afterFn",
        "before",
        "packageAnimations",
        "element",
        "options",
        "animations",
        "beforeFn",
        "after",
        "packageAnimations",
        "element",
        "options",
        "animations",
        "afterFn",
        "before",
        "after",
        "options",
        "applyAnimationClasses",
        "element",
        "options",
        "animationClosed",
        "applyOptions",
        "applyAnimationStyles",
        "element",
        "options",
        "runner",
        "runner",
        "close",
        "runner",
        "$$AnimateRunner",
        "runner",
        "runner",
        "runner",
        "runner",
        "runner",
        "$$AnimateRunner",
        "before",
        "chain",
        "fn",
        "closeActiveAnimations",
        "before",
        "fn",
        "chain",
        "chain",
        "fn",
        "applyOptions",
        "fn",
        "applyOptions",
        "after",
        "chain",
        "fn",
        "closeActiveAnimations",
        "after",
        "fn",
        "runner",
        "endAnimations",
        "endAnimations",
        "$$AnimateRunner",
        "chain",
        "onComplete",
        "runner",
        "success",
        "close",
        "success",
        "runner",
        "success",
        "cancelled",
        "animationClosed",
        "closeActiveAnimations",
        "noop",
        "cancelled",
        "onComplete",
        "cancelled",
        "fn",
        "element",
        "options",
        "onDone",
        "args",
        "element",
        "options",
        "options",
        "onDone",
        "args",
        "element",
        "classesToAdd",
        "classesToRemove",
        "onDone",
        "args",
        "element",
        "classesToAdd",
        "onDone",
        "args",
        "element",
        "classesToRemove",
        "onDone",
        "args",
        "element",
        "onDone",
        "args",
        "options",
        "fn",
        "fn",
        "args",
        "value",
        "isFunction",
        "value",
        "value",
        "value",
        "value",
        "$$AnimateRunner",
        "value",
        "onDone",
        "isFunction",
        "value",
        "value",
        "noop",
        "element",
        "options",
        "animations",
        "fnName",
        "forEach",
        "animations",
        "ani",
        "ani",
        "fnName",
        "animation",
        "operations",
        "rejected",
        "resolved",
        "resolved",
        "endProgressCb",
        "noop",
        "rejected",
        "runner",
        "rejected",
        "runner",
        "$$AnimateRunner",
        "onAnimationComplete",
        "onAnimationComplete",
        "endProgressCb",
        "executeAnimationFn",
        "animation",
        "element",
        "options",
        "result",
        "result",
        "onAnimationComplete",
        "cancelled",
        "runner",
        "operations",
        "element",
        "options",
        "animations",
        "fnName",
        "groupEventedAnimations",
        "element",
        "options",
        "animations",
        "fnName",
        "operations",
        "fnName",
        "a",
        "groupEventedAnimations",
        "element",
        "options",
        "animations",
        "b",
        "groupEventedAnimations",
        "element",
        "options",
        "animations",
        "fnName",
        "a",
        "groupEventedAnimations",
        "element",
        "options",
        "animations",
        "b",
        "groupEventedAnimations",
        "element",
        "options",
        "animations",
        "a",
        "operations",
        "operations",
        "a",
        "b",
        "operations",
        "operations",
        "b",
        "operations",
        "startAnimation",
        "callback",
        "operations",
        "forEach",
        "operations",
        "animateFn",
        "runners",
        "animateFn",
        "runners",
        "$$AnimateRunner",
        "runners",
        "callback",
        "callback",
        "endFn",
        "reject",
        "forEach",
        "runners",
        "runner",
        "reject",
        "runner",
        "runner",
        "classes",
        "classes",
        "isArray",
        "classes",
        "classes",
        "classes",
        "i",
        "classes",
        "i",
        "classes",
        "i",
        "$animateProvider",
        "klass",
        "animationFactory",
        "flagMap",
        "klass",
        "matches",
        "$injector",
        "animationFactory",
        "flagMap",
        "klass",
        "matches",
        "$$animationProvider",
        "$$animationProvider",
        "$$animateJs",
        "$$AnimateRunner",
        "initDriverFn",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "prepareAnimation",
        "animationDetails",
        "prepareAnimation",
        "animationDetails",
        "fromAnimation",
        "toAnimation",
        "fromAnimation",
        "animationRunners",
        "fromAnimation",
        "toAnimation",
        "animationRunners",
        "toAnimation",
        "$$AnimateRunner",
        "animationRunners",
        "done",
        "$$AnimateRunner",
        "endFnFactory",
        "endFnFactory",
        "runner",
        "forEach",
        "animationRunners",
        "runner",
        "runner",
        "status",
        "runner",
        "status",
        "prepareAnimation",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "$$animateJs",
        "element",
        "classes",
        "options",
        "$animateProvider",
        "classString",
        "classString",
        "classString",
        "ONE_SPACE",
        "forEach",
        "keys",
        "key",
        "key",
        "newClassString",
        "currentClassString",
        "newClassString",
        "currentClassString",
        "makeTruthyCssClassMap",
        "currentClassString",
        "newClassString",
        "ONE_SPACE",
        "className",
        "currentClassMap",
        "className",
        "ruleType",
        "element",
        "currentAnimation",
        "previousAnimation",
        "rules",
        "ruleType",
        "fn",
        "fn",
        "element",
        "currentAnimation",
        "previousAnimation",
        "animation",
        "animation",
        "animation",
        "a",
        "b",
        "a",
        "b",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "newAnimation",
        "hasAnimationClasses",
        "newAnimation",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "newAnimation",
        "hasAnimationClasses",
        "newAnimation",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "currentAnimation",
        "newAnimation",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "currentAnimation",
        "currentAnimation",
        "RUNNING_STATE",
        "newAnimation",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "currentAnimation",
        "newAnimation",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "currentAnimation",
        "RUNNING_STATE",
        "newAnimation",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "newAnimation",
        "newAnimation",
        "currentAnimation",
        "currentAnimation",
        "isUndefined",
        "nA",
        "isUndefined",
        "nR",
        "isUndefined",
        "cA",
        "isUndefined",
        "cR",
        "hasMatchingClasses",
        "nA",
        "cR",
        "hasMatchingClasses",
        "nR",
        "cA",
        "$$rAF",
        "$rootScope",
        "$rootElement",
        "$document",
        "$$HashMap",
        "$$animation",
        "$$AnimateRunner",
        "$templateRequest",
        "$$jqLite",
        "$$forceReflow",
        "$$HashMap",
        "$$HashMap",
        "fn",
        "postDigestCalled",
        "fn",
        "$rootScope",
        "postDigestCalled",
        "fn",
        "$rootScope",
        "$templateRequest",
        "isEmpty",
        "isEmpty",
        "deregisterWatch",
        "$rootScope",
        "$rootScope",
        "animationsEnabled",
        "animationsEnabled",
        "$animateProvider",
        "classNameFilter",
        "className",
        "classNameFilter",
        "className",
        "applyAnimationClassesFactory",
        "$$jqLite",
        "element",
        "animation",
        "mergeAnimationDetails",
        "element",
        "animation",
        "Node",
        "arg",
        "arg",
        "arg",
        "parent",
        "element",
        "getDomNode",
        "element",
        "getDomNode",
        "parent",
        "callbackRegistry",
        "entries",
        "forEach",
        "entries",
        "entry",
        "contains",
        "entry",
        "targetNode",
        "matches",
        "entry",
        "contains",
        "entry",
        "targetParentNode",
        "matches",
        "entry",
        "matches",
        "container",
        "callback",
        "extractElementNode",
        "container",
        "callbackRegistry",
        "callbackRegistry",
        "callbackRegistry",
        "node",
        "callback",
        "container",
        "callback",
        "callbackRegistry",
        "entries",
        "callbackRegistry",
        "arguments",
        "filterFromRegistry",
        "entries",
        "container",
        "callback",
        "matchContainer",
        "matchCallback",
        "extractElementNode",
        "matchContainer",
        "entry",
        "entry",
        "containerNode",
        "matchCallback",
        "entry",
        "matchCallback",
        "isMatch",
        "element",
        "parentElement",
        "assertArg",
        "isElement",
        "element",
        "assertArg",
        "isElement",
        "parentElement",
        "element",
        "NG_ANIMATE_PIN_DATA",
        "parentElement",
        "element",
        "options",
        "domOperation",
        "options",
        "options",
        "options",
        "domOperation",
        "queueAnimation",
        "element",
        "options",
        "element",
        "arguments",
        "argCount",
        "animationsEnabled",
        "isElement",
        "element",
        "hasElement",
        "animationsEnabled",
        "element",
        "getDomNode",
        "element",
        "disabledElementsLookup",
        "node",
        "argCount",
        "recordExists",
        "disabledElementsLookup",
        "node",
        "element",
        "initialOptions",
        "copy",
        "initialOptions",
        "element",
        "stripCommentsFromElement",
        "element",
        "element",
        "node",
        "getDomNode",
        "element",
        "parent",
        "element",
        "options",
        "prepareAnimationOptions",
        "options",
        "$$AnimateRunner",
        "postDigestTaskFactory",
        "isArray",
        "options",
        "options",
        "options",
        "options",
        "isString",
        "options",
        "options",
        "isArray",
        "options",
        "options",
        "options",
        "options",
        "isString",
        "options",
        "options",
        "options",
        "isObject",
        "options",
        "options",
        "options",
        "isObject",
        "options",
        "options",
        "node",
        "close",
        "runner",
        "node",
        "options",
        "options",
        "isAnimatableClassName",
        "className",
        "close",
        "runner",
        "animationsEnabled",
        "$document",
        "disabledElementsLookup",
        "node",
        "skipAnimations",
        "activeAnimationsLookup",
        "node",
        "existingAnimation",
        "skipAnimations",
        "hasExistingAnimation",
        "existingAnimation",
        "PRE_DIGEST_STATE",
        "skipAnimations",
        "areAnimationsAllowed",
        "element",
        "parent",
        "skipAnimations",
        "close",
        "runner",
        "isStructural",
        "closeChildAnimations",
        "element",
        "isStructural",
        "element",
        "options",
        "options",
        "close",
        "options",
        "runner",
        "hasExistingAnimation",
        "isAllowed",
        "element",
        "newAnimation",
        "existingAnimation",
        "skipAnimationFlag",
        "existingAnimation",
        "RUNNING_STATE",
        "close",
        "runner",
        "mergeAnimationDetails",
        "element",
        "existingAnimation",
        "newAnimation",
        "existingAnimation",
        "isAllowed",
        "element",
        "newAnimation",
        "existingAnimation",
        "cancelAnimationFlag",
        "existingAnimation",
        "RUNNING_STATE",
        "existingAnimation",
        "existingAnimation",
        "existingAnimation",
        "mergeAnimationDetails",
        "element",
        "existingAnimation",
        "newAnimation",
        "existingAnimation",
        "isAllowed",
        "element",
        "newAnimation",
        "existingAnimation",
        "joinAnimationFlag",
        "existingAnimation",
        "RUNNING_STATE",
        "normalizeAnimationDetails",
        "element",
        "newAnimation",
        "applyGeneratedPreparationClasses",
        "element",
        "isStructural",
        "options",
        "newAnimation",
        "existingAnimation",
        "options",
        "mergeAnimationDetails",
        "element",
        "existingAnimation",
        "newAnimation",
        "existingAnimation",
        "normalizeAnimationDetails",
        "element",
        "newAnimation",
        "newAnimation",
        "isValidAnimation",
        "isValidAnimation",
        "newAnimation",
        "newAnimation",
        "hasAnimationClasses",
        "newAnimation",
        "isValidAnimation",
        "close",
        "clearElementAnimationState",
        "element",
        "runner",
        "existingAnimation",
        "newAnimation",
        "counter",
        "markElementAnimationState",
        "element",
        "PRE_DIGEST_STATE",
        "newAnimation",
        "$rootScope",
        "activeAnimationsLookup",
        "node",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "element",
        "parentElement",
        "animationDetails",
        "animationDetails",
        "hasAnimationClasses",
        "animationDetails",
        "animationCancelled",
        "animationDetails",
        "counter",
        "isValidAnimation",
        "animationCancelled",
        "applyAnimationClasses",
        "element",
        "options",
        "applyAnimationStyles",
        "element",
        "options",
        "animationCancelled",
        "isStructural",
        "animationDetails",
        "options",
        "runner",
        "isValidAnimation",
        "clearElementAnimationState",
        "element",
        "animationDetails",
        "hasAnimationClasses",
        "animationDetails",
        "animationDetails",
        "markElementAnimationState",
        "element",
        "RUNNING_STATE",
        "$$animation",
        "element",
        "animationDetails",
        "realRunner",
        "status",
        "close",
        "status",
        "activeAnimationsLookup",
        "node",
        "animationDetails",
        "animationDetails",
        "counter",
        "clearElementAnimationState",
        "getDomNode",
        "element",
        "notifyProgress",
        "runner",
        "runner",
        "realRunner",
        "notifyProgress",
        "runner",
        "runner",
        "runner",
        "phase",
        "data",
        "runInNextPostDigestOrNow",
        "findCallbacks",
        "parent",
        "element",
        "callbacks",
        "$$rAF",
        "forEach",
        "callbacks",
        "callback",
        "callback",
        "element",
        "phase",
        "data",
        "runner",
        "phase",
        "data",
        "reject",
        "clearGeneratedClasses",
        "element",
        "options",
        "applyAnimationClasses",
        "element",
        "options",
        "applyAnimationStyles",
        "element",
        "options",
        "options",
        "runner",
        "reject",
        "element",
        "getDomNode",
        "element",
        "node",
        "NG_ANIMATE_ATTR_NAME",
        "forEach",
        "children",
        "child",
        "parseInt",
        "child",
        "NG_ANIMATE_ATTR_NAME",
        "activeAnimationsLookup",
        "child",
        "animationDetails",
        "state",
        "RUNNING_STATE",
        "animationDetails",
        "PRE_DIGEST_STATE",
        "activeAnimationsLookup",
        "child",
        "element",
        "getDomNode",
        "element",
        "node",
        "NG_ANIMATE_ATTR_NAME",
        "activeAnimationsLookup",
        "node",
        "nodeOrElmA",
        "nodeOrElmB",
        "getDomNode",
        "nodeOrElmA",
        "getDomNode",
        "nodeOrElmB",
        "element",
        "parentElement",
        "jqLite",
        "$document",
        "isMatchingElement",
        "element",
        "bodyElement",
        "element",
        "isMatchingElement",
        "element",
        "$rootElement",
        "disabledElementsLookup",
        "getDomNode",
        "element",
        "element",
        "NG_ANIMATE_PIN_DATA",
        "parentHost",
        "parentElement",
        "parentHost",
        "parentElement",
        "parentElement",
        "rootElementDetected",
        "rootElementDetected",
        "isMatchingElement",
        "parentElement",
        "$rootElement",
        "parentElement",
        "parentNode",
        "ELEMENT_NODE",
        "activeAnimationsLookup",
        "parentNode",
        "parentAnimationDetected",
        "disabledElementsLookup",
        "parentNode",
        "parentElementDisabled",
        "elementDisabled",
        "elementDisabled",
        "parentElementDisabled",
        "elementDisabled",
        "parentAnimationDetected",
        "details",
        "isUndefined",
        "animateChildren",
        "animateChildren",
        "parentElement",
        "NG_ANIMATE_CHILDREN_DATA",
        "isDefined",
        "value",
        "animateChildren",
        "value",
        "parentAnimationDetected",
        "animateChildren",
        "bodyElementDetected",
        "bodyElementDetected",
        "isMatchingElement",
        "parentElement",
        "bodyElement",
        "bodyElementDetected",
        "rootElementDetected",
        "rootElementDetected",
        "parentHost",
        "parentElement",
        "NG_ANIMATE_PIN_DATA",
        "parentHost",
        "parentElement",
        "parentHost",
        "parentElement",
        "parentElement",
        "parentAnimationDetected",
        "animateChildren",
        "elementDisabled",
        "allowAnimation",
        "rootElementDetected",
        "bodyElementDetected",
        "element",
        "state",
        "details",
        "details",
        "details",
        "details",
        "state",
        "getDomNode",
        "element",
        "node",
        "NG_ANIMATE_ATTR_NAME",
        "state",
        "activeAnimationsLookup",
        "node",
        "oldValue",
        "extend",
        "oldValue",
        "details",
        "details",
        "activeAnimationsLookup",
        "node",
        "newValue",
        "$animateProvider",
        "element",
        "runner",
        "element",
        "RUNNER_STORAGE_KEY",
        "runner",
        "element",
        "element",
        "RUNNER_STORAGE_KEY",
        "element",
        "element",
        "RUNNER_STORAGE_KEY",
        "$$jqLite",
        "$rootScope",
        "$injector",
        "$$AnimateRunner",
        "$$HashMap",
        "$$rAFScheduler",
        "applyAnimationClassesFactory",
        "$$jqLite",
        "animations",
        "$$HashMap",
        "i",
        "i",
        "animations",
        "i",
        "animations",
        "i",
        "lookup",
        "animation",
        "animations",
        "i",
        "animation",
        "animation",
        "i",
        "i",
        "animations",
        "i",
        "processNode",
        "animations",
        "i",
        "flatten",
        "tree",
        "entry",
        "entry",
        "entry",
        "entry",
        "entry",
        "elementNode",
        "lookup",
        "elementNode",
        "entry",
        "parentNode",
        "parentEntry",
        "lookup",
        "parentNode",
        "parentEntry",
        "parentEntry",
        "parentEntry",
        "processNode",
        "parentEntry",
        "parentNode",
        "parentNode",
        "parentEntry",
        "tree",
        "entry",
        "entry",
        "tree",
        "i",
        "i",
        "tree",
        "i",
        "queue",
        "tree",
        "i",
        "queue",
        "i",
        "i",
        "queue",
        "i",
        "queue",
        "i",
        "remainingLevelEntries",
        "remainingLevelEntries",
        "nextLevelEntries",
        "nextLevelEntries",
        "result",
        "row",
        "row",
        "row",
        "entry",
        "entry",
        "childEntry",
        "nextLevelEntries",
        "queue",
        "childEntry",
        "remainingLevelEntries",
        "row",
        "result",
        "row",
        "result",
        "element",
        "options",
        "options",
        "prepareAnimationOptions",
        "options",
        "$$AnimateRunner",
        "close",
        "close",
        "drivers",
        "close",
        "runner",
        "setRunner",
        "element",
        "runner",
        "mergeClasses",
        "element",
        "mergeClasses",
        "options",
        "options",
        "options",
        "tempClasses",
        "classes",
        "tempClasses",
        "options",
        "isStructural",
        "prepareClassName",
        "PREPARE_CLASS_SUFFIX",
        "$$jqLite",
        "element",
        "prepareClassName",
        "animationQueue",
        "element",
        "classes",
        "isStructural",
        "options",
        "beforeStart",
        "close",
        "element",
        "handleDestroyedElement",
        "animationQueue",
        "runner",
        "$rootScope",
        "forEach",
        "animationQueue",
        "entry",
        "getRunner",
        "entry",
        "animations",
        "entry",
        "entry",
        "animationQueue",
        "groupAnimations",
        "animations",
        "forEach",
        "groupedAnimations",
        "animationEntry",
        "toBeSortedAnimations",
        "getDomNode",
        "animationEntry",
        "animationEntry",
        "animationEntry",
        "triggerAnimationStart",
        "animationEntry",
        "animationEntry",
        "animationEntry",
        "animationEntry",
        "animationEntry",
        "animationEntry",
        "getRunner",
        "targetElement",
        "invokeFirstDriver",
        "animationEntry",
        "operation",
        "startAnimationFn",
        "operation",
        "startAnimationFn",
        "closeFn",
        "startAnimationFn",
        "animationRunner",
        "status",
        "closeFn",
        "status",
        "updateAnimationRunners",
        "animationEntry",
        "animationRunner",
        "$$rAFScheduler",
        "sortAnimations",
        "toBeSortedAnimations",
        "runner",
        "node",
        "NG_ANIMATE_REF_ATTR",
        "node",
        "NG_ANIMATE_REF_ATTR",
        "node",
        "node",
        "SELECTOR",
        "forEach",
        "items",
        "node",
        "node",
        "NG_ANIMATE_REF_ATTR",
        "attr",
        "attr",
        "anchors",
        "node",
        "anchors",
        "animations",
        "forEach",
        "animations",
        "animation",
        "index",
        "animation",
        "getDomNode",
        "element",
        "animation",
        "animation",
        "getAnchorNodes",
        "node",
        "anchorNodes",
        "enterOrMove",
        "forEach",
        "anchorNodes",
        "anchor",
        "anchor",
        "NG_ANIMATE_REF_ATTR",
        "refLookup",
        "key",
        "refLookup",
        "key",
        "refLookup",
        "key",
        "direction",
        "index",
        "jqLite",
        "anchor",
        "preparedAnimations",
        "animation",
        "forEach",
        "refLookup",
        "operations",
        "key",
        "operations",
        "operations",
        "to",
        "to",
        "index",
        "usedIndicesLookup",
        "indexKey",
        "usedIndicesLookup",
        "indexKey",
        "preparedAnimations",
        "animations",
        "index",
        "animations",
        "animations",
        "to",
        "anchorGroups",
        "lookupKey",
        "anchorGroups",
        "lookupKey",
        "fromAnimation",
        "toAnimation",
        "fromAnimation",
        "toAnimation",
        "cssClassesIntersection",
        "fromAnimation",
        "toAnimation",
        "fromAnimation",
        "toAnimation",
        "group",
        "preparedAnimations",
        "group",
        "preparedAnimations",
        "fromAnimation",
        "preparedAnimations",
        "toAnimation",
        "anchorGroups",
        "lookupKey",
        "to",
        "preparedAnimations",
        "a",
        "b",
        "a",
        "a",
        "b",
        "b",
        "i",
        "a",
        "i",
        "a",
        "i",
        "aa",
        "j",
        "b",
        "j",
        "aa",
        "b",
        "j",
        "matches",
        "aa",
        "matches",
        "animationDetails",
        "drivers",
        "i",
        "i",
        "drivers",
        "i",
        "$injector",
        "driverName",
        "$injector",
        "driverName",
        "factory",
        "animationDetails",
        "driver",
        "driver",
        "element",
        "NG_ANIMATE_CLASSNAME",
        "tempClasses",
        "$$jqLite",
        "element",
        "tempClasses",
        "prepareClassName",
        "$$jqLite",
        "element",
        "prepareClassName",
        "prepareClassName",
        "animation",
        "newRunner",
        "animation",
        "animation",
        "update",
        "animation",
        "update",
        "animation",
        "update",
        "animation",
        "element",
        "getRunner",
        "element",
        "newRunner",
        "getRunner",
        "element",
        "runner",
        "options",
        "runner",
        "rejected",
        "element",
        "handleDestroyedElement",
        "removeRunner",
        "element",
        "applyAnimationClasses",
        "element",
        "options",
        "applyAnimationStyles",
        "element",
        "options",
        "options",
        "tempClasses",
        "$$jqLite",
        "element",
        "tempClasses",
        "element",
        "NG_ANIMATE_CLASSNAME",
        "runner",
        "rejected",
        "$animate",
        "$rootScope",
        "scope",
        "$element",
        "attrs",
        "ctrl",
        "$transclude",
        "scope",
        "attrs",
        "attrs",
        "value",
        "previousElement",
        "$animate",
        "previousElement",
        "previousScope",
        "previousScope",
        "previousScope",
        "value",
        "value",
        "previousScope",
        "scope",
        "$transclude",
        "previousScope",
        "element",
        "previousElement",
        "element",
        "$animate",
        "element",
        "$element",
        "angular",
        "ngAnimateSwapDirective",
        "$$AnimateChildrenDirective",
        "$$rAFSchedulerFactory",
        "$$AnimateQueueProvider",
        "$$AnimationProvider",
        "$AnimateCssProvider",
        "$$AnimateCssDriverProvider",
        "$$AnimateJsProvider",
        "$$AnimateJsDriverProvider"
    ],
    "literals": [
        "'use strict'",
        "'-add'",
        "'-remove'",
        "'ng-'",
        "'-active'",
        "'-prepare'",
        "'ng-animate'",
        "'$$ngAnimateChildren'",
        "''",
        "'-webkit-'",
        "'WebkitTransition'",
        "'webkitTransitionEnd transitionend'",
        "'transition'",
        "'transitionend'",
        "'-webkit-'",
        "'WebkitAnimation'",
        "'webkitAnimationEnd animationend'",
        "'animation'",
        "'animationend'",
        "'Duration'",
        "'Property'",
        "'Delay'",
        "'TimingFunction'",
        "'IterationCount'",
        "'PlayState'",
        "'ng'",
        "'areq'",
        "\"Argument '{0}' is {1}\"",
        "'?'",
        "\"required\"",
        "''",
        "' '",
        "' '",
        "' '",
        "''",
        "' '",
        "''",
        "''",
        "' '",
        "''",
        "''",
        "' '",
        "''",
        "'class'",
        "''",
        "''",
        "'addClass'",
        "'removeClass'",
        "' '",
        "' '",
        "''",
        "'-'",
        "'s'",
        "''",
        "'paused'",
        "''",
        "' '",
        "'$$rAF'",
        "'$interpolate'",
        "'ngAnimateChildren'",
        "'on'",
        "'true'",
        "'$$animateCss'",
        "'s'",
        "'s'",
        "'-'",
        "'+'",
        "'s'",
        "'s'",
        "' linear all'",
        "'$animateProvider'",
        "'$window'",
        "'$$jqLite'",
        "'$$AnimateRunner'",
        "'$timeout'",
        "'$$forceReflow'",
        "'$sniffer'",
        "'$$rAFScheduler'",
        "'$$animateQueue'",
        "\"$$ngAnimateParentKey\"",
        "'-'",
        "'class'",
        "'-'",
        "'infinite'",
        "'-stagger'",
        "'class'",
        "' '",
        "''",
        "''",
        "' '",
        "' '",
        "' '",
        "''",
        "'all'",
        "\"boolean\"",
        "''",
        "' '",
        "' '",
        "\"boolean\"",
        "' '",
        "'$$animationProvider'",
        "'$$animateCssDriver'",
        "'ng-animate-shim'",
        "'ng-anchor'",
        "'ng-anchor-out'",
        "'ng-anchor-in'",
        "'$animateCss'",
        "'$rootScope'",
        "'$$AnimateRunner'",
        "'$rootElement'",
        "'$sniffer'",
        "'$$jqLite'",
        "'$document'",
        "''",
        "' '",
        "' '",
        "' '",
        "'width'",
        "'height'",
        "'top'",
        "'left'",
        "'top'",
        "'left'",
        "'px'",
        "'class'",
        "''",
        "' '",
        "' '",
        "'out'",
        "'in'",
        "'leave'",
        "'$animateProvider'",
        "'$injector'",
        "'$$AnimateRunner'",
        "'$$jqLite'",
        "'class'",
        "''",
        "' '",
        "' '",
        "'leave'",
        "'leave'",
        "'afterLeave'",
        "'before'",
        "'enter'",
        "'move'",
        "'animate'",
        "'setClass'",
        "'addClass'",
        "'removeClass'",
        "'beforeSetClass'",
        "'removeClass'",
        "'beforeRemoveClass'",
        "'addClass'",
        "'beforeAddClass'",
        "'setClass'",
        "'removeClass'",
        "'removeClass'",
        "'addClass'",
        "'addClass'",
        "' '",
        "'$$animationProvider'",
        "'$$animateJsDriver'",
        "'$$animateJs'",
        "'$$AnimateRunner'",
        "'data-ng-animate'",
        "'$ngAnimatePin'",
        "'$animateProvider'",
        "' '",
        "''",
        "''",
        "'leave'",
        "'$$rAF'",
        "'$rootScope'",
        "'$rootElement'",
        "'$document'",
        "'$$HashMap'",
        "'$$animation'",
        "'$$AnimateRunner'",
        "'$templateRequest'",
        "'$$jqLite'",
        "'$$forceReflow'",
        "'leave'",
        "'element'",
        "'not an element'",
        "'parentElement'",
        "'not an element'",
        "' '",
        "' '",
        "' '",
        "'enter'",
        "'move'",
        "'leave'",
        "'skip'",
        "'cancel'",
        "'join'",
        "'animate'",
        "'animate'",
        "'setClass'",
        "'close'",
        "'start'",
        "'['",
        "']'",
        "'HTML'",
        "'$animateProvider'",
        "'ng-animate-ref'",
        "'$$animationRunner'",
        "'$$jqLite'",
        "'$rootScope'",
        "'$injector'",
        "'$$AnimateRunner'",
        "'$$HashMap'",
        "'$$rAFScheduler'",
        "'enter'",
        "'move'",
        "'leave'",
        "'class'",
        "' '",
        "'ng-'",
        "'$destroy'",
        "'['",
        "']'",
        "'enter'",
        "'move'",
        "'to'",
        "'from'",
        "'out'",
        "'in'",
        "' '",
        "' '",
        "'ng-'",
        "' '",
        "'leave'",
        "'$destroy'",
        "'$animate'",
        "'$rootScope'",
        "'A'",
        "'element'",
        "'for'",
        "'ngAnimate'",
        "'ngAnimateSwap'",
        "'ngAnimateChildren'",
        "'$$rAFScheduler'",
        "'$$animateQueue'",
        "'$$animation'",
        "'$animateCss'",
        "'$$animateCssDriver'",
        "'$$animateJs'",
        "'$$animateJsDriver'"
    ],
    "variables": [
        "noop",
        "copy",
        "extend",
        "jqLite",
        "forEach",
        "isArray",
        "isString",
        "isObject",
        "isUndefined",
        "isDefined",
        "isFunction",
        "isElement",
        "ELEMENT_NODE",
        "COMMENT_NODE",
        "ADD_CLASS_SUFFIX",
        "REMOVE_CLASS_SUFFIX",
        "EVENT_CLASS_PREFIX",
        "ACTIVE_CLASS_SUFFIX",
        "PREPARE_CLASS_SUFFIX",
        "NG_ANIMATE_CLASSNAME",
        "NG_ANIMATE_CHILDREN_DATA",
        "CSS_PREFIX",
        "TRANSITION_PROP",
        "TRANSITIONEND_EVENT",
        "ANIMATION_PROP",
        "ANIMATIONEND_EVENT",
        "DURATION_KEY",
        "PROPERTY_KEY",
        "DELAY_KEY",
        "TIMING_KEY",
        "ANIMATION_ITERATION_COUNT_KEY",
        "ANIMATION_PLAYSTATE_KEY",
        "SAFE_FAST_FORWARD_DURATION_VALUE",
        "ANIMATION_DELAY_PROP",
        "ANIMATION_DURATION_PROP",
        "TRANSITION_DELAY_PROP",
        "TRANSITION_DURATION_PROP",
        "isPromiseLike",
        "ngMinErr",
        "styles",
        "className",
        "index",
        "i",
        "elm",
        "domOperation",
        "target",
        "newOptions",
        "toAdd",
        "toRemove",
        "classes",
        "realDomOperation",
        "ADD_CLASS",
        "REMOVE_CLASS",
        "flags",
        "classes",
        "prop",
        "allow",
        "obj",
        "classes",
        "value",
        "value",
        "key",
        "prop",
        "value",
        "$$rAFSchedulerFactory",
        "queue",
        "cancelFn",
        "items",
        "i",
        "$$AnimateChildrenDirective",
        "val",
        "ANIMATE_TIMER_KEY",
        "ONE_SECOND",
        "BASE_TEN",
        "ELAPSED_TIME_MAX_DECIMAL_PLACES",
        "CLOSING_TIME_BUFFER",
        "DETECT_CSS_PROPERTIES",
        "DETECT_STAGGER_CSS_PROPERTIES",
        "prop",
        "styles",
        "detectedStyles",
        "val",
        "c",
        "maxValue",
        "values",
        "style",
        "TRANSITION_PROP",
        "value",
        "cache",
        "entry",
        "entry",
        "$AnimateCssProvider",
        "gcsLookup",
        "gcsStaggerLookup",
        "applyAnimationClasses",
        "parentCounter",
        "KEY",
        "parentNode",
        "parentID",
        "timings",
        "stagger",
        "staggerClassName",
        "cancelLastRAFRequest",
        "rafWaitQueue",
        "pageWidth",
        "i",
        "timings",
        "aD",
        "tD",
        "options",
        "restoreStyles",
        "node",
        "temporaryStyles",
        "classes",
        "styles",
        "animationClosed",
        "animationPaused",
        "animationCompleted",
        "runner",
        "runnerHost",
        "maxDelay",
        "maxDelayTime",
        "maxDuration",
        "maxDurationTime",
        "startTime",
        "events",
        "method",
        "isStructural",
        "structuralClassName",
        "addRemoveClassName",
        "preparationClasses",
        "fullClassName",
        "activeClasses",
        "hasToStyles",
        "containsKeyframeAnimation",
        "cacheKey",
        "stagger",
        "staggerVal",
        "applyOnlyDuration",
        "transitionStyle",
        "durationStyle",
        "keyframeStyle",
        "itemIndex",
        "isFirst",
        "timings",
        "relativeDelay",
        "flags",
        "delayStyle",
        "animationTimerData",
        "ev",
        "timeStamp",
        "elapsedTime",
        "playPause",
        "value",
        "maxStagger",
        "key",
        "value",
        "easeProp",
        "easeVal",
        "timerTime",
        "endTime",
        "animationsData",
        "setupFallbackTimer",
        "currentTimerData",
        "timer",
        "animationsData",
        "i",
        "$$AnimateCssDriverProvider",
        "NG_ANIMATE_SHIM_CLASS_NAME",
        "NG_ANIMATE_ANCHOR_CLASS_NAME",
        "NG_OUT_ANCHOR_CLASS_NAME",
        "NG_IN_ANCHOR_CLASS_NAME",
        "bodyNode",
        "rootNode",
        "rootBodyElement",
        "applyAnimationClasses",
        "clone",
        "startingClasses",
        "animatorIn",
        "animatorOut",
        "startingAnimator",
        "runner",
        "currentAnimation",
        "styles",
        "coords",
        "value",
        "animator",
        "endingClasses",
        "toAdd",
        "toRemove",
        "animator",
        "fromAnimation",
        "toAnimation",
        "anchorAnimations",
        "outElement",
        "inElement",
        "animator",
        "animationRunners",
        "runner",
        "element",
        "options",
        "animator",
        "$$AnimateJsProvider",
        "applyAnimationClasses",
        "animationClosed",
        "classesToAdd",
        "classesToRemove",
        "animations",
        "before",
        "after",
        "afterFn",
        "beforeFn",
        "runner",
        "closeActiveAnimations",
        "chain",
        "args",
        "value",
        "operations",
        "animation",
        "runner",
        "endProgressCb",
        "resolved",
        "onAnimationComplete",
        "cancelled",
        "operations",
        "a",
        "b",
        "runners",
        "matches",
        "flagMap",
        "i",
        "klass",
        "animationFactory",
        "$$AnimateJsDriverProvider",
        "fromAnimation",
        "toAnimation",
        "animationRunners",
        "runner",
        "element",
        "options",
        "classes",
        "NG_ANIMATE_ATTR_NAME",
        "NG_ANIMATE_PIN_DATA",
        "$$AnimateQueueProvider",
        "PRE_DIGEST_STATE",
        "RUNNING_STATE",
        "ONE_SPACE",
        "rules",
        "keys",
        "currentClassMap",
        "a",
        "b",
        "nA",
        "nR",
        "cA",
        "cR",
        "activeAnimationsLookup",
        "disabledElementsLookup",
        "animationsEnabled",
        "postDigestCalled",
        "deregisterWatch",
        "callbackRegistry",
        "classNameFilter",
        "isAnimatableClassName",
        "applyAnimationClasses",
        "contains",
        "targetNode",
        "targetParentNode",
        "matches",
        "entries",
        "node",
        "entries",
        "containerNode",
        "isMatch",
        "argCount",
        "hasElement",
        "node",
        "recordExists",
        "options",
        "node",
        "parent",
        "runner",
        "runInNextPostDigestOrNow",
        "className",
        "isStructural",
        "skipAnimations",
        "existingAnimation",
        "hasExistingAnimation",
        "newAnimation",
        "skipAnimationFlag",
        "cancelAnimationFlag",
        "joinAnimationFlag",
        "isValidAnimation",
        "counter",
        "animationDetails",
        "animationCancelled",
        "parentElement",
        "isValidAnimation",
        "realRunner",
        "animationDetails",
        "callbacks",
        "node",
        "children",
        "state",
        "animationDetails",
        "node",
        "bodyElement",
        "bodyElementDetected",
        "rootElementDetected",
        "parentAnimationDetected",
        "animateChildren",
        "elementDisabled",
        "parentHost",
        "parentNode",
        "details",
        "parentElementDisabled",
        "value",
        "allowAnimation",
        "node",
        "oldValue",
        "newValue",
        "$$AnimationProvider",
        "NG_ANIMATE_REF_ATTR",
        "drivers",
        "RUNNER_STORAGE_KEY",
        "animationQueue",
        "applyAnimationClasses",
        "tree",
        "i",
        "lookup",
        "animation",
        "elementNode",
        "parentNode",
        "parentEntry",
        "result",
        "queue",
        "i",
        "remainingLevelEntries",
        "nextLevelEntries",
        "row",
        "entry",
        "isStructural",
        "runner",
        "classes",
        "tempClasses",
        "prepareClassName",
        "animations",
        "groupedAnimations",
        "toBeSortedAnimations",
        "startAnimationFn",
        "closeFn",
        "targetElement",
        "operation",
        "animationRunner",
        "SELECTOR",
        "items",
        "anchors",
        "attr",
        "preparedAnimations",
        "refLookup",
        "element",
        "node",
        "enterOrMove",
        "anchorNodes",
        "direction",
        "key",
        "usedIndicesLookup",
        "anchorGroups",
        "to",
        "index",
        "indexKey",
        "fromAnimation",
        "toAnimation",
        "lookupKey",
        "group",
        "matches",
        "i",
        "aa",
        "j",
        "i",
        "driverName",
        "factory",
        "driver",
        "runner",
        "ngAnimateSwapDirective",
        "previousElement",
        "previousScope"
    ],
    "comments": [
        "jshint ignore:start",
        "Detect proper transitionend/animationend event names.",
        "If unprefixed events are not supported but webkit-prefixed are, use the latter.",
        "Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.",
        "Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`",
        "but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.",
        "Register both events in case `window.onanimationend` is not supported because of that,",
        "do the same for `transitionend` as Safari is likely to exhibit similar behavior.",
        "Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit",
        "therefore there is no reason to test anymore for other vendor prefixes:",
        "http://caniuse.com/#search=transition",
        "there is no point of stripping anything if the element",
        "is the only element within the jqLite wrapper.",
        "(it's important that we retain the element instance.)",
        "noop is basically when there is no callback; otherwise something has been set",
        "TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.",
        "sometimes the split leaves empty string values",
        "incase extra spaces were applied to the options",
        "we use a negative delay value since it performs blocking",
        "yet it doesn't kill any existing transitions running on the",
        "same element which makes this safe for class-based animations",
        "we make a copy since RAFScheduler mutates the state",
        "of the passed in array variable and this would be difficult",
        "to track down on the outside code",
        "waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.",
        "empty attribute",
        "Interpolate and set the value, so that it is available to",
        "animations that run right after compilation",
        "only numerical-based values have a negative sign or digit as the first value",
        "by setting this to null in the event that the delay is not set or is set directly as 0",
        "then we can still allow for negative values to be used later on and not mistake this",
        "value for being greater than any other negative value.",
        "it's always safe to consider only second values and omit `ms` values since",
        "getComputedStyle will always handle the conversion for us",
        "we do not reassign an already present style value since",
        "if we detect the style property value again we may be",
        "detecting styles that were added via the `from` styles.",
        "We make use of `isDefined` here since an empty string",
        "or null value (which is what getPropertyValue will return",
        "for a non-existing style) will still be marked as a valid",
        "value for the style (a falsy value implies that the style",
        "is to be removed at the end of the animation). If we had a simple",
        "\"OR\" statement then it would not be enough to catch that.",
        "we keep putting this in multiple times even though the value and the cacheKey are the same",
        "because we're keeping an internal tally of how many duplicate animations are detected.",
        "if we have one or more existing matches of matching elements",
        "containing the same parent + CSS styles (which is how cacheKey works)",
        "then staggering is possible",
        "force the conversion of a null value to zero incase not set",
        "DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.",
        "PLEASE EXAMINE THE `$$forceReflow` service to understand why.",
        "we use a for loop to ensure that if the queue is changed",
        "during this looping then it will consider new requests",
        "all of the animation functions should create",
        "a copy of the options data, however, if a",
        "parent service has already created a copy then",
        "we should stick to using that",
        "there may be a situation where a structural animation is combined together",
        "with CSS classes that need to resolve before the animation is computed.",
        "However this means that there is no explicit CSS code to block the animation",
        "from happening (by setting 0s none in the class name). If this is the case",
        "we need to apply the classes before the first rAF so we know to continue if",
        "there actually is a detected transition or keyframe animation",
        "there is no way we can trigger an animation if no styles and",
        "no classes are being applied which would then trigger a transition,",
        "unless there a is raw keyframe value that is applied to the element.",
        "we set the duration so that it will be picked up by getComputedStyle later",
        "this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY",
        "without causing any combination of transitions to kick in. By adding a negative delay value",
        "it forces the setup class' transition to end immediately. We later then remove the negative",
        "transition delay to allow for the transition to naturally do it's thing. The beauty here is",
        "that if there is no transition defined then nothing will happen and this will also allow",
        "other transitions to be stacked on top of each other without any chopping them out.",
        "number in options.delay means we have to recalculate the delay for the closing timeout",
        "we need to recalculate the delay value since we used a pre-emptive negative",
        "delay value and the delay value is required for the final event checking. This",
        "property will ensure that this will happen after the RAF phase has passed.",
        "TODO(matsko): for 1.5 change this code to have an animator object for better debugging",
        "this will be set during the start() phase",
        "we don't have access to pause/resume the animation",
        "since it hasn't run yet. AnimateRunner will therefore",
        "set noop functions for resume and pause and they will",
        "later be overridden once the animation is triggered",
        "jshint ignore:line",
        "if the promise has been called already then we shouldn't close",
        "the animation again",
        "There is only one way to remove inline style properties entirely from elements.",
        "By using `removeProperty` this works, but we need to convert camel-cased CSS",
        "styles down to hyphenated values.",
        "the reason why we have this option is to allow a synchronous closing callback",
        "that is fired as SOON as the animation ends (when the CSS is removed) or if",
        "the animation never takes off at all. A good example is a leave animation since",
        "the element must be removed just after the animation is over or else the element",
        "will appear on screen for one animation frame causing an overbearing flicker.",
        "Remove the transitionend / animationend listener(s)",
        "Cancel the fallback closing timeout and remove the timer data",
        "if the preparation function fails then the promise is not setup",
        "should flush the cache animation",
        "we now always use `Date.now()` due to the recent changes with",
        "event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)",
        "Firefox (or possibly just Gecko) likes to not round values up\n         * when a ms measurement is used for the animation",
        "$manualTimeStamp is a mocked timeStamp value which is set\n         * within browserTrigger(). This is only here so that tests can\n         * mock animations properly. Real events fallback to event.timeStamp,\n         * or, if they don't, then a timeStamp is automatically created for them.\n         * We're checking to see if the timeStamp surpasses the expected delay,\n         * but we're using elapsedTime instead of the timeStamp on the 2nd\n         * pre-condition since animationPauseds sometimes close off early",
        "we set this flag to ensure that if the transition is paused then, when resumed,",
        "the animation will automatically close itself since transitions cannot be paused.",
        "even though we only pause keyframe animations here the pause flag",
        "will still happen when transitions are used. Only the transition will",
        "not be paused since that is not possible. If the animation ends when",
        "paused then it will not complete until unpaused or cancelled.",
        "checking the stagger duration prevents an accidentally cascade of the CSS delay style",
        "being inherited from the parent. If the transition duration is zero then we can safely",
        "rely that the delay value is an intentional stagger delay style.",
        "this will decorate the existing promise runner with pause/resume methods",
        "just incase a stagger animation kicks in when the animation",
        "itself was cancelled entirely",
        "this will be false in the event that the element was",
        "removed from the DOM (via a leave animation or something",
        "similar)",
        "only browsers that support these properties can render animations",
        "this is to avoid using something that exists outside of the body",
        "we also special case the doc fragment case because our unit test code",
        "appends the $rootElement to the body after the app has been bootstrapped",
        "remove all the `ng-` stuff",
        "the user may not end up using the `out` animation and",
        "only making use of the `in` animation or vice-versa.",
        "In either case we should allow this and not assume the",
        "animation is over unless both animations are not used.",
        "in the event that there is no `in` animation",
        "we iterate directly since safari messes up and doesn't return",
        "all the keys for the coords object when iterated",
        "read the comment within `prepareRegularAnimation` to understand",
        "why this check is necessary",
        "read the comment within `prepareRegularAnimation` to understand",
        "why this check is necessary",
        "no point in doing anything when there are no elements to animate",
        "CSS-driven animations cannot be cancelled, only ended",
        "we special case the leave animation since we want to ensure that",
        "the element is removed as soon as the animation is over. Otherwise",
        "a flicker might appear or the element may not be removed at all",
        "We assign the preparationClasses as the actual animation event since",
        "the internals of $animateCss will just suffix the event token values",
        "with `-active` to trigger the animation.",
        "the driver lookup code inside of $$animation attempts to spawn a",
        "driver one by one until a driver returns a.$$willAnimate animator object.",
        "$animateCss will always return an object, however, it will pass in",
        "a flag as a hint as to whether an animation was detected or not",
        "TODO(matsko): use caching here to speed things up for detection",
        "TODO(matsko): add documentation",
        "by the time...",
        "$animateJs(element, 'enter');",
        "the `classes` argument is optional and if it is not used",
        "then the classes will be resolved from the element's className",
        "property as well as options.addClass/options.removeClass.",
        "the lookupAnimations function returns a series of animation objects that are",
        "matched up with one or more of the CSS classes. These animation objects are",
        "defined via the module.animation factory function. If nothing is detected then",
        "we don't return anything which then makes $animation query the next driver.",
        "TODO(matsko): get rid of this",
        "no matching animations",
        "optional onEnd / onCancel callback",
        "note that all of these animations will run in parallel",
        "TODO(matsko): add documentation",
        "at this point we cannot cancel animations for groups just yet. 1.5+",
        "TODO(matsko): make sure to check for grouped animations and delegate down to normal animations",
        "if the new animation is class-based then we can just tack that on",
        "there is no need to animate anything if no classes are being added and",
        "there is no structural animation that will be triggered",
        "why should we trigger a new structural animation if the element will",
        "be removed from the DOM anyway?",
        "if there is an ongoing current animation then don't even bother running the class-based animation",
        "there can never be two structural animations running at the same time",
        "if the previous animation is already running, but the new animation will",
        "be triggered, but the new animation is structural",
        "early detection to save the global CPU shortage :)",
        "we only issue a call to postDigest before",
        "it has first passed. This prevents any callbacks",
        "from not firing once the animation has completed",
        "since it will be out of the digest cycle.",
        "Wait until all directive and route-related templates are downloaded and",
        "compiled. The $templateRequest.totalPendingRequests variable keeps track of",
        "all of the remote templates being currently downloaded. If there are no",
        "templates currently downloading then the watcher will still fire anyway.",
        "Now that all templates have been downloaded, $animate will wait until",
        "the post digest queue is empty before enabling animations. By having two",
        "calls to $postDigest calls we can ensure that the flag is enabled at the",
        "very end of the post digest queue. Since all of the animations in $animate",
        "use $postDigest, it's important that the code below executes at the end.",
        "This basically means that the page is fully downloaded and compiled before",
        "any animations are triggered.",
        "we check for null directly in the event that the application already called",
        ".enabled() with whatever arguments that it provided it with",
        "remember that the classNameFilter is set during the provider/config",
        "stage therefore we can optimize here and setup a helper function",
        "IE9-11 has no method \"contains\" in SVG element and in Node.prototype. Bug #10259.",
        "jshint bitwise: false",
        "jshint bitwise: true",
        "this method has four signatures:",
        "() - global getter",
        "(bool) - global setter",
        "(element) - element getter",
        "(element, bool) - element setter<F37>",
        "() - Global getter",
        "(bool) - Global setter",
        "(element) - Element getter",
        "(element, bool) - Element setter",
        "we always make a copy of the options since",
        "there should never be any side effects on",
        "the input data when running `$animateCss`.",
        "we create a fake runner with a working promise.",
        "These methods will become available after the digest has passed",
        "this is used to trigger callbacks in postDigest mode",
        "there are situations where a directive issues an animation for",
        "a jqLite wrapper that contains only comment nodes... If this",
        "happens then there is no way we can perform an animation",
        "this is a hard disable of all animations for the application or on",
        "the element itself, therefore  there is no need to continue further",
        "past this point if not enabled",
        "Animations are also disabled if the document is currently hidden (page is not visible",
        "to the user), because browsers slow down or do not flush calls to requestAnimationFrame",
        "there is no point in traversing the same collection of parent ancestors if a followup",
        "animation will be run on the same element that already did all that checking work",
        "this will end the animation right away and it is safe",
        "to do so since the animation is already running and the",
        "runner callback code will run in async",
        "this means that the animation is queued into a digest, but",
        "hasn't started yet. Therefore it is safe to run the close",
        "method which will call the runner methods in async.",
        "this will merge the new animation options into existing animation options",
        "a joined animation means that this animation will take over the existing one",
        "so an example would involve a leave animation taking over an enter. Then when",
        "the postDigest kicks in the enter will be ignored.",
        "we return the same runner since only the option values of this animation will",
        "be fed into the `existingAnimation`.",
        "normalization in this case means that it removes redundant CSS classes that",
        "already exist (addClass) or do not exist (removeClass) on the element",
        "when the options are merged and cleaned up we may end up not having to do",
        "an animation at all, therefore we should check this before issuing a post",
        "digest callback. Structural animations will always run no matter what.",
        "animate (from/to) can be quickly checked first, otherwise we check if any classes are present",
        "the counter keeps track of cancelled animations",
        "if addClass/removeClass is called before something like enter then the",
        "registered parent element may not be present. The code below will ensure",
        "that a final value for parent element is obtained",
        "animate/structural/class-based animations all have requirements. Otherwise there",
        "is no point in performing an animation. The parent node must also be set.",
        "this means that the previous animation was cancelled",
        "even if the follow-up animation is the same event",
        "if another animation did not take over then we need",
        "to make sure that the domOperation and options are",
        "handled accordingly",
        "if the event changed from something like enter to leave then we do",
        "it, otherwise if it's the same then the end result will be the same too",
        "in the event that the element animation was not cancelled or a follow-up animation",
        "isn't allowed to animate from here then we need to clear the state of the element",
        "so that any future animations won't read the expired animation data.",
        "this combined multiple class to addClass / removeClass into a setClass event",
        "so long as a structural event did not take over the animation",
        "this will update the runner's flow-control events based on",
        "the `realRunner` object.",
        "do not optimize this call here to RAF because",
        "we don't know how heavy the callback code here will",
        "be and if this code is buffered then this can",
        "lead to a performance regression.",
        "jshint ignore:line",
        "falls through",
        "angular doesn't want to attempt to animate elements outside of the application",
        "therefore we need to ensure that the rootElement is an ancestor of the current element",
        "no point in inspecting the #document element",
        "either an enter, leave or move animation will commence",
        "therefore we can't allow any animations to take place",
        "but if a parent animation is class-based then that's ok",
        "disable animations if the user hasn't explicitly enabled animations on the",
        "current element",
        "element is disabled via parent element, no need to check anything else",
        "there is no need to continue traversing at this point",
        "we also need to ensure that the element is or will be a part of the body element",
        "otherwise it is pointless to even issue an animation to be rendered",
        "If both body and root have been found, any other checks are pointless,",
        "as no animation data should live outside the application",
        "If no rootElement is detected, check if the parentElement is pinned to another element",
        "The pin target element becomes the next parent element",
        "this is done first beforehand so that the hashmap",
        "is filled with a list of the elements that will be animated",
        "TODO(matsko): document the signature in a better way",
        "there is no animation at the current moment, however",
        "these runner methods will get later updated with the",
        "methods leading into the driver's end/cancel methods",
        "for now they just stop the animation from starting",
        "this data is used by the postDigest code and passed into",
        "the driver step function",
        "we only want there to be one function called within the post digest",
        "block. This way we can group animations for all the animations that",
        "were apart of the same postDigest flush call.",
        "the element was destroyed early on which removed the runner",
        "form its storage. This means we can't animate this element",
        "at all and it already has been closed due to destruction.",
        "now any future animations will be in another postDigest",
        "it's important that we apply the `ng-animate` CSS class and the",
        "temporary classes before we do any driver invoking since these",
        "CSS classes may be required for proper CSS detection.",
        "in the event that the element was removed before the digest runs or",
        "during the RAF sequencing then we should not trigger the animation.",
        "we need to sort each of the animations in order of parent to child",
        "relationships. This ensures that the child classes are applied at the",
        "right time.",
        "TODO(matsko): change to reference nodes",
        "only one of these is set therefore we can't have an",
        "anchor animation since all three pieces are required",
        "TODO(matsko): change to reference nodes",
        "the anchor animations require that the from and to elements both have at least",
        "one shared CSS class which effectively marries the two elements together to use",
        "the same animation driver and to properly sequence the anchor animation.",
        "we loop in reverse order since the more general drivers (like CSS and JS)",
        "may attempt more elements, but custom drivers are more particular",
        "TODO(matsko): remove this check",
        "jshint ignore:line",
        "we use 600 here to ensure that the directive is caught before others",
        "global angularAnimateModule: true,\n\n   ngAnimateSwapDirective,\n   $$AnimateAsyncRunFactory,\n   $$rAFSchedulerFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,"
    ],
    "docstrings": [
        "* @license AngularJS v1.5.0\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT",
        "* @ngdoc directive\n * @name ngAnimateChildren\n * @restrict AE\n * @element ANY\n *\n * @description\n *\n * ngAnimateChildren allows you to specify that children of this element should animate even if any\n * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\n * (structural) animation, child elements that also have an active structural animation are not animated.\n *\n * Note that even if `ngAnimteChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\n *\n *\n * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,\n *     then child animations are allowed. If the value is `false`, child animations are not allowed.\n *\n * @example\n * <example module=\"ngAnimateChildren\" name=\"ngAnimateChildren\" deps=\"angular-animate.js\" animations=\"true\">\n     <file name=\"index.html\">\n       <div ng-controller=\"mainController as main\">\n         <label>Show container? <input type=\"checkbox\" ng-model=\"main.enterElement\" /></label>\n         <label>Animate children? <input type=\"checkbox\" ng-model=\"main.animateChildren\" /></label>\n         <hr>\n         <div ng-animate-children=\"{{main.animateChildren}}\">\n           <div ng-if=\"main.enterElement\" class=\"container\">\n             List of items:\n             <div ng-repeat=\"item in [0, 1, 2, 3]\" class=\"item\">Item {{item}}</div>\n           </div>\n         </div>\n       </div>\n     </file>\n     <file name=\"animations.css\">\n\n      .container.ng-enter,\n      .container.ng-leave {\n        transition: all ease 1.5s;\n      }\n\n      .container.ng-enter,\n      .container.ng-leave-active {\n        opacity: 0;\n      }\n\n      .container.ng-leave,\n      .container.ng-enter-active {\n        opacity: 1;\n      }\n\n      .item {\n        background: firebrick;\n        color: #FFF;\n        margin-bottom: 10px;\n      }\n\n      .item.ng-enter,\n      .item.ng-leave {\n        transition: transform 1.5s ease;\n      }\n\n      .item.ng-enter {\n        transform: translateX(50px);\n      }\n\n      .item.ng-enter-active {\n        transform: translateX(0);\n      }\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngAnimateChildren', ['ngAnimate'])\n        .controller('mainController', function() {\n          this.animateChildren = false;\n          this.enterElement = false;\n        });\n    </file>\n  </example>",
        "* @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.",
        "* This fn returns false if any of the following is true:\n     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed\n     * b) a parent element has an ongoing structural animation, and animateChildren is false\n     * c) the element is not a child of the body\n     * d) the element is not a child of the $rootElement",
        "* @ngdoc directive\n * @name ngAnimateSwap\n * @restrict A\n * @scope\n *\n * @description\n *\n * ngAnimateSwap is a animation-oriented directive that allows for the container to\n * be removed and entered in whenever the associated expression changes. A\n * common usecase for this directive is a rotating banner component which\n * contains one image being present at a time. When the active image changes\n * then the old image will perform a `leave` animation and the new element\n * will be inserted via an `enter` animation.\n *\n * @example\n * <example name=\"ngAnimateSwap-directive\" module=\"ngAnimateSwapExample\"\n *          deps=\"angular-animate.js\"\n *          animations=\"true\" fixBase=\"true\">\n *   <file name=\"index.html\">\n *     <div class=\"container\" ng-controller=\"AppCtrl\">\n *       <div ng-animate-swap=\"number\" class=\"cell swap-animation\" ng-class=\"colorClass(number)\">\n *         {{ number }}\n *       </div>\n *     </div>\n *   </file>\n *   <file name=\"script.js\">\n *     angular.module('ngAnimateSwapExample', ['ngAnimate'])\n *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {\n *         $scope.number = 0;\n *         $interval(function() {\n *           $scope.number++;\n *         }, 1000);\n *\n *         var colors = ['red','blue','green','yellow','orange'];\n *         $scope.colorClass = function(number) {\n *           return colors[number % colors.length];\n *         };\n *       }]);\n *   </file>\n *  <file name=\"animations.css\">\n *  .container {\n *    height:250px;\n *    width:250px;\n *    position:relative;\n *    overflow:hidden;\n *    border:2px solid black;\n *  }\n *  .container .cell {\n *    font-size:150px;\n *    text-align:center;\n *    line-height:250px;\n *    position:absolute;\n *    top:0;\n *    left:0;\n *    right:0;\n *    border-bottom:2px solid black;\n *  }\n *  .swap-animation.ng-enter, .swap-animation.ng-leave {\n *    transition:0.5s linear all;\n *  }\n *  .swap-animation.ng-enter {\n *    top:-250px;\n *  }\n *  .swap-animation.ng-enter-active {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave-active {\n *    top:250px;\n *  }\n *  .red { background:red; }\n *  .green { background:green; }\n *  .blue { background:blue; }\n *  .yellow { background:yellow; }\n *  .orange { background:orange; }\n *  </file>\n * </example>",
        "* @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=true\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ### The `ng-[event]-prepare` class\n *\n * This is a special class that can be used to prevent unwanted flickering / flash of content before\n * the actual animation starts. The class is added as soon as an animation is initialized, but removed\n * before the actual animation starts (after waiting for a $digest).\n * It is also only added for *structural* animations (`enter`, `move`, and `leave`).\n *\n * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`\n * into elements that have class-based animations such as `ngClass`.\n *\n * ```html\n * <div ng-class=\"{red: myProp}\">\n *   <div ng-class=\"{blue: myProp}\">\n *     <div class=\"message\" ng-if=\"myProp\"></div>\n *   </div>\n * </div>\n * ```\n *\n * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\n * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:\n *\n * ```css\n * .message.ng-enter-prepare {\n *   opacity: 0;\n * }\n *\n * ```\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the animation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]);\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n *\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix\n * will be evaluated for animation when any DOM changes occur in the application.\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)",
        "* @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}."
    ],
    "functions": [
        "assertArg",
        "mergeClasses",
        "packageStyles",
        "pendClasses",
        "removeFromArray",
        "stripCommentsFromElement",
        "extractElementNode",
        "$$addClass",
        "$$removeClass",
        "applyAnimationClassesFactory",
        "prepareAnimationOptions",
        "applyAnimationStyles",
        "applyAnimationFromStyles",
        "applyAnimationToStyles",
        "mergeAnimationDetails",
        "resolveElementClasses",
        "splitClassesToLookup",
        "getDomNode",
        "applyGeneratedPreparationClasses",
        "clearGeneratedClasses",
        "blockTransitions",
        "blockKeyframeAnimations",
        "applyInlineStyle",
        "concatWithSpace",
        "scheduler",
        "nextTick",
        "setData",
        "getCssKeyframeDurationStyle",
        "getCssDelayStyle",
        "computeCssStyles",
        "parseMaxTime",
        "truthyTimingValue",
        "getCssTransitionDurationStyle",
        "createLocalCacheLookup",
        "registerRestorableStyles",
        "gcsHashFn",
        "computeCachedCssStyles",
        "computeCachedCssStaggerStyles",
        "waitUntilQuiet",
        "computeTimings",
        "endFn",
        "cancelFn",
        "close",
        "applyBlocking",
        "closeAndReturnNoopAnimator",
        "onAnimationProgress",
        "start",
        "triggerAnimationStart",
        "onAnimationExpired",
        "isDocumentFragment",
        "filterCssClasses",
        "getUniqueValues",
        "prepareAnchoredAnimation",
        "endFn",
        "calculateAnchorStyles",
        "prepareOutAnimation",
        "getClassVal",
        "prepareInAnimation",
        "end",
        "prepareFromToAnchorAnimation",
        "endFn",
        "prepareRegularAnimation",
        "applyOptions",
        "close",
        "onComplete",
        "endAnimations",
        "executeAnimationFn",
        "groupEventedAnimations",
        "packageAnimations",
        "lookupAnimations",
        "endFnFactory",
        "done",
        "prepareAnimation",
        "makeTruthyCssClassMap",
        "hasMatchingClasses",
        "isAllowed",
        "hasAnimationClasses",
        "postDigestTaskFactory",
        "normalizeAnimationDetails",
        "findCallbacks",
        "filterFromRegistry",
        "queueAnimation",
        "notifyProgress",
        "close",
        "closeChildAnimations",
        "clearElementAnimationState",
        "isMatchingElement",
        "areAnimationsAllowed",
        "markElementAnimationState",
        "setRunner",
        "removeRunner",
        "getRunner",
        "sortAnimations",
        "processNode",
        "flatten",
        "getAnchorNodes",
        "groupAnimations",
        "cssClassesIntersection",
        "invokeFirstDriver",
        "beforeStart",
        "updateAnimationRunners",
        "update",
        "handleDestroyedElement",
        "close"
    ],
    "classes": []
}