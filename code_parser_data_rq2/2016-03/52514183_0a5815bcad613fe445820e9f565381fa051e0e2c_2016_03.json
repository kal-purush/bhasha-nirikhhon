{
    "identifiers": [
        "ipaddress",
        "re",
        "ssl",
        "CertificateError",
        "ImportError",
        "ValueError",
        "six",
        "ipname",
        "host_ip",
        "ipaddress",
        "ip_address",
        "six",
        "text_type",
        "ipname",
        "rstrip",
        "ip",
        "host_ip",
        "dn",
        "hostname",
        "max_wildcards",
        "dn",
        "dn",
        "split",
        "split_dn",
        "split_dn",
        "leftmost",
        "count",
        "wildcards",
        "max_wildcards",
        "CertificateError",
        "repr",
        "dn",
        "wildcards",
        "dn",
        "lower",
        "hostname",
        "lower",
        "leftmost",
        "pats",
        "append",
        "leftmost",
        "startswith",
        "hostname",
        "startswith",
        "pats",
        "append",
        "re",
        "escape",
        "leftmost",
        "pats",
        "append",
        "re",
        "escape",
        "leftmost",
        "replace",
        "frag",
        "remainder",
        "pats",
        "append",
        "re",
        "escape",
        "frag",
        "re",
        "compile",
        "join",
        "pats",
        "re",
        "IGNORECASE",
        "pat",
        "match",
        "hostname",
        "cert",
        "hostname",
        "cert",
        "ValueError",
        "ipaddress",
        "ip_address",
        "six",
        "text_type",
        "hostname",
        "ValueError",
        "cert",
        "get",
        "key",
        "value",
        "san",
        "key",
        "host_ip",
        "_dnsname_match",
        "value",
        "hostname",
        "dnsnames",
        "append",
        "value",
        "key",
        "host_ip",
        "_ipaddress_match",
        "value",
        "host_ip",
        "dnsnames",
        "append",
        "value",
        "dnsnames",
        "sub",
        "cert",
        "get",
        "key",
        "value",
        "sub",
        "key",
        "_dnsname_match",
        "value",
        "hostname",
        "dnsnames",
        "append",
        "value",
        "len",
        "dnsnames",
        "CertificateError",
        "hostname",
        "join",
        "repr",
        "dnsnames",
        "len",
        "dnsnames",
        "CertificateError",
        "hostname",
        "dnsnames",
        "CertificateError"
    ],
    "literals": [
        "r'.'",
        "'*'",
        "\"too many wildcards in certificate DNS name: \"",
        "'*'",
        "'[^.]+'",
        "'xn--'",
        "'xn--'",
        "r'\\*'",
        "'[^.]*'",
        "r'\\A'",
        "r'\\.'",
        "r'\\Z'",
        "\"empty or no certificate, match_hostname needs a \"",
        "\"SSL socket or SSL context with either \"",
        "\"CERT_OPTIONAL or CERT_REQUIRED\"",
        "'subjectAltName'",
        "'DNS'",
        "'IP Address'",
        "'subject'",
        "'commonName'",
        "\"hostname %r doesn't match either of %s\"",
        "', '",
        "\"hostname %r doesn't match %r\"",
        "\"no appropriate commonName or \"",
        "\"subjectAltName fields were found\""
    ],
    "variables": [
        "CertificateError",
        "ip",
        "pats",
        "split_dn",
        "leftmost",
        "remainder",
        "wildcards",
        "pat",
        "host_ip",
        "host_ip",
        "dnsnames",
        "san"
    ],
    "comments": [
        "Slightly modified version of match_hostname in python's ssl library",
        "https://hg.python.org/cpython/file/tip/Lib/ssl.py",
        "Changed to make code python 2.x compatible (unicode strings for ip_address",
        "and 3.5-specific var assignment syntax)",
        "OpenSSL may add a trailing newline to a subjectAltName's IP address",
        "Issue #17980: avoid denials of service by refusing more",
        "than one wildcard per fragment.  A survey of established",
        "policy among SSL implementations showed it to be a",
        "reasonable choice.",
        "speed up common case w/o wildcards",
        "RFC 6125, section 6.4.3, subitem 1.",
        "The client SHOULD NOT attempt to match a presented identifier in which",
        "the wildcard character comprises a label other than the left-most label.",
        "When '*' is a fragment by itself, it matches a non-empty dotless",
        "fragment.",
        "RFC 6125, section 6.4.3, subitem 3.",
        "The client SHOULD NOT attempt to match a presented identifier",
        "where the wildcard character is embedded within an A-label or",
        "U-label of an internationalized domain name.",
        "Otherwise, '*' matches any dotless string, e.g. www*",
        "add the remaining fragments, ignore any wildcards",
        "Not an IP address (common case)",
        "The subject is only checked when there is no dNSName entry",
        "in subjectAltName",
        "XXX according to RFC 2818, the most specific Common Name",
        "must be used."
    ],
    "docstrings": [
        "\"\"\"Exact matching of IP addresses.\n\n    RFC 6125 explicitly doesn't define an algorithm for this\n    (section 1.7.2 - \"Out of Scope\").\n    \"\"\"",
        "\"\"\"Matching according to RFC 6125, section 6.4.3\n\n    http://tools.ietf.org/html/rfc6125#section-6.4.3\n    \"\"\"",
        "\"\"\"Verify that *cert* (in decoded format as returned by\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n    rules are followed, but IP addresses are not accepted for *hostname*.\n\n    CertificateError is raised on failure. On success, the function\n    returns nothing.\n    \"\"\""
    ],
    "functions": [
        "_ipaddress_match",
        "_dnsname_match",
        "match_hostname"
    ],
    "classes": []
}