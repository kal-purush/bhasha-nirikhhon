{
    "identifiers": [
        "gov",
        "cms",
        "bfd",
        "pipeline",
        "ccw",
        "rif",
        "load",
        "com",
        "codahale",
        "metrics",
        "Meter",
        "com",
        "codahale",
        "metrics",
        "MetricRegistry",
        "java",
        "time",
        "Duration",
        "java",
        "time",
        "Instant",
        "java",
        "time",
        "temporal",
        "ChronoUnit",
        "java",
        "util",
        "Collections",
        "java",
        "util",
        "java",
        "util",
        "concurrent",
        "Callable",
        "java",
        "util",
        "concurrent",
        "ExecutionException",
        "java",
        "util",
        "concurrent",
        "ExecutorService",
        "java",
        "util",
        "concurrent",
        "Executors",
        "java",
        "util",
        "concurrent",
        "Future",
        "java",
        "util",
        "concurrent",
        "TimeUnit",
        "java",
        "util",
        "concurrent",
        "TimeoutException",
        "java",
        "util",
        "concurrent",
        "atomic",
        "AtomicInteger",
        "java",
        "util",
        "java",
        "util",
        "stream",
        "Collectors",
        "java",
        "util",
        "stream",
        "IntStream",
        "javax",
        "crypto",
        "SecretKeyFactory",
        "javax",
        "persistence",
        "EntityManager",
        "javax",
        "persistence",
        "EntityManagerFactory",
        "org",
        "hibernate",
        "SessionFactory",
        "org",
        "hibernate",
        "StatelessSession",
        "org",
        "hibernate",
        "Transaction",
        "org",
        "slf4j",
        "Logger",
        "org",
        "slf4j",
        "LoggerFactory",
        "TIME_SLICE_LIMIT_MILLIS",
        "TIME_SLICE_LIMIT",
        "Duration",
        "ofMillis",
        "TIME_SLICE_LIMIT_MILLIS",
        "MAX_EXECUTOR_TIME_SECONDS",
        "BATCH_COUNT",
        "NULL_EXECUTORS",
        "Collections",
        "emptyList",
        "LOGGER",
        "LoggerFactory",
        "getLogger",
        "DEFAULT_PARTITION_COUNT",
        "INITIAL",
        "POST_STARTUP",
        "POST_STARTUP_FIXUP_BENEFICIARIES",
        "POST_STARTUP_FIXUP_BENEFICIARY_HISTORY",
        "NORMAL",
        "options",
        "entityManagerFactory",
        "secretKeyFactory",
        "beneficaryMeter",
        "historyMeter",
        "executorService",
        "currentTask",
        "INITIAL",
        "options",
        "appMetrics",
        "entityManagerFactory",
        "secretKeyFactory",
        "options",
        "options",
        "entityManagerFactory",
        "entityManagerFactory",
        "secretKeyFactory",
        "secretKeyFactory",
        "beneficaryMeter",
        "appMetrics",
        "meter",
        "historyMeter",
        "appMetrics",
        "meter",
        "executorService",
        "Executors",
        "newFixedThreadPool",
        "options",
        "getFixupThreads",
        "currentTask",
        "executors",
        "getTaskExecutors",
        "currentTask",
        "isTaskDone",
        "doExecutors",
        "executors",
        "isTaskDone",
        "currentTask",
        "getNextTask",
        "currentTask",
        "currentTask",
        "INITIAL",
        "Collections",
        "singletonList",
        "doInitialTask",
        "POST_STARTUP",
        "NULL_EXECUTORS",
        "POST_STARTUP_FIXUP_BENEFICIARIES",
        "makeExecutorsForPartitions",
        "fixupBeneficiaryExecutor",
        "POST_STARTUP_FIXUP_BENEFICIARY_HISTORY",
        "makeExecutorsForPartitions",
        "fixupHistoryExecutor",
        "NORMAL",
        "NULL_EXECUTORS",
        "executor",
        "IntStream",
        "options",
        "getFixupThreads",
        "mapToObj",
        "partition",
        "executor",
        "apply",
        "partition",
        "collect",
        "Collectors",
        "toList",
        "executors",
        "executors",
        "size",
        "startTime",
        "Instant",
        "now",
        "LOGGER",
        "debug",
        "currentTask",
        "futures",
        "executors",
        "stream",
        "executorService",
        "submit",
        "collect",
        "Collectors",
        "toList",
        "isTaskDone",
        "futures",
        "stream",
        "future",
        "future",
        "get",
        "MAX_EXECUTOR_TIME_SECONDS",
        "TimeUnit",
        "SECONDS",
        "ex",
        "LOGGER",
        "error",
        "getCurrentTask",
        "LOGGER",
        "error",
        "ex",
        "reduce",
        "a",
        "b",
        "a",
        "b",
        "orElse",
        "LOGGER",
        "debug",
        "currentTask",
        "startTime",
        "until",
        "Instant",
        "now",
        "ChronoUnit",
        "MILLIS",
        "isTaskDone",
        "LOGGER",
        "info",
        "currentTask",
        "isTaskDone",
        "currentTask",
        "INITIAL",
        "POST_STARTUP",
        "POST_STARTUP",
        "options",
        "isFixupsEnabled",
        "POST_STARTUP_FIXUP_BENEFICIARIES",
        "LOGGER",
        "info",
        "NORMAL",
        "POST_STARTUP_FIXUP_BENEFICIARIES",
        "POST_STARTUP_FIXUP_BENEFICIARY_HISTORY",
        "POST_STARTUP_FIXUP_BENEFICIARY_HISTORY",
        "NORMAL",
        "NORMAL",
        "NORMAL",
        "options",
        "isFixupsEnabled",
        "em",
        "entityManagerFactory",
        "createEntityManager",
        "beneficiaryCount",
        "em",
        "createQuery",
        "getSingleResult",
        "historyCount",
        "em",
        "createQuery",
        "getSingleResult",
        "LOGGER",
        "info",
        "beneficiaryCount",
        "historyCount",
        "partition",
        "LOGGER",
        "debug",
        "partition",
        "counter",
        "isDone",
        "doBatches",
        "session",
        "fixupBatch",
        "session",
        "partition",
        "counter",
        "beneficaryMeter",
        "mark",
        "counter",
        "get",
        "LOGGER",
        "debug",
        "partition",
        "counter",
        "get",
        "isDone",
        "partition",
        "LOGGER",
        "debug",
        "partition",
        "counter",
        "isDone",
        "doBatches",
        "session",
        "fixupBatch",
        "session",
        "partition",
        "counter",
        "historyMeter",
        "mark",
        "counter",
        "get",
        "LOGGER",
        "debug",
        "partition",
        "counter",
        "get",
        "isDone",
        "batchWorker",
        "startTime",
        "Instant",
        "now",
        "sf",
        "entityManagerFactory",
        "unwrap",
        "statelessSession",
        "sf",
        "openStatelessSession",
        "txn",
        "isDone",
        "isDone",
        "inPeriod",
        "startTime",
        "TIME_SLICE_LIMIT",
        "txn",
        "statelessSession",
        "beginTransaction",
        "isDone",
        "batchWorker",
        "apply",
        "statelessSession",
        "txn",
        "commit",
        "isDone",
        "statelessSession",
        "isOpen",
        "txn",
        "txn",
        "isActive",
        "txn",
        "rollback",
        "statelessSession",
        "close",
        "session",
        "tableName",
        "idName",
        "hasTextId",
        "partition",
        "counter",
        "rows",
        "fetchBatchRows",
        "session",
        "tableName",
        "idName",
        "hasTextId",
        "partition",
        "rows",
        "size",
        "updateBatchMbiHash",
        "session",
        "rows",
        "tableName",
        "idName",
        "hasTextId",
        "counter",
        "addAndGet",
        "rows",
        "size",
        "SuppressWarnings",
        "session",
        "tableName",
        "idName",
        "hasTextId",
        "partition",
        "select",
        "idName",
        "tableName",
        "hasTextId",
        "idName",
        "options",
        "getFixupThreads",
        "partition",
        "idName",
        "options",
        "getFixupThreads",
        "partition",
        "session",
        "createNativeQuery",
        "select",
        "setMaxResults",
        "BATCH_COUNT",
        "getResultList",
        "session",
        "rows",
        "tableName",
        "idName",
        "hasTextId",
        "rowSize",
        "update",
        "rows",
        "size",
        "rowSize",
        "rowSize",
        "update",
        "append",
        "append",
        "tableName",
        "append",
        "i",
        "i",
        "rows",
        "size",
        "i",
        "row",
        "rows",
        "get",
        "i",
        "mbi",
        "row",
        "mbiHash",
        "RifLoader",
        "computeMbiHash",
        "options",
        "secretKeyFactory",
        "mbi",
        "i",
        "update",
        "append",
        "update",
        "append",
        "hasTextId",
        "append",
        "row",
        "toString",
        "append",
        "hasTextId",
        "append",
        "mbiHash",
        "append",
        "update",
        "append",
        "append",
        "idName",
        "append",
        "session",
        "createNativeQuery",
        "update",
        "toString",
        "executeUpdate",
        "start",
        "period",
        "nowInstant",
        "Instant",
        "now",
        "start",
        "compareTo",
        "nowInstant",
        "start",
        "plus",
        "period",
        "isAfter",
        "nowInstant"
    ],
    "literals": [
        "\"fixups.beneficiary.rate\"",
        "\"fixups.beneficiary_history.rate\"",
        "\"Unexpected idle task state\"",
        "\"Started a time slice: {}\"",
        "\"Error executing in sub-task {}\"",
        "\"Exception executing a task\"",
        "\"Finished a time slice: {}, {} millis\"",
        "\"Finished idle task: {}\"",
        "\"PostStartup fixups are not enabled.\"",
        "\"select count(*) from Beneficiary where mbiHash is null and medicareBeneficiaryId is not null\"",
        "\"select count(*) from BeneficiaryHistory where mbiHash is null and medicareBeneficiaryId is not null\"",
        "\"Missing mbiHash for: {} Beneficaries and {} Benficiary Histories\"",
        "\"Start a Beneficiary executor: partition {}\"",
        "\"Beneficiaries\"",
        "\"beneficiaryId\"",
        "\"Finished a Beneficiary executor: {}, count {}\"",
        "\"Start a BeneficiariesHistory partition {}\"",
        "\"BeneficiariesHistory\"",
        "\"beneficiaryHistoryId\"",
        "\"Finished a History executor: {}, count {}\"",
        "\"unchecked\"",
        "\"SELECT b.\\\"\"",
        "\"\\\", b.\\\"medicareBeneficiaryId\\\" \"",
        "\"FROM \\\"\"",
        "\"\\\" b \"",
        "\"WHERE b.\\\"mbiHash\\\" IS NULL AND b.\\\"medicareBeneficiaryId\\\" IS NOT NULL AND \"",
        "\"MOD(CAST(b.\\\"\"",
        "\"\\\" AS numeric), \"",
        "\") = \"",
        "\"MOD(b.\\\"\"",
        "\"\\\", \"",
        "\") = \"",
        "\"UPDATE \\\"\"",
        "\"\\\" b SET \\\"mbiHash\\\" = mbi_hash FROM (VALUES \"",
        "\",\"",
        "\"('\"",
        "\"(\"",
        "\"','\"",
        "\",'\"",
        "\"')\"",
        "\") AS t(id, mbi_hash) WHERE b.\\\"\"",
        "\"\\\" = id\""
    ],
    "variables": [
        "options",
        "entityManagerFactory",
        "secretKeyFactory",
        "beneficaryMeter",
        "historyMeter",
        "executorService"
    ],
    "comments": [
        "Allow for large table scans",
        "Use the stateless sessions to avoid the overhead of Hibernates caches which are not needed in",
        "this bulk update use-case",
        "64 for hash and 14 for MBI"
    ],
    "docstrings": [
        "* This class manages the work that is done during the idle time of a RifLoader. This is a helper\n * class for the RifLoader. It is expected to have a 1-to-1 relationship to a RifLoader.",
        "* Developer Notes:\n   *\n   * This class was created to fixup the mbiHash field, but with idea there may be other\n   * maintenance tasks in future.\n   *\n   * There are about a billion mbiHash fields to fill. So time was spent to come up with\n   * a fast method to fixup fields. In the end, batching large number of updates and doing these\n   * batches in parallel worked well enough.\n   *\n   * There is a hierarchy in the names and concepts used in this class.\n   *\n   *  Task - the overall state and goal of the manager.\n   *  Time Slice - A fixed amount of time that the task can execute before it must return to the main thread.\n   *    A task can take many time slices to complete.\n   *  Executor - Within a time slice, work is given to an executor.\n   *    Instead of another interface, a generic Callable interface is used.\n   *  Partition - Fixup work is divide among partitions of a table.\n   *    Partitions are numbered 0 ... PARTITION_COUNT-1;\n   *    Each partition is given its own executor.\n   *  Batch - A group of records to update in one DB transaction. All records come from a single partition.",
        "Time slice that a task can take before returning/yielding to the main pipeline",
        "Time slice that a task can take before returning/yielding to the main pipeline",
        "Max amount of time before a timeout occurs.",
        "The record count of a db update batch",
        "An executor list that does no work and always completes",
        "The number of partitions to run by default. It is an option.",
        "Enum to tell what the current task is being executed.",
        "The initial task which is executed after startup",
        "After the initial task, this general fixup is run.",
        "A sub-task to fixup Beneficiaries table",
        "A sub-task to fixup BeneficiariesHistory table",
        "Run the normal task",
        "Hashing entities",
        "Metrics",
        "Thread pool for post startup tasks",
        "The task that is going to execute next",
        "* Create a helper to manage the idle time tasks.\n   *\n   * @param options pipeline options\n   * @param appMetrics pipeline metrics\n   * @param entityManagerFactory a connection to the database of the pipeline\n   * @param secretKeyFactory for hashing",
        "* What task will be executed in the next idle time slot\n   *\n   * @return the current task",
        "* Run the current idle task. This method is expected to be called whenever no RIF files are\n   * present for process. It will respect the TASK_TIME_LIMIT to allow checking of RIF files and to\n   * not interfer with RIF file processing.",
        "* Form a list of callables to execute.\n   *\n   * @return the callables associated with the current task",
        "* Form a list of executors, one for each partition\n   *\n   * @param executor for a single partition\n   * @return the list of executors",
        "* Execute the work in parallel threads. Wait for all executors to complete.\n   *\n   * @param executors Callables to that do the work",
        "Return the next task given the current task.",
        "* Run this task as the first idle task.\n   *\n   * @return true if done with this task.",
        "* Executor for the Beneficiaries table.\n   *\n   * @param partition to work on\n   * @return true if done with the work on this partition",
        "* Executor for the BeneficiariesHistory table.\n   *\n   * @param partition to work on\n   * @return true if done with the work on this partition",
        "* Break up the work into a series of batches of record to update. Each batch is done in a\n   * transaction. After each batch, check the amount of time taken. Return after the\n   * TIME_SLICE_LIMIT is reached or the work is done.\n   *\n   * @param batchWorker does the work. Return the isDone value from the worker.\n   * @return the return value from the last batchWorker.",
        "* Fixup a batch of records. Executed in the context of a transaction.\n   *\n   * @param session to use\n   * @param tableName to fetch from\n   * @param idName of the table\n   * @param hasTextId is true if the id is a varchar, false if the id is a bigint\n   * @param partition to fetch from\n   * @param counter to increment with the record count\n   * @return the number of records fixed up;",
        "* Fetch the rows of a batch. Each row contains the tableId and a medicareBeneficiaryId.\n   *\n   * @param session to use\n   * @param tableName to fetch from\n   * @param idName of the table\n   * @param hasTextId is true if the id is a varchar, false if the id is a bigint\n   * @param partition to fetch from\n   * @return a list of rows",
        "* Update the mbiHash field of the batch.\n   *\n   * @param session to use\n   * @param rows rows of id and medicareBeneficiaryId tuples\n   * @param tableName to update\n   * @param idName of the table\n   * @param hasTextId is true if the id is a varchar, false if the id is a bigint",
        "* Developer Note:\n     * VALUES is a allows single statement update statement to update mulitple values.\n     * It's a common operator, but does not work on HSQLDB.",
        "* Any time left in this time slice?\n   *\n   * @param start of the period\n   * @param period duration\n   * @return true iff current period is less than the passed in period duration;"
    ],
    "functions": [
        "RifLoaderIdleTasks",
        "getCurrentTask",
        "doIdleTask",
        "getTaskExecutors",
        "makeExecutorsForPartitions",
        "doExecutors",
        "getNextTask",
        "doInitialTask",
        "fixupBeneficiaryExecutor",
        "fixupHistoryExecutor",
        "doBatches",
        "fixupBatch",
        "fetchBatchRows",
        "updateBatchMbiHash",
        "inPeriod"
    ],
    "classes": [
        "RifLoaderIdleTasks"
    ]
}