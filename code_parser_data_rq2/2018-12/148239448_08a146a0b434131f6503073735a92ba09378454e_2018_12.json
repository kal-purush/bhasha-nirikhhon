{
    "identifiers": [
        "copy",
        "pprint",
        "pprint",
        "random",
        "random",
        "randint",
        "problema",
        "Problema",
        "problema_mochila",
        "ProblemaMochila",
        "Problema",
        "property",
        "cont",
        "n",
        "randint",
        "n",
        "randint",
        "n",
        "estado",
        "i",
        "j",
        "estado",
        "i",
        "cont",
        "estado",
        "estado",
        "i",
        "n",
        "j",
        "n",
        "soma",
        "estado",
        "i",
        "j",
        "soma",
        "conflitos",
        "soma",
        "i",
        "n",
        "j",
        "n",
        "soma",
        "estado",
        "j",
        "i",
        "soma",
        "conflitos",
        "soma",
        "conflitos",
        "estado",
        "randint",
        "n",
        "randint",
        "n",
        "estado",
        "i",
        "j",
        "i",
        "j",
        "randint",
        "n",
        "randint",
        "n",
        "estado",
        "i",
        "j",
        "i",
        "j",
        "copy",
        "deepcopy",
        "estado",
        "vizinho",
        "pos_rainha",
        "pos_rainha",
        "vizinho",
        "pos_vazia",
        "pos_vazia",
        "vizinho",
        "Problema",
        "property",
        "randint",
        "randint",
        "sinal",
        "inteiro",
        "random",
        "estado",
        "estado",
        "x",
        "estado",
        "randint",
        "estado",
        "sinal",
        "random",
        "max_iteracoes",
        "max_iteracoes_sem_melhora",
        "max_iteracoes",
        "max_iteracoes_sem_melhora",
        "problema",
        "problema",
        "estado_inicial",
        "i",
        "max_iteracoes",
        "j",
        "max_iteracoes_sem_melhora",
        "i",
        "estado_atual",
        "problema",
        "funcao_objetivo",
        "estado_atual",
        "problema",
        "funcao_sucessora",
        "estado_atual",
        "problema",
        "funcao_objetivo",
        "estado_atual",
        "problema",
        "funcao_objetivo",
        "vizinho",
        "custo_vizinho",
        "custo_atual",
        "custo_atual",
        "custo_vizinho",
        "vizinho",
        "i",
        "j"
    ],
    "literals": [
        "f\"{i:03d} - {estado_atual} - {problema.funcao_objetivo(estado_atual)}\"",
        "f'achou melhor! atual = {custo_atual}  vizinho {custo_vizinho}'"
    ],
    "variables": [
        "n",
        "estado",
        "cont",
        "i",
        "j",
        "j",
        "conflitos",
        "soma",
        "soma",
        "pos_vazia",
        "pos_rainha",
        "i",
        "j",
        "pos_vazia",
        "i",
        "j",
        "pos_rainha",
        "vizinho",
        "sinal",
        "inteiro",
        "x",
        "sinal",
        "max_iteracoes",
        "max_iteracoes_sem_melhora",
        "estado_atual",
        "i",
        "j",
        "vizinho",
        "custo_atual",
        "custo_vizinho",
        "estado_atual",
        "j"
    ],
    "comments": [
        "!/usr/bin/env python",
        "class HillClimbing(object):",
        "",
        "def __init__(self, max_iteracoes, max_iteracoes_sem_melhora):",
        "self.max_iteracoes = max_iteracoes",
        "self.max_iteracoes_sem_melhora = max_iteracoes_sem_melhora",
        "",
        "def executa(self, problema):",
        "estado_atual = problema.estado_inicial",
        "i = 0",
        "j = 0",
        "",
        "while i < self.max_iteracoes or j < self.max_iteracoes_sem_melhora:",
        "print(f\"{i:03d} - {estado_atual} - {problema.funcao_objetivo(estado_atual)}\")",
        "vizinho = problema.funcao_sucessora(estado_atual)",
        "custo_atual = problema.funcao_objetivo(estado_atual)",
        "custo_vizinho = problema.funcao_objetivo(vizinho)",
        "if custo_vizinho < custo_atual:",
        "print(f'achou melhor! atual = {custo_atual}  vizinho {custo_vizinho}')",
        "estado_atual = vizinho",
        "j = 0",
        "i += 1",
        "j += 1",
        "conflitos em linhas",
        "conflitos em colunas",
        "conflitos na diagonal",
        "TODO: verificar se tem conflito na diagonal",
        "copy: permite realizar a copia de objetos",
        "deepcopy: realiza a copia recursiva dos objetos e seus atributos internos",
        "Gera o estado inicial",
        "Criterios de parada",
        "1. numero maximo de iteracoes",
        "2. numero maximo de iteracoes sem melhora",
        "3. tempo maximo",
        "4. atingiu o objetivo",
        "Loop principal",
        "maximo de iteracoes",
        "maximo de iteracoes sem melhora",
        "Imprime a solucao",
        "Gera um estado vizinho",
        "Verifica se o estado vizinho eh melhor que o atual",
        "while i < self.max_iteracoes or j < self.max_iteracoes_sem_melhora:",
        "",
        "# Imprime a solucao",
        "print(f\"{i:03d} - {estado_atual} - {problema.funcao_objetivo(estado_atual)}\")",
        "",
        "# Gera um estado vizinho",
        "vizinho = problema.funcao_sucessora(estado_atual)",
        "",
        "# Verifica se o estado vizinho eh melhor que o atual",
        "custo_atual = problema.funcao_objetivo(estado_atual)",
        "custo_vizinho = problema.funcao_objetivo(vizinho)",
        "",
        "if custo_vizinho < custo_atual:",
        "print(f'achou melhor! atual = {custo_atual}  vizinho {custo_vizinho}')",
        "estado_atual = vizinho",
        "j = 0",
        "",
        "i += 1",
        "j += 1",
        "Algoritmo GRASP",
        "Parametros: alpha, numero_interacoes",
        "enquanto i <= numero_interacoes faca",
        "Fase de construcao",
        "Algoritmo de melhoria",
        "Atualiza melhor solucao encontrada",
        "i <- i+1",
        "fim-do-enquanto",
        "def executa(self, max_iteracoes, ):",
        "Definicao do problema",
        "p = ProblemaRaiz()",
        "p = ProblemaRainha()",
        "hc = HillClimbing(max_iteracoes=100, max_iteracoes_sem_melhora=10)",
        "hc.executa(p)",
        "problema_mochila = ProblemaMochila()",
        "items = problema_mochila.gera_aleatorios()"
    ],
    "docstrings": [
        "\"\"\"Encontrar a raiz de uma funcao.\"\"\"",
        "\"\"\"Para este problema, parte de um estado aleatorio.\"\"\"",
        "\"\"\"Avalia o custo do estado atual.\"\"\"",
        "\"\"\"Gera o estado vizinho\"\"\"",
        "\"\"\"Encontrar a raiz de uma funcao.\"\"\"",
        "\"\"\"Para este problema, parte de um estado aleatorio.\"\"\"",
        "\"\"\"Avalia o custo do estado atual.\"\"\"",
        "\"\"\"Gera o estado vizinho\"\"\"",
        "\"\"\"Implementacao do hill climbing.\"\"\""
    ],
    "functions": [
        "estado_inicial",
        "funcao_objetivo",
        "funcao_sucessora",
        "estado_inicial",
        "funcao_objetivo",
        "funcao_sucessora",
        "executa",
        "main"
    ],
    "classes": [
        "ProblemaRainha",
        "ProblemaRaiz",
        "HillClimbing1",
        "Grasp"
    ]
}