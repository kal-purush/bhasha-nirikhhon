{
    "identifiers": [
        "dataclasses",
        "dataclass",
        "typing",
        "Dict",
        "Optional",
        "numpy",
        "np",
        "torch",
        "model",
        "Transducer",
        "model",
        "Transducer",
        "encoder_out",
        "torch",
        "Tensor",
        "max_sym_per_frame",
        "encoder_out",
        "ndim",
        "encoder_out",
        "size",
        "encoder_out",
        "size",
        "model",
        "decoder",
        "blank_id",
        "model",
        "decoder",
        "context_size",
        "model",
        "device",
        "torch",
        "tensor",
        "blank_id",
        "context_size",
        "device",
        "device",
        "reshape",
        "context_size",
        "model",
        "decoder",
        "decoder_input",
        "need_pad",
        "encoder_out",
        "size",
        "blank_id",
        "context_size",
        "t",
        "T",
        "sym_per_utt",
        "max_sym_per_utt",
        "sym_per_frame",
        "max_sym_per_frame",
        "t",
        "encoder_out",
        "t",
        "t",
        "model",
        "joiner",
        "current_encoder_out",
        "decoder_out",
        "logits",
        "argmax",
        "item",
        "y",
        "blank_id",
        "hyp",
        "append",
        "y",
        "torch",
        "tensor",
        "hyp",
        "context_size",
        "device",
        "device",
        "reshape",
        "context_size",
        "model",
        "decoder",
        "decoder_input",
        "need_pad",
        "sym_per_utt",
        "sym_per_frame",
        "t",
        "hyp",
        "context_size",
        "hyp",
        "dataclass",
        "property",
        "join",
        "ys",
        "data",
        "Optional",
        "Dict",
        "Hypothesis",
        "data",
        "data",
        "property",
        "_data",
        "hyp",
        "Hypothesis",
        "hyp",
        "key",
        "key",
        "_data",
        "key",
        "np",
        "logaddexp",
        "old_hyp",
        "log_prob",
        "hyp",
        "log_prob",
        "_data",
        "hyp",
        "length_norm",
        "Hypothesis",
        "length_norm",
        "max",
        "_data",
        "values",
        "key",
        "hyp",
        "hyp",
        "log_prob",
        "len",
        "hyp",
        "ys",
        "max",
        "_data",
        "values",
        "key",
        "hyp",
        "hyp",
        "log_prob",
        "hyp",
        "Hypothesis",
        "hyp",
        "key",
        "key",
        "key",
        "_data",
        "key",
        "threshold",
        "HypothesisList",
        "key",
        "hyp",
        "_data",
        "items",
        "hyp",
        "log_prob",
        "threshold",
        "ans",
        "add",
        "hyp",
        "ans",
        "k",
        "_data",
        "items",
        "sorted",
        "hyps",
        "key",
        "h",
        "h",
        "log_prob",
        "reverse",
        "k",
        "HypothesisList",
        "hyps",
        "ans",
        "key",
        "key",
        "_data",
        "iter",
        "_data",
        "values",
        "len",
        "_data",
        "key",
        "s",
        "append",
        "key",
        "join",
        "s",
        "model",
        "Transducer",
        "encoder_out",
        "torch",
        "Tensor",
        "beam",
        "encoder_out",
        "ndim",
        "encoder_out",
        "size",
        "encoder_out",
        "size",
        "model",
        "decoder",
        "blank_id",
        "model",
        "decoder",
        "context_size",
        "model",
        "device",
        "torch",
        "tensor",
        "blank_id",
        "context_size",
        "device",
        "device",
        "reshape",
        "context_size",
        "model",
        "decoder",
        "decoder_input",
        "need_pad",
        "encoder_out",
        "size",
        "HypothesisList",
        "B",
        "add",
        "Hypothesis",
        "ys",
        "blank_id",
        "context_size",
        "log_prob",
        "Dict",
        "torch",
        "Tensor",
        "t",
        "T",
        "sym_per_utt",
        "max_sym_per_utt",
        "encoder_out",
        "t",
        "t",
        "B",
        "HypothesisList",
        "Dict",
        "torch",
        "Tensor",
        "A",
        "get_most_probable",
        "A",
        "remove",
        "y_star",
        "y_star",
        "key",
        "cached_key",
        "decoder_cache",
        "torch",
        "tensor",
        "y_star",
        "ys",
        "context_size",
        "device",
        "device",
        "reshape",
        "context_size",
        "model",
        "decoder",
        "decoder_input",
        "need_pad",
        "decoder_out",
        "decoder_cache",
        "cached_key",
        "cached_key",
        "t",
        "cached_key",
        "joint_cache",
        "model",
        "joiner",
        "current_encoder_out",
        "decoder_out",
        "logits",
        "log_softmax",
        "dim",
        "log_prob",
        "squeeze",
        "log_prob",
        "joint_cache",
        "cached_key",
        "log_prob",
        "blank_id",
        "y_star",
        "log_prob",
        "skip_log_prob",
        "item",
        "B",
        "add",
        "Hypothesis",
        "ys",
        "y_star",
        "ys",
        "log_prob",
        "new_y_star_log_prob",
        "log_prob",
        "topk",
        "beam",
        "i",
        "v",
        "indices",
        "tolist",
        "values",
        "tolist",
        "i",
        "blank_id",
        "y_star",
        "ys",
        "i",
        "y_star",
        "log_prob",
        "v",
        "A",
        "add",
        "Hypothesis",
        "ys",
        "new_ys",
        "log_prob",
        "new_log_prob",
        "A",
        "get_most_probable",
        "B",
        "A_most_probable",
        "log_prob",
        "len",
        "kept_B",
        "beam",
        "kept_B",
        "topk",
        "beam",
        "t",
        "B",
        "get_most_probable",
        "length_norm",
        "best_hyp",
        "ys",
        "context_size",
        "ys"
    ],
    "literals": [
        "\"_\"",
        "f\"{key} does not exist\"",
        "\"HypothesisList\"",
        "\"HypothesisList\"",
        "\", \"",
        "f\"-t-{t}\""
    ],
    "variables": [
        "blank_id",
        "context_size",
        "device",
        "decoder_input",
        "decoder_out",
        "T",
        "t",
        "hyp",
        "max_sym_per_utt",
        "sym_per_frame",
        "sym_per_utt",
        "sym_per_frame",
        "current_encoder_out",
        "logits",
        "y",
        "decoder_input",
        "decoder_out",
        "sym_per_frame",
        "hyp",
        "ys",
        "log_prob",
        "_data",
        "_data",
        "key",
        "old_hyp",
        "old_hyp",
        "log_prob",
        "key",
        "key",
        "ans",
        "hyps",
        "hyps",
        "ans",
        "s",
        "blank_id",
        "context_size",
        "device",
        "decoder_input",
        "decoder_out",
        "T",
        "t",
        "B",
        "max_sym_per_utt",
        "sym_per_utt",
        "decoder_cache",
        "current_encoder_out",
        "A",
        "B",
        "joint_cache",
        "y_star",
        "cached_key",
        "decoder_input",
        "decoder_out",
        "decoder_cache",
        "cached_key",
        "decoder_out",
        "logits",
        "log_prob",
        "log_prob",
        "joint_cache",
        "cached_key",
        "log_prob",
        "skip_log_prob",
        "new_y_star_log_prob",
        "values",
        "indices",
        "new_ys",
        "new_log_prob",
        "A_most_probable",
        "kept_B",
        "B",
        "best_hyp",
        "ys"
    ],
    "comments": [
        "Copyright    2021  Xiaomi Corp.        (authors: Fangjun Kuang)",
        "",
        "See ../../../../LICENSE for clarification regarding multiple authors",
        "",
        "Licensed under the Apache License, Version 2.0 (the \"License\");",
        "you may not use this file except in compliance with the License.",
        "You may obtain a copy of the License at",
        "",
        "http://www.apache.org/licenses/LICENSE-2.0",
        "",
        "Unless required by applicable law or agreed to in writing, software",
        "distributed under the License is distributed on an \"AS IS\" BASIS,",
        "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
        "See the License for the specific language governing permissions and",
        "limitations under the License.",
        "support only batch_size == 1 for now",
        "Maximum symbols per utterance.",
        "symbols per frame",
        "symbols per utterance decoded so far",
        "fmt: off",
        "fmt: on",
        "logits is (1, 1, 1, vocab_size)",
        "remove blanks",
        "The predicted tokens so far.",
        "Newly predicted tokens are appended to `ys`.",
        "The log prob of ys",
        "def add(self, ys: List[int], log_prob: float):",
        "shallow copy",
        "support only batch_size == 1 for now",
        "fmt: off",
        "fmt: on",
        "TODO(fangjun): Implement prefix search to update the `log_prob`",
        "of hypotheses in A",
        "TODO(fangjun): Ccale the blank posterior",
        "log_prob is (1, 1, 1, vocab_size)",
        "Now log_prob is (vocab_size,)",
        "First, process the blank symbol",
        "ys[:] returns a copy of ys",
        "Second, process other non-blank labels",
        "Check whether B contains more than \"beam\" elements more probable",
        "than the most probable in A",
        "[context_size:] to remove blanks"
    ],
    "docstrings": [
        "\"\"\"\n    Args:\n      model:\n        An instance of `Transducer`.\n      encoder_out:\n        A tensor of shape (N, T, C) from the encoder. Support only N==1 for now.\n      max_sym_per_frame:\n        Maximum number of symbols per frame. If it is set to 0, the WER\n        would be 100%.\n    Returns:\n      Return the decoded result.\n    \"\"\"",
        "\"\"\"Return a string representation of self.ys\"\"\"",
        "\"\"\"\n        Args:\n          data:\n            A dict of Hypotheses. Its key is its `value.key`.\n        \"\"\"",
        "\"\"\"Add a Hypothesis to `self`.\n\n        If `hyp` already exists in `self`, its probability is updated using\n        `log-sum-exp` with the existed one.\n\n        Args:\n          hyp:\n            The hypothesis to be added.\n        \"\"\"",
        "\"\"\"Get the most probable hypothesis, i.e., the one with\n        the largest `log_prob`.\n\n        Args:\n          length_norm:\n            If True, the `log_prob` of a hypothesis is normalized by the\n            number of tokens in it.\n\n        \"\"\"",
        "\"\"\"Remove a given hypothesis.\n\n        Args:\n          hyp:\n            The hypothesis to be removed from `self`.\n            Note: It must be contained in `self`. Otherwise,\n            an exception is raised.\n        \"\"\"",
        "\"\"\"Remove all Hypotheses whose log_prob is less than threshold.\n\n        Caution:\n          `self` is not modified. Instead, a new HypothesisList is returned.\n\n        Returns:\n          Return a new HypothesisList containing all hypotheses from `self`\n          that have `log_prob` being greater than the given `threshold`.\n        \"\"\"",
        "\"\"\"Return the top-k hypothesis.\"\"\"",
        "\"\"\"\n    It implements Algorithm 1 in https://arxiv.org/pdf/1211.3711.pdf\n\n    espnet/nets/beam_search_transducer.py#L247 is used as a reference.\n\n    Args:\n      model:\n        An instance of `Transducer`.\n      encoder_out:\n        A tensor of shape (N, T, C) from the encoder. Support only N==1 for now.\n      beam:\n        Beam size.\n    Returns:\n      Return the decoded result.\n    \"\"\""
    ],
    "functions": [
        "greedy_search",
        "key",
        "data",
        "add",
        "get_most_probable",
        "remove",
        "topk",
        "__contains__",
        "__iter__",
        "__len__",
        "__str__",
        "beam_search"
    ],
    "classes": [
        "Hypothesis",
        "HypothesisList"
    ]
}