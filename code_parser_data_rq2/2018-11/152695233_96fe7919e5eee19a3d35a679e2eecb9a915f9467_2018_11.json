{
    "identifiers": [
        "hw4standard",
        "expr",
        "literal",
        "expr",
        "s",
        "s",
        "literal",
        "literal",
        "s",
        "literal",
        "literal",
        "s",
        "prettyexpr",
        "atom",
        "s",
        "consequence",
        "i",
        "consequence",
        "PrettyCNF",
        "i",
        "unit",
        "clause",
        "result",
        "PrettyCNF",
        "clause",
        "PrettyCNF",
        "unit",
        "PrettyCNF",
        "result",
        "a",
        "b",
        "unify",
        "a",
        "b",
        "subs",
        "ret",
        "subs",
        "ret",
        "bottom",
        "ret",
        "values",
        "isVar",
        "bottom",
        "bottom",
        "seen",
        "seen",
        "append",
        "bottom",
        "literal",
        "literal",
        "literal",
        "literal",
        "literal",
        "unit",
        "clause",
        "negate",
        "unit",
        "disjunct",
        "clause",
        "unify",
        "neg_unit",
        "disjunct",
        "subs",
        "substitute",
        "clause",
        "subs",
        "substitute",
        "neg_unit",
        "subs",
        "sub_clause",
        "remove",
        "sub_neg_unit",
        "sub_clause",
        "unit",
        "clause",
        "negate",
        "unit",
        "disjunct",
        "clause",
        "unify",
        "neg_unit",
        "disjunct",
        "resolution",
        "c_set",
        "disjunct",
        "c_set",
        "sameclause",
        "resolution",
        "disjunct",
        "s1",
        "s2",
        "s1",
        "copy",
        "expression",
        "s2",
        "already_in_c_set",
        "expression",
        "new_set",
        "new_set",
        "append",
        "expression",
        "new_set",
        "kb",
        "query",
        "kb",
        "copy",
        "negate",
        "query",
        "consequence",
        "append",
        "neg_query",
        "unit",
        "consequence",
        "len",
        "unit",
        "freshvariables",
        "unit",
        "expression",
        "consequence",
        "can_resolve",
        "unit_clause",
        "expression",
        "resolve",
        "unit_clause",
        "expression",
        "PrettyResolution",
        "unit_clause",
        "expression",
        "new_clause",
        "new_clause",
        "already_in_c_set",
        "new_clause",
        "temp_set",
        "already_in_c_set",
        "new_clause",
        "consequence",
        "temp_set",
        "append",
        "new_clause",
        "PrettyConsequence",
        "merge_sets",
        "consequence",
        "temp_set",
        "temp_set",
        "merge_sets",
        "consequence",
        "temp_set",
        "prove",
        "kb",
        "prove",
        "kb",
        "prove"
    ],
    "literals": [
        "\"\"",
        "\"\"",
        "\" v \"",
        "\"not\"",
        "\"!\"",
        "\"Resolving\"",
        "\"with\"",
        "\"Result:\"",
        "\"not\"",
        "'not'",
        "\"\\n\"",
        "\"\\n\"",
        "'ostrich'",
        "'sam'",
        "'canary'",
        "'tweety'",
        "'bird'",
        "'X'",
        "'not'",
        "'ostrich'",
        "'X'",
        "'bird'",
        "'X'",
        "'not'",
        "'canary'",
        "'X'",
        "'fly'",
        "'X'",
        "'not'",
        "'bird'",
        "'X'",
        "'not'",
        "'normal'",
        "'X'",
        "'not'",
        "'normal'",
        "'X'",
        "'not'",
        "'ostrich'",
        "'X'",
        "'normal'",
        "'X'",
        "'not'",
        "'canary'",
        "'X'",
        "'fly'",
        "'tweety'",
        "'fly'",
        "'sam'",
        "'boy'",
        "'goo'",
        "'X'",
        "'Y'",
        "'boy'",
        "'foo'",
        "'X'",
        "'Y'",
        "'boy'",
        "'X'"
    ],
    "variables": [
        "s",
        "atom",
        "atom",
        "subs",
        "ret",
        "seen",
        "neg_unit",
        "subs",
        "sub_clause",
        "sub_neg_unit",
        "neg_unit",
        "new_set",
        "consequence",
        "neg_query",
        "temp_set",
        "unit_clause",
        "new_clause",
        "consequence",
        "kb"
    ],
    "comments": [
        "### Helper Functions",
        "In[158]:",
        "print(expr,\"\\n\\n\")",
        "print(type(literal))",
        "same clause if bottom just has variables and each is different",
        "negate the unit clause for resolution",
        "look for matching disjunct in clause",
        "find one and get subs",
        "remove instance that was resolved",
        "return new clause",
        "TEST",
        "print(resolve(['canary','tweety'],[['normal','X'],['not',['canary','X']]]))",
        "TEST",
        "can_resolve(['canary','tweety'],[['normal','X'],['not',['canary','X']]])",
        "TEST",
        "print(alread_in_c_set([['canary','tweety']],kb))",
        "print(alread_in_c_set([['canary','SHOULD FAIL']],kb))",
        "TEST",
        "print(merge_sets(kb[:3],kb[1:5]))",
        "### Prove Function",
        "In[159]:",
        "declare consequence set",
        "negate query",
        "add query negation to consequence set",
        "PrettyConsequence(consequence)",
        "loop",
        "new resolutions before adding to consequence",
        "look for units and try to resolve",
        "unit clause found, give fresh variables",
        "look at every expression in the current consequence set",
        "if it can be resolved do so and add the result to the temp set",
        "success if empty disjunct",
        "otherwise check to see if resolution is in temp or consequence.",
        "add to temp set if it is not.",
        "if no further possible resolutions, fail",
        "otherwise, merge temp and consequence and run again",
        "### Demo 1",
        "In[160]:",
        "## Demo 2",
        "In[162]:",
        "### Demo 3",
        "In[161]:"
    ],
    "docstrings": [
        "'''prints an entire consequenct set'''",
        "'''Takes in a unit clause and a disjunct clause and returns a resolution of the two'''",
        "'''Checks to see if a resolution is possible'''",
        "''' See if a clause is already in a set'''",
        "'''Merges to sets without overlap'''"
    ],
    "functions": [
        "PrettyCNF",
        "PrettyConsequence",
        "PrettyResolution",
        "sameclause",
        "negate",
        "resolve",
        "can_resolve",
        "already_in_c_set",
        "merge_sets",
        "prove"
    ],
    "classes": []
}