{
    "identifiers": [
        "decorate",
        "decorators",
        "target",
        "decorate",
        "decorators",
        "target",
        "targetKey",
        "descriptor",
        "metadata",
        "metadataKey",
        "metadataValue",
        "target",
        "target",
        "propertyKey",
        "defineMetadata",
        "metadataKey",
        "metadataValue",
        "target",
        "defineMetadata",
        "metadataKey",
        "metadataValue",
        "target",
        "targetKey",
        "hasMetadata",
        "metadataKey",
        "target",
        "hasMetadata",
        "metadataKey",
        "target",
        "targetKey",
        "hasOwnMetadata",
        "metadataKey",
        "target",
        "hasOwnMetadata",
        "metadataKey",
        "target",
        "targetKey",
        "getMetadata",
        "metadataKey",
        "target",
        "getMetadata",
        "metadataKey",
        "target",
        "targetKey",
        "getOwnMetadata",
        "metadataKey",
        "target",
        "getOwnMetadata",
        "metadataKey",
        "target",
        "targetKey",
        "getMetadataKeys",
        "target",
        "getMetadataKeys",
        "target",
        "targetKey",
        "getOwnMetadataKeys",
        "target",
        "getOwnMetadataKeys",
        "target",
        "targetKey",
        "deleteMetadata",
        "metadataKey",
        "target",
        "deleteMetadata",
        "metadataKey",
        "target",
        "targetKey"
    ],
    "literals": [
        "\"reflect-metadata\"",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string"
    ],
    "variables": [],
    "comments": [
        "! *****************************************************************************\nCopyright (C) Microsoft. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n*****************************************************************************",
        "The \"reflect-metadata\" module has no imports or exports, but can be used by modules to load the polyfill."
    ],
    "docstrings": [
        "* Applies a set of decorators to a target object.\n      * @param decorators An array of decorators.\n      * @param target The target object.\n      * @returns The result of applying the provided decorators.\n      * @remarks Decorators are applied in reverse order of their positions in the array.\n      * @example\n      *\n      *     class C { }\n      *\n      *     // constructor\n      *     C = Reflect.decorate(decoratorsArray, C);\n      *",
        "* Applies a set of decorators to a property of a target object.\n      * @param decorators An array of decorators.\n      * @param target The target object.\n      * @param targetKey The property key to decorate.\n      * @param descriptor A property descriptor\n      * @remarks Decorators are applied in reverse order.\n      * @example\n      *\n      *     class C {\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\n      *         // static staticProperty;\n      *         // property;\n      *\n      *         static staticMethod() { }\n      *         method() { }\n      *     }\n      *\n      *     // property (on constructor)\n      *     Reflect.decorate(decoratorsArray, C, \"staticProperty\");\n      *\n      *     // property (on prototype)\n      *     Reflect.decorate(decoratorsArray, C.prototype, \"property\");\n      *\n      *     // method (on constructor)\n      *     Object.defineProperty(C, \"staticMethod\",\n      *         Reflect.decorate(decoratorsArray, C, \"staticMethod\",\n      *             Object.getOwnPropertyDescriptor(C, \"staticMethod\")));\n      *\n      *     // method (on prototype)\n      *     Object.defineProperty(C.prototype, \"method\",\n      *         Reflect.decorate(decoratorsArray, C.prototype, \"method\",\n      *             Object.getOwnPropertyDescriptor(C.prototype, \"method\")));\n      *",
        "* A default metadata decorator factory that can be used on a class, class member, or parameter.\n      * @param metadataKey The key for the metadata entry.\n      * @param metadataValue The value for the metadata entry.\n      * @returns A decorator function.\n      * @remarks\n      * If `metadataKey` is already defined for the target and target key, the\n      * metadataValue for that key will be overwritten.\n      * @example\n      *\n      *     // constructor\n      *     @Reflect.metadata(key, value)\n      *     class C {\n      *     }\n      *\n      *     // property (on constructor, TypeScript only)\n      *     class C {\n      *         @Reflect.metadata(key, value)\n      *         static staticProperty;\n      *     }\n      *\n      *     // property (on prototype, TypeScript only)\n      *     class C {\n      *         @Reflect.metadata(key, value)\n      *         property;\n      *     }\n      *\n      *     // method (on constructor)\n      *     class C {\n      *         @Reflect.metadata(key, value)\n      *         static staticMethod() { }\n      *     }\n      *\n      *     // method (on prototype)\n      *     class C {\n      *         @Reflect.metadata(key, value)\n      *         method() { }\n      *     }\n      *",
        "* Define a unique metadata entry on the target.\n      * @param metadataKey A key used to store and retrieve metadata.\n      * @param metadataValue A value that contains attached metadata.\n      * @param target The target object on which to define metadata.\n      * @example\n      *\n      *     class C {\n      *     }\n      *\n      *     // constructor\n      *     Reflect.defineMetadata(\"custom:annotation\", options, C);\n      *\n      *     // decorator factory as metadata-producing annotation.\n      *     function MyAnnotation(options): ClassDecorator {\n      *         return target => Reflect.defineMetadata(\"custom:annotation\", options, target);\n      *     }\n      *",
        "* Define a unique metadata entry on the target.\n      * @param metadataKey A key used to store and retrieve metadata.\n      * @param metadataValue A value that contains attached metadata.\n      * @param target The target object on which to define metadata.\n      * @param targetKey The property key for the target.\n      * @example\n      *\n      *     class C {\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\n      *         // static staticProperty;\n      *         // property;\n      *\n      *         static staticMethod(p) { }\n      *         method(p) { }\n      *     }\n      *\n      *     // property (on constructor)\n      *     Reflect.defineMetadata(\"custom:annotation\", Number, C, \"staticProperty\");\n      *\n      *     // property (on prototype)\n      *     Reflect.defineMetadata(\"custom:annotation\", Number, C.prototype, \"property\");\n      *\n      *     // method (on constructor)\n      *     Reflect.defineMetadata(\"custom:annotation\", Number, C, \"staticMethod\");\n      *\n      *     // method (on prototype)\n      *     Reflect.defineMetadata(\"custom:annotation\", Number, C.prototype, \"method\");\n      *\n      *     // decorator factory as metadata-producing annotation.\n      *     function MyAnnotation(options): PropertyDecorator {\n      *         return (target, key) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\n      *     }\n      *",
        "* Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n      * @param metadataKey A key used to store and retrieve metadata.\n      * @param target The target object on which the metadata is defined.\n      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n      * @example\n      *\n      *     class C {\n      *     }\n      *\n      *     // constructor\n      *     result = Reflect.hasMetadata(\"custom:annotation\", C);\n      *",
        "* Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n      * @param metadataKey A key used to store and retrieve metadata.\n      * @param target The target object on which the metadata is defined.\n      * @param targetKey The property key for the target.\n      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n      * @example\n      *\n      *     class C {\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\n      *         // static staticProperty;\n      *         // property;\n      *\n      *         static staticMethod(p) { }\n      *         method(p) { }\n      *     }\n      *\n      *     // property (on constructor)\n      *     result = Reflect.hasMetadata(\"custom:annotation\", C, \"staticProperty\");\n      *\n      *     // property (on prototype)\n      *     result = Reflect.hasMetadata(\"custom:annotation\", C.prototype, \"property\");\n      *\n      *     // method (on constructor)\n      *     result = Reflect.hasMetadata(\"custom:annotation\", C, \"staticMethod\");\n      *\n      *     // method (on prototype)\n      *     result = Reflect.hasMetadata(\"custom:annotation\", C.prototype, \"method\");\n      *",
        "* Gets a value indicating whether the target object has the provided metadata key defined.\n      * @param metadataKey A key used to store and retrieve metadata.\n      * @param target The target object on which the metadata is defined.\n      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\n      * @example\n      *\n      *     class C {\n      *     }\n      *\n      *     // constructor\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", C);\n      *",
        "* Gets a value indicating whether the target object has the provided metadata key defined.\n      * @param metadataKey A key used to store and retrieve metadata.\n      * @param target The target object on which the metadata is defined.\n      * @param targetKey The property key for the target.\n      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\n      * @example\n      *\n      *     class C {\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\n      *         // static staticProperty;\n      *         // property;\n      *\n      *         static staticMethod(p) { }\n      *         method(p) { }\n      *     }\n      *\n      *     // property (on constructor)\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", C, \"staticProperty\");\n      *\n      *     // property (on prototype)\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", C.prototype, \"property\");\n      *\n      *     // method (on constructor)\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", C, \"staticMethod\");\n      *\n      *     // method (on prototype)\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", C.prototype, \"method\");\n      *",
        "* Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n      * @param metadataKey A key used to store and retrieve metadata.\n      * @param target The target object on which the metadata is defined.\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n      * @example\n      *\n      *     class C {\n      *     }\n      *\n      *     // constructor\n      *     result = Reflect.getMetadata(\"custom:annotation\", C);\n      *",
        "* Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n      * @param metadataKey A key used to store and retrieve metadata.\n      * @param target The target object on which the metadata is defined.\n      * @param targetKey The property key for the target.\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n      * @example\n      *\n      *     class C {\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\n      *         // static staticProperty;\n      *         // property;\n      *\n      *         static staticMethod(p) { }\n      *         method(p) { }\n      *     }\n      *\n      *     // property (on constructor)\n      *     result = Reflect.getMetadata(\"custom:annotation\", C, \"staticProperty\");\n      *\n      *     // property (on prototype)\n      *     result = Reflect.getMetadata(\"custom:annotation\", C.prototype, \"property\");\n      *\n      *     // method (on constructor)\n      *     result = Reflect.getMetadata(\"custom:annotation\", C, \"staticMethod\");\n      *\n      *     // method (on prototype)\n      *     result = Reflect.getMetadata(\"custom:annotation\", C.prototype, \"method\");\n      *",
        "* Gets the metadata value for the provided metadata key on the target object.\n      * @param metadataKey A key used to store and retrieve metadata.\n      * @param target The target object on which the metadata is defined.\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n      * @example\n      *\n      *     class C {\n      *     }\n      *\n      *     // constructor\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", C);\n      *",
        "* Gets the metadata value for the provided metadata key on the target object.\n      * @param metadataKey A key used to store and retrieve metadata.\n      * @param target The target object on which the metadata is defined.\n      * @param targetKey The property key for the target.\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n      * @example\n      *\n      *     class C {\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\n      *         // static staticProperty;\n      *         // property;\n      *\n      *         static staticMethod(p) { }\n      *         method(p) { }\n      *     }\n      *\n      *     // property (on constructor)\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", C, \"staticProperty\");\n      *\n      *     // property (on prototype)\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", C.prototype, \"property\");\n      *\n      *     // method (on constructor)\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", C, \"staticMethod\");\n      *\n      *     // method (on prototype)\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", C.prototype, \"method\");\n      *",
        "* Gets the metadata keys defined on the target object or its prototype chain.\n      * @param target The target object on which the metadata is defined.\n      * @returns An array of unique metadata keys.\n      * @example\n      *\n      *     class C {\n      *     }\n      *\n      *     // constructor\n      *     result = Reflect.getMetadataKeys(C);\n      *",
        "* Gets the metadata keys defined on the target object or its prototype chain.\n      * @param target The target object on which the metadata is defined.\n      * @param targetKey The property key for the target.\n      * @returns An array of unique metadata keys.\n      * @example\n      *\n      *     class C {\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\n      *         // static staticProperty;\n      *         // property;\n      *\n      *         static staticMethod(p) { }\n      *         method(p) { }\n      *     }\n      *\n      *     // property (on constructor)\n      *     result = Reflect.getMetadataKeys(C, \"staticProperty\");\n      *\n      *     // property (on prototype)\n      *     result = Reflect.getMetadataKeys(C.prototype, \"property\");\n      *\n      *     // method (on constructor)\n      *     result = Reflect.getMetadataKeys(C, \"staticMethod\");\n      *\n      *     // method (on prototype)\n      *     result = Reflect.getMetadataKeys(C.prototype, \"method\");\n      *",
        "* Gets the unique metadata keys defined on the target object.\n      * @param target The target object on which the metadata is defined.\n      * @returns An array of unique metadata keys.\n      * @example\n      *\n      *     class C {\n      *     }\n      *\n      *     // constructor\n      *     result = Reflect.getOwnMetadataKeys(C);\n      *",
        "* Gets the unique metadata keys defined on the target object.\n      * @param target The target object on which the metadata is defined.\n      * @param targetKey The property key for the target.\n      * @returns An array of unique metadata keys.\n      * @example\n      *\n      *     class C {\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\n      *         // static staticProperty;\n      *         // property;\n      *\n      *         static staticMethod(p) { }\n      *         method(p) { }\n      *     }\n      *\n      *     // property (on constructor)\n      *     result = Reflect.getOwnMetadataKeys(C, \"staticProperty\");\n      *\n      *     // property (on prototype)\n      *     result = Reflect.getOwnMetadataKeys(C.prototype, \"property\");\n      *\n      *     // method (on constructor)\n      *     result = Reflect.getOwnMetadataKeys(C, \"staticMethod\");\n      *\n      *     // method (on prototype)\n      *     result = Reflect.getOwnMetadataKeys(C.prototype, \"method\");\n      *",
        "* Deletes the metadata entry from the target object with the provided key.\n      * @param metadataKey A key used to store and retrieve metadata.\n      * @param target The target object on which the metadata is defined.\n      * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n      * @example\n      *\n      *     class C {\n      *     }\n      *\n      *     // constructor\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", C);\n      *",
        "* Deletes the metadata entry from the target object with the provided key.\n      * @param metadataKey A key used to store and retrieve metadata.\n      * @param target The target object on which the metadata is defined.\n      * @param targetKey The property key for the target.\n      * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n      * @example\n      *\n      *     class C {\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\n      *         // static staticProperty;\n      *         // property;\n      *\n      *         static staticMethod(p) { }\n      *         method(p) { }\n      *     }\n      *\n      *     // property (on constructor)\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", C, \"staticProperty\");\n      *\n      *     // property (on prototype)\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", C.prototype, \"property\");\n      *\n      *     // method (on constructor)\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", C, \"staticMethod\");\n      *\n      *     // method (on prototype)\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", C.prototype, \"method\");\n      *"
    ],
    "functions": [],
    "classes": []
}