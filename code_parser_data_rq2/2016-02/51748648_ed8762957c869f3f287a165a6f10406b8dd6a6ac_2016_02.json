{
    "identifiers": [
        "f",
        "delay",
        "delay",
        "setImmediate",
        "f",
        "setTimeout",
        "f",
        "delay",
        "arr",
        "arr",
        "i",
        "schedule",
        "elem",
        "index",
        "elem",
        "elem",
        "index",
        "arr",
        "i",
        "i",
        "args",
        "observer",
        "observer",
        "f",
        "f",
        "f",
        "f",
        "f",
        "f",
        "index",
        "index",
        "f",
        "f",
        "__arguments",
        "e",
        "e",
        "e",
        "__arguments",
        "e",
        "e",
        "e",
        "__arguments",
        "BOOL_OPERATOR",
        "Signal",
        "Signal",
        "BOOL_OPERATOR",
        "__conditionIndex",
        "id",
        "id",
        "BOOL_OPERATOR",
        "BOOL_OPERATOR",
        "BOOL_OPERATOR",
        "BOOL_OPERATOR",
        "BOOL_OPERATOR",
        "BOOL_OPERATOR",
        "BOOL_OPERATOR",
        "callback",
        "callback",
        "callback",
        "schedule",
        "callback",
        "me",
        "callback",
        "me",
        "condition",
        "condition",
        "callback",
        "me",
        "callback",
        "callback",
        "schedule",
        "callback",
        "me",
        "callback",
        "me",
        "condition",
        "condition",
        "callback",
        "me",
        "callback",
        "timeout",
        "setTimeout",
        "timeout",
        "clearTimeout",
        "f",
        "f",
        "success",
        "error",
        "success",
        "error",
        "error",
        "BOOLEAN_OPERATOR",
        "Condition",
        "BOOLEAN_OPERATOR",
        "op",
        "op",
        "i",
        "l",
        "i",
        "l",
        "i",
        "i",
        "BOOL_OPERATOR",
        "i",
        "notSet",
        "notSet",
        "BOOL_OPERATOR",
        "BOOL_OPERATOR",
        "i",
        "l",
        "i",
        "l",
        "i",
        "i",
        "BOOL_OPERATOR",
        "i",
        "notSet",
        "notSet",
        "BOOL_OPERATOR",
        "BOOL_OPERATOR",
        "value",
        "BOOLEAN_OPERATOR",
        "value",
        "condition",
        "condition",
        "condition",
        "BOOL_OPERATOR",
        "BOOL_OPERATOR",
        "BOOL_OPERATOR",
        "fn",
        "condition",
        "condition",
        "fn",
        "c",
        "index",
        "ConditionTree",
        "array",
        "timeout",
        "array",
        "timeout",
        "array",
        "array",
        "array",
        "element",
        "element",
        "condition",
        "Condition",
        "me",
        "condition",
        "iterableArray",
        "ParallelConditionDescriptor",
        "element",
        "condition",
        "element",
        "ParallelCondition",
        "condition",
        "element",
        "me",
        "condition",
        "iterableArray",
        "ParallelConditionDescriptor",
        "element",
        "condition",
        "iterableArray",
        "forEachP",
        "f",
        "Condition",
        "v",
        "v",
        "callback",
        "schedule",
        "callback",
        "me",
        "callback",
        "callback",
        "callback",
        "task",
        "timeout",
        "timeout",
        "Future",
        "task",
        "c",
        "__workerIndex",
        "Condition",
        "Condition",
        "workerTask",
        "workerTask",
        "workerTask",
        "me",
        "future",
        "timeout",
        "setTimeout",
        "future",
        "me",
        "timeoutId",
        "clearTimeout",
        "timeoutId",
        "timeoutId",
        "workerTask",
        "future",
        "timeout",
        "timeoutId",
        "setTimeout",
        "me",
        "timeoutId",
        "timeout",
        "future",
        "workerTask",
        "f",
        "f",
        "f",
        "f",
        "dispatcher",
        "concurrency",
        "i",
        "concurrency",
        "i",
        "__createWorker",
        "dispatcher",
        "workers",
        "worker",
        "workers",
        "dispatcher",
        "Worker",
        "worker",
        "dispatcher",
        "dispatcher",
        "worker",
        "worker",
        "dispatcher",
        "dispatcher",
        "worker",
        "worker",
        "d",
        "concurrency",
        "concurrency",
        "__createWorkers",
        "Signal",
        "_task",
        "_timeout",
        "WorkerTask",
        "_task",
        "_timeout",
        "task",
        "task",
        "__task",
        "_timeout",
        "haltOnError",
        "haltOnError",
        "haltOnError",
        "__task",
        "__task",
        "_task",
        "task",
        "future",
        "future",
        "task",
        "future",
        "_task",
        "args",
        "pendingTasks",
        "fnIndex",
        "arguments",
        "auditArguments",
        "auditArgument",
        "retValue",
        "fn",
        "iterate",
        "arguments",
        "retValue",
        "pendingTasks",
        "iterate",
        "retValue",
        "auditArgument",
        "retValue",
        "pendingTasks",
        "future",
        "retValue",
        "e",
        "auditArgument",
        "e",
        "haltOnError",
        "e",
        "error",
        "__getSequenceStackTrace",
        "_task",
        "auditArguments",
        "fnIndex",
        "future",
        "error",
        "iterate",
        "e",
        "iterate",
        "task",
        "__task",
        "task",
        "_timeout",
        "_condition",
        "_timeout",
        "_condition",
        "ParallelCondition",
        "future",
        "_condition",
        "future",
        "_condition",
        "future",
        "_condition",
        "_timeout",
        "l",
        "l",
        "worker",
        "task",
        "worker",
        "worker",
        "worker",
        "__createWorker",
        "worker",
        "worker",
        "_task",
        "auditArguments",
        "fnIndex",
        "v",
        "v",
        "e1",
        "v",
        "args",
        "j",
        "j",
        "args",
        "j",
        "__stringify",
        "args",
        "j",
        "j",
        "args",
        "i",
        "i",
        "_task",
        "i",
        "auditArgument",
        "i",
        "auditArguments",
        "auditArguments",
        "i",
        "fnStr",
        "_task",
        "i",
        "strtmp",
        "fnStr",
        "fnStr",
        "i",
        "fnIndex",
        "strtmp",
        "i",
        "fnIndex",
        "strtmp",
        "i",
        "fnIndex",
        "strtmp",
        "strtmp",
        "auditArgument",
        "__args",
        "auditArgument",
        "__stringify",
        "auditArgument"
    ],
    "literals": [
        "string",
        "'Condition'",
        "string",
        "\"ParallelCondition needs an Array of functions or other ParallelConditions.\"",
        "\"function\"",
        "\"ParallelCondition needs functions or other ParallelCondition as parameters.\"",
        "string",
        "\"worker\"",
        "Worker '${this._id}' timeout. Future value as Error.",
        "\"Worker '\"",
        "\"' Timeout\"",
        "'undefined'",
        "'[object Array]'",
        "'args=['",
        "','",
        "']'",
        "''",
        "'{'",
        "'- [errored] -->'",
        "'+ [current] -->'",
        "'+ '",
        "'- '",
        "'  '",
        "'  '",
        "'ret=['",
        "']'",
        "'\\n'"
    ],
    "variables": [
        "index",
        "__conditionIndex",
        "i",
        "l",
        "notSet",
        "i",
        "l",
        "notSet",
        "value",
        "me",
        "iterableArray",
        "condition",
        "me",
        "__workerIndex",
        "future",
        "timeoutId",
        "workers",
        "i",
        "worker",
        "worker",
        "task",
        "task",
        "_task",
        "pendingTasks",
        "fnIndex",
        "auditArguments",
        "fn",
        "retValue",
        "auditArgument",
        "error",
        "task",
        "worker",
        "fnStr",
        "strtmp",
        "args",
        "i",
        "j",
        "auditArgument"
    ],
    "comments": [
        ",array",
        "element is supposed to be a function that receives as parameters:",
        "+ Condition object",
        "+ Number as the index sequence of the paralleled functions",
        "schedule",
        "cambia la condicion de working cuando se establece valor al Future",
        "trivial.",
        "an empty array has been set.",
        "str+= '  error: [';\n            try {\n                str+= JSON.stringify( auditArgument.ret );\n            } catch(e2) {\n                str+= auditArgument.ret.toString();\n            }\n            str+=']';"
    ],
    "docstrings": [
        "* (c) 2013-2016 Ibon Tolosana.",
        "* Untangle: untangle the callback nightmare with stateful objects and asynchronous functionality.\n * Objects available:\n *\n *  Signal\n *  Condition\n *  ConditionTree\n *  ParallelCondition\n *  Future\n *  WorkerTask\n *  Worker\n *  Dispatcher\n *\n * @see license.txt file\n *",
        "* Schedule a task in the future.\n * @param f {function()}\n * @param delay {number=} milliseconds to schedule in the future",
        "* ForEach parallel.\n * Schedule each of the Array elements in the future.\n * Do not use directly, it is used internally by the library.",
        "* Signal is a string-based observer substitution. Instead of registering events by (commonly) string,\n * the signal gives context to the event by creating an object which takes care of notifying its observers.\n * It also takes care of all the burden of managing observers, registering, notifying, etc.\n *\n * It allows to registers single and multi shot observers.\n *\n * The signal is agnostic regarding what content will notify to its observers.\n *\n * Every time the signal emits (notifies observers) the <code>observersOnce</code> collection will be reset.\n *\n * @return {*}\n * @constructor",
        "* Add a multishot observer.\n     * @param f {function(*)} a callback function with variable parameters.\n     * @return {*}",
        "* Add a multi shot observer as the first one in the list.\n     * @param f {function(*)} a callback function with variable parameters.\n     * @return {*}",
        "* Remove a multishot observer.\n     * @param f {function(*)} a previously registered observer by a call to addLitener.\n     * @return {*}",
        "* Remove all multishot observers.\n     * @return {*}",
        "* Add a one shot observer.\n     * The callback function will only be called once.\n     * @param f {function()}",
        "* Notify all observers, either single/multi shot.",
        "* @enum Condition possible values.",
        "* Condition is a wrapper for a tri-state condition.\n *\n * The need for a Condition object is that of statefulness. In certain situations, you want to know\n * whether certain condition has happened in time, and whether it was true or false.\n *\n * A condition will only notify once when its value is set. It will never notify again after set, and can't\n * have its internal condition value changed.\n *\n * Whenever the Condition changes state, it will notify any registered observers. To do so, the Condition\n * holds a Signal object.\n *\n * Conditions can have associated a timeout. If the timer expires, the Condition is automatically set to\n * false by calling <code>setFalse()</code>.\n *\n * You can wait for value changes on a condition by calling\n * <li><code>onTrue(callback)</code>\n * <li><code>onFalse(callback)</code>\n * <li><code>onChange(callback)</code>\n *\n * in all three cases, the callback function will receive the Condition as parameter.\n *\n * A condition usage use case:\n *\n * var c= new Condition().onTrue( function(condition) {\n *     // do something here when the condition is met\n *     } );\n *\n * later in the code:\n *\n * c.setTrue();\n *\n * This is no different than setting a callback, but at any given moment, you can ask if the condition has\n * ever had value:\n *\n * c.isNotSet()\n *\n * and if it has ever met, whether it was true or false:\n *\n * c.isTrue() or c.isFalse().\n *\n * @return {*}\n * @constructor",
        "* Signal to emit state change events {Signal}\n     * @type {Signal}\n     * @private",
        "* Signal to emit condition timed out.\n     * @type {Signal}",
        "* internal state value {Condition}\n     * @type {BOOL_OPERATOR}\n     * @private",
        "* Arbitrary id.\n     * @type {*}",
        "* Emit condition state change events.\n     * @private",
        "* Set a condition as true.\n     * If the condition was true, nothing happens.\n     * Otherwise, the internal status will be <code>BOOL_OPERATOR.TRUE</code>.\n     * Observers of this condition will be notified of the state change.\n     * @return {*}",
        "* Set a condition as true.\n     * If the condition was false, nothing happens.\n     * Otherwise, the internal status will be a value from <code>BOOL_OPERATOR.FALSE</code>.\n     * Observers of this condition will be notified of the state change.\n     * @return {*}",
        "* Test this condition for BOOL_OPERATOR.TRUE\n     * @return {Boolean}",
        "* Test this condition for BOOL_OPERATOR.FALSE\n     * @return {Boolean}",
        "* Test this condition for BOOL_OPERATOR.NOT_SET\n     * @return {Boolean}",
        "* Register a callback function to be notified whenever the Condition changes state.\n     * @param callback {SignalObserver} a callback function to notify upon Condition state changes.\n     * @return {Condition}",
        "* Register a callback function to be notified whenever the Condition gets BOOL_OPERATOR.TRUE.\n     * @param callback {SignalObserver} a callback function to notify upon Condition state changes.\n     * @return {Condition}",
        "* Register a callback function to be notified whenever the Condition gets BOOL_OPERATOR.FALSE.\n     * @param callback {SignalObserver} a callback function to notify upon Condition state changes.\n     * @return {Condition}",
        "* Set this condition timeout.\n     * When the timeout expires, <code>setFalse</code> is called in the condition.\n     * @param timeout\n     * @return {*}",
        "* Cancel this Condition internal timeout.\n     * @private",
        "* This function is invoked when the Condition is timed out.\n     * @private",
        "* Register an observer callback function for timeout events.\n     * @param f\n     * @return {*}",
        "* Disable this condition by removing all registered listeners.",
        "* Return this Condition's internal value.\n     * @return {*}",
        "* ConditionTree is the extension of a simple Condition into a full fledged boolean condition tree.\n * A ConditionTree can contain other trees as conditions to form structures like:\n *   A or (B and (C or D))\n *\n * All the base behavior of a simple Condition can be applied to ConditionTree objects.\n *\n * A condition tree applies fast condition short circuit, notifying as soon as possible about condition\n * state changed.\n *\n * @return {*}\n * @constructor",
        "* Set the boolean operator that will be applied to this tree's children.\n     * @param op\n     * @return {*}",
        "* Find this tree's boolean value making a logical OR with its children.\n     * @return {BOOL_OPERATOR}\n     * @private",
        "* Find this tree's boolen value making a logical AND with its children.\n     * @return {(BOOL_OPERATOR)}\n     * @private",
        "* @return {BOOL_OPERATOR}\n     * @private",
        "* Add a new Condition to this ConditionTree.\n     * @param condition {Condition | ConditionTree}",
        "* Invoked when a condition in this tree changes value.\n     * @private",
        "*\n * A parallel condition object defines a ConditionTree where each condition is associated with an asynchronous\n * executing function.\n * It expects a list of functions or other ParallelCondition objects to be asynchronously executed.\n * As a ConditionTree, it will short circuit the condition fast to allow your main execution line progress as\n * soon as possible.\n *\n * It inherits all the behavior from ConditionTree and hence from Condition.\n *\n * @param array Array.<{ ( function( Condition, number ) | ParallelCondition) } > array of functions that accept a\n *  Condition and a number (index sequence of paralleled functions).\n * @param timeout {number} millisecond to have the task completed",
        "* Set the internal ConditionTree object.\n     * @param array {Array< SignalObserver | ParallelCondition >}\n     * @private",
        "* Start the asynchronous condition evaluation.\n     * This function will notify any registered observer via:\n     *\n     * <code>onTrue</code>\n     * <code>onFalse</code>\n     * <code>onStateChange</code>\n     * <code>onTimeout</code>",
        "* Future objects are holders for values of functions not yet executed.\n * Futures have stateful semantics and their values can be set only once.\n *\n * Futures expect value observers to register via a call to <code>onValueSet</code>.\n *\n * If you want to test for a valid value in the Future object, a call to <code>isValueSet</code> must\n * be performed to know whether a value has been set, followed by a call to <code>getValue</code> which\n * will return the actual value set in this Future object.\n *\n * @return {*}\n * @constructor",
        "* Return this Future object's value.\n     * If calling this method, a call to <code>isValueSet</code> must be performed to know whether the Future\n     * has had a value set.\n     *\n     * @return {*}",
        "* Test internal Condition object to know whether a value has been set in the Future object.\n     * @return {Boolean}",
        "* Set this Future object's value and notify any registered observers.\n     * @param v {Object}",
        "* Register a callback function as observer for this Future object's set value event.\n     * @param callback {FutureCallback}\n     * @return {*}",
        "* This class is for internal use of a Dispatcher/Pool object.\n *\n * The task object is expected to be a function receiving a <code>Future</code> object,\n * but it may be a closure which behaves distinctly depending on the function called in the\n * <code>Dispatcher</code> object.\n *\n * A chained call, may be interrupted by external events:\n *\n * + if a timeout event is generated, the function execution will stop and the WorkerTask disabled (no condition\n *   or callback notification). The worker will be killed, and a new one will be created.\n * + if one function in the chain sets the Future's parameter to an Error instance, the chain call will stop\n *   and the worker will be reused.\n *\n *\n * @param task {FutureCallback}\n * @param timeout {number}\n * @return {*}\n * @constructor",
        "* A Worker is the heart of Dispatcher and Pool objects.\n * It keeps all the logic needed to execute asynchronous tasks, timeout them, and all the mechanics for\n * notifying about its internal activity:\n *\n * <li>is busy executing an asynchronous function\n * <li>is timed out. Timeout is just a notification, since the running asynchronous function can't be cancelled.\n *\n * @return {*}\n * @constructor",
        "*\n     * @return {Boolean} is this Worker executing an asynchronous function ?",
        "*\n     * @return {Boolean} is this worker is timed out ?",
        "* Register an observer for worker-ends-execution event.\n     * @param f {function( Condition )} a callback function which will be notified when the worker ends.\n     * @return {*}",
        "* Register an observer for worker-times-out event.\n     * @param f {function( Condition ) } a callback function which will be notified when the worker ends.\n     * @return {*}",
        "* When the worker times out, a Dispatcher or Pool will mark a worker as invalid, and then Kill it,\n     * preventing from notifying results from the asynchronous function is being performed.\n     * @protected",
        "* Create the number of workers specified in the constructor.\n * Only called from the constructor.\n *\n * @private",
        "* Helper to create\n * @return {Worker}\n * @private",
        "* A Dispatcher object sequences the execution of tasks. Internally allocates a predefined number of\n * Worker instances to handle the submitted asynchronous tasks.\n * Each task can be submitted with its own timeout control.\n *\n * The Dispatcher will handle a list of submitted tasks and the specified number of Worker objects\n * in an attempt to sequentially execute tasks.\n * If more than one worker is specified in the constructor, there's no sequential execution guarantee\n * since the workers will have allocated tasks on demand.\n *\n * When one worker expires, the Dispatcher simply creates a new one and kills expired Workers's observers.\n *\n * @param concurrency {number} of active Worker objects. Defaults to 1.\n * @return {*}\n * @constructor",
        "* Submit a task for asynchronous execution.\n     *\n     * @param _task { FutureCallback }\n     * @param _timeout {number=} millisecond to consider this task timed out.\n     * @return {Future}",
        "* Register a function as observer for Dispatcher lazy event.\n     * @param l { DispatcherCallback }\n     * @return {*}",
        "* Execute a queued task.\n     * Tasks are processed FIFO.\n     *\n     * @private",
        "* Internally notified when a worker ends executing its assigned task.\n     * @param worker {Worker}\n     * @private",
        "* Internally notified when a worker times out.\n     * @param worker {Worker}\n     * @private",
        "*\n * @param _task {Array.<function>}\n * @param auditArguments {Array.<{ Array, Object }>}\n * @param fnIndex {number}\n *\n * @private\n *\n * @return {string}"
    ],
    "functions": [
        "schedule",
        "forEachP",
        "on",
        "addListener",
        "addListenerInFrontOfList",
        "removeListener",
        "removeAllListeners",
        "addListenerOnce",
        "emit",
        "id",
        "id",
        "__emit",
        "setTrue",
        "setFalse",
        "isTrue",
        "isFalse",
        "isNotSet",
        "onStateChange",
        "onTrue",
        "onFalse",
        "setTimeout",
        "__cancelTimer",
        "__timeout",
        "onTimeout",
        "disable",
        "getCurrentValue",
        "then",
        "setBooleanOperator",
        "__isTrueOr",
        "__isTrueAnd",
        "__isTrue",
        "addCondition",
        "__conditionChanged",
        "__setIterableArray",
        "execute",
        "getValue",
        "isValueSet",
        "setValue",
        "onValueSet",
        "then",
        "getTask",
        "getTimeout",
        "getFuture",
        "run",
        "isWorking",
        "isTimedOut",
        "onWorkDone",
        "onTimeout",
        "kill",
        "__createWorkers",
        "__createWorker",
        "submit",
        "submitNodeSequence",
        "iterate",
        "submitCondition",
        "addIsEmptyListener",
        "__executeTask",
        "__workerNotBusy",
        "__workerTimedOut",
        "__getSequenceStackTrace",
        "__stringify",
        "__args"
    ],
    "classes": [
        "Signal",
        "Condition",
        "ConditionTree",
        "ParallelConditionDescriptor",
        "ParallelCondition",
        "Future",
        "WorkerTask",
        "Worker",
        "Dispatcher"
    ]
}