{
    "identifiers": [
        "grid",
        "grid",
        "AI",
        "bonuses",
        "edgeScore",
        "AI",
        "alpha",
        "beta",
        "depth",
        "player",
        "Infinity",
        "direction",
        "depth",
        "bestMove",
        "player",
        "bestEval",
        "alpha",
        "direction",
        "newGrid",
        "direction",
        "AI",
        "newGrid",
        "result",
        "newAI",
        "alpha",
        "beta",
        "depth",
        "result",
        "alpha",
        "alpha",
        "result",
        "bestMove",
        "direction",
        "beta",
        "alpha",
        "bestEval",
        "alpha",
        "bestEval",
        "beta",
        "val",
        "x",
        "cells",
        "possibleScores",
        "cells",
        "x",
        "j",
        "possibleScores",
        "j",
        "AI",
        "newGrid2",
        "result",
        "AI2",
        "alpha",
        "beta",
        "depth",
        "result",
        "beta",
        "beta",
        "result",
        "beta",
        "alpha",
        "bestEval",
        "beta",
        "cells",
        "bestEval",
        "bestEval",
        "bestMove",
        "AI",
        "Infinity",
        "Infinity"
    ],
    "literals": [],
    "variables": [
        "bonuses",
        "edgeScore",
        "bestEval",
        "bestMove",
        "result",
        "newGrid",
        "newAI",
        "possibleScores",
        "cells",
        "j",
        "newGrid2",
        "AI2"
    ],
    "comments": [
        "AI.prototype.evaluation = function () {\n  var edgeScore = 0;\n  if(this.gird.largestTileInEdge()) {\n    edgeScore = 100;\n  }\n  var bonuses = this.grid.availableCells().length;\n  return edgeScore + bonuses * 2;\n};",
        "if(this.grid.largestTileInEdge()) {\n    edgeScore = 100;\n  }",
        "minimax search with alpha-beta pruning:",
        "var directions = [0, 1, 2, 3];",
        "bestEval = Infinity;",
        "bestEval = this.evaluation();",
        "result = {eval: bestEval, move: direction};",
        "bestEval = this.evaluation();",
        "player's turn:",
        "if(depth == 0) {\n            return {eval: newAI.evaluation(), move: direction};\n          }",
        "else {",
        "}",
        "alpha = Math.max(alpha, bestEval);",
        "result = {eval: beta, move: bestMove};",
        "return result;",
        "computer's turn:",
        "var list = [2, 4];",
        "var worstScores = [];",
        "put 2 and 4 in each empty cell and evaluate the values and find the worst one:",
        "for each worst case, perform the recursion:",
        "result = {eval: alpha, move: null};",
        "return result;"
    ],
    "docstrings": [
        "* β cut-off *",
        "* α cut-off *"
    ],
    "functions": [
        "AI"
    ],
    "classes": []
}