{
    "identifiers": [
        "Heron",
        "source",
        "CST",
        "source",
        "result",
        "CST",
        "source",
        "sequence",
        "optionalWhitespace",
        "endOfString",
        "program",
        "source",
        "source",
        "start",
        "token",
        "source",
        "start",
        "source",
        "start",
        "token",
        "token",
        "token",
        "source",
        "start",
        "start",
        "token",
        "literal",
        "literal",
        "literal",
        "literal",
        "literal",
        "literal",
        "literal",
        "literal",
        "literal",
        "literal",
        "literal",
        "literal",
        "literal",
        "literal",
        "literal",
        "test",
        "source",
        "start",
        "test",
        "source",
        "start",
        "source",
        "start",
        "start",
        "assertion",
        "source",
        "start",
        "start",
        "source",
        "rules",
        "source",
        "start",
        "source",
        "start",
        "start",
        "rule",
        "rules",
        "rule",
        "source",
        "result",
        "subnode",
        "result",
        "subnode",
        "result",
        "subnode",
        "result",
        "source",
        "start",
        "end",
        "source",
        "source",
        "end",
        "end",
        "source",
        "end",
        "source",
        "end",
        "source",
        "end",
        "end",
        "cr",
        "cr",
        "source",
        "lf",
        "lf",
        "source",
        "source",
        "end",
        "source",
        "end",
        "end",
        "ss",
        "ss",
        "source",
        "end",
        "start",
        "source",
        "start",
        "end",
        "rule",
        "source",
        "start",
        "rule",
        "source",
        "start",
        "source",
        "start",
        "subnode",
        "subnode",
        "start",
        "subnode",
        "optional",
        "whitespace",
        "BlaEos",
        "sequence",
        "literal",
        "endOfString"
    ],
    "literals": [
        "string",
        "string",
        "'correct'",
        "'wrong'",
        "string",
        "'program'",
        "string",
        "string",
        "string",
        "string",
        "'float'",
        "'float2'",
        "'float3'",
        "'float4'",
        "'int'",
        "'int2'",
        "'int3'",
        "'int4'",
        "'bool'",
        "'bool2'",
        "'bool3'",
        "'bool4'",
        "'mat2'",
        "'mat3'",
        "'mat4'",
        "string",
        "'eos'",
        "string",
        "' \\t\\v\\f\\r\\n'",
        "'//'",
        "'\\r'",
        "'\\n'",
        "'/*'",
        "'*/'",
        "'ws'",
        "string",
        "'ows'",
        "'blaeos'",
        "'bla'"
    ],
    "variables": [
        "result",
        "program",
        "float2",
        "float3",
        "float4",
        "int2",
        "int3",
        "int4",
        "bool2",
        "bool3",
        "bool4",
        "mat2",
        "mat3",
        "mat4",
        "endOfString",
        "result",
        "subnode",
        "whitespace",
        "end",
        "start",
        "cr",
        "lf",
        "ss",
        "subnode",
        "optionalWhitespace",
        "blaEos"
    ],
    "comments": [
        "The main entry point for compiling a Heron source string.",
        "CST = Concrete Syntax Tree",
        "The main entry point for parsing a Heron source string.",
        "A parsing rule is a function which takes a source string\n           and a starting index into that string, and either\n           succeeds at parsing, in which case it returns a T, or\n           fails at parsing, in which case in returns nothing.\n           It should have no side effects (except maybe caching).\n           Usually T is a subtype of Node.",
        "A generic return value for a parsing rule.\n           Usually a subtype will be returned.",
        "what kind of node is this?",
        "reference to the whole source code",
        "the starting position in source",
        "just past the ending position in source",
        "A rule for parsing literal tokens.",
        "Literals for basic type names.",
        "An assertion is a zero-length node which indicates that\n           a certain condition is met at a location in the source.",
        "A rule for matching the end of the source string.",
        "Given a sequence of rules, we can chain them to produce\n           a rule which succeeds if all parts succeed, one after the\n           other, at consecutive points in the source string. Each\n           of the subrules generates a subnode, which is kept in the\n           'nodes' array.\n           We can use const enums to maintain a mapping between\n           field names for a sequence node and indices into the\n           nodes array.",
        "modified later",
        "modified later",
        "Whitespace nodes, which (currently) include comments.\n           We don't allow empty whitespace nodes; if a grammar\n           rule calls for optional whitespace, use the\n           optionalWhitespace rule instead.",
        "The grammar can have optional elements, which could\n           be present or absent, without making the parsing fail.\n           Regardless of whether this element is found, we wrap\n           the result in an Optional node."
    ],
    "docstrings": [],
    "functions": [
        "compile",
        "parse",
        "literal",
        "assertion",
        "sequence",
        "optional"
    ],
    "classes": []
}