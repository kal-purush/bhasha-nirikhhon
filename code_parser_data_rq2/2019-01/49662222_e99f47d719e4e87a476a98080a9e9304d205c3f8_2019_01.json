{
    "identifiers": [
        "com",
        "oracle",
        "svm",
        "core",
        "posix",
        "linux",
        "com",
        "oracle",
        "svm",
        "core",
        "Isolates",
        "IMAGE_HEAP_RELOCATABLE_BEGIN",
        "com",
        "oracle",
        "svm",
        "core",
        "Isolates",
        "IMAGE_HEAP_RELOCATABLE_END",
        "com",
        "oracle",
        "svm",
        "core",
        "Isolates",
        "IMAGE_HEAP_WRITABLE_BEGIN",
        "com",
        "oracle",
        "svm",
        "core",
        "Isolates",
        "IMAGE_HEAP_WRITABLE_END",
        "com",
        "oracle",
        "svm",
        "core",
        "posix",
        "linux",
        "ProcFSSupport",
        "findMapping",
        "com",
        "oracle",
        "svm",
        "core",
        "util",
        "PointerUtils",
        "roundUp",
        "com",
        "oracle",
        "svm",
        "core",
        "Isolates",
        "com",
        "oracle",
        "svm",
        "core",
        "MemoryUtil",
        "com",
        "oracle",
        "svm",
        "core",
        "SubstrateOptions",
        "com",
        "oracle",
        "svm",
        "core",
        "UnsafeAccess",
        "com",
        "oracle",
        "svm",
        "core",
        "annotate",
        "AutomaticFeature",
        "com",
        "oracle",
        "svm",
        "core",
        "annotate",
        "Uninterruptible",
        "com",
        "oracle",
        "svm",
        "core",
        "c",
        "CGlobalData",
        "com",
        "oracle",
        "svm",
        "core",
        "c",
        "CGlobalDataFactory",
        "com",
        "oracle",
        "svm",
        "core",
        "c",
        "CEntryPointErrors",
        "com",
        "oracle",
        "svm",
        "core",
        "os",
        "CopyingImageHeapProvider",
        "com",
        "oracle",
        "svm",
        "core",
        "os",
        "ImageHeapProvider",
        "com",
        "oracle",
        "svm",
        "core",
        "os",
        "VirtualMemoryProvider",
        "com",
        "oracle",
        "svm",
        "core",
        "os",
        "VirtualMemoryProvider",
        "Access",
        "com",
        "oracle",
        "svm",
        "core",
        "posix",
        "headers",
        "Fcntl",
        "com",
        "oracle",
        "svm",
        "core",
        "posix",
        "headers",
        "LibC",
        "com",
        "oracle",
        "svm",
        "core",
        "posix",
        "headers",
        "Stat",
        "com",
        "oracle",
        "svm",
        "core",
        "posix",
        "headers",
        "Unistd",
        "com",
        "oracle",
        "svm",
        "core",
        "util",
        "UnsignedUtils",
        "org",
        "graalvm",
        "compiler",
        "api",
        "replacements",
        "Fold",
        "org",
        "graalvm",
        "compiler",
        "word",
        "Word",
        "org",
        "graalvm",
        "nativeimage",
        "Feature",
        "org",
        "graalvm",
        "nativeimage",
        "ImageInfo",
        "org",
        "graalvm",
        "nativeimage",
        "ImageSingletons",
        "org",
        "graalvm",
        "nativeimage",
        "Platform",
        "org",
        "graalvm",
        "nativeimage",
        "Platforms",
        "org",
        "graalvm",
        "nativeimage",
        "StackValue",
        "org",
        "graalvm",
        "nativeimage",
        "c",
        "CCharPointer",
        "org",
        "graalvm",
        "nativeimage",
        "c",
        "CIntPointer",
        "org",
        "graalvm",
        "nativeimage",
        "c",
        "CLongPointer",
        "org",
        "graalvm",
        "nativeimage",
        "c",
        "WordPointer",
        "org",
        "graalvm",
        "word",
        "LocationIdentity",
        "org",
        "graalvm",
        "word",
        "Pointer",
        "org",
        "graalvm",
        "word",
        "PointerBase",
        "org",
        "graalvm",
        "word",
        "UnsignedWord",
        "org",
        "graalvm",
        "word",
        "WordFactory",
        "AutomaticFeature",
        "Platforms",
        "Override",
        "access",
        "ImageSingletons",
        "contains",
        "ImageSingletons",
        "add",
        "SELF_EXE",
        "CGlobalDataFactory",
        "createCString",
        "MAPS",
        "CGlobalDataFactory",
        "createCString",
        "OBJECT_FD",
        "CGlobalDataFactory",
        "createWord",
        "WordFactory",
        "signed",
        "FD_OFFSET",
        "CGlobalDataFactory",
        "createWord",
        "WordFactory",
        "signed",
        "SVM_BASE",
        "CGlobalDataFactory",
        "createWord",
        "WordFactory",
        "signed",
        "MAX_PATHLEN",
        "Fold",
        "ImageInfo",
        "isExecutable",
        "Override",
        "Uninterruptible",
        "reason",
        "begin",
        "reservedSize",
        "basePointer",
        "endPointer",
        "result",
        "cowInitialize",
        "begin",
        "reservedSize",
        "basePointer",
        "endPointer",
        "result",
        "CEntryPointErrors",
        "NO_ERROR",
        "initialize",
        "begin",
        "reservedSize",
        "basePointer",
        "endPointer",
        "result",
        "Uninterruptible",
        "reason",
        "begin",
        "reservedSize",
        "basePointer",
        "endPointer",
        "imageHeapBegin",
        "Isolates",
        "IMAGE_HEAP_BEGIN",
        "get",
        "imageHeapSize",
        "Isolates",
        "IMAGE_HEAP_END",
        "get",
        "subtract",
        "imageHeapBegin",
        "begin",
        "isNonNull",
        "reservedSize",
        "belowThan",
        "imageHeapSize",
        "CEntryPointErrors",
        "UNSPECIFIED",
        "executable",
        "isExecutable",
        "UnsafeAccess",
        "UNSAFE",
        "loadFence",
        "fd",
        "OBJECT_FD",
        "get",
        "readLong",
        "fd",
        "createMapping",
        "begin",
        "basePointer",
        "endPointer",
        "imageHeapBegin",
        "imageHeapSize",
        "fd",
        "FD_OFFSET",
        "get",
        "readLong",
        "executable",
        "mapFD",
        "Fcntl",
        "NoTransitions",
        "open",
        "MAPS",
        "get",
        "Fcntl",
        "O_RDONLY",
        "mapFD",
        "CEntryPointErrors",
        "MAP_HEAP_FAILED",
        "buffer",
        "LibC",
        "malloc",
        "WordFactory",
        "unsigned",
        "MAX_PATHLEN",
        "startAddr",
        "StackValue",
        "get",
        "offset",
        "StackValue",
        "get",
        "dev",
        "StackValue",
        "get",
        "inode",
        "StackValue",
        "get",
        "found",
        "findMapping",
        "mapFD",
        "buffer",
        "MAX_PATHLEN",
        "imageHeapBegin",
        "rawValue",
        "startAddr",
        "offset",
        "dev",
        "inode",
        "executable",
        "Unistd",
        "NoTransitions",
        "close",
        "mapFD",
        "found",
        "LibC",
        "free",
        "buffer",
        "CEntryPointErrors",
        "MAP_HEAP_FAILED",
        "fd",
        "Fcntl",
        "NoTransitions",
        "open",
        "executable",
        "SELF_EXE",
        "get",
        "buffer",
        "Fcntl",
        "O_RDONLY",
        "LibC",
        "free",
        "buffer",
        "fd",
        "CEntryPointErrors",
        "MAP_HEAP_FAILED",
        "executable",
        "stat",
        "StackValue",
        "get",
        "Stat",
        "fstat_no_transition",
        "fd",
        "stat",
        "stat",
        "st_ino",
        "inode",
        "read",
        "stat",
        "st_dev",
        "dev",
        "read",
        "Unistd",
        "NoTransitions",
        "close",
        "fd",
        "CEntryPointErrors",
        "MAP_HEAP_FAILED",
        "newOffset",
        "offset",
        "read",
        "imageHeapBegin",
        "rawValue",
        "startAddr",
        "read",
        "FD_OFFSET",
        "get",
        "logicCompareAndSwapLong",
        "newOffset",
        "LocationIdentity",
        "ANY_LOCATION",
        "Unistd",
        "NoTransitions",
        "close",
        "fd",
        "UnsafeAccess",
        "UNSAFE",
        "loadFence",
        "fd",
        "OBJECT_FD",
        "get",
        "readLong",
        "fd",
        "newOffset",
        "FD_OFFSET",
        "get",
        "readLong",
        "SVM_BASE",
        "get",
        "writeLong",
        "startAddr",
        "read",
        "offset",
        "read",
        "OBJECT_FD",
        "get",
        "writeLong",
        "fd",
        "UnsafeAccess",
        "UNSAFE",
        "fullFence",
        "createMapping",
        "begin",
        "basePointer",
        "endPointer",
        "imageHeapBegin",
        "imageHeapSize",
        "fd",
        "newOffset",
        "executable",
        "Uninterruptible",
        "reason",
        "begin",
        "basePointer",
        "endPointer",
        "imageHeapBegin",
        "imageHeapSize",
        "fd",
        "offset",
        "patch",
        "heap",
        "VirtualMemoryProvider",
        "get",
        "mapFile",
        "begin",
        "imageHeapSize",
        "WordFactory",
        "unsigned",
        "fd",
        "WordFactory",
        "unsigned",
        "offset",
        "Access",
        "READ",
        "Access",
        "WRITE",
        "heap",
        "isNull",
        "CEntryPointErrors",
        "MAP_HEAP_FAILED",
        "pageSize",
        "VirtualMemoryProvider",
        "get",
        "getGranularity",
        "patch",
        "relocationOffset",
        "UnsignedUtils",
        "roundDown",
        "IMAGE_HEAP_RELOCATABLE_BEGIN",
        "get",
        "subtract",
        "imageHeapBegin",
        "pageSize",
        "relocationEndOffset",
        "UnsignedUtils",
        "roundUp",
        "IMAGE_HEAP_RELOCATABLE_END",
        "get",
        "subtract",
        "imageHeapBegin",
        "pageSize",
        "size",
        "relocationEndOffset",
        "subtract",
        "relocationOffset",
        "imageHeapBegin",
        "add",
        "relocationOffset",
        "to",
        "heap",
        "add",
        "relocationOffset",
        "VirtualMemoryProvider",
        "get",
        "commit",
        "to",
        "size",
        "Access",
        "READ",
        "Access",
        "WRITE",
        "MemoryUtil",
        "copyConjointMemoryAtomic",
        "to",
        "size",
        "writableBeginPageOffset",
        "UnsignedUtils",
        "roundDown",
        "IMAGE_HEAP_WRITABLE_BEGIN",
        "get",
        "subtract",
        "imageHeapBegin",
        "pageSize",
        "writableBeginPageOffset",
        "aboveThan",
        "VirtualMemoryProvider",
        "get",
        "protect",
        "heap",
        "writableBeginPageOffset",
        "Access",
        "READ",
        "CEntryPointErrors",
        "PROTECT_HEAP_FAILED",
        "writableEndPageOffset",
        "UnsignedUtils",
        "roundUp",
        "IMAGE_HEAP_WRITABLE_END",
        "get",
        "subtract",
        "imageHeapBegin",
        "pageSize",
        "writableEndPageOffset",
        "belowThan",
        "imageHeapSize",
        "afterWritableBoundary",
        "heap",
        "add",
        "writableEndPageOffset",
        "afterWritableSize",
        "imageHeapSize",
        "subtract",
        "writableEndPageOffset",
        "VirtualMemoryProvider",
        "get",
        "protect",
        "afterWritableBoundary",
        "afterWritableSize",
        "Access",
        "READ",
        "CEntryPointErrors",
        "PROTECT_HEAP_FAILED",
        "basePointer",
        "write",
        "heap",
        "endPointer",
        "isNonNull",
        "endPointer",
        "write",
        "roundUp",
        "heap",
        "add",
        "imageHeapSize",
        "pageSize",
        "CEntryPointErrors",
        "NO_ERROR",
        "Uninterruptible",
        "reason",
        "WordFactory",
        "nullPointer"
    ],
    "literals": [
        "\"/proc/self/exe\"",
        "\"/proc/self/maps\"",
        "\"Called during isolate initialization.\"",
        "\"Called during isolate initialization.\"",
        "\"Called during isolate initialization.\"",
        "\"Called from uninterruptible code.\""
    ],
    "variables": [],
    "comments": [
        "Reuse the already loaded file descriptor and discovered offset for",
        "all subsequent isolate initializations. To avoid stalling threads we",
        "intentionally allow for racing during first-time initialization. It's",
        "the lesser of evils, since the overhead of proc parsing and required",
        "i/o is nominal, due to its virtual nature.",
        "",
        "However, we ensure this remains temporary and consensus is quickly",
        "reached on a single FD,",
        "Unfortunately, in the case of a shared library, we must open the",
        "library by the registered file name, since we don't have a usable",
        "equivalent of /proc/self/exe, which remains even if the file is",
        "deleted, since it keeps an inode reference active. The kernel does",
        "provide a similar notion in /proc/map_files, but directly opening",
        "those entries intentionally requires CAP_SYS_ADMIN, out of security",
        "concerns (see discussion in https://lkml.org/lkml/2015/5/19/896)",
        "",
        "In practice, this is unlikely to be a problem since the window for an",
        "unlink race is tiny. We immediately read the file in the earliest",
        "stages of start, and we cache the FD after. Once we have the FD we",
        "can still access the mapped file even after it has been deleted.",
        "",
        "As a precaution we verify the file we open matches the inode",
        "associated with the true mapped in original. In the case it does",
        "not we must abort and fall back to the copy strategy. In the case of",
        "native executables, it will always match due to /proc/self/exe.",
        "Another thread won, busy-wait until we can use it's descriptor",
        "Ensure we have a Store-Load barrier to match up with loads",
        "so that we get volatile access semantics",
        "Create an overlapping anonymous area replacing the relocatable",
        "section of heap, and overwrite with the already relocated original"
    ],
    "docstrings": [
        "* Copyright (c) 2019, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.",
        "* An optimal image heap provider for Linux which creates isolate image heaps\n * that retain the copy-on-write, lazy loading and reclamation semantics\n * provided by the original heap's backing resource.\n *\n * This is accomplished by discovering the backing executable or shared object\n * file the kernel has mmapped to the original heap image virtual address, as\n * well as the location in the file storing the original heap. A new memory map\n * is created to a new virtual range pointing to this same location. This allows\n * the kernel to share the same physical pages between multiple heaps that have\n * not been modified, as well as lazily load them only when needed.\n *\n * The implementation avoids dirtying the pages of the original, and only\n * referencing what is strictly required.\n *\n * This provider falls back to the POSIX friendly\n * <code>CopyImageHeapProvider</code> if either the architecture is not\n * supported, or an error occurs during the mapping process."
    ],
    "functions": [
        "beforeAnalysis",
        "isExecutable",
        "initialize",
        "cowInitialize",
        "createMapping",
        "T",
        "nullPointer"
    ],
    "classes": [
        "LinuxImageHeapProviderFeature",
        "LinuxImageHeapProvider"
    ]
}