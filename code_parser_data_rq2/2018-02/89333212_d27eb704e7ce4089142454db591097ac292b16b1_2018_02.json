{
    "identifiers": [
        "org",
        "spectrumauctions",
        "sats",
        "core",
        "bidlang",
        "xor",
        "com",
        "google",
        "common",
        "Preconditions",
        "org",
        "apache",
        "logging",
        "log4j",
        "LogManager",
        "org",
        "apache",
        "logging",
        "log4j",
        "Logger",
        "org",
        "spectrumauctions",
        "sats",
        "core",
        "model",
        "Bundle",
        "org",
        "spectrumauctions",
        "sats",
        "core",
        "model",
        "cats",
        "CATSBidder",
        "org",
        "spectrumauctions",
        "sats",
        "core",
        "model",
        "cats",
        "CATSLicense",
        "org",
        "spectrumauctions",
        "sats",
        "core",
        "model",
        "cats",
        "CATSWorld",
        "org",
        "spectrumauctions",
        "sats",
        "core",
        "util",
        "random",
        "RNGSupplier",
        "org",
        "spectrumauctions",
        "sats",
        "core",
        "util",
        "random",
        "UniformDistributionRNG",
        "java",
        "math",
        "BigDecimal",
        "java",
        "util",
        "java",
        "util",
        "concurrent",
        "LinkedBlockingQueue",
        "java",
        "util",
        "stream",
        "Collectors",
        "logger",
        "LogManager",
        "getLogger",
        "goods",
        "bidder",
        "rngSupplier",
        "world",
        "noCapForSubstitutableGoods",
        "goods",
        "rngSupplier",
        "bidder",
        "goods",
        "goods",
        "bidder",
        "bidder",
        "rngSupplier",
        "rngSupplier",
        "world",
        "goods",
        "stream",
        "findAny",
        "orElseThrow",
        "getWorld",
        "noCapForSubstitutableGoods",
        "noCapForSubstitutableGoods",
        "Override",
        "bidder",
        "Override",
        "noCapForSubstitutableGoods",
        "rngSupplier",
        "getUniformDistributionRNG",
        "getCATSXORBids",
        "iterator",
        "sortedSet",
        "result",
        "iterator",
        "rngSupplier",
        "getUniformDistributionRNG",
        "result",
        "add",
        "iterator",
        "next",
        "iterator",
        "hasNext",
        "next",
        "iterator",
        "next",
        "next",
        "sortedSet",
        "add",
        "next",
        "i",
        "i",
        "world",
        "getMaxSubstitutableBids",
        "sortedSet",
        "isEmpty",
        "i",
        "val",
        "sortedSet",
        "first",
        "result",
        "stream",
        "XORValue",
        "getLicenses",
        "collect",
        "Collectors",
        "toList",
        "contains",
        "val",
        "getLicenses",
        "result",
        "add",
        "val",
        "sortedSet",
        "remove",
        "val",
        "result",
        "MAX_RETRIES",
        "uniRng",
        "originalLicenseQueue",
        "originalBundle",
        "minValue",
        "budget",
        "minResaleValue",
        "retries",
        "acceptNulls",
        "uniRng",
        "acceptNulls",
        "Preconditions",
        "checkArgument",
        "world",
        "getLicenses",
        "size",
        "goods",
        "size",
        "uniRng",
        "uniRng",
        "minValue",
        "retries",
        "acceptNulls",
        "acceptNulls",
        "Override",
        "originalBundle",
        "licensesLeftToChoose",
        "goods",
        "size",
        "originalBundle",
        "size",
        "originalBundle",
        "size",
        "originalLicenseQueue",
        "isEmpty",
        "licensesLeftToChoose",
        "retries",
        "MAX_RETRIES",
        "Override",
        "hasNext",
        "bundle",
        "entry",
        "bidder",
        "getPrivateValues",
        "entrySet",
        "entry",
        "getValue",
        "doubleValue",
        "minValue",
        "minValue",
        "entry",
        "getValue",
        "doubleValue",
        "originalLicenseQueue",
        "weightedGoods",
        "uniRng",
        "goods",
        "forEach",
        "g",
        "positivePrivateValue",
        "bidder",
        "getPrivateValues",
        "get",
        "g",
        "getId",
        "doubleValue",
        "minValue",
        "weightedGoods",
        "add",
        "positivePrivateValue",
        "g",
        "first",
        "weightedGoods",
        "next",
        "bundle",
        "add",
        "first",
        "uniRng",
        "nextDouble",
        "world",
        "getAdditionalLocation",
        "bundle",
        "add",
        "selectLicenseToAdd",
        "bundle",
        "value",
        "bidder",
        "calculateValue",
        "bundle",
        "value",
        "compareTo",
        "BigDecimal",
        "ZERO",
        "next",
        "budget",
        "world",
        "getBudgetFactor",
        "value",
        "doubleValue",
        "minResaleValue",
        "world",
        "getResaleFactor",
        "bundle",
        "stream",
        "mapToDouble",
        "CATSLicense",
        "getCommonValue",
        "sum",
        "originalLicenseQueue",
        "bundle",
        "originalBundle",
        "bundle",
        "bundle",
        "value",
        "first",
        "originalLicenseQueue",
        "poll",
        "bundle",
        "add",
        "first",
        "bundle",
        "size",
        "originalBundle",
        "size",
        "toAdd",
        "selectLicenseToAdd",
        "bundle",
        "toAdd",
        "bundle",
        "add",
        "toAdd",
        "value",
        "bidder",
        "calculateValue",
        "bundle",
        "resaleValue",
        "bundle",
        "stream",
        "mapToDouble",
        "CATSLicense",
        "getCommonValue",
        "sum",
        "value",
        "doubleValue",
        "value",
        "doubleValue",
        "budget",
        "resaleValue",
        "minResaleValue",
        "bundle",
        "equals",
        "originalBundle",
        "retries",
        "bundle",
        "value",
        "handleNulls",
        "first",
        "e",
        "logger",
        "error",
        "e",
        "logger",
        "error",
        "first",
        "acceptNulls",
        "originalLicenseQueue",
        "add",
        "first",
        "hasNext",
        "retries",
        "MAX_RETRIES",
        "next",
        "bundle",
        "uniRng",
        "nextDouble",
        "world",
        "getJumpProbability",
        "goods",
        "size",
        "bundle",
        "size",
        "randomLicense",
        "iterator",
        "goods",
        "iterator",
        "index",
        "uniRng",
        "nextInt",
        "goods",
        "size",
        "i",
        "i",
        "index",
        "i",
        "iterator",
        "next",
        "randomLicense",
        "iterator",
        "next",
        "bundle",
        "contains",
        "randomLicense",
        "randomLicense",
        "neighbors",
        "uniRng",
        "goods",
        "stream",
        "l",
        "bundle",
        "contains",
        "l",
        "edgeExists",
        "l",
        "bundle",
        "forEach",
        "g",
        "positivePrivateValue",
        "bidder",
        "getPrivateValues",
        "get",
        "g",
        "getId",
        "doubleValue",
        "minValue",
        "neighbors",
        "add",
        "positivePrivateValue",
        "g",
        "neighbors",
        "hasNext",
        "neighbors",
        "next",
        "license",
        "bundle",
        "l",
        "bundle",
        "world",
        "getGrid",
        "isAdjacent",
        "license",
        "getVertex",
        "l",
        "getVertex",
        "retries",
        "random",
        "total",
        "random",
        "random",
        "random",
        "weight",
        "result",
        "total",
        "weight",
        "put",
        "total",
        "result",
        "Override",
        "isEmpty",
        "value",
        "random",
        "nextDouble",
        "total",
        "entry",
        "ceilingEntry",
        "value",
        "entry",
        "entry",
        "getValue"
    ],
    "literals": [
        "\"All passed goods must have a world\"",
        "\"Returning null.\"",
        "\"After \"",
        "\" retries, no other bundle was found \"",
        "\"that was not identical to the original bundle bid and is valid in terms of budget and \"",
        "\"min_resale_value constraints. \\n\"",
        "\"Most likely, there are either almost no licenses to choose from or the original bundle is very\"",
        "\"small and highly valued, so that it's difficult to create another bundle that satisfies the\"",
        "\"constraints. Try again (maybe with a higher number of goods) or use the the iterator that handles\"",
        "\"this situation with null-values.\""
    ],
    "variables": [
        "goods",
        "bidder",
        "rngSupplier",
        "world",
        "noCapForSubstitutableGoods",
        "uniRng",
        "originalLicenseQueue",
        "originalBundle",
        "minValue",
        "budget",
        "minResaleValue",
        "retries",
        "acceptNulls",
        "randomLicense",
        "random"
    ],
    "comments": [
        "CATS always includes the original bundle",
        "Fill the sorted set with all the elements that are not null",
        "Get the most valuable elements from the substitutable bids",
        "The first bundle has not been created yet",
        "The original bundle included only one license",
        "We're not done yet with creating substitutable bundles",
        "We didn't construct an original bid yet",
        "Restart bundle generation for this bidder",
        "Found one - reset retries counter",
        "Add this license to the original queue again",
        "Prevent infinite loop if there is no other license",
        "Filter the licenses that are not contained yet in the bundle and where there exists an edge to one",
        "of the licenses in the bundle."
    ],
    "docstrings": [
        "* <p>The original CATS Regions model has a specific way to generate bids, which does not directly translate into our\n * iterator-based way of generating bids. This class provides an iterator that imitates the original bid-generation\n * technique. To do this, it first collects and filters all possible bids and then provides the iterator on that\n * collection.</p>\n *\n * <p>If you prefer to have an iterator that works more like the other iterators in SATS, you can change the behavior of\n * this class via {@link #noCapForSubstitutableGoods()}.\n *\n * In that case, the first bundle of the provided iterator is the initial bundle which the following elements are based\n * on. The next bundles each have one license of the original bundle as a starting point and are extended so that they\n * have the same amount of licenses as the original bundle. In the CATS Regions model, they are called substitutable\n * bids/bundles.\n *\n * Two things to consider when using the option {@link #noCapForSubstitutableGoods()}:\n *  <ul>\n *      <li>If this iterator finds an invalid bundle (identical to the original bundle or not satisfying the budget/\n *          reselling value constraints), it will try to find another one until #MAX_RETRIES is reached. This is rare,\n *          but still make sure to handle this #NoSuchElementException.</li>\n *      <li>The elements which #next() returns are checked to be not identical to the original bundle, but it's\n *          impossible to detect if it's similar to another substitutable bundle. If duplicate substitutable bundles are\n *          an issue, make sure to handle after you iterated through all the elements.</li>\n *  </ul>\n * </p>\n *\n * @author Fabio Isler"
    ],
    "functions": [
        "CatsXOR",
        "CatsXOR",
        "noCapForSubstitutableGoods",
        "CATSBidder",
        "getBidder",
        "iterator",
        "getCATSXORBids",
        "CATSIterator",
        "hasNext",
        "next",
        "handleNulls",
        "CATSLicense",
        "selectLicenseToAdd",
        "edgeExists",
        "NoValidElementFoundException",
        "WeightedRandomCollection",
        "add",
        "hasNext",
        "T",
        "next"
    ],
    "classes": [
        "CatsXOR",
        "CATSIterator",
        "NoValidElementFoundException",
        "WeightedRandomCollection"
    ]
}