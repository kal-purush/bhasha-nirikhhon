{
    "identifiers": [
        "token",
        "token",
        "match",
        "match",
        "token",
        "isTag",
        "token",
        "word",
        "word",
        "word",
        "word",
        "word",
        "atomicTagsRegExp",
        "word",
        "result",
        "result",
        "word",
        "tag",
        "word",
        "word",
        "tag",
        "tag",
        "token",
        "token",
        "token",
        "token",
        "is_img",
        "isntTag",
        "token",
        "isStartOfAtomicTag",
        "token",
        "isVoidTag",
        "token",
        "currentWord",
        "currentWord",
        "getKeyForToken",
        "currentWord",
        "startInBefore",
        "startInAfter",
        "length",
        "segment",
        "segment",
        "length",
        "startInBefore",
        "segment",
        "startInAfter",
        "segment",
        "startInBefore",
        "startInAfter",
        "html",
        "i",
        "html",
        "i",
        "html",
        "i",
        "mode",
        "isStartOfAtomicTag",
        "currentWord",
        "atomicTag",
        "mode",
        "currentAtomicTag",
        "atomicTag",
        "currentWord",
        "isStartofHTMLComment",
        "currentWord",
        "mode",
        "currentWord",
        "isEndOfTag",
        "currentWord",
        "words",
        "createToken",
        "currentWord",
        "currentWord",
        "isWhitespace",
        "mode",
        "mode",
        "currentWord",
        "isEndOfTag",
        "isEndOfAtomicTag",
        "currentWord",
        "currentAtomicTag",
        "currentWord",
        "words",
        "createToken",
        "currentWord",
        "currentWord",
        "currentAtomicTag",
        "mode",
        "currentWord",
        "currentWord",
        "isEndOfHTMLComment",
        "currentWord",
        "currentWord",
        "mode",
        "isStartOfTag",
        "currentWord",
        "words",
        "createToken",
        "currentWord",
        "currentWord",
        "mode",
        "currentWord",
        "words",
        "createToken",
        "currentWord",
        "currentWord",
        "mode",
        "currentWord",
        "currentWord",
        "words",
        "createToken",
        "currentWord",
        "currentWord",
        "currentWord",
        "words",
        "createToken",
        "currentWord",
        "currentWord",
        "isStartOfTag",
        "currentWord",
        "words",
        "createToken",
        "currentWord",
        "currentWord",
        "mode",
        "isWhitespace",
        "currentWord",
        "currentWord",
        "words",
        "createToken",
        "currentWord",
        "currentWord",
        "mode",
        "mode",
        "currentWord",
        "words",
        "createToken",
        "currentWord",
        "words",
        "token",
        "token",
        "img",
        "img",
        "token",
        "token",
        "token",
        "uuid",
        "token",
        "uuid",
        "token",
        "uuid",
        "start",
        "end",
        "token",
        "token",
        "iframe",
        "iframe",
        "token",
        "tagName",
        "tagName",
        "token",
        "token",
        "token",
        "tokens",
        "tokens",
        "token",
        "index",
        "token",
        "token",
        "index",
        "token",
        "index",
        "m1",
        "m2",
        "m2",
        "m1",
        "m2",
        "m1",
        "m2",
        "m1",
        "m2",
        "m1",
        "MatchBinarySearchTree",
        "value",
        "value",
        "current",
        "compareMatches",
        "current",
        "value",
        "position",
        "current",
        "current",
        "current",
        "current",
        "node",
        "position",
        "current",
        "current",
        "current",
        "current",
        "node",
        "node",
        "node",
        "nodes",
        "node",
        "inOrder",
        "node",
        "nodes",
        "nodes",
        "node",
        "inOrder",
        "node",
        "nodes",
        "nodes",
        "inOrder",
        "segment",
        "segment",
        "segment",
        "beforeIndex",
        "beforeTokens",
        "beforeIndex",
        "beforeTokens",
        "beforeIndex",
        "bestMatch",
        "remainingTokens",
        "bestMatch",
        "beforeTokens",
        "beforeIndex",
        "beforeToken",
        "lastSpace",
        "beforeIndex",
        "lastSpace",
        "beforeIndex",
        "lookBehind",
        "afterMap",
        "beforeToken",
        "afterTokenLocations",
        "afterTokenLocations",
        "afterIndex",
        "bestMatch",
        "bestMatch",
        "getFullMatch",
        "segment",
        "beforeIndex",
        "afterIndex",
        "bestMatchLength",
        "lookBehind",
        "match",
        "match",
        "bestMatchLength",
        "bestMatch",
        "match",
        "bestMatch",
        "segment",
        "beforeStart",
        "afterStart",
        "minLength",
        "lookBehind",
        "segment",
        "segment",
        "beforeStart",
        "minLength",
        "afterStart",
        "minLength",
        "minBeforeIndex",
        "beforeTokens",
        "minAfterIndex",
        "afterTokens",
        "minLength",
        "beforeTokens",
        "minBeforeIndex",
        "afterTokens",
        "minAfterIndex",
        "nextBeforeWord",
        "nextAfterWord",
        "beforeStart",
        "currentLength",
        "afterStart",
        "currentLength",
        "searching",
        "beforeIndex",
        "beforeTokens",
        "afterIndex",
        "afterTokens",
        "beforeTokens",
        "beforeIndex",
        "afterTokens",
        "afterIndex",
        "beforeWord",
        "afterWord",
        "currentLength",
        "beforeIndex",
        "beforeStart",
        "currentLength",
        "afterIndex",
        "afterStart",
        "currentLength",
        "searching",
        "lookBehind",
        "beforeStart",
        "afterStart",
        "beforeTokens",
        "beforeStart",
        "afterTokens",
        "afterStart",
        "prevBeforeKey",
        "prevAfterKey",
        "beforeStart",
        "afterStart",
        "currentLength",
        "Match",
        "beforeStart",
        "afterStart",
        "currentLength",
        "segment",
        "beforeTokens",
        "afterTokens",
        "beforeIndex",
        "afterIndex",
        "beforeTokens",
        "afterTokens",
        "createMap",
        "beforeTokens",
        "createMap",
        "afterTokens",
        "beforeIndex",
        "afterIndex",
        "segment",
        "MatchBinarySearchTree",
        "segment",
        "segments",
        "segment",
        "segments",
        "match",
        "findBestMatch",
        "segment",
        "match",
        "match",
        "match",
        "match",
        "segment",
        "match",
        "segment",
        "match",
        "segments",
        "createSegment",
        "leftBeforeTokens",
        "leftAfterTokens",
        "segment",
        "segment",
        "segment",
        "match",
        "segment",
        "match",
        "segment",
        "match",
        "segment",
        "match",
        "rightBeforeTokens",
        "rightAfterTokens",
        "segments",
        "createSegment",
        "rightBeforeTokens",
        "rightAfterTokens",
        "rightBeforeIndex",
        "rightAfterIndex",
        "matches",
        "match",
        "matches",
        "beforeTokens",
        "afterTokens",
        "beforeTokens",
        "afterTokens",
        "createSegment",
        "beforeTokens",
        "afterTokens",
        "findMatchingBlocks",
        "segment",
        "matches",
        "Match",
        "beforeTokens",
        "afterTokens",
        "segment",
        "index",
        "matches",
        "index",
        "matches",
        "index",
        "positionInBefore",
        "match",
        "positionInAfter",
        "match",
        "actionUpToMatchPositions",
        "actionUpToMatchPositions",
        "positionInAfter",
        "match",
        "actionUpToMatchPositions",
        "actionUpToMatchPositions",
        "operations",
        "actionUpToMatchPositions",
        "positionInBefore",
        "actionUpToMatchPositions",
        "match",
        "positionInAfter",
        "actionUpToMatchPositions",
        "match",
        "match",
        "operations",
        "match",
        "match",
        "match",
        "match",
        "positionInBefore",
        "match",
        "positionInAfter",
        "match",
        "op",
        "op",
        "op",
        "op",
        "beforeTokens",
        "op",
        "op",
        "i",
        "operations",
        "i",
        "operations",
        "i",
        "isSingleWhitespace",
        "op",
        "lastOp",
        "op",
        "lastOp",
        "lastOp",
        "op",
        "lastOp",
        "op",
        "postProcessed",
        "op",
        "lastOp",
        "op",
        "postProcessed",
        "tokens",
        "tokens",
        "tokens",
        "data",
        "token",
        "index",
        "data",
        "isWrappable",
        "token",
        "isVoidTag",
        "token",
        "isTag",
        "token",
        "data",
        "data",
        "tag",
        "lastEntry",
        "lastEntry",
        "tag",
        "data",
        "lastEntry",
        "data",
        "data",
        "tag",
        "index",
        "data",
        "TokenWrapper",
        "mapFn",
        "tagFn",
        "tokens",
        "data",
        "token",
        "index",
        "notes",
        "index",
        "tokens",
        "index",
        "tagFn",
        "tokens",
        "index",
        "data",
        "data",
        "notes",
        "index",
        "notes",
        "index",
        "status",
        "data",
        "data",
        "data",
        "tokens",
        "data",
        "index",
        "data",
        "index",
        "data",
        "status",
        "index",
        "tokens",
        "data",
        "data",
        "tokens",
        "data",
        "index",
        "data",
        "segments",
        "mapFn",
        "tag",
        "content",
        "opIndex",
        "dataPrefix",
        "className",
        "TokenWrapper",
        "content",
        "dataPrefix",
        "dataPrefix",
        "dataPrefix",
        "dataPrefix",
        "opIndex",
        "className",
        "attrs",
        "className",
        "wrapper",
        "segment",
        "segment",
        "segment",
        "val",
        "tag",
        "attrs",
        "val",
        "tag",
        "segment",
        "openingTag",
        "tag",
        "dataAttrs",
        "dataPrefix",
        "opIndex",
        "openingTag",
        "dataAttrs",
        "op",
        "beforeTokens",
        "afterTokens",
        "opIndex",
        "dataPrefix",
        "className",
        "afterTokens",
        "op",
        "op",
        "tokens",
        "prev",
        "curr",
        "prev",
        "curr",
        "op",
        "beforeTokens",
        "afterTokens",
        "opIndex",
        "dataPrefix",
        "className",
        "afterTokens",
        "op",
        "op",
        "tokens",
        "token",
        "token",
        "wrap",
        "val",
        "opIndex",
        "dataPrefix",
        "className",
        "op",
        "beforeTokens",
        "afterTokens",
        "opIndex",
        "dataPrefix",
        "className",
        "beforeTokens",
        "op",
        "op",
        "tokens",
        "token",
        "token",
        "wrap",
        "val",
        "opIndex",
        "dataPrefix",
        "className",
        "OPS",
        "arguments",
        "OPS",
        "arguments",
        "beforeTokens",
        "afterTokens",
        "operations",
        "dataPrefix",
        "className",
        "operations",
        "rendering",
        "op",
        "index",
        "rendering",
        "OPS",
        "op",
        "op",
        "beforeTokens",
        "afterTokens",
        "index",
        "dataPrefix",
        "className",
        "before",
        "after",
        "className",
        "dataPrefix",
        "atomicTags",
        "before",
        "after",
        "before",
        "atomicTags",
        "atomicTagsRegExp",
        "atomicTags",
        "atomicTagsRegExp",
        "defaultAtomicTagsRegExp",
        "before",
        "htmlToTokens",
        "before",
        "after",
        "htmlToTokens",
        "after",
        "calculateOperations",
        "before",
        "after",
        "renderOperations",
        "before",
        "after",
        "ops",
        "dataPrefix",
        "className",
        "diff",
        "htmlToTokens",
        "diff",
        "findMatchingBlocks",
        "findMatchingBlocks",
        "findBestMatch",
        "findMatchingBlocks",
        "createMap",
        "findMatchingBlocks",
        "createToken",
        "findMatchingBlocks",
        "createSegment",
        "findMatchingBlocks",
        "getKeyForToken",
        "diff",
        "calculateOperations",
        "diff",
        "renderOperations"
    ],
    "literals": [
        "'>'",
        "'<'",
        "' '",
        "'^<(iframe|object|math|svg|script|video|head|style)'",
        "'</'",
        "'char'",
        "''",
        "''",
        "'tag'",
        "'atomic_tag'",
        "'html_comment'",
        "'>'",
        "''",
        "'whitespace'",
        "'char'",
        "'atomic_tag'",
        "'>'",
        "''",
        "''",
        "'char'",
        "'html_comment'",
        "''",
        "'char'",
        "'char'",
        "'<'",
        "'tag'",
        "'whitespace'",
        "''",
        "'whitespace'",
        "'<'",
        "'tag'",
        "'char'",
        "'Unknown mode '",
        "'<img src=\"'",
        "'\">'",
        "'<object src=\"'",
        "'\"></object>'",
        "'data-uuid=\"'",
        "'<iframe src=\"'",
        "'\"></iframe>'",
        "'<'",
        "'>'",
        "' '",
        "' '",
        "' '",
        "' '",
        "'Missing beforeTokens'",
        "'Missing afterTokens'",
        "'none'",
        "'insert'",
        "'delete'",
        "'replace'",
        "'none'",
        "'insert'",
        "'delete'",
        "'equal'",
        "'none'",
        "'equal'",
        "'replace'",
        "'replace'",
        "'replace'",
        "'/'",
        "''",
        "'-'",
        "''",
        "' data-'",
        "'operation-index=\"'",
        "'\"'",
        "' class=\"'",
        "'\"'",
        "''",
        "'<'",
        "'>'",
        "'</'",
        "'>'",
        "''",
        "''",
        "' data-diff-node=\"'",
        "'\"'",
        "' data-'",
        "'operation-index=\"'",
        "'\"'",
        "'$&'",
        "'equal'",
        "''",
        "'insert'",
        "'ins'",
        "'delete'",
        "'del'",
        "'replace'",
        "'delete'",
        "'insert'",
        "''",
        "'^<('",
        "''",
        "'|'",
        "')'"
    ],
    "variables": [
        "match",
        "atomicTagsRegExp",
        "defaultAtomicTagsRegExp",
        "result",
        "is_img",
        "mode",
        "currentWord",
        "currentAtomicTag",
        "words",
        "i",
        "atomicTag",
        "img",
        "uuid",
        "start",
        "end",
        "iframe",
        "tagName",
        "node",
        "current",
        "position",
        "beforeTokens",
        "afterMap",
        "lastSpace",
        "bestMatch",
        "beforeIndex",
        "lookBehind",
        "remainingTokens",
        "beforeToken",
        "afterTokenLocations",
        "bestMatchLength",
        "match",
        "beforeTokens",
        "afterTokens",
        "minBeforeIndex",
        "minAfterIndex",
        "nextBeforeWord",
        "nextAfterWord",
        "searching",
        "currentLength",
        "beforeIndex",
        "afterIndex",
        "beforeWord",
        "afterWord",
        "prevBeforeKey",
        "prevAfterKey",
        "matches",
        "match",
        "segments",
        "leftBeforeTokens",
        "leftAfterTokens",
        "rightBeforeTokens",
        "rightAfterTokens",
        "rightBeforeIndex",
        "rightAfterIndex",
        "positionInBefore",
        "positionInAfter",
        "operations",
        "segment",
        "matches",
        "index",
        "match",
        "actionUpToMatchPositions",
        "postProcessed",
        "lastOp",
        "i",
        "op",
        "tag",
        "lastEntry",
        "notes",
        "tokens",
        "segments",
        "status",
        "wrapper",
        "attrs",
        "val",
        "dataAttrs",
        "OPS",
        "tokens",
        "tokens",
        "val",
        "tokens",
        "val",
        "ops"
    ],
    "comments": [
        "Added head and style (for style tags inside the body)",
        "If the token is an image element, grab it's src attribute to include in the key.",
        "If the token is an object element, grab it's data attribute to include in the key.",
        "If it's a video, math or svg element, the entire token should be compared except the",
        "data-uuid.",
        "If the token is an iframe element, grab it's src attribute to include in it's key.",
        "If the token is any other element, just grab the tag name.",
        "Otherwise, the token is text, collapse the whitespace.",
        "Create the node to hold the match value.",
        "eslint-disable-next-line no-constant-condition",
        "Determine if the match value should go to the left or right of the current",
        "node.",
        "The position of the match is to the left of this node.",
        "The position of the match is to the right of this node.",
        "If 0 was returned from compareMatches, that means the node cannot",
        "be inserted because it overlaps an existing node.",
        "If no nodes exist in the tree, make this the root node.",
        "Iterate through the entirety of the beforeTokens to find the best match.",
        "If the current best match is longer than the remaining tokens, we can bail because we",
        "won't find a better match.",
        "If the current token is whitespace, make a note of it and move on. Trying to start a",
        "set of matches with whitespace is not efficient because it's too prevelant in most",
        "documents. Instead, if the next token yields a match, we'll see if the whitespace can",
        "be included in that match.",
        "Check to see if we just skipped a space, if so, we'll ask getFullMatch to look behind",
        "by one token to see if it can include the whitespace.",
        "If the current token is not found in the afterTokens, it won't match and we can move",
        "on.",
        "For each instance of the current token in afterTokens, let's see how big of a match",
        "we can build.",
        "getFullMatch will see how far the current token match will go in both",
        "beforeTokens and afterTokens.",
        "If we got a new best match, we'll save it aside.",
        "If we already have a match that goes to the end of the document, no need to keep looking.",
        "If a minLength was provided, we can do a quick check to see if the tokens after that",
        "length match. If not, we won't be beating the previous best match, and we can bail out",
        "early.",
        "Extend the current match as far foward as it can go, without overflowing beforeTokens or",
        "afterTokens.",
        "If we've been asked to look behind, it's because both beforeTokens and afterTokens may",
        "have a whitespace token just behind the current match that was previously ignored. If so,",
        "we'll expand the current match to include it.",
        "Create a binary search tree to hold the matches we find in order.",
        "Each time the best match is found in a segment, zero, one or two new segments may be",
        "created from the parts of the original segment not included in the match. We will",
        "continue to iterate until all segments have been processed.",
        "If there's an unmatched area at the start of the segment, create a new segment",
        "from that area and throw it into the segments array to get processed.",
        "If there's an unmatched area at the end of the segment, create a new segment from that",
        "area and throw it into the segments array to get processed.",
        "Enable user provided atomic tag list."
    ],
    "docstrings": [
        "* node-htmldiff: Vendored and modified from https://github.com/idesis-gmbh/htmldiff.js\n * See packages/lesswrong/lib/vendor/node-htmldiff/LICENSE\n *\n * htmldiff.js is a library that compares HTML content. It creates a diff between two\n * HTML documents by combining the two documents and wrapping the differences with\n * <ins> and <del> tags. Here is a high-level overview of how the diff works.\n *\n * 1. Tokenize the before and after HTML with htmlToTokens.\n * 2. Generate a list of operations that convert the before list of tokens to the after\n *    list of tokens with calculateOperations, which does the following:\n *      a. Find all the matching blocks of tokens between the before and after lists of\n *         tokens with findMatchingBlocks. This is done by finding the single longest\n *         matching block with findMatch, then iteratively finding the next longest\n *         matching blocks that precede and follow the longest matching block.\n *      b. Determine insertions, deletions, and replacements from the matching blocks.\n *         This is done in calculateOperations.\n * 3. Render the list of operations by wrapping tokens with <ins> and <del> tags where\n *    appropriate with renderOperations.\n *\n * Example usage:\n *\n *   var htmldiff = require('htmldiff.js');\n *\n *   htmldiff('<p>this is some text</p>', '<p>this is some more text</p>')\n *   == '<p>this is some <ins>more </ins>text</p>'\n *\n *   htmldiff('<p>this is some text</p>', '<p>this is some more text</p>', 'diff-class')\n *   == '<p>this is some <ins class=\"diff-class\">more </ins>text</p>'",
        "* Determines if the given token is a tag.\n *\n * @param {string} token The token in question.\n *\n * @return {boolean|string} False if the token is not a tag, or the tag name otherwise.",
        "* Regular expression to check atomic tags.\n * @see function diff.",
        "* Checks if the current word is the beginning of an atomic tag. An atomic tag is one whose\n * child nodes should not be compared - the entire tag should be treated as one token. This\n * is useful for tags where it does not make sense to insert <ins> and <del> tags.\n *\n * @param {string} word The characters of the current token read so far.\n *\n * @return {string|null} The name of the atomic tag if the word will be an atomic tag,\n *    null otherwise",
        "* Checks if the current word is the end of an atomic tag (i.e. it has all the characters,\n * except for the end bracket of the closing tag, such as '<iframe></iframe').\n *\n * @param {string} word The characters of the current token read so far.\n * @param {string} tag The ending tag to look for.\n *\n * @return {boolean} True if the word is now a complete token (including the end tag),\n *    false otherwise.",
        "* Checks if a tag is a void tag.\n *\n * @param {string} token The token to check.\n *\n * @return {boolean} True if the token is a void tag, false otherwise.",
        "* Checks if a token can be wrapped inside a tag.\n *\n * @param {string} token The token to check.\n *\n * @return {boolean} True if the token can be wrapped inside a tag, false otherwise.",
        "* Creates a token that holds a string and key representation. The key is used for diffing\n * comparisons and the string is used to recompose the document after the diff is complete.\n *\n * @param {string} currentWord The section of the document to create a token for.\n *\n * @return {Object} A token object with a string and key property.",
        "* A Match stores the information of a matching block. A matching block is a list of\n * consecutive tokens that appear in both the before and after lists of tokens.\n *\n * @param {number} startInBefore The index of the first token in the list of before tokens.\n * @param {number} startInAfter The index of the first token in the list of after tokens.\n * @param {number} length The number of consecutive matching tokens in this block.\n * @param {Segment} segment The segment where the match was found.",
        "* Tokenizes a string of HTML.\n *\n * @param {string} html The string to tokenize.\n *\n * @return {Array.<string>} The list of tokens.",
        "* Creates a key that should be used to match tokens. This is useful, for example, if we want\n * to consider two open tag tokens as equal, even if they don't have the same attributes. We\n * use a key instead of overwriting the token because we may want to render the original string\n * without losing the attributes.\n *\n * @param {string} token The token to create the key for.\n *\n * @return {string} The identifying key that should be used to match before and after tokens.",
        "* Creates a map from token key to an array of indices of locations of the matching token in\n * the list of all tokens.\n *\n * @param {Array.<string>} tokens The list of tokens to be mapped.\n *\n * @return {Object} A mapping that can be used to search for tokens.",
        "* Compares two match objects to determine if the second match object comes before or after the\n * first match object. Returns -1 if the m2 should come before m1. Returns 1 if m1 should come\n * before m2. If the two matches criss-cross each other, a null is returned.\n *\n * @param {Match} m1 The first match object to compare.\n * @param {Match} m2 The second match object to compare.\n *\n * @return {number} Returns -1 if the m2 should come before m1. Returns 1 if m1 should come\n *    before m2. If the two matches criss-cross each other, 0 is returned.",
        "* A constructor for a binary search tree used to keep match objects in the proper order as\n * they're found.\n *\n * @constructor",
        "* Adds matches to the binary search tree.\n     *\n     * @param {Match} value The match to add to the binary search tree.",
        "* Converts the binary search tree into an array using an in-order traversal.\n     *\n     * @return {Array.<Match>} An array containing the matches in the binary search tree.",
        "* Finds and returns the best match between the before and after arrays contained in the segment\n * provided.\n *\n * @param {Segment} segment The segment in which to look for a match.\n *\n * @return {Match} The best match.",
        "* Takes the start of a match, and expands it in the beforeTokens and afterTokens of the\n * current segment as far as it can go.\n *\n * @param {Segment} segment The segment object to search within when expanding the match.\n * @param {number} beforeStart The offset within beforeTokens to start looking.\n * @param {number} afterStart The offset within afterTokens to start looking.\n * @param {number} minLength The minimum length match that must be found.\n * @param {boolean} lookBehind If true, attempt to match a whitespace token just before the\n *    beforeStart and afterStart tokens.\n *\n * @return {Match} The full match.",
        "* Creates segment objects from the original document that can be used to restrict the area that\n * findBestMatch and it's helper functions search to increase performance.\n *\n * @param {Array.<Token>} beforeTokens Tokens from the before document.\n * @param {Array.<Token>} afterTokens Tokens from the after document.\n * @param {number} beforeIndex The index within the before document where this segment begins.\n * @param {number} afterIndex The index within the after document where this segment behinds.\n *\n * @return {Segment} The segment object.",
        "* Finds all the matching blocks within the given segment in the before and after lists of\n * tokens.\n *\n * @param {Segment} The segment that should be searched for matching blocks.\n *\n * @return {Array.<Match>} The list of matching blocks in this range.",
        "* Gets a list of operations required to transform the before list of tokens into the\n * after list of tokens. An operation describes whether a particular list of consecutive\n * tokens are equal, replaced, inserted, or deleted.\n *\n * @param {Array.<string>} beforeTokens The before list of tokens.\n * @param {Array.<string>} afterTokens The after list of tokens.\n *\n * @return {Array.<Object>} The list of operations to transform the before list of\n *      tokens into the after list of tokens, where each operation has the following\n *      keys:\n *      - {string} action One of {'replace', 'insert', 'delete', 'equal'}.\n *      - {number} startInBefore The beginning of the range in the list of before tokens.\n *      - {number} endInBefore The end of the range in the list of before tokens.\n *      - {number} startInAfter The beginning of the range in the list of after tokens.\n *      - {number} endInAfter The end of the range in the list of after tokens.",
        "* A TokenWrapper provides a utility for grouping segments of tokens based on whether they're\n * wrappable or not. A tag is considered wrappable if it is closed within the given set of\n * tokens. For example, given the following tokens:\n *\n *      ['</b>', 'this', ' ', 'is', ' ', 'a', ' ', '<b>', 'test', '</b>', '!']\n *\n * The first '</b>' is not considered wrappable since the tag is not fully contained within the\n * array of tokens. The '<b>', 'test', and '</b>' would be a part of the same wrappable segment\n * since the entire bold tag is within the set of tokens.\n *\n * TokenWrapper has a method 'combine' which allows walking over the segments to wrap them in\n * tags.",
        "* Wraps the contained tokens in tags based on output given by a map function. Each segment of\n * tokens will be visited. A segment is a continuous run of either all wrappable\n * tokens or unwrappable tokens. The given map function will be called with each segment of\n * tokens and the resulting strings will be combined to form the wrapped HTML.\n *\n * @param {function(boolean, Array.<string>)} mapFn A function called with an array of tokens\n *      and whether those tokens are wrappable or not. The result should be a string.",
        "* Wraps and concatenates a list of tokens with a tag. Does not wrap tag tokens,\n * unless they are wrappable (i.e. void and atomic tags).\n *\n * @param {sting} tag The tag name of the wrapper tags.\n * @param {Array.<string>} content The list of tokens to wrap.\n * @param {string} dataPrefix (Optional) The prefix to use in data attributes.\n * @param {string} className (Optional) The class name to include in the wrapper tag.",
        "* OPS.equal/insert/delete/replace are functions that render an operation into\n * HTML content.\n *\n * @param {Object} op The operation that applies to a prticular list of tokens. Has the\n *      following keys:\n *      - {string} action One of ['replace', 'insert', 'delete', 'equal'].\n *      - {number} startInBefore The beginning of the range in the list of before tokens.\n *      - {number} endInBefore The end of the range in the list of before tokens.\n *      - {number} startInAfter The beginning of the range in the list of after tokens.\n *      - {number} endInAfter The end of the range in the list of after tokens.\n * @param {Array.<string>} beforeTokens The before list of tokens.\n * @param {Array.<string>} afterTokens The after list of tokens.\n * @param {number} opIndex The index into the list of operations that identifies the change to\n *      be rendered. This is used to mark wrapped HTML as part of the same operation.\n * @param {string} dataPrefix (Optional) The prefix to use in data attributes.\n * @param {string} className (Optional) The class name to include in the wrapper tag.\n *\n * @return {string} The rendering of that operation.",
        "* Renders a list of operations into HTML content. The result is the combined version\n * of the before and after tokens with the differences wrapped in tags.\n *\n * @param {Array.<string>} beforeTokens The before list of tokens.\n * @param {Array.<string>} afterTokens The after list of tokens.\n * @param {Array.<Object>} operations The list of operations to transform the before\n *      list of tokens into the after list of tokens, where each operation has the\n *      following keys:\n *      - {string} action One of {'replace', 'insert', 'delete', 'equal'}.\n *      - {number} startInBefore The beginning of the range in the list of before tokens.\n *      - {number} endInBefore The end of the range in the list of before tokens.\n *      - {number} startInAfter The beginning of the range in the list of after tokens.\n *      - {number} endInAfter The end of the range in the list of after tokens.\n * @param {string} dataPrefix (Optional) The prefix to use in data attributes.\n * @param {string} className (Optional) The class name to include in the wrapper tag.\n *\n * @return {string} The rendering of the list of operations.",
        "* Compares two pieces of HTML content and returns the combined content with differences\n * wrapped in <ins> and <del> tags.\n *\n * @param {string} before The HTML content before the changes.\n * @param {string} after The HTML content after the changes.\n * @param {string} className (Optional) The class attribute to include in <ins> and <del> tags.\n * @param {string} dataPrefix (Optional) The data prefix to use for data attributes. The\n *      operation index data attribute will be named `data-${dataPrefix-}operation-index`.\n * @param {string} atomicTags (Optional) Comma separated list of atomic tag names. The \n *     list has to be in the form `tag1,tag2,...` e. g. `head,script,style`. If not used, \n *     the default list `iframe,object,math,svg,script,video,head,style` will be used.\n *\n * @return {string} The combined HTML content with differences wrapped in <ins> and <del> tags."
    ],
    "functions": [
        "isEndOfTag",
        "isStartOfTag",
        "isWhitespace",
        "isTag",
        "isntTag",
        "isStartofHTMLComment",
        "isEndOfHTMLComment",
        "isStartOfAtomicTag",
        "isEndOfAtomicTag",
        "isVoidTag",
        "isWrappable",
        "createToken",
        "Match",
        "htmlToTokens",
        "getKeyForToken",
        "createMap",
        "compareMatches",
        "MatchBinarySearchTree",
        "inOrder",
        "findBestMatch",
        "getFullMatch",
        "createSegment",
        "findMatchingBlocks",
        "calculateOperations",
        "isSingleWhitespace",
        "TokenWrapper",
        "wrap",
        "renderOperations",
        "diff"
    ],
    "classes": []
}