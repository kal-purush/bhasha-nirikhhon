{
    "identifiers": [],
    "literals": [],
    "variables": [],
    "comments": [
        "coding:utf-8"
    ],
    "docstrings": [
        "'''\n第一种方式：使用os模块中的fork方式实现多进程\n\nimport os\nif __name__ == '__main__':\n    print 'current Process (%s) start ...'%(os.getpid())\n    pid = os.fork()\n    if pid < 0:\n        print 'error in fork'\n    elif pid == 0:\n        print 'I am child process(%s) and my parent process is (%s)',(os.getpid(),os.getppid())\n    else:\n        print 'I(%s) created a chlid process (%s).',(os.getpid(),pid)\n'''",
        "'''\n第二种方法：使用multiprocessing模块创建多进程\nimport os\nfrom multiprocessing import Process\n# 子进程要执行的代码\ndef run_proc(name):\n    print 'Child process %s (%s) Running...' % (name, os.getpid())\nif __name__ == '__main__':\n    print 'Parent process %s.' % os.getpid()\n    for i in range(5):\n        p = Process(target=run_proc, args=(str(i),))\n        print 'Process will start.'\n        p.start()\n    p.join()\n    print 'Process end.'\n\n'''",
        "'''\nmultiprocessing模块提供了一个Pool类来代表进程池对象\n\nfrom multiprocessing import Pool\nimport os, time, random\n\ndef run_task(name):\n    print 'Task %s (pid = %s) is running...' % (name, os.getpid())\n    time.sleep(random.random() * 3)\n    print 'Task %s end.' % name\n\nif __name__=='__main__':\n    print 'Current process %s.' % os.getpid()\n    p = Pool(processes=3)\n    for i in range(5):\n        p.apply_async(run_task, args=(i,))\n    print 'Waiting for all subprocesses done...'\n    p.close()\n    p.join()\n    print 'All subprocesses done.'\n\n'''",
        "'''\nQueue进程间通信\n\nfrom multiprocessing import Process, Queue\nimport os, time, random\n\n# 写数据进程执行的代码:\ndef proc_write(q,urls):\n    print('Process(%s) is writing...' % os.getpid())\n    for url in urls:\n        q.put(url)\n        print('Put %s to queue...' % url)\n        time.sleep(random.random())\n\n# 读数据进程执行的代码:\ndef proc_read(q):\n    print('Process(%s) is reading...' % os.getpid())\n    while True:\n\n        url = q.get(True)\n        print('Get %s from queue.' % url)\n\nif __name__=='__main__':\n    # 父进程创建Queue，并传给各个子进程：\n    q = Queue()\n    proc_writer1 = Process(target=proc_write, args=(q,['url_1', 'url_2', 'url_3']))\n    proc_writer2 = Process(target=proc_write, args=(q,['url_4','url_5','url_6']))\n    proc_reader = Process(target=proc_read, args=(q,))\n    # 启动子进程proc_writer，写入:\n    proc_writer1.start()\n    proc_writer2.start()\n    # 启动子进程proc_reader，读取:\n    proc_reader.start()\n    # 等待proc_writer结束:\n    proc_writer1.join()\n    proc_writer2.join()\n    # proc_reader进程里是死循环，无法等待其结束，只能强行终止:\n    proc_reader.terminate()\n'''",
        "'''\npipe进程间通信\n\nimport multiprocessing\nimport random\nimport time,os\n\ndef proc_send(pipe,urls):\n    for url in urls:\n        print \"Process(%s) send: %s\" %(os.getpid(),url)\n        pipe.send(url)\n        time.sleep(random.random())\n\ndef proc_recv(pipe):\n    while True:\n        print \"Process(%s) rev:%s\" %(os.getpid(),pipe.recv())\n        time.sleep(random.random())\n\n'''"
    ],
    "functions": [],
    "classes": []
}