{
    "identifiers": [
        "IterPlus",
        "SyncIterPlus",
        "PromiseOrValue",
        "CircularBuffer",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "obj",
        "nullVal",
        "Null",
        "iter",
        "iter",
        "elem",
        "nullVal",
        "elem",
        "ret",
        "AsyncIterPlus",
        "ret",
        "func",
        "ret",
        "func",
        "val",
        "nullVal",
        "val",
        "AsyncIterPlus",
        "ret",
        "func",
        "ret",
        "func",
        "AsyncIterPlus",
        "ret",
        "val",
        "ret",
        "val",
        "AsyncIterPlus",
        "ret",
        "func",
        "ret",
        "func",
        "AsyncIterPlus",
        "ret",
        "val",
        "ret",
        "val",
        "AsyncIterPlus",
        "ret",
        "first",
        "func",
        "prev",
        "ret",
        "first",
        "nullVal",
        "first",
        "first",
        "func",
        "first",
        "AsyncIterPlus",
        "ret",
        "data",
        "ret",
        "item",
        "data",
        "item",
        "cache",
        "item",
        "cache",
        "AsyncIterPlus",
        "ret",
        "data",
        "count",
        "data",
        "ret",
        "count",
        "data",
        "count",
        "i",
        "count",
        "i",
        "indices",
        "i",
        "indices",
        "v",
        "data",
        "v",
        "i",
        "i",
        "indices",
        "i",
        "indices",
        "indices",
        "i",
        "data",
        "i",
        "indices",
        "indices",
        "i",
        "i",
        "indices",
        "i",
        "i",
        "indices",
        "indices",
        "i",
        "indices",
        "indices",
        "i",
        "i",
        "AsyncIterPlus",
        "ret",
        "data",
        "count",
        "data",
        "ret",
        "data",
        "count",
        "i",
        "count",
        "i",
        "indices",
        "indices",
        "v",
        "data",
        "v",
        "i",
        "i",
        "indices",
        "i",
        "indices",
        "indices",
        "i",
        "data",
        "indices",
        "indices",
        "i",
        "i",
        "indices",
        "i",
        "i",
        "indices",
        "indices",
        "i",
        "indices",
        "indices",
        "i",
        "i",
        "AsyncIterPlus",
        "ret",
        "data",
        "count",
        "data",
        "ret",
        "count",
        "data",
        "count",
        "count",
        "i",
        "data",
        "i",
        "indices",
        "i",
        "data",
        "i",
        "data",
        "count",
        "i",
        "cycles",
        "i",
        "indices",
        "count",
        "v",
        "data",
        "v",
        "i",
        "count",
        "i",
        "i",
        "cycles",
        "i",
        "cycles",
        "i",
        "indices",
        "i",
        "j",
        "indices",
        "j",
        "indices",
        "j",
        "indices",
        "j",
        "indices",
        "indices",
        "first",
        "cycles",
        "i",
        "data",
        "i",
        "indices",
        "i",
        "indices",
        "i",
        "indices",
        "indices",
        "cycles",
        "i",
        "indices",
        "indices",
        "cycles",
        "i",
        "temp",
        "indices",
        "count",
        "v",
        "data",
        "v",
        "i",
        "AsyncIterPlus",
        "ret",
        "data",
        "count",
        "data",
        "ret",
        "data",
        "count",
        "count",
        "i",
        "count",
        "i",
        "indices",
        "indices",
        "v",
        "data",
        "v",
        "i",
        "i",
        "indices",
        "i",
        "indices",
        "indices",
        "i",
        "data",
        "indices",
        "indices",
        "i",
        "i",
        "indices",
        "i",
        "i",
        "indices",
        "indices",
        "i",
        "i",
        "AsyncIterPlus",
        "ret",
        "data",
        "ret",
        "i",
        "data",
        "i",
        "AsyncIterPlus",
        "data",
        "i",
        "AsyncIterPlus",
        "ret",
        "data",
        "ret",
        "data",
        "i",
        "data",
        "i",
        "data",
        "i",
        "indices",
        "indices",
        "v",
        "i",
        "data",
        "i",
        "v",
        "i",
        "i",
        "indices",
        "i",
        "indices",
        "data",
        "i",
        "data",
        "data",
        "i",
        "indices",
        "data",
        "i",
        "i",
        "indices",
        "i",
        "i",
        "indices",
        "data",
        "i",
        "i",
        "AsyncIterPlus",
        "ret",
        "pred",
        "elem",
        "elem",
        "pred",
        "elem",
        "pred",
        "elem",
        "elem",
        "pred",
        "elem",
        "iters",
        "ret",
        "iter",
        "that",
        "iters",
        "val",
        "iter",
        "val",
        "AsyncIterPlus",
        "ret",
        "other",
        "cmp",
        "first",
        "second",
        "other",
        "iter",
        "a",
        "b",
        "a",
        "b",
        "cmp",
        "a",
        "b",
        "diff",
        "diff",
        "other",
        "key",
        "elem",
        "other",
        "a",
        "b",
        "key",
        "a",
        "key",
        "b",
        "ak",
        "bk",
        "ak",
        "bk",
        "other",
        "other",
        "a",
        "b",
        "a",
        "b",
        "a",
        "b",
        "item",
        "ret",
        "item",
        "ret",
        "item",
        "ret",
        "ret",
        "ret",
        "item",
        "that",
        "count",
        "item",
        "count",
        "AsyncIterPlus",
        "ret",
        "other",
        "cmp",
        "first",
        "second",
        "other",
        "iter",
        "a",
        "b",
        "a",
        "b",
        "cmp",
        "a",
        "b",
        "eq",
        "other",
        "key",
        "elem",
        "other",
        "iter",
        "a",
        "b",
        "a",
        "b",
        "key",
        "a",
        "key",
        "b",
        "eq",
        "other",
        "other",
        "iter",
        "a",
        "b",
        "a",
        "b",
        "a",
        "b",
        "eq",
        "pred",
        "elem",
        "ret",
        "elem",
        "that",
        "pred",
        "elem",
        "elem",
        "AsyncIterPlus",
        "ret",
        "func",
        "elem",
        "ret",
        "elem",
        "that",
        "func",
        "elem",
        "val",
        "nullVal",
        "val",
        "AsyncIterPlus",
        "ret",
        "pred",
        "elem",
        "elem",
        "pred",
        "elem",
        "elem",
        "nullVal",
        "func",
        "elem",
        "elem",
        "func",
        "elem",
        "val",
        "nullVal",
        "val",
        "nullVal",
        "ret",
        "iterable",
        "that",
        "iterable",
        "AsyncIterPlus",
        "ret",
        "func",
        "elem",
        "ret",
        "elem",
        "that",
        "func",
        "elem",
        "AsyncIterPlus",
        "ret",
        "func",
        "args",
        "ret",
        "elem",
        "that",
        "func",
        "elem",
        "AsyncIterPlus",
        "ret",
        "func",
        "elem",
        "ret",
        "elem",
        "that",
        "func",
        "elem",
        "AsyncIterPlus",
        "ret",
        "func",
        "accum",
        "elem",
        "initializer",
        "func",
        "accum",
        "elem",
        "func",
        "accum",
        "elem",
        "initializer",
        "initializer",
        "next",
        "accum",
        "next",
        "accum",
        "initializer",
        "elem",
        "accum",
        "func",
        "accum",
        "elem",
        "accum",
        "func",
        "elem",
        "elem",
        "func",
        "elem",
        "ret",
        "elem",
        "that",
        "elem",
        "AsyncIterPlus",
        "ret",
        "func",
        "elem",
        "ret",
        "elem",
        "that",
        "func",
        "elem",
        "elem",
        "AsyncIterPlus",
        "ret",
        "pred",
        "elem",
        "elem",
        "pred",
        "elem",
        "seenFalse",
        "seenFalse",
        "cmp",
        "first",
        "second",
        "first",
        "first",
        "elem",
        "cmp",
        "prev",
        "elem",
        "prev",
        "elem",
        "key",
        "elem",
        "first",
        "key",
        "first",
        "elem",
        "key",
        "elem",
        "prev",
        "elKey",
        "prev",
        "elKey",
        "x",
        "x",
        "elem",
        "last",
        "elem",
        "last",
        "func",
        "elem",
        "ret",
        "elem",
        "that",
        "func",
        "elem",
        "val",
        "val",
        "AsyncIterPlus",
        "ret",
        "cmp",
        "first",
        "second",
        "overwrite",
        "next",
        "next",
        "elem",
        "cmp",
        "elem",
        "curMax",
        "diff",
        "overwrite",
        "diff",
        "curMax",
        "elem",
        "curMax",
        "key",
        "elem",
        "overwrite",
        "next",
        "next",
        "key",
        "curMax",
        "elem",
        "key",
        "elem",
        "elemKey",
        "curMaxKey",
        "overwrite",
        "elemKey",
        "curMaxKey",
        "curMax",
        "elem",
        "curMaxKey",
        "elemKey",
        "curMax",
        "overwrite",
        "x",
        "x",
        "overwrite",
        "cmp",
        "first",
        "second",
        "overwrite",
        "next",
        "next",
        "elem",
        "cmp",
        "elem",
        "curMax",
        "diff",
        "overwrite",
        "diff",
        "curMax",
        "elem",
        "curMax",
        "key",
        "elem",
        "overwrite",
        "next",
        "next",
        "key",
        "curMax",
        "elem",
        "key",
        "elem",
        "elemKey",
        "curMaxKey",
        "overwrite",
        "elemKey",
        "curMaxKey",
        "curMax",
        "elem",
        "curMaxKey",
        "elemKey",
        "curMax",
        "overwrite",
        "x",
        "x",
        "overwrite",
        "n",
        "n",
        "nullVal",
        "elem",
        "n",
        "elem",
        "n",
        "nullVal",
        "pred",
        "elem",
        "elem",
        "pred",
        "elem",
        "truePart",
        "elem",
        "falsePart",
        "elem",
        "truePart",
        "falsePart",
        "AsyncPeekable",
        "pred",
        "elem",
        "elem",
        "pred",
        "elem",
        "count",
        "count",
        "elem",
        "typechecked",
        "accum",
        "elem",
        "typechecked",
        "accum",
        "accum",
        "elem",
        "accum",
        "elem",
        "typechecked",
        "accum",
        "elem",
        "typechecked",
        "accum",
        "elem",
        "accum",
        "accum",
        "accum",
        "item",
        "collected",
        "item",
        "SyncIterPlus",
        "collected",
        "n",
        "ret",
        "i",
        "n",
        "i",
        "that",
        "val",
        "that",
        "AsyncIterPlus",
        "ret",
        "pred",
        "elem",
        "ret",
        "that",
        "val",
        "pred",
        "val",
        "val",
        "that",
        "AsyncIterPlus",
        "ret",
        "n",
        "ret",
        "i",
        "n",
        "i",
        "that",
        "val",
        "val",
        "AsyncIterPlus",
        "ret",
        "pred",
        "elem",
        "ret",
        "that",
        "val",
        "pred",
        "val",
        "val",
        "AsyncIterPlus",
        "ret",
        "elem",
        "elem",
        "ret",
        "ret",
        "i",
        "elem",
        "i",
        "ret",
        "i",
        "elem",
        "i",
        "ret",
        "func",
        "args",
        "iters",
        "ret",
        "that",
        "iters",
        "v",
        "v",
        "iter",
        "zippers",
        "iter",
        "val",
        "tot",
        "val",
        "func",
        "tot",
        "AsyncIterPlus",
        "ret",
        "iters",
        "ret",
        "that",
        "iters",
        "v",
        "v",
        "iter",
        "zippers",
        "iter",
        "val",
        "tot",
        "val",
        "tot",
        "AsyncIterPlus",
        "ret",
        "count",
        "count",
        "CircularBuffer",
        "ret",
        "index",
        "n",
        "init",
        "stored",
        "finished",
        "that",
        "elem",
        "finished",
        "stored",
        "elem",
        "elem",
        "stored",
        "n",
        "init",
        "indices",
        "minind",
        "init",
        "init",
        "stored",
        "n",
        "indices",
        "index",
        "n",
        "i",
        "count",
        "i",
        "indices",
        "tot",
        "AsyncIterPlus",
        "ret",
        "i",
        "tot",
        "elem",
        "typechecked",
        "elem",
        "bigint",
        "accum",
        "accum",
        "typechecked",
        "accum",
        "accum",
        "elem",
        "count",
        "bigint",
        "count",
        "count",
        "count",
        "RangeError",
        "accum",
        "count",
        "chunkSize",
        "ret",
        "i",
        "chunkSize",
        "i",
        "that",
        "val",
        "eles",
        "eles",
        "eles",
        "val",
        "eles",
        "AsyncIterPlus",
        "ret",
        "chunkSize",
        "ret",
        "i",
        "chunkSize",
        "i",
        "that",
        "val",
        "eles",
        "chunkSize",
        "eles",
        "eles",
        "val",
        "eles",
        "AsyncIterPlus",
        "ret",
        "n",
        "ret",
        "item",
        "that",
        "eles",
        "item",
        "eles",
        "i",
        "n",
        "i",
        "eles",
        "AsyncIterPlus",
        "ret",
        "amount",
        "amount",
        "RangeError",
        "ret",
        "i",
        "amount",
        "i",
        "that",
        "val",
        "eles",
        "amount",
        "eles",
        "eles",
        "amount",
        "eles",
        "amount",
        "eles",
        "val",
        "that",
        "eles",
        "AsyncIterPlus",
        "ret",
        "amount",
        "amount",
        "RangeError",
        "ret",
        "that",
        "val",
        "eles",
        "val",
        "eles",
        "amount",
        "eles",
        "eles",
        "amount",
        "eles",
        "amount",
        "AsyncIterPlus",
        "ret",
        "elem",
        "limit",
        "Infinity",
        "ret",
        "elem",
        "that",
        "val",
        "foundEle",
        "eles",
        "foundEle",
        "chunks",
        "limit",
        "val",
        "awaited",
        "eles",
        "eles",
        "chunks",
        "eles",
        "val",
        "AsyncIterPlus",
        "ret",
        "pred",
        "elem",
        "limit",
        "Infinity",
        "ret",
        "that",
        "val",
        "foundEle",
        "eles",
        "foundEle",
        "chunks",
        "limit",
        "pred",
        "val",
        "eles",
        "eles",
        "chunks",
        "eles",
        "val",
        "AsyncIterPlus",
        "ret",
        "elem",
        "limit",
        "Infinity",
        "ret",
        "elem",
        "that",
        "val",
        "foundEle",
        "eles",
        "eles",
        "foundEle",
        "eles",
        "val",
        "chunks",
        "limit",
        "val",
        "awaited",
        "eles",
        "eles",
        "chunks",
        "AsyncIterPlus",
        "ret",
        "pred",
        "elem",
        "limit",
        "Infinity",
        "ret",
        "that",
        "val",
        "foundEle",
        "eles",
        "eles",
        "foundEle",
        "eles",
        "val",
        "chunks",
        "limit",
        "pred",
        "val",
        "eles",
        "eles",
        "chunks",
        "AsyncIterPlus",
        "ret",
        "windowSize",
        "interval",
        "ret",
        "CircularBuffer",
        "i",
        "windowSize",
        "i",
        "that",
        "val",
        "eles",
        "val",
        "eles",
        "i",
        "interval",
        "i",
        "that",
        "val",
        "eles",
        "eles",
        "val",
        "AsyncIterPlus",
        "ret",
        "ret",
        "that",
        "val",
        "val",
        "val",
        "item",
        "that",
        "item",
        "prev",
        "item",
        "prev",
        "item",
        "AsyncIterPlus",
        "ret",
        "key",
        "elem",
        "ret",
        "that",
        "val",
        "val",
        "key",
        "val",
        "item",
        "that",
        "key",
        "item",
        "keyItem",
        "prev",
        "item",
        "prev",
        "keyItem",
        "AsyncIterPlus",
        "ret",
        "cmp",
        "first",
        "second",
        "ret",
        "that",
        "val",
        "val",
        "val",
        "item",
        "that",
        "cmp",
        "prev",
        "item",
        "item",
        "prev",
        "item",
        "AsyncIterPlus",
        "ret",
        "elem",
        "ret",
        "elem",
        "that",
        "val",
        "val",
        "item",
        "that",
        "awaited",
        "item",
        "AsyncIterPlus",
        "ret",
        "elems",
        "ret",
        "item",
        "elems",
        "awaited",
        "item",
        "that",
        "val",
        "val",
        "item",
        "that",
        "awaited",
        "item",
        "AsyncIterPlus",
        "ret",
        "elem",
        "ret",
        "elem",
        "that",
        "val",
        "val",
        "item",
        "that",
        "awaited",
        "item",
        "AsyncIterPlus",
        "ret",
        "elems",
        "ret",
        "item",
        "elems",
        "awaited",
        "item",
        "that",
        "val",
        "val",
        "item",
        "that",
        "awaited",
        "item",
        "AsyncIterPlus",
        "ret",
        "duplicate",
        "key",
        "key",
        "duplicate",
        "key",
        "ret",
        "duplicate",
        "RangeError",
        "duplicate",
        "ret",
        "key",
        "val",
        "ret",
        "key",
        "val",
        "ret",
        "duplicate",
        "duplicate",
        "ret",
        "key",
        "duplicate",
        "RangeError",
        "duplicate",
        "ret",
        "key",
        "val",
        "ret",
        "key",
        "val",
        "ret",
        "val",
        "ret",
        "val",
        "ret",
        "item",
        "ret",
        "item",
        "ret",
        "iters",
        "ret",
        "that",
        "iters",
        "v",
        "v",
        "v",
        "v",
        "obj",
        "iterList",
        "obj",
        "found",
        "obj",
        "val",
        "obj",
        "val",
        "found",
        "AsyncIterPlus",
        "ret",
        "func",
        "accum",
        "elem",
        "initializer",
        "ret",
        "elem",
        "that",
        "func",
        "accum",
        "elem",
        "newElem",
        "accum",
        "newAccum",
        "AsyncIterPlus",
        "ret",
        "pred",
        "elem",
        "item",
        "pred",
        "item",
        "ret",
        "ret",
        "func",
        "accum",
        "elem",
        "initializer",
        "func",
        "accum",
        "elem",
        "func",
        "accum",
        "elem",
        "initializer",
        "ret",
        "initializer",
        "that",
        "next",
        "accum",
        "next",
        "accum",
        "initializer",
        "elem",
        "that",
        "accum",
        "accum",
        "func",
        "accum",
        "elem",
        "accum",
        "AsyncIterPlus",
        "ret",
        "other",
        "cmp",
        "first",
        "second",
        "other",
        "iter",
        "a",
        "b",
        "cmp",
        "a",
        "b",
        "eq",
        "other",
        "key",
        "elem",
        "other",
        "iter",
        "a",
        "b",
        "key",
        "a",
        "key",
        "b",
        "eq",
        "other",
        "other",
        "iter",
        "a",
        "b",
        "a",
        "b",
        "eq",
        "AsyncIterPlus",
        "iter",
        "iter",
        "ret"
    ],
    "literals": [
        "\"./IterPlus.ts\"",
        "\"./util.ts\"",
        "\"./CircularBuffer.ts\"",
        "\"object\"",
        "\"function\"",
        "\"object\"",
        "\"./IterPlus.ts\"",
        "\"./IterPlus.ts\"",
        "\"Reduce of empty iterator with no initializer.\"",
        "string",
        "string",
        "\"bigint\"",
        "\"Cannot average an empty iterator.\"",
        "\"Cannot left rotate by a negative amount.\"",
        "\"Cannot right rotate by a negative amount.\"",
        "\"overwrite\"",
        "\"maintain\"",
        "\"error\"",
        "\"overwrite\"",
        "string",
        "string",
        "\"overwrite\"",
        "\"error\"",
        "\"Duplicate key encountered.\"",
        "\"maintain\"",
        "\"overwrite\"",
        "\"maintain\"",
        "\"error\"",
        "\"overwrite\"",
        "\"overwrite\"",
        "\"error\"",
        "\"Duplicate key encountered.\"",
        "\"maintain\"",
        "\"Scan of empty iterator with no initializer.\""
    ],
    "variables": [
        "elem",
        "val",
        "cache",
        "indices",
        "i",
        "i",
        "indices",
        "i",
        "i",
        "indices",
        "cycles",
        "i",
        "i",
        "i",
        "first",
        "j",
        "i",
        "temp",
        "indices",
        "i",
        "i",
        "i",
        "indices",
        "i",
        "i",
        "that",
        "iter",
        "a",
        "b",
        "diff",
        "ak",
        "bk",
        "ret",
        "ret",
        "that",
        "count",
        "iter",
        "a",
        "b",
        "eq",
        "iter",
        "a",
        "b",
        "eq",
        "iter",
        "a",
        "b",
        "eq",
        "that",
        "that",
        "val",
        "val",
        "that",
        "that",
        "that",
        "that",
        "accum",
        "next",
        "that",
        "that",
        "seenFalse",
        "first",
        "prev",
        "first",
        "prev",
        "elKey",
        "last",
        "nullVal",
        "that",
        "val",
        "next",
        "curMax",
        "diff",
        "next",
        "curMax",
        "curMaxKey",
        "elemKey",
        "next",
        "curMax",
        "diff",
        "next",
        "curMax",
        "curMaxKey",
        "elemKey",
        "truePart",
        "falsePart",
        "count",
        "accum",
        "typechecked",
        "accum",
        "typechecked",
        "collected",
        "that",
        "i",
        "val",
        "that",
        "val",
        "that",
        "i",
        "val",
        "that",
        "val",
        "ret",
        "i",
        "that",
        "zippers",
        "tot",
        "val",
        "that",
        "zippers",
        "tot",
        "val",
        "stored",
        "init",
        "finished",
        "that",
        "tot",
        "indices",
        "n",
        "elem",
        "minind",
        "i",
        "accum",
        "typechecked",
        "bigint",
        "count",
        "that",
        "eles",
        "i",
        "val",
        "that",
        "eles",
        "i",
        "val",
        "that",
        "eles",
        "i",
        "that",
        "eles",
        "i",
        "val",
        "that",
        "eles",
        "val",
        "that",
        "awaited",
        "foundEle",
        "chunks",
        "eles",
        "val",
        "that",
        "foundEle",
        "chunks",
        "eles",
        "val",
        "that",
        "awaited",
        "foundEle",
        "chunks",
        "eles",
        "val",
        "that",
        "foundEle",
        "chunks",
        "eles",
        "val",
        "that",
        "eles",
        "i",
        "val",
        "i",
        "val",
        "that",
        "val",
        "prev",
        "that",
        "val",
        "prev",
        "keyItem",
        "that",
        "val",
        "prev",
        "that",
        "awaited",
        "val",
        "that",
        "awaited",
        "val",
        "that",
        "awaited",
        "val",
        "that",
        "awaited",
        "val",
        "ret",
        "key",
        "val",
        "ret",
        "key",
        "val",
        "ret",
        "ret",
        "that",
        "iterList",
        "found",
        "val",
        "that",
        "accum",
        "initializer",
        "newAccum",
        "newElem",
        "ret",
        "that",
        "accum",
        "next",
        "iter",
        "a",
        "b",
        "eq",
        "iter",
        "a",
        "b",
        "eq",
        "iter",
        "a",
        "b",
        "eq",
        "ret"
    ],
    "comments": [
        "typeof obj === \"string\" ||",
        "export const nullVal = null;",
        "export type AsyncNull = typeof asyncNullVal;",
        "==== STATIC METHODS ====",
        "do nothing",
        "do nothing"
    ],
    "docstrings": [
        "* Tests if an object is an iterator.\n * @param obj The object to test for.\n * @returns If `obj` is an iterator.",
        "* Tests if an object is iterable.\n * @param obj The object to test for.\n * @returns If `obj` is an iterable.",
        "* Dirty workaround for Prettier moving comments.",
        "* Dirty workaround for Prettier moving comments.",
        "* Typescript-abusing type that wraps every type in a tuple type with an array.",
        "* Typescript-abusing type that wraps every type in a tuple type with an Iterable.",
        "* The value of null to use.\n *\n * Defaults to `null`.",
        "* The type of null to use.",
        "* A wrapper around an iterator to add additional functionality. The types intentionally ignore return value.\n *\n * Many of the methods consume elements of the iterator,\n * so use `tee` the iterator into two first if you want to preserve elements.\n *\n * @typeParam T The item type of the iterator.",
        "* The internal iterator that this wraps around.",
        "* Instantiates an `IterPlus` from any iterator.\n     *\n     * @param iter The iterator to wrap around.",
        "* Yields the next element in the iterator.\n     *\n     * @returns The next element.",
        "* Returns the next value, or null if the iterator ended.\n     *\n     * @returns The next value, or null if the iterator ended.",
        "* Makes the iterator work as an iterable.\n     *\n     * @returns The same iterator.",
        "* Generates an empty iterator.\n     *\n     * @typeParam T The item yielded by the iterator.\n     * @returns The generated iterator.",
        "* Generates an iterator that yields values from a function and ends once the function returns null.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param func The function to yield values, or null to end the iterator.\n     * @returns The generated iterator.",
        "* Generates an iterator that lazily yields a single value.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param func The function to generate a single value.\n     * @returns The generated iterator.",
        "* Generates an iterator that yields a single value.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param val The value to yield.\n     * @returns The generated iterator.",
        "* Generates an iterator that endlessly calls a function.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param func The function to generate values.\n     * @returns The generated iterator.",
        "* Generates an iterator that endlessly repeats a value.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param val The value to yield.\n     * @returns The generated iterator.",
        "* Generates an iterator that generates values based on the previous value.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param first The initial value.\n     * @param func The function to generate new values.\n     * @returns The generated iterator.",
        "* Generates an iterator that cycles through an iterable.\n     *\n     * While this **does** work on infinite iterators,\n     * it should be avoided as it stores all elements,\n     * leading to an ever-growing memory usage.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param data The iterable to cycle through.\n     * @returns The generated iterator.",
        "* Generates an iterator that iterates through lexicographically sorted combinations without repetition of a dataset.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param data The data to generate combinations from.\n     * @param count The number of elements in each combination.\n     * @returns The generated iterator.",
        "* Generates an iterator that iterates through lexicographically sorted combinations with repetition of a dataset.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param data The data to generate combinations from.\n     * @param count The number of elements in each combination.\n     * @returns The generated iterator.",
        "* Generates an iterator that iterates through lexicographically sorted permutations without repetition of a dataset.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param data The data to generate permutations from.\n     * @param count The number of elements in each permutations.\n     * @returns The generated iterator.",
        "* Generates an iterator that iterates through lexicographically sorted permutations with repetition of a dataset.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param data The data to generate permutations from.\n     * @param count The number of elements in each permutations.\n     * @returns The generated iterator.",
        "* Generates an iterator that iterates through the lexicographically sorted powerset of a dataset.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param data The data to get the powerset of.\n     * @return The generated iterator.",
        "* Generates an iterator that generates a lexicographically sorted cartesian product.\n     *\n     * @typeParam T The item type of the iterator.\n     * @param data The iterators to take the product of.\n     * @returns The generated iterator.",
        "* Checks if every element in the iterator matches a predicate.\n     *\n     * This function is short-circuiting,\n     * so if any element returns `false`,\n     * the function immediately returns `false`.\n     *\n     * @param pred The predicate function.\n     * @returns If every element satisfies the predicate.",
        "* Checks if some element in the iterator matches a predicate.\n     *\n     * This function is short-circuiting,\n     * so if any element returns `true`,\n     * the function immediately returns `true`.\n     *\n     * @param pred The predicate function.\n     * @returns If some element satisfies the predicate.",
        "* Concatenates one or more iterables to this iterator,\n     * creating an iterator that yields their elements in sequentual order.\n     *\n     * @param iters The iterables to chain to this one.\n     * @returns The generated iterator.",
        "* Lexicographically compares this iterator with another using a comparison function.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first inequality.\n     *\n     * @typeParam O The type of the other iterator.\n     * @param other Iterable to compare to.\n     * @param cmp A function that should return a negative for less than, zero for equal to,\n     * and positive for greater than.\n     * @returns -1 if this is less than the other, 0 if it's equal, and 1 if it's greater than.",
        "* Lexicographically compares this iterator with another using a key.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first inequality.\n     *\n     * @typeParam K The type of the key.\n     * @param other Iterable to compare to.\n     * @param key Function to generate a key to compare with from an element.\n     * @returns -1 if this is less than the other, 0 if it's equal, and 1 if it's greater than.",
        "* Lexicographically compares this iterator with another.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first inequality.\n     *\n     * @param other Iterable to compare to.\n     * @returns -1 if this is less than the other, 0 if it's equal, and 1 if it's greater than.",
        "* Collects the items in this iterator into an array.\n     *\n     * @returns An array with the items in the iterator.",
        "* Counts the number of items in this iterator.\n     *\n     * @returns The number of items in the iterator.",
        "* Generates an iterator that yields a 2 element array with the index and the element.\n     *\n     * @returns The generated iterator.",
        "* Checks if this iterator is equal to another using a comparison function.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first inequality.\n     *\n     * @typeParam O The type of the other iterable.\n     * @param other Iterable to compare to.\n     * @param cmp A function that checks if elements are equal.\n     * @returns If the two iterators are equal.",
        "* Checks if this iterator is equal to another using a key.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first inequality.\n     *\n     * @typeParam K The type of the key.\n     * @param other Iterable to compare to.\n     * @param key Function to generate a key to compare with from an element.\n     * @returns If the two iterators are equal.",
        "* Checks if this iterator is equal to another.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first inequality.\n     *\n     * @param other Iterable to compare to.\n     * @returns If the two iterators are equal.",
        "* Generates an iterator that only yields elements that match a predicate.\n     *\n     * @param pred The predicate function.\n     * @returns The generated iterator.",
        "* Generates a mapped iterator that yields non-null elements.\n     *\n     * @typeParam K The resulting type.\n     * @typeParam N The type of the null value.\n     * @param func The mapping function.\n     * @returns The generated iterator.",
        "* Finds an element that satisfies a predicate.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first match.\n     *\n     * @param pred The predicate function.\n     * @returns The element, or null if none was found.",
        "* Runs a function on every element and returns the first non-null element.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first match.\n     *\n     * @typeParam K The resulting type.\n     * @typeParam N The type of the null value.\n     * @param func The mapping function.\n     * @returns The element, or null if none was found.",
        "* Flattens an iterator of iterables,\n     * yielding an iterator that sequentially produces their elements.\n     *\n     * @typeParam K The internal type.\n     * @returns The generated iterator.",
        "* Lazily maps an iterator, creating a new iterator where each element has been modified by a function.\n     *\n     * If you want to immediately run a function on all elements of the iterator, use `forEach` instead.\n     *\n     * @typeParam K The resulting type.\n     * @param func The mapping function.\n     * @returns The generated iterator.",
        "* Maps an iterator of iterables,\n     * and calls a function with the contents of the iterable as the argument.\n     *\n     * @typeParam K The iterable type.\n     * @typeParam R The resulting type.\n     * @param func The mapping function.\n     * @returns The generated iterator.",
        "* Maps then flattens an iterator.\n     *\n     * @typeParam K The resulting type.\n     * @param func The mapping function.\n     * @returns The generated iterator.",
        "* Runs a function for every element of the iterator, keeping track of an accumulator.\n     *\n     * @typeParam A The type of the accumulator.\n     * @param func The reducing function.\n     * @param initializer The initial accumulator.\n     * @returns The final accumulator.",
        "* Runs a function for every element of the iterator, keeping track of an accumulator.\n     *\n     * Uses the first element as the initial accumulator,\n     * and it will be skipped over in the reduction.\n     *\n     * @param func The reducing function.\n     * @throws If the iterator is empty,\n     * then an error will be thrown.\n     * @returns The final accumulator.",
        "* Runs a function on each element of an iterator.\n     *\n     * This is equivalent to running a for loop on the iterator.\n     * If you want to obtain the values, consider using `.map(func).collect()` instead.\n     *\n     * @param func The function to run.",
        "* Generates an iterator that is guaranteed to never yield a value after finishing.\n     *\n     * @returns The generated iterator.",
        "* Lazily runs functions on an iterator, returning a new iterator with unmodified elements.\n     *\n     * This function is primarily used as a debugging tool to inspect elements in the middle of an iterator function chain.\n     *\n     * @param func The function to call.\n     * @returns The generated iterator.",
        "* Determines if an iterator is partitioned by a predicate\n     * (Items that return true come before items that return false).\n     *\n     * This function is short-circuiting,\n     * so it stops on the first non-partitioned element.\n     *\n     * @param pred The predicate function.\n     * @returns If the iterator is partitioned.",
        "* Determines if an iterator is sorted increasingly by a comparison function.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first non-sorted element.\n     *\n     * @param cmp A function that should return a negative for less than, zero for equal to,\n     * and positive for greater than.\n     * @returns If the iterator is sorted.",
        "* Determines if an iterator is sorted increasingly by a key.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first non-sorted element.\n     *\n     * @typeParam K The type of the key.\n     * @param key The key function.\n     * @returns If the iterator is sorted.",
        "* Determines if an iterator is sorted increasingly.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first non-sorted element.\n     *\n     * @returns If the iterator is sorted.",
        "* Finds the last element in an iterator.\n     *\n     * @returns The last element of the iterator, or null if the iterator is empty.",
        "* Lazily maps an iterator until it encounters null.\n     *\n     * @typeParam K The resulting type.\n     * @param func The mapping function.\n     * @returns The generated iterator.",
        "* Finds the maximum value of an iterator with a comparison function.\n     *\n     * @param cmp A function that should return a negative for less than, zero for equal to,\n     * and positive for greater than.\n     * @param overwrite If `true`, elements will be counted as the new maximum if they are equal to the maximum.\n     * Defaults to `false`.\n     * @returns The maximum element, or null if the iterator is empty.",
        "* Finds the maximum value of an iterator with a key.\n     *\n     * @typeParam K The type of the key.\n     * @param key The key function.\n     * @param overwrite If `true`, elements will be counted as the new maximum if they are equal to the maximum.\n     * Defaults to `false`.\n     * @returns The maximum element, or null if the iterator is empty.",
        "* Finds the maximum value of an iterator.\n     *\n     * @param overwrite If `true`, elements will be counted as the new maximum if they are equal to the maximum.\n     * Defaults to `false`.\n     * @returns The maximum element, or null if the iterator is empty.",
        "* Finds the minimum value of an iterator with a comparison function.\n     *\n     * @param cmp A function that should return a negative for less than, zero for equal to,\n     * and positive for greater than.\n     * @param overwrite If `true`, elements will be counted as the new minimum if they are equal to the minimum.\n     * Defaults to `false`.\n     * @returns The minimum element, or null if the iterator is empty.",
        "* Finds the minimum value of an iterator with a key.\n     *\n     * @typeParam K The type of the key.\n     * @param key The key function.\n     * @param overwrite If `true`, elements will be counted as the new minimum if they are equal to the minimum.\n     * Defaults to `false`.\n     * @returns The minimum element, or null if the iterator is empty.",
        "* Finds the minimum value of an iterator.\n     *\n     * @param overwrite If `true`, elements will be counted as the new minimum if they are equal to the minimum.\n     * Defaults to `false`.\n     * @returns The minimum element, or null if the iterator is empty.",
        "* Finds the nth element in an iterator.\n     *\n     * @param n The number element to get.\n     * @returns The nth element of the iterator, or null if the iterator is too short.",
        "* Partitions an iterator into two groups.\n     *\n     * @param pred The predicate function.\n     * @returns An array with two elements:\n     *  - The elements where the predicate returned true.\n     *  - The elements where the predicate returned false.",
        "* Generates a `Peekable` iterator.\n     *\n     * @returns The peekable iterator.",
        "* Finds the index of an element that satisfies a predicate.\n     *\n     * If you want to find the value and the index, consider using `enumerate`\n     * then using `find`.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first match.\n     *\n     * @param pred The predicate function.\n     * @returns The index, or -1 if none was found.",
        "* Returns the product of all elements in the iterator.\n     *\n     * @returns The product, or 1 if the iterator is empty.",
        "* Returns the sum of all elements in the iterator.\n     *\n     * @returns The sum, or 0 if the iterator is empty.",
        "* Consumes the iterator and reverses it.\n     *\n     * This has to immediately resolve every element in the iterator,\n     * so it is equivalent to collecting to an array and revsersing the array,\n     * so it is very inefficient on memory and should be avoided.\n     *\n     * @returns The reversed iterator.",
        "* Skips the first n elements of an iterator.\n     *\n     * @param n The number of elements to skip.\n     * @returns The generated iterator.",
        "* Skips elements of an iterator while a predicate is met.\n     *\n     * @param pred The predicate function.\n     * @returns The generated iterator.",
        "* Takes the first n elements of an iterator.\n     *\n     * @param n The number of elements to take.\n     * @returns The generated iterator.",
        "* Takes elements of an iterator while a predicate is met.\n     *\n     * @param pred The predicate function.\n     * @returns The generated iterator.",
        "* \"Unzips\" an iterator of tuples into a tuple of arrays.\n     *\n     * @typeParam K The tuple type.\n     * @returns A tuple with the individual elements.",
        "* Zips one or more iterables with this iterator using a function.\n     *\n     * Stops once any one of the iterators stop.\n     *\n     * @typeParam K The types of the other iterables.\n     * @typeParam R The resulting value.\n     * @param func The function to use when zipping.\n     * @param iters The iterables to zip with this one.\n     * @returns The generated iterator.",
        "* Zips one or more iterables with this iterator.\n     *\n     * @typeParam K The types of the other iterables.\n     * @param iters The iterables to zip with this one.\n     * @returns The generated iterator.",
        "* Splits an iterator into multiple, where advancing one iterator does not advance the others.\n     *\n     * Functions by storing old values and removing when no longer needed,\n     * so only tee as many iterators as you need in order for memory to be cleaned properly.\n     *\n     * The original iterator will still be advanced,\n     * so only used the iterators returned by `tee`.\n     *\n     * @param count The number of iterators to split into.\n     * @returns An array of length `count` with separate iterators.",
        "* Returns the average of all elements in the iterator.\n     *\n     * @throws A RangeError on an empty iterator.\n     * @returns The average.",
        "* Returns an iterator yielding non-overlapping chunks of the iterator.\n     *\n     * If there aren't enough elements to fill a chunk,\n     * the last chunk will be smaller than the chunk size.\n     *\n     * If you want gaps between the chunks,\n     * consider using `windows` with the appropriate interval instead.\n     *\n     * @param chunkSize The chunk size.\n     * @returns An iterator that yields the chunks.",
        "* Returns an iterator yielding non-overlapping chunks of the iterator.\n     *\n     * If there aren't enough elements to fill a chunk,\n     * the extra elements will be omitted.\n     *\n     * If you want gaps between the chunks,\n     * consider using `windows` with the appropriate interval instead.\n     *\n     * @param chunkSize The chunk size.\n     * @returns An iterator that yields the chunks.",
        "* Creates an iterator that repeats the contents of the current iterator a certain number of times.\n     *\n     * @param n The number of times to repeat.\n     * @returns An iterator that repeats itself n times.",
        "* Creates an iterator that's rotated left a certain amount,\n     * so elements at the start end up at the end.\n     *\n     * This **does not** handle negative numbers due to right rotation being significantly slower.\n     * If you want negatives, please do the checks yourself and use rotateRight when appropriate.\n     *\n     * @param amount Amount to rotate by.\n     * @throws A RangeError when the amount is negative.\n     * @returns The rotated iterator.",
        "* Creates an iterator that's rotated right a certain amount,\n     * so elements at the end end up at the start.\n     *\n     * **Due to the one-directional nature of iterators, this is not lazy and therefore much slower than `rotateLeft`.**\n     *\n     * This **does not** handle negative numbers to be consistent with `rotateLeft`.\n     * If you want negatives, please do the checks yourself and use rotateRight when appropriate.\n     *\n     * @param amount Amount to rotate by.\n     * @throws A RangeError when the amount is negative.\n     * @returns The rotated iterator.",
        "* Splits an iterator on an element.\n     *\n     * @param ele The element to split on.\n     * @param limit The maximum number of chunks to make.\n     * @returns The iterator with the split chunks.",
        "* Splits an iterator on a predicate.\n     *\n     * @param pred The predicate to split with.\n     * @param limit The maximum number of chunks to make.\n     * @returns The iterator with the split chunks.",
        "* Splits an iterator on an element,\n     * including the matched element as the last element of the chunk.\n     *\n     * Unlike the exclusive split,\n     * this does not create an empty chunk on the end when ending with the matched element.\n     *\n     * @param ele The element to split on.\n     * @param limit The maximum number of chunks to make.\n     * @returns The iterator with the split chunks.",
        "* Splits an iterator on a predicate,\n     * including the matched element as the last element of the chunk.\n     *\n     * Unlike the exclusive split,\n     * this does not create an empty chunk on the end when ending with the matched element.\n     *\n     * @param pred The predicate to split with.\n     * @param limit The maximum number of chunks to make.\n     * @returns The iterator with the split chunks.",
        "* Returns an iterator yielding overlapping windows of the iterator.\n     *\n     * If there aren't enough elements to fill a window,\n     * no windows will be yielded.\n     *\n     * @param windowSize The window size.\n     * @param interval The increment between the starts of windows. Defaults to 1.\n     * @returns An iterator that yields the windows.",
        "* Removes elements of an iterator that are equal to the previous one.\n     * @returns An iterator with no consecutive duplicates.",
        "* Removes elements of an iterator that are equal to the previous one with a key.\n     *\n     * @typeParam K The type of the key.\n     * @param key The key function.\n     * @returns An iterator with no consecutive duplicates.",
        "* Removes elements of an iterator that are equal to the previous one with a comparison function.\n     *\n     * @param cmp A function that checks if elements are equal.\n     * @returns An iterator with no consecutive duplicates.",
        "* Intersperses an element between every element of the iterator.\n     *\n     * @param elem The element to intersperse.\n     * @returns The new iterator.",
        "* Intersperses multiple elements between every element of the iterator.\n     *\n     * @param elems The elements to intersperse.\n     * @returns The new iterator.",
        "* Joins an iterator of iterables with an element.\n     *\n     * @typeParam K The internal type.\n     * @param elem The element to join with.\n     * @returns The joined iterator.",
        "* Joins an iterator of iterables with multiple elements.\n     *\n     * @typeParam K The internal type.\n     * @param elems The elements to intersperse.\n     * @returns The joined iterator.",
        "* Converts an iterator of key-value pairs into an object.\n     *\n     * @typeParam K The key type.\n     * @typeParam V The value type.\n     * @param duplicate How to handle duplicate keys.\n     * `\"overwrite\"` replaces values with the new value.\n     * `\"maintain\"` maintains the old value.\n     * `\"error\"` throws an error.\n     * Defaults to `\"overwrite\"`.\n     * @throws A RangeError if `duplicate` is `\"error\"` and a duplicate key is encountered.\n     * @returns The generated object.",
        "* Converts an iterator of key-value pairs into a map.\n     *\n     * @typeParam K The key type.\n     * @typeParam V The value type.\n     * @param duplicate How to handle duplicate keys.\n     * `\"overwrite\"` replaces values with the new value.\n     * `\"maintain\"` maintains the old value.\n     * `\"error\"` throws an error.\n     * Defaults to `\"overwrite\"`.\n     * @throws A RangeError if `duplicate` is `\"error\"` and a duplicate key is encountered.\n     * @returns The generated map.",
        "* Converts an iterator into a set.\n     *\n     * @returns The generated set.",
        "* Converts an iterator into an array.\n     *\n     * @returns The generated array.",
        "* Interleaves one or more iterables with this iterator.\n     *\n     * @param iters The iterables to interleave with this one.\n     *\n     * @returns The interleaved iterator, yielding elements in the iterators in order.",
        "* Runs a function for every element of the iterator, keeping track of an accumulator.\n     *\n     * @typeParam A The type of the accumulator.\n     * @typeParam V The resulting type.\n     * @param func The mapping function.\n     * @param initializer The initial accumulator.\n     * @returns The mapped iterator.",
        "* Counts the number of items in this iterator that match a predicate.\n     *\n     * @param pred The predicate function.\n     * @returns The number of matched items in the iterator.",
        "* Runs a function for every element of the iterator, keeping track of an accumulator.\n     *\n     * @typeParam A The type of the accumulator.\n     * @param func The reducing function.\n     * @param initializer The initial accumulator.\n     * @returns The iterator containing all intermediate accumulators.",
        "* Runs a function for every element of the iterator, keeping track of an accumulator.\n     *\n     * Uses the first element as the initial accumulator,\n     * and it will be skipped over in the scan.\n     *\n     * @param func The reducing function.\n     * @throws If the iterator is empty,\n     * then an error will be thrown.\n     * @returns The iterator containing all intermediate accumulators.",
        "* Checks if this iterator is equal to another,\n     * while they both yield elements, using a comparison function.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first inequality.\n     *\n     * However, if the first iterator terminates,\n     * a value will still be yielded from the second so that `headEquals` is commutative.\n     *\n     * @typeParam O The type of the other iterable.\n     * @param other Iterable to compare to.\n     * @param cmp A function that checks if elements are equal.\n     * @returns If the two iterators are equal.",
        "* Checks if this iterator is equal to another,\n     * while they both yield elements, using a key.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first inequality.\n     *\n     * However, if the first iterator terminates,\n     * a value will still be yielded from the second so that `headEquals` is commutative.\n     *\n     * @typeParam O The type of the Key.\n     * @param other Iterable to compare to.\n     * @param key The key function.\n     * @returns If the two iterators are equal.",
        "* Checks if this iterator is equal to another,\n     * while they both yield elements.\n     *\n     * This function is short-circuiting,\n     * so it stops on the first inequality.\n     *\n     * However, if the first iterator terminates,\n     * a value will still be yielded from the second so that `headEquals` is commutative.\n     *\n     * @param other Iterable to compare to.\n     * @returns If the two iterators are equal.",
        "* An iterator with a `peek`. method that can look one element in advance.\n *\n * Do not instantiate this directly, instead use the `peekable` method in `IterPlus` or `AsyncIterPlus`.\n *\n * @typeParam T The item type of the iterator.",
        "* Yields the next element in the iterator.\n     *\n     * @returns The next element.",
        "* Peeks the next element in the iterator and does not consume it.\n     *\n     * @returns The next element."
    ],
    "functions": [
        "isAsyncIter",
        "canAsyncIter",
        "next",
        "nextVal",
        "empty",
        "fromFunction",
        "onceWith",
        "once",
        "repeatWith",
        "repeat",
        "successors",
        "cycle",
        "combinations",
        "combinationsWithRepetition",
        "permutations",
        "permutationsWithRepetition",
        "powerset",
        "product",
        "every",
        "some",
        "concat",
        "compareBy",
        "compareWith",
        "compare",
        "collect",
        "count",
        "equalsBy",
        "equalsWith",
        "equals",
        "filterMap",
        "find",
        "findMap",
        "flatten",
        "starmap",
        "flatMap",
        "reduce",
        "forEach",
        "fuse",
        "inspect",
        "isPartitioned",
        "isSortedBy",
        "isSortedWith",
        "isSorted",
        "last",
        "mapWhile",
        "maxBy",
        "maxWith",
        "max",
        "minBy",
        "minWith",
        "min",
        "nth",
        "partition",
        "peekable",
        "findIndex",
        "product",
        "sum",
        "reverse",
        "skip",
        "skipWhile",
        "take",
        "takeWhile",
        "unzip",
        "zipWith",
        "tee",
        "average",
        "chunks",
        "chunksExact",
        "repeat",
        "rotateLeft",
        "rotateRight",
        "split",
        "splitPred",
        "splitInclusive",
        "splitPredInclusive",
        "windows",
        "dedup",
        "dedupWith",
        "dedupBy",
        "intersperse",
        "intersperseMultiple",
        "join",
        "joinMultiple",
        "toObject",
        "toMap",
        "toSet",
        "toArray",
        "interleave",
        "mapAccum",
        "countIf",
        "scan",
        "headEqualsBy",
        "headEqualsWith",
        "headEquals",
        "next",
        "peek"
    ],
    "classes": [
        "AsyncIterPlus",
        "AsyncPeekable"
    ]
}