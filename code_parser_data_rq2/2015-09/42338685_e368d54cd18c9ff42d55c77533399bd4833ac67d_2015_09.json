{
    "identifiers": [
        "bootstrap",
        "appComponentType",
        "Component",
        "arg",
        "target",
        "View",
        "arg",
        "target",
        "For",
        "If",
        "NonBindable",
        "Switch",
        "bind",
        "token"
    ],
    "literals": [
        "string",
        "string",
        "string",
        "string",
        "\"angular2/angular2\"",
        "\"angular2/di\""
    ],
    "variables": [],
    "comments": [
        "Type definitions for Angular v2.0.0-alpha.22",
        "Project: http://angular.io/",
        "Definitions by: angular team <https://github.com/angular/>",
        "Definitions: https://github.com/borisyankov/DefinitelyTyped"
    ],
    "docstrings": [
        "****************\n * This is a minimal type definition for the Angular2 quickstart.\n * We plan to publish a complete definition soon.\n *****************",
        "* The CSS selector that triggers the instantiation of a directive.\n   *\n   * Angular only allows directives to trigger on CSS selectors that do not cross element boundaries.\n   *\n   * `selector` may be declared as one of the following:\n   *\n   * - `element-name`: select by element name.\n   * - `.class`: select by class name.\n   * - `[attribute]`: select by attribute name.\n   * - `[attribute=value]`: select by attribute name and value.\n   * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.\n   * - `selector1, selector2`: select if either `selector1` or `selector2` matches.\n   *\n   *\n   * ## Example\n   *\n   * Suppose we have a directive with an `input[type=text]` selector.\n   *\n   * And the following HTML:\n   *\n   * ```html\n   * <form>\n   *   <input type=\"text\">\n   *   <input type=\"radio\">\n   * <form>\n   * ```\n   *\n   * The directive would only be instantiated on the `<input type=\"text\">` element.\n   *",
        "* Enumerates the set of properties that accept data binding for a directive.\n   *\n   * The `properties` property defines a set of `directiveProperty` to `bindingProperty`\n   * key-value pairs:\n   *\n   * - `directiveProperty` specifies the component property where the value is written.\n   * - `bindingProperty` specifies the DOM property where the value is read from.\n   *\n   * You can include a {@link Pipe} when specifying a `bindingProperty` to allow for data transformation and structural\n   * change detection of the value. These pipes will be evaluated in the context of this component.\n   *\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   properties: {\n   *     'directiveProperty1': 'bindingProperty1',\n   *     'directiveProperty2': 'bindingProperty2 | pipe1 | ...',\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   *\n   * ## Basic Property Binding\n   *\n   * We can easily build a simple `Tooltip` directive that exposes a `tooltip` property, which can be used in templates\n   * with standard Angular syntax. For example:\n   *\n   * ```\n   * @Directive({\n   *   selector: '[tooltip]',\n   *   properties: {\n   *     'text': 'tooltip'\n   *   }\n   * })\n   * class Tooltip {\n   *   set text(text) {\n   *     // This will get called every time the 'tooltip' binding changes with the new value.\n   *   }\n   * }\n   * ```\n   *\n   * We can then bind to the `tooltip' property as either an expression (`someExpression`) or as a string literal, as\n   * shown in the HTML template below:\n   *\n   * ```html\n   * <div [tooltip]=\"someExpression\">...</div>\n   * <div tooltip=\"Some Text\">...</div>\n   * ```\n   *\n   * Whenever the `someExpression` expression changes, the `properties` declaration instructs\n   * Angular to update the `Tooltip`'s `text` property.\n   *\n   *\n   *\n   * ## Bindings With Pipes\n   *\n   * You can also use pipes when writing binding definitions for a directive.\n   *\n   * For example, we could write a binding that updates the directive on structural changes, rather than on reference\n   * changes, as normally occurs in change detection.\n   *\n   * See {@link Pipe} and {@link keyValDiff} documentation for more details.\n   *\n   * ```\n   * @Directive({\n   *   selector: '[class-set]',\n   *   properties: {\n   *     'classChanges': 'classSet | keyValDiff'\n   *   }\n   * })\n   * class ClassSet {\n   *   set classChanges(changes:KeyValueChanges) {\n   *     // This will get called every time the `class-set` expressions changes its structure.\n   *   }\n   * }\n   * ```\n   *\n   * The template that this directive is used in may also contain its own pipes. For example:\n   *\n   * ```html\n   * <div [class-set]=\"someExpression | somePipe\">\n   * ```\n   *\n   * In this case, the two pipes compose as if they were inlined: `someExpression | somePipe | keyValDiff`.\n   *",
        "* Specifies which DOM hostListeners a directive listens to.\n   *\n   * The `hostListeners` property defines a set of `event` to `method` key-value pairs:\n   *\n   * - `event1`: the DOM event that the directive listens to.\n   * - `statement`: the statement to execute when the event occurs.\n   * If the evalutation of the statement returns `false`, then `preventDefault`is applied on the DOM event.\n   *\n   * To listen to global events, a target must be added to the event name.\n   * The target can be `window`, `document` or `body`.\n   *\n   * When writing a directive event binding, you can also refer to the following local variables:\n   * - `$event`: Current event object which triggered the event.\n   * - `$target`: The source of the event. This will be either a DOM element or an Angular directive.\n   *   (will be implemented in later release)\n   *\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   hostListeners: {\n   *     'event1': 'onMethod1(arguments)',\n   *     'target:event2': 'onMethod2(arguments)',\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Basic Event Binding:\n   *\n   * Suppose you want to write a directive that triggers on `change` events in the DOM and on `resize` events in window.\n   * You would define the event binding as follows:\n   *\n   * ```\n   * @Directive({\n   *   selector: 'input',\n   *   hostListeners: {\n   *     'change': 'onChange($event)',\n   *     'window:resize': 'onResize($event)'\n   *   }\n   * })\n   * class InputDirective {\n   *   onChange(event:Event) {\n   *   }\n   *   onResize(event:Event) {\n   *   }\n   * }\n   * ```\n   *\n   * Here the `onChange` method of `InputDirective` is invoked whenever the DOM element fires the 'change' event.\n   *",
        "* Defines the set of injectable objects that are visible to a Component and its children.\n   *\n   * The `injectables` defined in the Component annotation allow you to configure a set of bindings for the component's\n   * injector.\n   *\n   * When a component is instantiated, Angular creates a new child Injector, which is configured with the bindings in\n   * the Component `injectables` annotation. The injectable objects then become available for injection to the component\n   * itself and any of the directives in the component's template, i.e. they are not available to the directives which\n   * are children in the component's light DOM.\n   *\n   *\n   * The syntax for configuring the `injectables` injectable is identical to {@link Injector} injectable configuration.\n   * See {@link Injector} for additional detail.\n   *\n   *\n   * ## Simple Example\n   *\n   * Here is an example of a class that can be injected:\n   *\n   * ```\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @Component({\n   *   selector: 'greet',\n   *   injectables: [\n   *     Greeter\n   *   ]\n   * })\n   * @View({\n   *   template: `{{greeter.greet('world')}}!`,\n   *   directives: Child\n   * })\n   * class HelloWorld {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   * ```",
        "* Specifies a set of lifecycle hostListeners in which the directive participates.\n   *\n   * See {@link onChange}, {@link onDestroy}, {@link onAllChangesDone} for details.",
        "* Defines the used change detection strategy.\n   *\n   * When a component is instantiated, Angular creates a change detector, which is responsible for propagating\n   * the component's bindings.\n   *\n   * The `changeDetection` property defines, whether the change detection will be checked every time or only when the component\n   * tells it to do so.",
        "* Specifies a template URL for an angular component.\n   *\n   * NOTE: either `templateUrl` or `template` should be used, but not both.",
        "* Specifies an inline template for an angular component.\n   *\n   * NOTE: either `templateUrl` or `template` should be used, but not both.",
        "* Specifies a list of directives that can be used within a template.\n   *\n   * Directives must be listed explicitly to provide proper component encapsulation.",
        "* Bootstrapping for Angular applications.\n   *\n   * You instantiate an Angular application by explicitly specifying a component to use as the root component for your\n   * application via the `bootstrap()` method.\n   *\n   * ## Simple Example\n   *\n   * Assuming this `index.html`:\n   *\n   * ```html\n   * <html>\n   *   <!-- load Angular script tags here. -->\n   *   <body>\n   *     <my-app>loading...</my-app>\n   *   </body>\n   * </html>\n   * ```\n   *\n   * An application is bootstrapped inside an existing browser DOM, typically `index.html`. Unlike Angular 1, Angular 2\n   * does not compile/process bindings in `index.html`. This is mainly for security reasons, as well as architectural\n   * changes in Angular 2. This means that `index.html` can safely be processed using server-side technologies such as\n   * bindings. Bindings can thus use double-curly `{{ syntax }}` without collision from Angular 2 component double-curly\n   * `{{ syntax }}`.\n   *\n   * We can use this script code:\n   *\n   * ```\n   * @Component({\n   *    selector: 'my-app'\n   * })\n   * @View({\n   *    template: 'Hello {{ name }}!'\n   * })\n   * class MyApp {\n   *   name:string;\n   *\n   *   constructor() {\n   *     this.name = 'World';\n   *   }\n   * }\n   *\n   * main() {\n   *   return bootstrap(MyApp);\n   * }\n   * ```\n   *\n   * When the app developer invokes `bootstrap()` with the root component `MyApp` as its argument, Angular performs the\n   * following tasks:\n   *\n   *  1. It uses the component's `selector` property to locate the DOM element which needs to be upgraded into\n   *     the angular component.\n   *  2. It creates a new child injector (from the platform injector) and configures the injector with the component's\n   *     `injectables`. Optionally, you can also override the injector configuration for an app by invoking\n   *     `bootstrap` with the `componentInjectableBindings` argument.\n   *  3. It creates a new `Zone` and connects it to the angular application's change detection domain instance.\n   *  4. It creates a shadow DOM on the selected component's host element and loads the template into it.\n   *  5. It instantiates the specified component.\n   *  6. Finally, Angular performs change detection to apply the initial data bindings for the application.\n   *\n   *\n   * ## Instantiating Multiple Applications on a Single Page\n   *\n   * There are two ways to do this.\n   *\n   *\n   * ### Isolated Applications\n   *\n   * Angular creates a new application each time that the `bootstrap()` method is invoked. When multiple applications\n   * are created for a page, Angular treats each application as independent within an isolated change detection and\n   * `Zone` domain. If you need to share data between applications, use the strategy described in the next\n   * section, \"Applications That Share Change Detection.\"\n   *\n   *\n   * ### Applications That Share Change Detection\n   *\n   * If you need to bootstrap multiple applications that share common data, the applications must share a common\n   * change detection and zone. To do that, create a meta-component that lists the application components in its template.\n   * By only invoking the `bootstrap()` method once, with the meta-component as its argument, you ensure that only a\n   * single change detection zone is created and therefore data can be shared across the applications.\n   *\n   *\n   * ## Platform Injector\n   *\n   * When working within a browser window, there are many singleton resources: cookies, title, location, and others.\n   * Angular services that represent these resources must likewise be shared across all Angular applications that\n   * occupy the same browser window.  For this reason, Angular creates exactly one global platform injector which stores\n   * all shared services, and each angular application injector has the platform injector as its parent.\n   *\n   * Each application has its own private injector as well. When there are multiple applications on a page, Angular treats\n   * each application injector's services as private to that application.\n   *\n   *\n   * # API\n   * - `appComponentType`: The root component which should act as the application. This is a reference to a `Type`\n   *   which is annotated with `@Component(...)`.\n   * - `componentInjectableBindings`: An additional set of bindings that can be added to `injectables` for the\n   * {@link Component} to override default injection behavior.\n   * - `errorReporter`: `function(exception:any, stackTrace:string)` a default error reporter for unhandled exceptions.\n   *\n   * Returns a `Promise` with the application`s private {@link Injector}.\n   *",
        "* Declare reusable UI building blocks for an application.\n   *\n   * Each Angular component requires a single `@Component` and at least one `@View` annotation. The `@Component`\n   * annotation specifies when a component is instantiated, and which properties and hostListeners it binds to.\n   *\n   * When a component is instantiated, Angular\n   * - creates a shadow DOM for the component.\n   * - loads the selected template into the shadow DOM.\n   * - creates a child {@link Injector} which is configured with the `injectables` for the {@link Component}.\n   *\n   * All template expressions and statements are then evaluated against the component instance.\n   *\n   * For details on the `@View` annotation, see {@link View}.\n   *\n   * ## Example\n   *\n   * ```\n   * @Component({\n   *   selector: 'greet'\n   * })\n   * @View({\n   *   template: 'Hello {{name}}!'\n   * })\n   * class Greet {\n   *   name: string;\n   *\n   *   constructor() {\n   *     this.name = 'World';\n   *   }\n   * }\n   * ```\n   *\n   *\n   * Dynamically loading a component at runtime:\n   *\n   * Regular Angular components are statically resolved. Dynamic components allows to resolve a component at runtime\n   * instead by providing a placeholder into which a regular Angular component can be dynamically loaded. Once loaded,\n   * the dynamically-loaded component becomes permanent and cannot be changed.\n   * Dynamic components are declared just like components, but without a `@View` annotation.\n   *\n   *\n   * ## Example\n   *\n   * Here we have `DynamicComp` which acts as the placeholder for `HelloCmp`. At runtime, the dynamic component\n   * `DynamicComp` requests loading of the `HelloCmp` component.\n   *\n   * There is nothing special about `HelloCmp`, which is a regular Angular component. It can also be used in other static\n   * locations.\n   *\n   * ```\n   * @Component({\n   *   selector: 'dynamic-comp'\n   * })\n   * class DynamicComp {\n   *   helloCmp:HelloCmp;\n   *   constructor(loader:DynamicComponentLoader, location:ElementRef) {\n   *     loader.load(HelloCmp, location).then((helloCmp) => {\n   *       this.helloCmp = helloCmp;\n   *     });\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'hello-cmp'\n   * })\n   * @View({\n   *   template: \"{{greeting}}\"\n   * })\n   * class HelloCmp {\n   *   greeting:string;\n   *   constructor() {\n   *     this.greeting = \"hello\";\n   *   }\n   * }\n   * ```\n   *",
        "* Declares the available HTML templates for an application.\n   *\n   * Each angular component requires a single `@Component` and at least one `@View` annotation. The @View\n   * annotation specifies the HTML template to use, and lists the directives that are active within the template.\n   *\n   * When a component is instantiated, the template is loaded into the component's shadow root, and the\n   * expressions and statements in the template are evaluated against the component.\n   *\n   * For details on the `@Component` annotation, see {@link Component}.\n   *\n   * ## Example\n   *\n   * ```\n   * @Component({\n   *   selector: 'greet'\n   * })\n   * @View({\n   *   template: 'Hello {{name}}!',\n   *   directives: [GreetUser, Bold]\n   * })\n   * class Greet {\n   *   name: string;\n   *\n   *   constructor() {\n   *     this.name = 'World';\n   *   }\n   * }\n   * ```\n   *",
        "* The `For` directive instantiates a template once per item from an iterable. The context for each\n   * instantiated template inherits from the outer context with the given loop variable set to the\n   * current item from the iterable.\n   *\n   * It is possible to alias the `index` to a local variable that will be set to the current loop\n   * iteration in the template context.\n   *\n   * When the contents of the iterator changes, `For` makes the corresponding changes to the DOM:\n   *\n   * * When an item is added, a new instance of the template is added to the DOM.\n   * * When an item is removed, its template instance is removed from the DOM.\n   * * When items are reordered, their respective templates are reordered in the DOM.\n   *\n   * # Example\n   *\n   * ```\n   * <ul>\n   *   <li *for=\"#error of errors; #i = index\">\n   *     Error {{i}} of {{errors.length}}: {{error.message}}\n   *   </li>\n   * </ul>\n   * ```\n   *\n   * # Syntax\n   *\n   * - `<li *for=\"#item of items; #i = index\">...</li>`\n   * - `<li template=\"for #item of items; #i=index\">...</li>`\n   * - `<template [for]=\"#item\" [of]=\"items\" #i=\"index\"><li>...</li></template>`\n   *",
        "* Removes or recreates a portion of the DOM tree based on an {expression}.\n   *\n   * If the expression assigned to `if` evaluates to a false value then the element is removed from the\n   * DOM, otherwise a clone of the element is reinserted into the DOM.\n   *\n   * # Example:\n   *\n   * ```\n   * <div *if=\"errorCount > 0\" class=\"error\">\n   *   <!-- Error message displayed when the errorCount property on the current context is greater than 0. -->\n   *   {{errorCount}} errors detected\n   * </div>\n   * ```\n   *\n   * # Syntax\n   *\n   * - `<div *if=\"condition\">...</div>`\n   * - `<div template=\"if condition\">...</div>`\n   * - `<template [if]=\"condition\"><div>...</div></template>`\n   *",
        "* The `NonBindable` directive tells Angular not to compile or bind the contents of the current\n   * DOM element. This is useful if the element contains what appears to be Angular directives and\n   * bindings but which should be ignored by Angular. This could be the case if you have a site that\n   * displays snippets of code, for instance.\n   *\n   * Example:\n   *\n   * ```\n   * <div>Normal: {{1 + 2}}</div> // output \"Normal: 3\"\n   * <div non-bindable>Ignored: {{1 + 2}}</div> // output \"Ignored: {{1 + 2}}\"\n   * ```\n   *",
        "* The `Switch` directive is used to conditionally swap DOM structure on your template based on a\n   * scope expression.\n   * Elements within `Switch` but without `SwitchWhen` or `SwitchDefault` directives will be\n   * preserved at the location as specified in the template.\n   *\n   * `Switch` simply chooses nested elements and makes them visible based on which element matches\n   * the value obtained from the evaluated expression. In other words, you define a container element\n   * (where you place the directive), place an expression on the **`[switch]=\"...\"` attribute**),\n   * define any inner elements inside of the directive and place a `[switch-when]` attribute per\n   * element.\n   * The when attribute is used to inform Switch which element to display when the expression is\n   * evaluated. If a matching expression is not found via a when attribute then an element with the\n   * default attribute is displayed.\n   *\n   * # Example:\n   *\n   * ```\n   * <ANY [switch]=\"expression\">\n   *   <template [switch-when]=\"whenExpression1\">...</template>\n   *   <template [switch-when]=\"whenExpression1\">...</template>\n   *   <template [switch-default]>...</template>\n   * </ANY>\n   * ```\n   *",
        "* Provides an API for imperatively constructing {@link Binding}s.\n   *\n   * This is only relevant for JavaScript. See {@link BindingBuilder}.\n   *\n   * ## Example\n   *\n   * ```javascript\n   * bind(MyInterface).toClass(MyClass)\n   *\n   * ```\n   *"
    ],
    "functions": [],
    "classes": []
}