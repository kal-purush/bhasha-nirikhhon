{
    "identifiers": [
        "numpy",
        "np",
        "numpy",
        "functions",
        "f",
        "testing",
        "numpy",
        "observer",
        "resN",
        "atoms",
        "distLimit",
        "K",
        "_construct",
        "observer",
        "resN",
        "distLimit",
        "atoms",
        "K",
        "value",
        "dist",
        "LEFT",
        "RIGHT",
        "value",
        "LEFT",
        "RIGHT",
        "dist",
        "top",
        "top",
        "children",
        "top",
        "left",
        "top",
        "right",
        "distance",
        "top",
        "distance",
        "children",
        "children",
        "distance",
        "top",
        "distance",
        "_insert",
        "top",
        "left",
        "_insert",
        "top",
        "right",
        "K",
        "top",
        "children",
        "K",
        "Warning",
        "top",
        "grandparent",
        "right",
        "right",
        "grandparent",
        "right",
        "distance",
        "grandparent",
        "right",
        "distance",
        "top",
        "observer",
        "Res",
        "distLimit",
        "atoms",
        "K",
        "atom",
        "atoms",
        "distLimit",
        "atom",
        "resName",
        "Res",
        "f",
        "euclideanDistance",
        "observer",
        "x",
        "observer",
        "y",
        "observer",
        "z",
        "atom",
        "x",
        "atom",
        "y",
        "atom",
        "z",
        "dist",
        "distLimit",
        "Node",
        "atom",
        "observer",
        "children",
        "K",
        "_insert",
        "curr",
        "Root",
        "_update",
        "curr",
        "K",
        "Root",
        "Root",
        "raw_input",
        "urllib",
        "urlretrieve",
        "pdbID",
        "pdbID",
        "pdbID",
        "readFile",
        "file",
        "IOError",
        "pdbID",
        "readFile",
        "file",
        "grabStandardAtomsFromPDB",
        "pdbData",
        "getSpecificAtom",
        "Atoms",
        "constraint",
        "sort",
        "len",
        "constraint",
        "treeTesting"
    ],
    "literals": [
        "\"\"",
        "\"\"",
        "\"Enter a pdb code: \"",
        "'http://files.rcsb.org/download/%s.pdb'",
        "'C:/Users/Brianna/Downloads/proteinDATA/%s.pdb'",
        "'C:/Users/blm7643/Downloads/proteinDATA/%s.pdb'",
        "'%s.pdb'",
        "\"CB\"",
        "\"GLU\"",
        "\"SG\"",
        "\"CB\"",
        "\"CA\"",
        "\"C\"",
        "\"N\"",
        "\"O\""
    ],
    "variables": [
        "tree",
        "children",
        "data",
        "left",
        "right",
        "distance",
        "top",
        "left",
        "top",
        "right",
        "grandparent",
        "grandparent",
        "grandparent",
        "right",
        "Root",
        "dist",
        "curr",
        "Root",
        "Root",
        "pdbID",
        "path",
        "file",
        "pdbData",
        "file",
        "pdbData",
        "Atoms",
        "desiredAtoms",
        "distance",
        "constraint",
        "K"
    ],
    "comments": [
        "Source : kdtreeCOPY.py ( equivalent to scipy.spatial.kdtree )",
        "Use: Help build KD_Tree",
        "Construct tree",
        "def _remove(self, top):",
        "# assume (for now) tree is balanced",
        "if self.children <= 1 or top.right == None:",
        "if top == None: # tree = 0",
        "raise Warning",
        "elif top.left == None and top.right == None: # tree = 1",
        "return None",
        "else: # tree has no right",
        "return top.left",
        "else:",
        "grandparent = top",
        "while grandparent.right.right != None:",
        "grandparent = grandparent.right",
        "grandparent.right = None",
        "return top",
        "assume (for now) tree is balanced",
        "kNN_resNames here to compare code structure"
    ],
    "docstrings": [
        "\"\"\"\n    Binary Heap\n    \"\"\"",
        "\"\"\"\ndef kNN_resNames(Atoms, K, distance, observer, resname):\n\n    # initialize root\n    neighbors = []\n    walking = []\n\n    # same\n    for atom in Atoms:\n            # same\n            if atom.resName.strip() == resname:\n                # same\n                d = euclideanDistance((atom.x, atom.y, atom.z), (observer.x, observer.y, observer.z))\n                # same\n                if d <= distance:\n                    # compare children to K\n                    if len(neighbors) < K:\n                        # _insert\n                        neighbors.append(atom.name)\n                        walking.append(d)\n                    # compare children to K\n                    elif len(neighbors) == K:\n                        # _update:\n\n                        # temp: top\n                        max = d\n                        marker = K+1\n                        # while loop moving only to right of tree structure until temp's right is None\n                        for PO in range(len(walking)):\n                            if max < walking[PO]:\n                                marker = PO\n                                max = walking[PO]\n                        if marker < K+1:\n                            neighbors[marker] = atom.name\n                            walking[marker] = d\n    # return tree\n    return neighbors\n\"\"\""
    ],
    "functions": [
        "_insert",
        "_update",
        "_construct",
        "treeTesting"
    ],
    "classes": [
        "KD_Tree",
        "Node"
    ]
}