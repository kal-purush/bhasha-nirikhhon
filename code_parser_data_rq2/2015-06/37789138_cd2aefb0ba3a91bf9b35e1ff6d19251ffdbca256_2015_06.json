{
    "identifiers": [
        "buffer_core",
        "buffer_core_array",
        "buffer_core_arraybuffer",
        "buffer_core_imagedata",
        "string_util",
        "buffer_core",
        "buffer_core_arraybuffer",
        "buffer_core_imagedata",
        "buffer_core_array",
        "buffer_core",
        "buffer_core",
        "buffer_core",
        "i",
        "i",
        "BufferCorePreferences",
        "i",
        "bci",
        "BufferCorePreferences",
        "i",
        "bci",
        "bci",
        "index",
        "index",
        "value",
        "buffer_core",
        "start",
        "end",
        "ab",
        "encoding",
        "size",
        "array",
        "obj",
        "encoding",
        "totalLength",
        "idx",
        "buffer_core",
        "size",
        "data",
        "data",
        "data",
        "data",
        "data",
        "encoding",
        "data",
        "buffer_core",
        "start",
        "end",
        "arg1",
        "arg2",
        "arg3",
        "Buffer",
        "Buffer",
        "arg1",
        "arg2",
        "arg1",
        "buffer_core",
        "buffer_core",
        "arg1",
        "arg2",
        "arg2",
        "arg3",
        "arg3",
        "start",
        "end",
        "start",
        "arg1",
        "arg1",
        "arg1",
        "arg1",
        "PreferredBufferCore",
        "arg1",
        "DataView",
        "arg1",
        "DataView",
        "buffer_core_arraybuffer",
        "arg1",
        "arg1",
        "ArrayBuffer",
        "arg1",
        "buffer_core_arraybuffer",
        "arg1",
        "arg1",
        "arg1",
        "Buffer",
        "arg1",
        "PreferredBufferCore",
        "arg1",
        "arg1",
        "argBuff",
        "arg1",
        "arg1",
        "arg1",
        "arg1",
        "PreferredBufferCore",
        "arg1",
        "i",
        "i",
        "arg1",
        "i",
        "i",
        "arg1",
        "i",
        "arg1",
        "arg1",
        "Buffer",
        "arg1",
        "arg2",
        "PreferredBufferCore",
        "arg1",
        "arg2",
        "arg1",
        "buffer_core",
        "index",
        "value",
        "value",
        "value",
        "index",
        "value",
        "index",
        "index",
        "index",
        "offset",
        "length",
        "encoding",
        "offset",
        "encoding",
        "offset",
        "offset",
        "length",
        "length",
        "encoding",
        "length",
        "length",
        "offset",
        "string_util",
        "encoding",
        "length",
        "length",
        "offset",
        "offset",
        "length",
        "offset",
        "strUtil",
        "offset",
        "length",
        "Buffer",
        "offset",
        "length",
        "offset",
        "encoding",
        "start",
        "end",
        "start",
        "end",
        "start",
        "end",
        "start",
        "end",
        "end",
        "end",
        "string_util",
        "encoding",
        "strUtil",
        "start",
        "end",
        "Buffer",
        "start",
        "end",
        "len",
        "i",
        "len",
        "i",
        "byteArr",
        "i",
        "i",
        "byteArr",
        "buffCore",
        "buffer_core_arraybuffer",
        "buffCore",
        "dv",
        "dv",
        "dv",
        "ab",
        "ab",
        "ab",
        "dv",
        "dv",
        "ArrayBuffer",
        "Buffer",
        "ab",
        "newBuff",
        "ab",
        "target",
        "targetStart",
        "sourceStart",
        "sourceEnd",
        "targetStart",
        "targetStart",
        "targetStart",
        "sourceStart",
        "sourceStart",
        "sourceStart",
        "sourceEnd",
        "sourceStart",
        "RangeError",
        "sourceEnd",
        "sourceStart",
        "targetStart",
        "target",
        "RangeError",
        "sourceStart",
        "RangeError",
        "sourceEnd",
        "RangeError",
        "sourceEnd",
        "sourceStart",
        "target",
        "targetStart",
        "sourceStart",
        "i",
        "i",
        "bytesCopied",
        "i",
        "target",
        "sourceStart",
        "i",
        "targetStart",
        "i",
        "i",
        "bytesCopied",
        "i",
        "bytesCopied",
        "i",
        "target",
        "sourceStart",
        "i",
        "targetStart",
        "i",
        "bytesCopied",
        "start",
        "end",
        "start",
        "start",
        "start",
        "start",
        "end",
        "end",
        "end",
        "end",
        "end",
        "end",
        "start",
        "end",
        "start",
        "end",
        "start",
        "end",
        "start",
        "end",
        "Buffer",
        "start",
        "end",
        "start",
        "end",
        "start",
        "start",
        "start",
        "start",
        "end",
        "end",
        "end",
        "end",
        "end",
        "end",
        "start",
        "end",
        "start",
        "end",
        "start",
        "end",
        "start",
        "end",
        "Buffer",
        "start",
        "end",
        "value",
        "offset",
        "end",
        "value",
        "valType",
        "value",
        "value",
        "offset",
        "end",
        "value",
        "offset",
        "end",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "value",
        "offset",
        "noAssert",
        "offset",
        "offset",
        "value",
        "enc",
        "string_util",
        "enc",
        "e",
        "obj",
        "obj",
        "Buffer",
        "encoding",
        "string_util",
        "encoding",
        "strUtil",
        "totalLength",
        "totalLength",
        "Buffer",
        "totalLength",
        "totalLength",
        "i",
        "i",
        "item",
        "i",
        "totalLength",
        "item",
        "Buffer",
        "totalLength",
        "j",
        "j",
        "item",
        "j",
        "curPos",
        "item",
        "buf",
        "curPos",
        "buf"
    ],
    "literals": [
        "'./buffer_core'",
        "'./buffer_core_array'",
        "'./buffer_core_arraybuffer'",
        "'./buffer_core_imagedata'",
        "'./string_util'",
        "\"This browser does not support any available BufferCore implementations.\"",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string",
        "'utf8'",
        "'number'",
        "'number'",
        "'number'",
        "'Buffer size must be a uint32.'",
        "'undefined'",
        "'undefined'",
        "'number'",
        "'object'",
        "'number'",
        "'string'",
        "\"Invalid argument to Buffer constructor: \"",
        "string",
        "'utf8'",
        "'string'",
        "\"\"",
        "'string'",
        "\"\"",
        "'utf8'",
        "string",
        "\"Invalid start/end positions: \"",
        "\" - \"",
        "''",
        "string",
        "'Buffer'",
        "'sourceEnd < sourceStart'",
        "'targetStart out of bounds'",
        "'sourceStart out of bounds'",
        "'sourceEnd out of bounds'",
        "\"Invalid slice indices.\"",
        "\"Invalid slice indices.\"",
        "\"string\"",
        "\"number\"",
        "'Invalid argument to fill.'",
        "string",
        "string",
        "string",
        "'utf8'"
    ],
    "variables": [
        "BufferCorePreferences",
        "PreferredBufferCore",
        "i",
        "bci",
        "i",
        "start",
        "end",
        "argBuff",
        "strUtil",
        "strUtil",
        "len",
        "byteArr",
        "i",
        "buffCore",
        "dv",
        "ab",
        "ab",
        "newBuff",
        "bytesCopied",
        "i",
        "i",
        "valType",
        "strUtil",
        "item",
        "i",
        "buf",
        "curPos",
        "j",
        "_",
        "Buffer"
    ],
    "comments": [
        "<reference path=\"../typings/tsd.d.ts\" />",
        "BC implementations earlier in the array are preferred.",
        "Should never happen; Array works in all browsers.",
        "It's not tractable to emulate array indexing by defining numeric properties",
        "for each index of the buffer, so we have getters/setters.",
        "Used by backends to get the backing data.",
        "Used by backends in conjunction with getBufferCore() and the length",
        "property to determine which segment of the backing memory is applicable",
        "for a given operation.",
        "Like Buffer.slice, but copies the Buffer contents.",
        "Note: This array property is *not* true, but it's required to satisfy",
        "TypeScript typings.",
        "Node apparently allows you to construct buffers w/o 'new'.",
        "constructor (data: buffer_core.BufferCore, start?: number, end?: number)",
        "constructor (size: number);",
        "constructor (data: DataView);",
        "constructor (data: ArrayBuffer);",
        "Note: Can't do 'instanceof ArrayBuffer' in Safari in some cases. :|",
        "constructor (data: Buffer);",
        "constructor (data: number[]);",
        "constructor (data: string, encoding?: string);",
        "In Node, the following happens:",
        "buffer[0] = -1;",
        "buffer[0]; // 255",
        "I hate Node's optional arguments.",
        "'str' and 'encoding' specified",
        "'str', 'offset', and 'encoding' specified",
        "Don't waste our time if the offset is beyond the buffer length",
        "Are we trying to write past the buffer?",
        "Avoid creating a slice unless it's needed.",
        "Get the string representation of the given slice. Create a new buffer",
        "if need be.",
        "Construct a byte array for the JSON 'data'.",
        "The Node code is weird. It sets some out-of-bounds args to their defaults",
        "and throws exceptions for others (sourceEnd).",
        "Need to sanity check all of the input. Node has really odd rules regarding",
        "when to apply default arguments. I decided to copy Node's logic.",
        "Copy as many 32-bit chunks as possible.",
        "TODO: Alignment.",
        "Copy any remaining bytes, if applicable",
        "Translate negative indices to positive ones.",
        "Sanity check.",
        "Create a new buffer backed by the same BufferCore.",
        "Translate negative indices to positive ones.",
        "Sanity check.",
        "Copy the BufferCore.",
        "Trim to a byte.",
        "Calculate totalLength",
        "Type-check the class."
    ],
    "docstrings": [
        "* Buffer module. Exports an appropriate version of Buffer for the current\n * platform.",
        "* We extend Node's buffer interface to account for differences in the browser\n * environment.",
        "* Superset of the Buffer singleton described in node.d.ts.",
        "* Emulates Node's Buffer API. Wraps a BufferCore object that is responsible\n * for actually writing/reading data from some data representation in memory.",
        "* Constructs a buffer.\n   * @param {(number|DataView|ArrayBuffer|Buffer|string)} arg1 - Instantiate a buffer of the indicated size, or\n   *   from the indicated Array or String.\n   * @param {string} [arg2=utf8] - Encoding to use if arg1 is a string",
        "* **NONSTANDARD**: Set the octet at index. Emulates NodeJS buffer's index\n   * operation. Octet can be signed or unsigned.\n   * @param {number} index - the index to set the value at\n   * @param {number} value - the value to set at the given index",
        "* **NONSTANDARD**: Get the octet at index.\n   * @param {number} index - index to fetch the value at\n   * @return {number} the value at the given index",
        "* Writes string to the buffer at offset using the given encoding.\n   * If buffer did not contain enough space to fit the entire string, it will\n   * write a partial amount of the string.\n   * @param {string} str - Data to be written to buffer\n   * @param {number} [offset=0] - Offset in the buffer to write to\n   * @param {number} [length=this.length] - Number of bytes to write\n   * @param {string} [encoding=utf8] - Character encoding\n   * @return {number} Number of octets written.",
        "* Decodes a portion of the Buffer into a String.\n   * @param {string} encoding - Character encoding to decode to\n   * @param {number} [start=0] - Start position in the buffer\n   * @param {number} [end=this.length] - Ending position in the buffer\n   * @return {string} A string from buffer data encoded with encoding, beginning\n   *   at start, and ending at end.",
        "* Returns a JSON-representation of the Buffer instance, which is identical to\n   * the output for JSON Arrays. JSON.stringify implicitly calls this function\n   * when stringifying a Buffer instance.\n   * @return {object} An object that can be used for JSON stringification.",
        "* Converts the buffer into an ArrayBuffer. Will attempt to use an underlying\n   * ArrayBuffer, but will need to copy the data if the underlaying object is an\n   * ArrayBufferView or not an ArrayBuffer.",
        "* Does copy between buffers. The source and target regions can be overlapped.\n   * All values passed that are undefined/NaN or are out of bounds are set equal\n   * to their respective defaults.\n   * @param {Buffer} target - Buffer to copy into\n   * @param {number} [targetStart=0] - Index to start copying to in the targetBuffer\n   * @param {number} [sourceStart=0] - Index in this buffer to start copying from\n   * @param {number} [sourceEnd=this.length] - Index in this buffer stop copying at\n   * @return {number} The number of bytes copied into the target buffer.",
        "* Returns a slice of this buffer.\n   * @param {number} [start=0] - Index to start slicing from\n   * @param {number} [end=this.length] - Index to stop slicing at\n   * @return {Buffer} A new buffer which references the same\n   *   memory as the old, but offset and cropped by the start (defaults to 0) and\n   *   end (defaults to buffer.length) indexes. Negative indexes start from the end\n   *   of the buffer.",
        "* [NONSTANDARD] A copy-based version of Buffer.slice.",
        "* Fills the buffer with the specified value. If the offset and end are not\n   * given it will fill the entire buffer.\n   * @param {(string|number)} value - The value to fill the buffer with\n   * @param {number} [offset=0]\n   * @param {number} [end=this.length]",
        "**************************STATIC METHODS********************************///",
        "* Checks if enc is a valid string encoding type.\n   * @param {string} enc - Name of a string encoding type.\n   * @return {boolean} Whether or not enc is a valid encoding type.",
        "* Tests if obj is a Buffer.\n   * @param {object} obj - An arbitrary object\n   * @return {boolean} True if this object is a Buffer.",
        "* Gives the actual byte length of a string. This is not the same as\n   * String.prototype.length since that returns the number of characters in a\n   * string.\n   * @param {string} str - The string to get the byte length of\n   * @param {string} [encoding=utf8] - Character encoding of the string\n   * @return {number} The number of bytes in the string",
        "* Returns a buffer which is the result of concatenating all the buffers in the\n   * list together.\n   * If the list has no items, or if the totalLength is 0, then it returns a\n   * zero-length buffer.\n   * If the list has exactly one item, then the first item of the list is\n   * returned.\n   * If the list has more than one item, then a new Buffer is created.\n   * If totalLength is not provided, it is read from the buffers in the list.\n   * However, this adds an additional loop to the function, so it is faster to\n   * provide the length explicitly.\n   * @param {Buffer[]} list - List of Buffer objects to concat\n   * @param {number} [totalLength] - Total length of the buffers when concatenated\n   * @return {Buffer}"
    ],
    "functions": [
        "getBufferCore",
        "getOffset",
        "get",
        "write",
        "toString",
        "toJSON",
        "toArrayBuffer",
        "copy",
        "sliceCopy",
        "fill",
        "readUInt8",
        "readUInt16LE",
        "readUInt16BE",
        "readUInt32LE",
        "readUInt32BE",
        "readInt8",
        "readInt16LE",
        "readInt16BE",
        "readInt32LE",
        "readInt32BE",
        "readFloatLE",
        "readFloatBE",
        "readDoubleLE",
        "readDoubleBE",
        "writeUInt8",
        "writeUInt16LE",
        "writeUInt16BE",
        "writeUInt32LE",
        "writeUInt32BE",
        "writeInt8",
        "writeInt16LE",
        "writeInt16BE",
        "writeInt32LE",
        "writeInt32BE",
        "writeFloatLE",
        "writeFloatBE",
        "writeDoubleLE",
        "writeDoubleBE",
        "isEncoding",
        "isBuffer",
        "byteLength",
        "concat"
    ],
    "classes": [
        "Buffer"
    ]
}