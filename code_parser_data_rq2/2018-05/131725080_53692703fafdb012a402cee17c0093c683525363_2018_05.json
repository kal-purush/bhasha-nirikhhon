{
    "identifiers": [
        "BarcodeFormat",
        "BinaryBitmap",
        "BitArray",
        "DecodeHintType",
        "Reader",
        "Result",
        "ResultMetadataType",
        "ResultPoint",
        "OneDReader",
        "StringBuilder",
        "start",
        "OneDReader",
        "rowNumber",
        "row",
        "hints",
        "row",
        "row",
        "StringBuilder",
        "ITFReader",
        "row",
        "startRange",
        "endRange",
        "result",
        "result",
        "hints",
        "allowedLengths",
        "hints",
        "DecodeHintType",
        "allowedLengths",
        "allowedLengths",
        "ITFReader",
        "resultString",
        "value",
        "allowedLengths",
        "length",
        "value",
        "lengthOK",
        "value",
        "maxAllowedLength",
        "maxAllowedLength",
        "value",
        "lengthOK",
        "length",
        "maxAllowedLength",
        "lengthOK",
        "lengthOK",
        "ResultPoint",
        "startRange",
        "rowNumber",
        "ResultPoint",
        "endRange",
        "rowNumber",
        "Result",
        "resultString",
        "points",
        "BarcodeFormat",
        "resultReturn",
        "resultReturn",
        "row",
        "payloadStart",
        "payloadEnd",
        "resultString",
        "counterDigitPair",
        "counterBlack",
        "counterWhite",
        "payloadStart",
        "payloadEnd",
        "OneDReader",
        "row",
        "payloadStart",
        "counterDigitPair",
        "k",
        "k",
        "k",
        "counterBlack",
        "k",
        "counterDigitPair",
        "twoK",
        "counterWhite",
        "k",
        "counterDigitPair",
        "twoK",
        "ITFReader",
        "counterBlack",
        "resultString",
        "bestMatch",
        "bestMatch",
        "counterWhite",
        "resultString",
        "bestMatch",
        "counterDigitPair",
        "counterDigit",
        "payloadStart",
        "counterDigit",
        "row",
        "ITFReader",
        "row",
        "ITFReader",
        "row",
        "endStart",
        "ITFReader",
        "startPattern",
        "startPattern",
        "startPattern",
        "startPattern",
        "row",
        "startPattern",
        "startPattern",
        "row",
        "startPattern",
        "quietCount",
        "quietCount",
        "startPattern",
        "quietCount",
        "startPattern",
        "startPattern",
        "quietCount",
        "i",
        "i",
        "row",
        "i",
        "quietCount",
        "quietCount",
        "row",
        "row",
        "row",
        "endStart",
        "width",
        "endStart",
        "row",
        "row",
        "ITFReader",
        "row",
        "endPattern",
        "ITFReader",
        "row",
        "endStart",
        "ITFReader",
        "NotFoundException",
        "endPattern",
        "ITFReader",
        "row",
        "endStart",
        "ITFReader",
        "row",
        "endPattern",
        "endPattern",
        "endPattern",
        "row",
        "endPattern",
        "endPattern",
        "row",
        "temp",
        "endPattern",
        "row",
        "row",
        "rowOffset",
        "pattern",
        "pattern",
        "patternLength",
        "row",
        "counters",
        "counters",
        "patternLength",
        "rowOffset",
        "x",
        "width",
        "x",
        "row",
        "x",
        "isWhite",
        "counters",
        "counterPosition",
        "counterPosition",
        "patternLength",
        "counters",
        "OneDReader",
        "counters",
        "pattern",
        "ITFReader",
        "ITFReader",
        "patternStart",
        "x",
        "returnArray",
        "returnArray",
        "counters",
        "counters",
        "patternStart",
        "counters",
        "counters",
        "counters",
        "counters",
        "counterPosition",
        "counters",
        "counterPosition",
        "counters",
        "counterPosition",
        "counterPosition",
        "counterPosition",
        "counters",
        "counterPosition",
        "isWhite",
        "isWhite",
        "counters",
        "ITFReader",
        "ITFReader",
        "i",
        "max",
        "i",
        "ITFReader",
        "i",
        "OneDReader",
        "counters",
        "pattern",
        "ITFReader",
        "variance",
        "bestVariance",
        "bestVariance",
        "variance",
        "bestMatch",
        "i",
        "variance",
        "bestVariance",
        "bestMatch",
        "bestMatch",
        "bestMatch"
    ],
    "literals": [
        "'../BarcodeFormat'",
        "'../BinaryBitmap'",
        "'../common/BitArray'",
        "'../DecodeHintType'",
        "'../Exception'",
        "'../Reader'",
        "'../Result'",
        "'../ResultMetadataType'",
        "'../ResultPoint'",
        "'./OneDReader'",
        "\"../util/StringBuilder\"",
        "\"../util/System\"",
        "\"repl\"",
        "\"Decoding start...\"",
        "\"Decoding end...\"",
        "\"Decoding middle...\"",
        "string",
        "'Length is NOT ok'",
        "\"Result: \"",
        "'finding guard pattern'",
        "\"found guard pattern\"",
        "\"For zone: (0) \"",
        "\"(1) \"",
        "'Validating Quiet Zone'",
        "\"quiet\"",
        "\"NOT QUIET\"",
        "\"Row Offset: \"",
        "\"moving on\"",
        "\" \""
    ],
    "variables": [
        "startRange",
        "endRange",
        "result",
        "resultString",
        "allowedLengths",
        "length",
        "lengthOK",
        "maxAllowedLength",
        "points",
        "resultReturn",
        "counterDigitPair",
        "counterBlack",
        "counterWhite",
        "k",
        "twoK",
        "bestMatch",
        "endStart",
        "startPattern",
        "quietCount",
        "i",
        "width",
        "endStart",
        "endStart",
        "endPattern",
        "temp",
        "patternLength",
        "counters",
        "width",
        "isWhite",
        "counterPosition",
        "patternStart",
        "rowOffset",
        "x",
        "rowOffset",
        "returnArray",
        "bestVariance",
        "bestMatch",
        "max",
        "i",
        "pattern",
        "variance"
    ],
    "comments": [
        "namespace com.google.zxing.oned {",
        "Pixel width of a 3x wide line",
        "Pixel width of a 2x wide line",
        "Pixed width of a narrow line",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "/!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/",
        "Stores the actual narrow line width of the image being decoded.",
        "/!**\n     * Start/end guard pattern.\n     *\n     * Note: The end pattern is reversed because the row is reversed before\n     * searching for the END_PATTERN\n     *!/",
        "2x",
        "3x",
        "See ITFWriter.PATTERNS",
        "/!**\n     * Patterns of Wide / Narrow lines to indicate each digit\n     *!/",
        "Find out where the Middle section (payload) starts & ends",
        "To avoid false positives with 2D barcodes (and other patterns), make",
        "an assumption that the decoded string must be a 'standard' length if it's short",
        "no natural byte representation for these barcodes",
        "/!**\n     * @param row          row of black/white values to search\n     * @param payloadStart offset of start pattern\n     * @param resultString {@link StringBuilder} to append decoded chars to\n     * @throws NotFoundException if decoding could not complete successfully\n     *!/",
        "Digits are interleaved in pairs - 5 black lines for one digit, and the",
        "5",
        "interleaved white lines for the second digit.",
        "Therefore, need to scan 10 lines and then",
        "split these into two arrays",
        "10",
        "5",
        "5",
        "Get 10 runs of black/white.",
        "Split them into each array",
        "/!**\n     * Identify where the start of the middle / payload section starts.\n     *\n     * @param row row of black/white values to search\n     * @return Array, containing index of start of 'start block' and end of\n     *         'start block'\n     *!/",
        "Determine the width of a narrow line in pixels. We can do this by",
        "getting the width of the start pattern and dividing by 4 because its",
        "made up of 4 narrow lines.",
        "/!**\n     * The start & end patterns must be pre/post fixed by a quiet zone. This\n     * zone must be at least 10 times the width of a narrow line.  Scan back until\n     * we either get to the start of the barcode or match the necessary number of\n     * quiet zone pixels.\n     *\n     * Note: Its assumed the row is reversed when using this method to find\n     * quiet zone after the end pattern.\n     *\n     * ref: http://www.barcode-1.net/i25code.html\n     *\n     * @param row bit array representing the scanned barcode.\n     * @param startPattern index into row of the start or end pattern.\n     * @throws NotFoundException if the quiet zone cannot be found\n     *!/",
        "expect to find this many pixels of quiet zone",
        "if there are not so many pixel at all let's try as many as possible",
        "Unable to find the necessary number of quiet zone pixels.",
        "/!**\n     * Skip all whitespace until we get to the first black line.\n     *\n     * @param row row of black/white values to search\n     * @return index of the first black line.\n     * @throws NotFoundException Throws exception if no black lines are found in the row\n     *!/",
        "/!**\n     * Identify where the end of the middle / payload section ends.\n     *\n     * @param row row of black/white values to search\n     * @return Array, containing index of start of 'end block' and end of 'end\n     *         block'\n     *!/",
        "For convenience, reverse the row and then",
        "search from 'the start' for the end block",
        "The start & end patterns must be pre/post fixed by a quiet zone. This",
        "zone must be at least 10 times the width of a narrow line.",
        "ref: http://www.barcode-1.net/i25code.html",
        "Now recalculate the indices of where the 'endblock' starts & stops to",
        "accommodate",
        "the reversed nature of the search",
        "Put the row back the right way.",
        "/!**\n     * @param row       row of black/white values to search\n     * @param rowOffset position to start search\n     * @param pattern   pattern of counts of number of black and white pixels that are\n     *                  being searched for as a pattern\n     * @return start/end horizontal offset of guard pattern, as an array of two\n     *         ints\n     * @throws NotFoundException if pattern is not found\n     *!/",
        "/!**\n     * Attempts to decode a sequence of ITF black/white lines into single\n     * digit.\n     *\n     * @param counters the counts of runs of observed black/white/black/... values\n     * @return The decoded digit\n     * @throws NotFoundException if digit cannot be decoded\n     *!/",
        "worst variance we'll accept",
        "if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match"
    ],
    "docstrings": [
        "* Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.",
        "* <p>Decodes Code 128 barcodes.</p>\n *\n * @author Tjieco"
    ],
    "functions": [
        "decodeRow",
        "decodeMiddle",
        "decodeStart",
        "validateQuietZone",
        "skipWhiteSpace",
        "decodeEnd",
        "findGuardPattern",
        "decodeDigit"
    ],
    "classes": [
        "ITFReader"
    ]
}