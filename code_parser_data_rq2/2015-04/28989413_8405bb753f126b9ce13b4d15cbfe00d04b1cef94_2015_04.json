{
    "identifiers": [
        "com",
        "swrve",
        "ratelimitedlogger",
        "com",
        "google",
        "common",
        "Objects",
        "com",
        "google",
        "common",
        "Optional",
        "com",
        "google",
        "common",
        "Stopwatch",
        "net",
        "jcip",
        "annotations",
        "GuardedBy",
        "net",
        "jcip",
        "annotations",
        "ThreadSafe",
        "org",
        "joda",
        "time",
        "Duration",
        "org",
        "slf4j",
        "Logger",
        "javax",
        "annotation",
        "java",
        "util",
        "concurrent",
        "TimeUnit",
        "java",
        "util",
        "concurrent",
        "atomic",
        "AtomicLong",
        "ThreadSafe",
        "NOT_RATE_LIMITED_YET",
        "RATE_LIMITED_COUNT_SUFFIX",
        "message",
        "level",
        "rateAndPeriod",
        "logger",
        "stats",
        "stopwatch",
        "counter",
        "rateLimitedAt",
        "NOT_RATE_LIMITED_YET",
        "message",
        "level",
        "rateAndPeriod",
        "stats",
        "stopwatch",
        "logger",
        "message",
        "message",
        "level",
        "level",
        "rateAndPeriod",
        "rateAndPeriod",
        "logger",
        "logger",
        "stats",
        "stats",
        "stopwatch",
        "stopwatch",
        "args",
        "isRateLimited",
        "LogLevelHelper",
        "log",
        "logger",
        "level",
        "message",
        "args",
        "incrementStats",
        "count",
        "counter",
        "incrementAndGet",
        "count",
        "rateAndPeriod",
        "maxRate",
        "count",
        "rateAndPeriod",
        "maxRate",
        "rateLimitedAt",
        "get",
        "NOT_RATE_LIMITED_YET",
        "haveJustExceededRateLimit",
        "whenLimited",
        "rateLimitedAt",
        "getAndSet",
        "NOT_RATE_LIMITED_YET",
        "whenLimited",
        "NOT_RATE_LIMITED_YET",
        "reportSuppression",
        "whenLimited",
        "GuardedBy",
        "whenLimited",
        "count",
        "counter",
        "get",
        "counter",
        "addAndGet",
        "count",
        "numSuppressed",
        "count",
        "rateAndPeriod",
        "maxRate",
        "numSuppressed",
        "howLong",
        "whenLimited",
        "elapsedMsecs",
        "LogLevelHelper",
        "log",
        "logger",
        "level",
        "numSuppressed",
        "message",
        "howLong",
        "rateLimitedAt",
        "elapsedMsecs",
        "elapsed",
        "stopwatch",
        "elapsed",
        "TimeUnit",
        "MILLISECONDS",
        "elapsed",
        "NOT_RATE_LIMITED_YET",
        "elapsed",
        "elapsed",
        "stats",
        "isPresent",
        "stats",
        "get",
        "increment",
        "level",
        "getLevelName",
        "RATE_LIMITED_COUNT_SUFFIX",
        "Override",
        "o",
        "o",
        "o",
        "getClass",
        "o",
        "getClass",
        "other",
        "o",
        "other",
        "level",
        "level",
        "message",
        "equals",
        "other",
        "message",
        "Override",
        "Objects",
        "hashCode",
        "message",
        "level",
        "ordinal"
    ],
    "literals": [
        "\"_rate_limited_log_count\"",
        "\"this\"",
        "\"(suppressed {} logs similar to '{}' in {})\""
    ],
    "variables": [
        "message",
        "level",
        "rateAndPeriod",
        "logger",
        "stats",
        "stopwatch",
        "args"
    ],
    "comments": [
        "mutable",
        "mutable",
        "note: this method is not synchronized, for performance.  If we exceed the maxRate, we will start checking",
        "haveExceededLimit, and if that's still false, we enter the synchronized haveJustExceededRateLimit() method.",
        "",
        "There is still potential for a race -- the rate of incrementing could be so high that we are already",
        "over the maxRate by the time the reset thread runs, but the haveJustExceededRateLimit() hasn't yet been",
        "run in this thread. In this scenario, we will fail to notice that we are over the limit, but when",
        "the next iteration runs, we will correctly report the correct number of suppressions and the time",
        "when haveJustExceededRateLimit() eventually got to execute.  We will also potentially log a small",
        "number more lines to the logger than the rate limit allows.",
        "",
        "we still issue this final log, though",
        "special case: we hit the rate limit, but did not actually exceed it -- nothing got suppressed, so there's no need to log",
        "avoid using the magic value by \"rounding up\""
    ],
    "docstrings": [
        "* An individual log pattern and level - the unit of rate limiting.  Each object is rate-limited\n * individually.\n * <p/>\n * Thread-safe.",
        "* Number of observed logs in the current time period based on the log level.",
        "* When we exceed the rate limit during a period, we record when.  If the rate limit has not been exceeded, the\n     * magic value of NOT_RATE_LIMITED_YET will be recorded.",
        "* logging APIs.\n     * <p/>\n     * These can use the SLF4J style of templating to parameterize the Logs.\n     * See http://www.slf4j.org/api/org/slf4j/helpers/MessageFormatter.html .\n     * <p/>\n     * <pre>\n     *    rateLimitedLog.info(\"Just saw an event of type {}: {}\", event.getType(), event);\n     * </pre>\n     *\n     * @param args the varargs list of arguments matching the message template",
        "* Reset the counter and suppression details, if necessary.  This is called once every period, by the Registry.",
        "* Increment a counter metric called \"{level}_rate_limited_log_count\", where \"{level}\" is the log\n     * level in question.  This is still performed even when a log is rate limited, since incrementing\n     * a counter metric is cheap!\n     * <p/>\n     * This deliberately doesn't attempt to use counter metrics named after the log message, since\n     * extracting that without making a mess is complex, and if that's desired, it's easy enough\n     * for calling code to do it instead.  As an \"early warning\" indicator that lots of logging\n     * activity took place, this is useful enough.",
        "* Two RateLimitedLogWithPattern objects are considered equal if their messages match; the\n     * RateAndPeriods are not significant."
    ],
    "functions": [
        "LogWithPatternAndLevel",
        "log",
        "isRateLimited",
        "periodicReset",
        "reportSuppression",
        "haveJustExceededRateLimit",
        "elapsedMsecs",
        "incrementStats",
        "equals",
        "hashCode"
    ],
    "classes": [
        "LogWithPatternAndLevel"
    ]
}