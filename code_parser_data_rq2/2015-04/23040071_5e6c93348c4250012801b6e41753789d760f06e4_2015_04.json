{
    "identifiers": [
        "com",
        "google",
        "inject",
        "com",
        "google",
        "common",
        "Preconditions",
        "com",
        "google",
        "common",
        "collect",
        "ImmutableListMultimap",
        "com",
        "google",
        "common",
        "collect",
        "ListMultimap",
        "com",
        "google",
        "common",
        "collect",
        "Lists",
        "com",
        "google",
        "common",
        "collect",
        "Maps",
        "com",
        "google",
        "common",
        "collect",
        "Multimap",
        "com",
        "google",
        "common",
        "collect",
        "MultimapBuilder",
        "java",
        "util",
        "Collection",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "concurrent",
        "locks",
        "Lock",
        "java",
        "util",
        "concurrent",
        "locks",
        "ReentrantLock",
        "CycleDetectingLock",
        "lockThreadIsWaitingOn",
        "Maps",
        "newHashMap",
        "locksOwnedByThread",
        "MultimapBuilder",
        "linkedHashKeys",
        "linkedHashSetValues",
        "build",
        "newLockId",
        "newLockId",
        "lockImplementation",
        "userLockId",
        "lockOwnerThreadId",
        "lockReentranceCount",
        "userLockId",
        "lockImplementation",
        "userLockId",
        "Preconditions",
        "checkNotNull",
        "userLockId",
        "lockImplementation",
        "Preconditions",
        "checkNotNull",
        "lockImplementation",
        "Override",
        "currentThreadId",
        "currentThread",
        "getId",
        "CycleDetectingLockFactory",
        "checkState",
        "locksInCycle",
        "detectPotentialLocksCycle",
        "locksInCycle",
        "isEmpty",
        "locksInCycle",
        "lockThreadIsWaitingOn",
        "put",
        "currentThreadId",
        "lockImplementation",
        "CycleDetectingLockFactory",
        "lockThreadIsWaitingOn",
        "remove",
        "currentThreadId",
        "checkState",
        "lockOwnerThreadId",
        "currentThreadId",
        "lockReentranceCount",
        "locksOwnedByThread",
        "put",
        "currentThreadId",
        "ImmutableListMultimap",
        "of",
        "Override",
        "currentThreadId",
        "currentThread",
        "getId",
        "CycleDetectingLockFactory",
        "checkState",
        "Preconditions",
        "checkState",
        "lockOwnerThreadId",
        "Preconditions",
        "checkState",
        "lockOwnerThreadId",
        "currentThreadId",
        "lockImplementation",
        "unlock",
        "lockReentranceCount",
        "lockReentranceCount",
        "lockOwnerThreadId",
        "Preconditions",
        "checkState",
        "locksOwnedByThread",
        "remove",
        "currentThreadId",
        "locksOwnedByThread",
        "get",
        "currentThreadId",
        "isEmpty",
        "locksOwnedByThread",
        "removeAll",
        "currentThreadId",
        "currentThreadId",
        "currentThread",
        "getId",
        "Preconditions",
        "checkState",
        "lockThreadIsWaitingOn",
        "containsKey",
        "currentThreadId",
        "lockOwnerThreadId",
        "Preconditions",
        "checkState",
        "lockReentranceCount",
        "Preconditions",
        "checkState",
        "locksOwnedByThread",
        "get",
        "lockOwnerThreadId",
        "contains",
        "Preconditions",
        "checkState",
        "lockReentranceCount",
        "Preconditions",
        "checkState",
        "locksOwnedByThread",
        "values",
        "contains",
        "currentThreadId",
        "currentThread",
        "getId",
        "lockOwnerThreadId",
        "lockOwnerThreadId",
        "currentThreadId",
        "ImmutableListMultimap",
        "of",
        "potentialLocksCycle",
        "MultimapBuilder",
        "linkedHashKeys",
        "arrayListValues",
        "build",
        "lockOwnerWaitingOn",
        "lockOwnerWaitingOn",
        "lockOwnerWaitingOn",
        "lockOwnerThreadId",
        "threadOwnerThreadWaits",
        "lockOwnerWaitingOn",
        "lockOwnerThreadId",
        "potentialLocksCycle",
        "putAll",
        "threadOwnerThreadWaits",
        "getAllLockIdsAfter",
        "threadOwnerThreadWaits",
        "lockOwnerWaitingOn",
        "threadOwnerThreadWaits",
        "currentThreadId",
        "potentialLocksCycle",
        "lockOwnerWaitingOn",
        "lockThreadIsWaitingOn",
        "get",
        "threadOwnerThreadWaits",
        "ImmutableListMultimap",
        "of",
        "threadId",
        "ids",
        "Lists",
        "newArrayList",
        "found",
        "ownedLocks",
        "locksOwnedByThread",
        "get",
        "threadId",
        "Preconditions",
        "checkNotNull",
        "ownedLocks",
        "ownedLock",
        "ownedLocks",
        "ownedLock",
        "found",
        "found",
        "ids",
        "add",
        "ownedLock",
        "userLockId",
        "Preconditions",
        "checkState",
        "found",
        "ids",
        "Override",
        "localLockOwnerThreadId",
        "lockOwnerThreadId",
        "localLockOwnerThreadId",
        "format",
        "userLockId",
        "localLockOwnerThreadId",
        "format",
        "userLockId"
    ],
    "literals": [
        "\"userLockId\"",
        "\"lockImplementation\"",
        "\"Thread is trying to unlock a lock that is not locked\"",
        "\"Thread is trying to unlock a lock owned by another thread\"",
        "\"Internal error: Can not find this lock in locks owned by a current thread\"",
        "\"Internal error: Thread should not be in a waiting thread on a lock now\"",
        "\"Internal error: Lock ownership and reentrance count internal states do not match\"",
        "\"Internal error: Set of locks owned by a current thread and lock \"",
        "\"ownership status do not match\"",
        "\"Internal error: Reentrance count of a non locked lock is expect to be zero\"",
        "\"Internal error: Non locked lock should not be owned by any thread\"",
        "\"Internal error: No locks were found taken by a thread\"",
        "\"Internal error: We can not find locks that \"",
        "\"created a cycle that we detected\"",
        "\"CycleDetectingLock[%s][locked by %s]\"",
        "\"CycleDetectingLock[%s][unlocked]\""
    ],
    "variables": [
        "lockImplementation",
        "userLockId"
    ],
    "comments": [
        "potential deadlock is found, we don't try to take this lock",
        "this may be blocking, but we don't expect it to cause a deadlock",
        "current thread is no longer waiting on this lock",
        "mark it as owned by us",
        "add this lock to the list of locks owned by a current thread",
        "no deadlock is found, locking successful",
        "releasing underlying lock",
        "be sure to release the lock synchronously with updating internal state",
        "we no longer own this lock",
        "clearing memory",
        "check state of a locked lock",
        "check state of a non locked lock",
        "if nobody owns this lock, lock cycle is impossible",
        "if a current thread owns this lock, we let Guice to handle it",
        "lock that is a part of a potential locks cycle, starts with current lock",
        "try to find a dependency path between lock's owner thread and a current thread",
        "in case locks cycle exists lock we're waiting for is part of it",
        "owner thread depends on current thread, cycle detected",
        "going for the next thread we wait on indirectly",
        "no dependency path from an owner thread to a current thread",
        "copy is made to prevent a data race",
        "no synchronization is used, potentially stale data, should be good enough"
    ],
    "docstrings": [
        "* Simplified version of {@link Lock} that is special due to how it handles deadlocks detection.\n *\n * <p>Is an inherent part of {@link SingletonScope}, moved into a upper level class due\n * to its size and complexity.\n *\n * @param <ID> Lock identification provided by the client, is returned unmodified to the client\n *        when lock cycle is detected to identify it. Only toString() needs to be implemented.\n *        Lock references this object internally,\n *        for the purposes of Garbage Collection you should not use heavy IDs.\n *        Lock is referenced by a lock factory as long as it's owned by a thread.\n *\n * @see SingletonScope\n * @see com.google.inject.internal.CycleDetectingLock.CycleDetectingLockFactory\n *\n * @author timofeyb (Timothy Basanov)",
        "* Takes a lock in a blocking fashion in case no potential deadlocks are detected.\n   * If the lock was successfully owned, returns an empty map indicating no detected potential\n   * deadlocks.\n   *\n   * Otherwise, a map indicating threads involved in a potential deadlock are returned.\n   * Map is ordered by dependency cycle and lists locks for each thread that are part of\n   * the loop in order. Returned map is created atomically.\n   *\n   * In case no cycle is detected performance is O(threads creating singletons),\n   * in case cycle is detected performance is O(singleton locks).",
        "* Unlocks previously locked lock.",
        "* Wraps locks so they would never cause a deadlock. On each\n   * {@link CycleDetectingLock#lockOrDetectPotentialLocksCycle} we check for dependency cycles\n   * within locks created by the same factory. Either we detect a cycle and return it\n   * or take it atomically.\n   *\n   * <p>Important to note that we do not prevent deadlocks in the client code. As an example:\n   * Thread A takes lock L and creates singleton class CA depending on the singleton class CB.\n   * Meanwhile thread B is creating class CB and is waiting on the lock L. Issue happens\n   * due to client code creating interdependent classes and using locks, where\n   * no guarantees on the creation order from Guice are provided.\n   *\n   * <p>Instances of these locks are not intended to be exposed outside of {@link SingletonScope}.",
        "* Specifies lock that thread is currently waiting on to own it.\n     * Used only for purposes of locks cycle detection.\n     *\n     * Key: thread id\n     * Value: lock that is being waited on\n     *\n     * Element is added inside {@link #lockOrDetectPotentialLocksCycle()} before {@link Lock#lock}\n     * is called. Element is removed inside {@link #lockOrDetectPotentialLocksCycle()} after\n     * {@link Lock#lock} and synchronously with adding it to {@link #locksOwnedByThread}.\n     *\n     * Same lock can be added for several threads in case all of them are trying to\n     * take it.\n     *\n     * Guarded by {@code this}.",
        "* Lists locks that thread owns.\n     * Used only to populate locks in a potential cycle when it is detected.\n     *\n     * Key: thread id\n     * Value: stack of locks that were owned.\n     *\n     * Element is added inside {@link #lockOrDetectPotentialLocksCycle()} after {@link Lock#lock}\n     * is called. Element is removed inside {@link #unlock()} synchronously with\n     * {@link Lock#unlock()} call.\n     *\n     * Same lock can only be present several times for the same thread as locks are\n     * reentrant. Lock can not be owned by several different threads as the same time.\n     *\n     * Guarded by {@code this}.",
        "* Creates new lock within this factory context. We can guarantee that locks created by\n     * the same factory would not deadlock.\n     *\n     * @param newLockId lock id that would be used to report lock cycles if detected",
        "The implementation for {@link CycleDetectingLock}.",
        "Underlying lock used for actual waiting when no potential deadlocks are detected.",
        "User id for this lock.",
        "* Thread id for the thread that owned this lock. Nullable.\n       * Guarded by {@code CycleDetectingLockFactory.this}.",
        "* Number of times that thread owned this lock.\n       * Guarded by {@code CycleDetectingLockFactory.this}.",
        "Check consistency of an internal state.",
        "* Algorithm to detect a potential lock cycle.\n       *\n       * For lock's thread owner check which lock is it trying to take.\n       * Repeat recursively. When current thread is found a potential cycle is detected.\n       *\n       * @see CycleDetectingLock#lockOrDetectPotentialLocksCycle()",
        "Return locks owned by a thread after a lock specified, inclusive."
    ],
    "functions": [
        "lockOrDetectPotentialLocksCycle",
        "unlock",
        "create",
        "ReentrantCycleDetectingLock",
        "lockOrDetectPotentialLocksCycle",
        "unlock",
        "checkState",
        "detectPotentialLocksCycle",
        "getAllLockIdsAfter",
        "toString"
    ],
    "classes": [
        "CycleDetectingLockFactory",
        "ReentrantCycleDetectingLock"
    ]
}