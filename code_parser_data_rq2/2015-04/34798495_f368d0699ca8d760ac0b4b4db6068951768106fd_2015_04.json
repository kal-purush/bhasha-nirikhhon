{
    "identifiers": [
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "angular",
        "p",
        "p",
        "p",
        "arg",
        "name",
        "reason",
        "arg",
        "ngMinErr",
        "name",
        "reason",
        "arg",
        "a",
        "b",
        "a",
        "b",
        "a",
        "b",
        "b",
        "a",
        "isArray",
        "a",
        "a",
        "a",
        "isArray",
        "b",
        "b",
        "b",
        "a",
        "b",
        "options",
        "options",
        "options",
        "options",
        "styles",
        "options",
        "styles",
        "options",
        "styles",
        "classes",
        "fix",
        "isPrefix",
        "classes",
        "isArray",
        "classes",
        "classes",
        "classes",
        "isString",
        "classes",
        "classes",
        "classes",
        "forEach",
        "classes",
        "klass",
        "i",
        "klass",
        "klass",
        "className",
        "i",
        "className",
        "isPrefix",
        "fix",
        "klass",
        "klass",
        "fix",
        "className",
        "arr",
        "val",
        "arr",
        "val",
        "val",
        "arr",
        "index",
        "element",
        "element",
        "ELEMENT_NODE",
        "jqLite",
        "element",
        "element",
        "element",
        "element",
        "ELEMENT_NODE",
        "element",
        "jqLite",
        "extractElementNode",
        "element",
        "element",
        "element",
        "element",
        "i",
        "element",
        "i",
        "element",
        "i",
        "elm",
        "ELEMENT_NODE",
        "elm",
        "$$jqLite",
        "element",
        "className",
        "forEach",
        "element",
        "elm",
        "$$jqLite",
        "elm",
        "className",
        "$$jqLite",
        "element",
        "className",
        "forEach",
        "element",
        "elm",
        "$$jqLite",
        "elm",
        "className",
        "$$jqLite",
        "element",
        "options",
        "options",
        "$$addClass",
        "$$jqLite",
        "element",
        "options",
        "options",
        "options",
        "$$removeClass",
        "$$jqLite",
        "element",
        "options",
        "options",
        "options",
        "options",
        "options",
        "options",
        "options",
        "noop",
        "options",
        "options",
        "domOperation",
        "domOperation",
        "noop",
        "options",
        "options",
        "element",
        "options",
        "applyAnimationFromStyles",
        "element",
        "options",
        "applyAnimationToStyles",
        "element",
        "options",
        "element",
        "options",
        "options",
        "element",
        "options",
        "options",
        "element",
        "options",
        "options",
        "element",
        "options",
        "options",
        "element",
        "target",
        "newOptions",
        "target",
        "newOptions",
        "target",
        "newOptions",
        "resolveElementClasses",
        "element",
        "toAdd",
        "toRemove",
        "extend",
        "target",
        "newOptions",
        "classes",
        "target",
        "classes",
        "target",
        "classes",
        "target",
        "classes",
        "target",
        "target",
        "existing",
        "toAdd",
        "toRemove",
        "existing",
        "splitClassesToLookup",
        "existing",
        "toAdd",
        "splitClassesToLookup",
        "toAdd",
        "forEach",
        "toAdd",
        "value",
        "key",
        "flags",
        "key",
        "ADD_CLASS",
        "toRemove",
        "splitClassesToLookup",
        "toRemove",
        "forEach",
        "toRemove",
        "value",
        "key",
        "flags",
        "key",
        "flags",
        "key",
        "ADD_CLASS",
        "REMOVE_CLASS",
        "forEach",
        "flags",
        "val",
        "klass",
        "val",
        "ADD_CLASS",
        "prop",
        "allow",
        "existing",
        "klass",
        "val",
        "REMOVE_CLASS",
        "prop",
        "allow",
        "existing",
        "klass",
        "allow",
        "classes",
        "prop",
        "classes",
        "prop",
        "classes",
        "prop",
        "klass",
        "classes",
        "isString",
        "classes",
        "classes",
        "classes",
        "forEach",
        "classes",
        "klass",
        "klass",
        "obj",
        "klass",
        "obj",
        "classes",
        "scope",
        "element",
        "attrs",
        "attrs",
        "angular",
        "val",
        "val",
        "element",
        "NG_ANIMATE_CHILDREN_DATA",
        "attrs",
        "value",
        "value",
        "value",
        "value",
        "element",
        "NG_ANIMATE_CHILDREN_DATA",
        "value",
        "CSS_PREFIX",
        "TRANSITION_PROP",
        "TRANSITIONEND_EVENT",
        "TRANSITION_PROP",
        "TRANSITIONEND_EVENT",
        "CSS_PREFIX",
        "ANIMATION_PROP",
        "ANIMATIONEND_EVENT",
        "ANIMATION_PROP",
        "ANIMATIONEND_EVENT",
        "ANIMATION_PROP",
        "DELAY_KEY",
        "ANIMATION_PROP",
        "DURATION_KEY",
        "TRANSITION_PROP",
        "DELAY_KEY",
        "TRANSITION_PROP",
        "DURATION_KEY",
        "TRANSITION_DURATION_PROP",
        "TRANSITION_DELAY_PROP",
        "TRANSITION_PROP",
        "PROPERTY_KEY",
        "ANIMATION_DURATION_PROP",
        "ANIMATION_DELAY_PROP",
        "ANIMATION_PROP",
        "ANIMATION_ITERATION_COUNT_KEY",
        "TRANSITION_DURATION_PROP",
        "TRANSITION_DELAY_PROP",
        "ANIMATION_DURATION_PROP",
        "ANIMATION_DELAY_PROP",
        "$window",
        "element",
        "properties",
        "$window",
        "element",
        "forEach",
        "properties",
        "formalStyleName",
        "actualStyleName",
        "detectedStyles",
        "formalStyleName",
        "val",
        "val",
        "c",
        "c",
        "c",
        "val",
        "parseMaxTime",
        "val",
        "val",
        "val",
        "styles",
        "actualStyleName",
        "val",
        "styles",
        "forEach",
        "values",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "value",
        "parseFloat",
        "value",
        "maxValue",
        "maxValue",
        "value",
        "maxValue",
        "value",
        "maxValue",
        "val",
        "val",
        "val",
        "duration",
        "applyOnlyDuration",
        "duration",
        "applyOnlyDuration",
        "style",
        "DURATION_KEY",
        "value",
        "style",
        "value",
        "duration",
        "ANIMATION_DURATION_PROP",
        "duration",
        "delay",
        "isKeyframeAnimation",
        "isKeyframeAnimation",
        "ANIMATION_DELAY_PROP",
        "TRANSITION_DELAY_PROP",
        "prop",
        "delay",
        "node",
        "duration",
        "duration",
        "duration",
        "applyInlineStyle",
        "node",
        "TRANSITION_DELAY_PROP",
        "value",
        "TRANSITION_DELAY_PROP",
        "value",
        "node",
        "applyBlock",
        "applyBlock",
        "ANIMATION_PROP",
        "ANIMATION_PLAYSTATE_KEY",
        "applyInlineStyle",
        "node",
        "key",
        "value",
        "key",
        "value",
        "node",
        "styleTuple",
        "styleTuple",
        "styleTuple",
        "node",
        "prop",
        "value",
        "cache",
        "key",
        "cache",
        "key",
        "entry",
        "entry",
        "key",
        "cache",
        "key",
        "entry",
        "entry",
        "key",
        "value",
        "cache",
        "key",
        "cache",
        "key",
        "value",
        "cache",
        "key",
        "$animateProvider",
        "createLocalCacheLookup",
        "createLocalCacheLookup",
        "$window",
        "$$jqLite",
        "$$AnimateRunner",
        "$timeout",
        "$document",
        "$sniffer",
        "$$rAF",
        "applyAnimationClassesFactory",
        "$$jqLite",
        "node",
        "extraClasses",
        "node",
        "parentNode",
        "KEY",
        "parentNode",
        "KEY",
        "parentCounter",
        "parentID",
        "node",
        "extraClasses",
        "node",
        "className",
        "cacheKey",
        "properties",
        "gcsLookup",
        "cacheKey",
        "timings",
        "timings",
        "computeCssStyles",
        "$window",
        "node",
        "properties",
        "timings",
        "timings",
        "gcsLookup",
        "cacheKey",
        "timings",
        "timings",
        "node",
        "className",
        "cacheKey",
        "properties",
        "gcsLookup",
        "cacheKey",
        "stagger",
        "gcsStaggerLookup",
        "cacheKey",
        "stagger",
        "pendClasses",
        "className",
        "$$jqLite",
        "node",
        "staggerClassName",
        "stagger",
        "computeCssStyles",
        "$window",
        "node",
        "properties",
        "stagger",
        "stagger",
        "stagger",
        "stagger",
        "$$jqLite",
        "node",
        "staggerClassName",
        "gcsStaggerLookup",
        "cacheKey",
        "stagger",
        "stagger",
        "$document",
        "callback",
        "cancelLastRAFRequest",
        "cancelLastRAFRequest",
        "rafWaitQueue",
        "callback",
        "cancelLastRAFRequest",
        "$$rAF",
        "cancelLastRAFRequest",
        "gcsLookup",
        "gcsStaggerLookup",
        "bod",
        "i",
        "rafWaitQueue",
        "i",
        "rafWaitQueue",
        "i",
        "width",
        "rafWaitQueue",
        "init",
        "node",
        "className",
        "cacheKey",
        "computeCachedCssStyles",
        "node",
        "className",
        "cacheKey",
        "DETECT_CSS_PROPERTIES",
        "timings",
        "timings",
        "timings",
        "aD",
        "tD",
        "aD",
        "tD",
        "aD",
        "tD",
        "timings",
        "timings",
        "timings",
        "timings",
        "timings",
        "element",
        "options",
        "element",
        "options",
        "prepareAnimationOptions",
        "options",
        "element",
        "packageStyles",
        "options",
        "options",
        "$sniffer",
        "$sniffer",
        "close",
        "options",
        "isArray",
        "options",
        "options",
        "options",
        "method",
        "options",
        "isStructural",
        "structuralClassName",
        "pendClasses",
        "method",
        "method",
        "structuralClassName",
        "method",
        "options",
        "addRemoveClassName",
        "pendClasses",
        "options",
        "options",
        "addRemoveClassName",
        "addRemoveClassName",
        "addRemoveClassName",
        "pendClasses",
        "options",
        "options",
        "addRemoveClassName",
        "applyAnimationClasses",
        "element",
        "options",
        "addRemoveClassName",
        "structuralClassName",
        "addRemoveClassName",
        "classes",
        "setupClasses",
        "pendClasses",
        "setupClasses",
        "styles",
        "styles",
        "hasToStyles",
        "setupClasses",
        "close",
        "options",
        "parseFloat",
        "options",
        "stagger",
        "staggerVal",
        "staggerVal",
        "cacheKey",
        "gcsHashFn",
        "node",
        "fullClassName",
        "stagger",
        "computeCachedCssStaggerStyles",
        "node",
        "setupClasses",
        "cacheKey",
        "DETECT_STAGGER_CSS_PROPERTIES",
        "$$jqLite",
        "element",
        "setupClasses",
        "options",
        "TRANSITION_PROP",
        "options",
        "applyInlineStyle",
        "node",
        "transitionStyle",
        "temporaryStyles",
        "transitionStyle",
        "options",
        "applyOnlyDuration",
        "node",
        "TRANSITION_PROP",
        "getCssTransitionDurationStyle",
        "options",
        "applyOnlyDuration",
        "applyInlineStyle",
        "node",
        "durationStyle",
        "temporaryStyles",
        "durationStyle",
        "options",
        "ANIMATION_PROP",
        "options",
        "applyInlineStyle",
        "node",
        "keyframeStyle",
        "temporaryStyles",
        "keyframeStyle",
        "stagger",
        "options",
        "options",
        "gcsLookup",
        "cacheKey",
        "itemIndex",
        "isFirst",
        "blockTransitions",
        "node",
        "SAFE_FAST_FORWARD_DURATION_VALUE",
        "computeTimings",
        "node",
        "fullClassName",
        "cacheKey",
        "timings",
        "maxDelay",
        "relativeDelay",
        "maxDuration",
        "timings",
        "flags",
        "timings",
        "flags",
        "timings",
        "flags",
        "flags",
        "timings",
        "flags",
        "hasToStyles",
        "flags",
        "flags",
        "flags",
        "flags",
        "flags",
        "options",
        "flags",
        "flags",
        "truthyTimingValue",
        "options",
        "flags",
        "flags",
        "flags",
        "truthyTimingValue",
        "options",
        "flags",
        "flags",
        "addRemoveClassName",
        "flags",
        "flags",
        "maxDuration",
        "options",
        "parseFloat",
        "options",
        "maxDuration",
        "flags",
        "flags",
        "timings",
        "maxDuration",
        "applyOnlyDuration",
        "node",
        "TRANSITION_PROP",
        "PROPERTY_KEY",
        "temporaryStyles",
        "getCssTransitionDurationStyle",
        "maxDuration",
        "applyOnlyDuration",
        "flags",
        "flags",
        "timings",
        "maxDuration",
        "temporaryStyles",
        "getCssKeyframeDurationStyle",
        "maxDuration",
        "maxDuration",
        "flags",
        "close",
        "timings",
        "flags",
        "flags",
        "isFirst",
        "maxDelayTime",
        "maxDelay",
        "ONE_SECOND",
        "maxDurationTime",
        "maxDuration",
        "ONE_SECOND",
        "options",
        "flags",
        "timings",
        "flags",
        "timings",
        "stagger",
        "stagger",
        "applyAnimationFromStyles",
        "element",
        "options",
        "flags",
        "blockTransitions",
        "node",
        "applyBlocking",
        "maxDuration",
        "endFn",
        "animationClosed",
        "runnerHost",
        "endFn",
        "cancelFn",
        "runner",
        "$$AnimateRunner",
        "runnerHost",
        "waitUntilQuiet",
        "start",
        "runner",
        "close",
        "close",
        "rejected",
        "animationClosed",
        "animationCompleted",
        "animationPaused",
        "animationClosed",
        "animationPaused",
        "$$jqLite",
        "element",
        "setupClasses",
        "$$jqLite",
        "element",
        "activeClasses",
        "blockKeyframeAnimations",
        "node",
        "blockTransitions",
        "node",
        "forEach",
        "temporaryStyles",
        "entry",
        "node",
        "entry",
        "applyAnimationClasses",
        "element",
        "options",
        "applyAnimationStyles",
        "element",
        "options",
        "options",
        "options",
        "runner",
        "runner",
        "rejected",
        "duration",
        "flags",
        "blockTransitions",
        "node",
        "duration",
        "flags",
        "blockKeyframeAnimations",
        "node",
        "duration",
        "animationClosed",
        "playAnimation",
        "animationCompleted",
        "animationPaused",
        "playAnimation",
        "timings",
        "blockKeyframeAnimations",
        "node",
        "animationPaused",
        "animationPaused",
        "temporaryStyles",
        "value",
        "removeFromArray",
        "temporaryStyles",
        "value",
        "animationPaused",
        "playAnimation",
        "animationPaused",
        "close",
        "itemIndex",
        "timings",
        "stagger",
        "timings",
        "stagger",
        "stagger",
        "stagger",
        "maxStagger",
        "$timeout",
        "triggerAnimationStart",
        "maxStagger",
        "itemIndex",
        "ONE_SECOND",
        "triggerAnimationStart",
        "runnerHost",
        "playPause",
        "runnerHost",
        "playPause",
        "animationClosed",
        "applyBlocking",
        "forEach",
        "temporaryStyles",
        "entry",
        "entry",
        "entry",
        "node",
        "key",
        "value",
        "applyAnimationClasses",
        "element",
        "options",
        "$$jqLite",
        "element",
        "activeClasses",
        "flags",
        "fullClassName",
        "node",
        "setupClasses",
        "cacheKey",
        "gcsHashFn",
        "node",
        "fullClassName",
        "timings",
        "computeTimings",
        "node",
        "fullClassName",
        "cacheKey",
        "relativeDelay",
        "timings",
        "maxDelay",
        "relativeDelay",
        "maxDuration",
        "timings",
        "maxDuration",
        "close",
        "flags",
        "timings",
        "flags",
        "timings",
        "flags",
        "flags",
        "relativeDelay",
        "options",
        "truthyTimingValue",
        "options",
        "parseFloat",
        "options",
        "relativeDelay",
        "maxDelay",
        "relativeDelay",
        "flags",
        "timings",
        "relativeDelay",
        "delayStyle",
        "getCssDelayStyle",
        "relativeDelay",
        "temporaryStyles",
        "delayStyle",
        "node",
        "delayStyle",
        "delayStyle",
        "flags",
        "timings",
        "relativeDelay",
        "delayStyle",
        "getCssDelayStyle",
        "relativeDelay",
        "temporaryStyles",
        "delayStyle",
        "node",
        "delayStyle",
        "delayStyle",
        "maxDelayTime",
        "maxDelay",
        "ONE_SECOND",
        "maxDurationTime",
        "maxDuration",
        "ONE_SECOND",
        "options",
        "options",
        "flags",
        "easeProp",
        "TRANSITION_PROP",
        "TIMING_KEY",
        "temporaryStyles",
        "easeProp",
        "easeVal",
        "node",
        "easeProp",
        "easeVal",
        "flags",
        "easeProp",
        "ANIMATION_PROP",
        "TIMING_KEY",
        "temporaryStyles",
        "easeProp",
        "easeVal",
        "node",
        "easeProp",
        "easeVal",
        "timings",
        "events",
        "TRANSITIONEND_EVENT",
        "timings",
        "events",
        "ANIMATIONEND_EVENT",
        "startTime",
        "element",
        "events",
        "onAnimationProgress",
        "$timeout",
        "onAnimationExpired",
        "maxDelayTime",
        "CLOSING_TIME_BUFFER",
        "maxDurationTime",
        "applyAnimationToStyles",
        "element",
        "options",
        "close",
        "ev",
        "ev",
        "parseFloat",
        "ev",
        "ELAPSED_TIME_MAX_DECIMAL_PLACES",
        "timeStamp",
        "startTime",
        "maxDelayTime",
        "elapsedTime",
        "maxDuration",
        "animationCompleted",
        "close",
        "$$animationProvider",
        "$$animationProvider",
        "$animateCss",
        "$rootScope",
        "$$AnimateRunner",
        "$rootElement",
        "$document",
        "$sniffer",
        "$sniffer",
        "$sniffer",
        "noop",
        "$document",
        "$rootElement",
        "jqLite",
        "bodyNode",
        "rootNode",
        "bodyNode",
        "rootNode",
        "initDriverFn",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "prepareFromToAnchorAnimation",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "prepareRegularAnimation",
        "animationDetails",
        "classes",
        "classes",
        "a",
        "b",
        "isString",
        "a",
        "a",
        "a",
        "isString",
        "b",
        "b",
        "b",
        "a",
        "val",
        "b",
        "val",
        "classes",
        "outAnchor",
        "inAnchor",
        "jqLite",
        "outAnchor",
        "filterCssClasses",
        "clone",
        "pendClasses",
        "classes",
        "NG_ANIMATE_ANCHOR_SUFFIX",
        "outAnchor",
        "NG_ANIMATE_SHIM_CLASS_NAME",
        "inAnchor",
        "NG_ANIMATE_SHIM_CLASS_NAME",
        "clone",
        "NG_ANIMATE_ANCHOR_CLASS_NAME",
        "clone",
        "anchorClasses",
        "rootBodyElement",
        "clone",
        "prepareOutAnimation",
        "animatorOut",
        "animatorIn",
        "prepareInAnimation",
        "animatorIn",
        "end",
        "animatorOut",
        "animatorIn",
        "startingAnimator",
        "currentAnimation",
        "currentAnimation",
        "animatorIn",
        "animatorIn",
        "prepareInAnimation",
        "animatorIn",
        "currentAnimation",
        "animatorIn",
        "currentAnimation",
        "currentAnimation",
        "end",
        "runner",
        "currentAnimation",
        "end",
        "runner",
        "runner",
        "$$AnimateRunner",
        "endFn",
        "endFn",
        "runner",
        "currentAnimation",
        "currentAnimation",
        "anchor",
        "anchor",
        "forEach",
        "key",
        "coords",
        "key",
        "key",
        "value",
        "bodyNode",
        "value",
        "bodyNode",
        "styles",
        "key",
        "value",
        "styles",
        "$animateCss",
        "clone",
        "NG_OUT_ANCHOR_CLASS_NAME",
        "calculateAnchorStyles",
        "outAnchor",
        "filterCssClasses",
        "inAnchor",
        "getUniqueValues",
        "endingClasses",
        "startingClasses",
        "$animateCss",
        "clone",
        "calculateAnchorStyles",
        "inAnchor",
        "NG_IN_ANCHOR_CLASS_NAME",
        "classes",
        "NG_OUT_ANCHOR_CLASS_NAME",
        "startingClasses",
        "clone",
        "outAnchor",
        "NG_ANIMATE_SHIM_CLASS_NAME",
        "inAnchor",
        "NG_ANIMATE_SHIM_CLASS_NAME",
        "to",
        "classes",
        "anchors",
        "prepareRegularAnimation",
        "prepareRegularAnimation",
        "to",
        "forEach",
        "anchors",
        "anchor",
        "anchor",
        "anchor",
        "prepareAnchoredAnimation",
        "classes",
        "outElement",
        "inElement",
        "animator",
        "anchorAnimations",
        "animator",
        "fromAnimation",
        "toAnimation",
        "anchorAnimations",
        "fromAnimation",
        "animationRunners",
        "fromAnimation",
        "toAnimation",
        "animationRunners",
        "toAnimation",
        "forEach",
        "anchorAnimations",
        "animation",
        "animationRunners",
        "animation",
        "$$AnimateRunner",
        "endFn",
        "endFn",
        "$$AnimateRunner",
        "animationRunners",
        "status",
        "runner",
        "status",
        "runner",
        "forEach",
        "animationRunners",
        "runner",
        "runner",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "options",
        "animationDetails",
        "options",
        "options",
        "options",
        "animationDetails",
        "options",
        "animationDetails",
        "options",
        "animationDetails",
        "$animateCss",
        "element",
        "options",
        "$animateProvider",
        "$injector",
        "$$AnimateRunner",
        "$$rAFMutex",
        "$$jqLite",
        "applyAnimationClassesFactory",
        "$$jqLite",
        "element",
        "classes",
        "options",
        "arguments",
        "isObject",
        "classes",
        "options",
        "classes",
        "classes",
        "options",
        "prepareAnimationOptions",
        "options",
        "classes",
        "classes",
        "element",
        "options",
        "classes",
        "options",
        "options",
        "classes",
        "options",
        "options",
        "options",
        "lookupAnimations",
        "classes",
        "animations",
        "beforeFn",
        "afterFn",
        "beforeFn",
        "afterFn",
        "before",
        "packageAnimations",
        "element",
        "options",
        "animations",
        "beforeFn",
        "after",
        "packageAnimations",
        "element",
        "options",
        "animations",
        "afterFn",
        "before",
        "after",
        "options",
        "applyAnimationClasses",
        "element",
        "options",
        "before",
        "chain",
        "fn",
        "closeActiveAnimations",
        "before",
        "fn",
        "chain",
        "chain",
        "fn",
        "applyOptions",
        "fn",
        "applyOptions",
        "after",
        "chain",
        "fn",
        "closeActiveAnimations",
        "after",
        "fn",
        "$$AnimateRunner",
        "endAnimations",
        "endAnimations",
        "$$AnimateRunner",
        "chain",
        "onComplete",
        "runner",
        "success",
        "animationClosed",
        "applyOptions",
        "applyAnimationStyles",
        "element",
        "options",
        "runner",
        "success",
        "cancelled",
        "animationClosed",
        "closeActiveAnimations",
        "noop",
        "cancelled",
        "onComplete",
        "cancelled",
        "fn",
        "element",
        "options",
        "onDone",
        "args",
        "element",
        "options",
        "options",
        "onDone",
        "args",
        "element",
        "classesToAdd",
        "classesToRemove",
        "onDone",
        "args",
        "element",
        "classesToAdd",
        "onDone",
        "args",
        "element",
        "classesToRemove",
        "onDone",
        "args",
        "element",
        "onDone",
        "args",
        "options",
        "fn",
        "fn",
        "args",
        "isFunction",
        "value",
        "value",
        "noop",
        "element",
        "options",
        "animations",
        "fnName",
        "forEach",
        "animations",
        "ani",
        "ani",
        "fnName",
        "animation",
        "operations",
        "rejected",
        "resolved",
        "resolved",
        "endProgressCb",
        "noop",
        "rejected",
        "runner",
        "rejected",
        "runner",
        "$$AnimateRunner",
        "onAnimationComplete",
        "onAnimationComplete",
        "endProgressCb",
        "executeAnimationFn",
        "animation",
        "element",
        "options",
        "result",
        "result",
        "onAnimationComplete",
        "cancelled",
        "runner",
        "operations",
        "element",
        "options",
        "animations",
        "fnName",
        "groupEventedAnimations",
        "element",
        "options",
        "animations",
        "fnName",
        "operations",
        "fnName",
        "a",
        "groupEventedAnimations",
        "element",
        "options",
        "animations",
        "b",
        "groupEventedAnimations",
        "element",
        "options",
        "animations",
        "fnName",
        "a",
        "groupEventedAnimations",
        "element",
        "options",
        "animations",
        "b",
        "groupEventedAnimations",
        "element",
        "options",
        "animations",
        "a",
        "operations",
        "operations",
        "a",
        "b",
        "operations",
        "operations",
        "b",
        "operations",
        "startAnimation",
        "callback",
        "operations",
        "forEach",
        "operations",
        "animateFn",
        "runners",
        "animateFn",
        "runners",
        "$$AnimateRunner",
        "runners",
        "callback",
        "callback",
        "endFn",
        "reject",
        "forEach",
        "runners",
        "runner",
        "reject",
        "runner",
        "runner",
        "classes",
        "classes",
        "isArray",
        "classes",
        "classes",
        "classes",
        "i",
        "classes",
        "i",
        "classes",
        "i",
        "$animateProvider",
        "klass",
        "animationFactory",
        "flagMap",
        "klass",
        "matches",
        "$injector",
        "animationFactory",
        "flagMap",
        "klass",
        "matches",
        "$$animationProvider",
        "$$animationProvider",
        "$$animateJs",
        "$$AnimateRunner",
        "initDriverFn",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "prepareAnimation",
        "animationDetails",
        "prepareAnimation",
        "animationDetails",
        "fromAnimation",
        "toAnimation",
        "fromAnimation",
        "animationRunners",
        "fromAnimation",
        "toAnimation",
        "animationRunners",
        "toAnimation",
        "$$AnimateRunner",
        "animationRunners",
        "done",
        "$$AnimateRunner",
        "endFnFactory",
        "endFnFactory",
        "runner",
        "forEach",
        "animationRunners",
        "runner",
        "runner",
        "status",
        "runner",
        "status",
        "prepareAnimation",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "$$animateJs",
        "element",
        "classes",
        "options",
        "$animateProvider",
        "ruleType",
        "element",
        "currentAnimation",
        "previousAnimation",
        "rules",
        "ruleType",
        "fn",
        "fn",
        "element",
        "currentAnimation",
        "previousAnimation",
        "options",
        "options",
        "options",
        "options",
        "options",
        "a",
        "b",
        "a",
        "b",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "newAnimation",
        "hasAnimationClasses",
        "newAnimation",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "newAnimation",
        "hasAnimationClasses",
        "newAnimation",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "currentAnimation",
        "newAnimation",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "currentAnimation",
        "newAnimation",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "currentAnimation",
        "newAnimation",
        "rules",
        "element",
        "newAnimation",
        "currentAnimation",
        "currentAnimation",
        "RUNNING_STATE",
        "newAnimation",
        "$$rAF",
        "$rootScope",
        "$rootElement",
        "$document",
        "$$HashMap",
        "$$animation",
        "$$AnimateRunner",
        "$templateRequest",
        "$$jqLite",
        "$$HashMap",
        "$$HashMap",
        "$rootScope",
        "$templateRequest",
        "isEmpty",
        "isEmpty",
        "deregisterWatch",
        "$rootScope",
        "$rootScope",
        "animationsEnabled",
        "animationsEnabled",
        "jqLite",
        "$document",
        "$animateProvider",
        "classNameFilter",
        "className",
        "classNameFilter",
        "className",
        "applyAnimationClassesFactory",
        "$$jqLite",
        "element",
        "options",
        "mergeAnimationOptions",
        "element",
        "options",
        "element",
        "element",
        "callbackRegistry",
        "entries",
        "forEach",
        "entries",
        "entry",
        "entry",
        "targetNode",
        "matches",
        "entry",
        "matches",
        "element",
        "phase",
        "data",
        "$$rAF",
        "forEach",
        "findCallbacks",
        "element",
        "callback",
        "callback",
        "element",
        "phase",
        "data",
        "container",
        "callback",
        "extractElementNode",
        "container",
        "callbackRegistry",
        "callbackRegistry",
        "callbackRegistry",
        "node",
        "callback",
        "container",
        "callback",
        "callbackRegistry",
        "entries",
        "callbackRegistry",
        "arguments",
        "filterFromRegistry",
        "entries",
        "container",
        "callback",
        "matchContainer",
        "matchCallback",
        "extractElementNode",
        "matchContainer",
        "entry",
        "entry",
        "containerNode",
        "matchCallback",
        "entry",
        "matchCallback",
        "isMatch",
        "element",
        "parentElement",
        "assertArg",
        "isElement",
        "element",
        "assertArg",
        "isElement",
        "parentElement",
        "element",
        "NG_ANIMATE_PIN_DATA",
        "parentElement",
        "element",
        "options",
        "domOperation",
        "options",
        "options",
        "options",
        "domOperation",
        "queueAnimation",
        "element",
        "options",
        "element",
        "arguments",
        "argCount",
        "animationsEnabled",
        "isElement",
        "element",
        "hasElement",
        "animationsEnabled",
        "element",
        "element",
        "element",
        "element",
        "disabledElementsLookup",
        "node",
        "argCount",
        "recordExists",
        "disabledElementsLookup",
        "node",
        "recordExists",
        "disabledElementsLookup",
        "node",
        "element",
        "options",
        "element",
        "stripCommentsFromElement",
        "element",
        "element",
        "options",
        "prepareAnimationOptions",
        "options",
        "element",
        "$$AnimateRunner",
        "node",
        "runner",
        "runner",
        "isArray",
        "options",
        "options",
        "options",
        "isArray",
        "options",
        "options",
        "options",
        "options",
        "isObject",
        "options",
        "options",
        "options",
        "isObject",
        "options",
        "options",
        "node",
        "options",
        "options",
        "isAnimatableClassName",
        "className",
        "close",
        "runner",
        "animationsEnabled",
        "disabledElementsLookup",
        "node",
        "skipAnimations",
        "activeAnimationsLookup",
        "node",
        "existingAnimation",
        "skipAnimations",
        "hasExistingAnimation",
        "existingAnimation",
        "PRE_DIGEST_STATE",
        "skipAnimations",
        "areAnimationsAllowed",
        "element",
        "parent",
        "skipAnimations",
        "close",
        "runner",
        "isStructural",
        "closeChildAnimations",
        "element",
        "isStructural",
        "element",
        "options",
        "runner",
        "hasExistingAnimation",
        "isAllowed",
        "element",
        "newAnimation",
        "existingAnimation",
        "skipAnimationFlag",
        "existingAnimation",
        "RUNNING_STATE",
        "close",
        "runner",
        "mergeAnimationOptions",
        "element",
        "existingAnimation",
        "options",
        "existingAnimation",
        "isAllowed",
        "element",
        "newAnimation",
        "existingAnimation",
        "cancelAnimationFlag",
        "existingAnimation",
        "RUNNING_STATE",
        "existingAnimation",
        "mergeAnimationOptions",
        "element",
        "newAnimation",
        "existingAnimation",
        "isAllowed",
        "element",
        "newAnimation",
        "existingAnimation",
        "joinAnimationFlag",
        "existingAnimation",
        "RUNNING_STATE",
        "normalizeAnimationOptions",
        "element",
        "options",
        "newAnimation",
        "existingAnimation",
        "options",
        "mergeAnimationOptions",
        "element",
        "existingAnimation",
        "newAnimation",
        "runner",
        "normalizeAnimationOptions",
        "element",
        "options",
        "newAnimation",
        "isValidAnimation",
        "isValidAnimation",
        "newAnimation",
        "newAnimation",
        "hasAnimationClasses",
        "newAnimation",
        "isValidAnimation",
        "close",
        "runner",
        "closeParentClassBasedAnimations",
        "parent",
        "existingAnimation",
        "newAnimation",
        "counter",
        "markElementAnimationState",
        "element",
        "PRE_DIGEST_STATE",
        "newAnimation",
        "$rootScope",
        "activeAnimationsLookup",
        "node",
        "animationDetails",
        "animationDetails",
        "animationDetails",
        "element",
        "parentElement",
        "animationDetails",
        "animationDetails",
        "hasAnimationClasses",
        "animationDetails",
        "animationCancelled",
        "animationDetails",
        "counter",
        "isValidAnimation",
        "animationCancelled",
        "applyAnimationClasses",
        "element",
        "options",
        "applyAnimationStyles",
        "element",
        "options",
        "animationCancelled",
        "isStructural",
        "animationDetails",
        "options",
        "runner",
        "animationDetails",
        "hasAnimationClasses",
        "animationDetails",
        "animationDetails",
        "closeParentClassBasedAnimations",
        "parentElement",
        "markElementAnimationState",
        "element",
        "RUNNING_STATE",
        "$$animation",
        "element",
        "animationDetails",
        "realRunner",
        "status",
        "close",
        "status",
        "activeAnimationsLookup",
        "node",
        "animationDetails",
        "animationDetails",
        "counter",
        "clearElementAnimationState",
        "element",
        "notifyProgress",
        "runner",
        "runner",
        "realRunner",
        "notifyProgress",
        "runner",
        "runner",
        "runner",
        "phase",
        "data",
        "triggerCallback",
        "element",
        "phase",
        "data",
        "runner",
        "phase",
        "data",
        "reject",
        "applyAnimationClasses",
        "element",
        "options",
        "applyAnimationStyles",
        "element",
        "options",
        "options",
        "runner",
        "reject",
        "element",
        "element",
        "node",
        "NG_ANIMATE_ATTR_NAME",
        "forEach",
        "children",
        "child",
        "parseInt",
        "child",
        "NG_ANIMATE_ATTR_NAME",
        "activeAnimationsLookup",
        "child",
        "state",
        "RUNNING_STATE",
        "animationDetails",
        "PRE_DIGEST_STATE",
        "animationDetails",
        "activeAnimationsLookup",
        "child",
        "element",
        "element",
        "element",
        "element",
        "element",
        "element",
        "NG_ANIMATE_ATTR_NAME",
        "activeAnimationsLookup",
        "element",
        "a",
        "b",
        "a",
        "a",
        "a",
        "a",
        "b",
        "b",
        "b",
        "b",
        "a",
        "b",
        "startingElement",
        "startingElement",
        "parentNode",
        "parentNode",
        "ELEMENT_NODE",
        "activeAnimationsLookup",
        "parentNode",
        "animationDetails",
        "examineParentAnimation",
        "parentNode",
        "animationDetails",
        "parentNode",
        "parentNode",
        "node",
        "animationDetails",
        "animationDetails",
        "hasAnimationClasses",
        "animationDetails",
        "animationDetails",
        "RUNNING_STATE",
        "animationDetails",
        "clearElementAnimationState",
        "node",
        "element",
        "parent",
        "element",
        "NG_ANIMATE_PIN_DATA",
        "parentHost",
        "parent",
        "parentHost",
        "parent",
        "parent",
        "rootElementDetected",
        "rootElementDetected",
        "isMatchingElement",
        "parent",
        "$rootElement",
        "parent",
        "parentNode",
        "ELEMENT_NODE",
        "activeAnimationsLookup",
        "parentNode",
        "parentAnimationDetected",
        "parentAnimationDetected",
        "details",
        "disabledElementsLookup",
        "parentNode",
        "isUndefined",
        "animateChildren",
        "animateChildren",
        "parent",
        "NG_ANIMATE_CHILDREN_DATA",
        "isDefined",
        "value",
        "animateChildren",
        "value",
        "parentAnimationDetected",
        "animateChildren",
        "rootElementDetected",
        "rootElementDetected",
        "isMatchingElement",
        "parent",
        "$rootElement",
        "rootElementDetected",
        "parentHost",
        "parent",
        "NG_ANIMATE_PIN_DATA",
        "parentHost",
        "parent",
        "parentHost",
        "bodyElementDetected",
        "bodyElementDetected",
        "isMatchingElement",
        "parent",
        "bodyElement",
        "parent",
        "parent",
        "parentAnimationDetected",
        "animateChildren",
        "allowAnimation",
        "rootElementDetected",
        "bodyElementDetected",
        "element",
        "state",
        "details",
        "details",
        "details",
        "details",
        "state",
        "element",
        "element",
        "element",
        "element",
        "element",
        "NG_ANIMATE_ATTR_NAME",
        "state",
        "activeAnimationsLookup",
        "element",
        "oldValue",
        "extend",
        "oldValue",
        "details",
        "details",
        "activeAnimationsLookup",
        "element",
        "newValue",
        "$$rAF",
        "$$rAF",
        "passed",
        "fn",
        "passed",
        "fn",
        "$$rAF",
        "fn",
        "$q",
        "$$rAFMutex",
        "AnimateRunner",
        "chain",
        "callback",
        "next",
        "index",
        "chain",
        "callback",
        "chain",
        "index",
        "response",
        "response",
        "callback",
        "index",
        "next",
        "AnimateRunner",
        "runners",
        "callback",
        "forEach",
        "runners",
        "runner",
        "runner",
        "onProgress",
        "response",
        "status",
        "status",
        "response",
        "count",
        "runners",
        "callback",
        "status",
        "host",
        "host",
        "$$rAFMutex",
        "AnimateRunner",
        "host",
        "host",
        "fn",
        "DONE_COMPLETE_STATE",
        "fn",
        "fn",
        "noop",
        "$q",
        "resolve",
        "reject",
        "status",
        "status",
        "reject",
        "resolve",
        "resolveHandler",
        "rejectHandler",
        "resolveHandler",
        "rejectHandler",
        "handler",
        "handler",
        "handler",
        "handler",
        "response",
        "INITIAL_STATE",
        "DONE_PENDING_STATE",
        "response",
        "response",
        "DONE_COMPLETE_STATE",
        "forEach",
        "fn",
        "fn",
        "response",
        "DONE_COMPLETE_STATE",
        "AnimateRunner",
        "$animateProvider",
        "element",
        "runner",
        "element",
        "RUNNER_STORAGE_KEY",
        "runner",
        "element",
        "element",
        "RUNNER_STORAGE_KEY",
        "element",
        "element",
        "RUNNER_STORAGE_KEY",
        "$$jqLite",
        "$rootScope",
        "$injector",
        "$$AnimateRunner",
        "applyAnimationClassesFactory",
        "$$jqLite",
        "element",
        "options",
        "options",
        "prepareAnimationOptions",
        "options",
        "$$AnimateRunner",
        "close",
        "close",
        "drivers",
        "close",
        "runner",
        "setRunner",
        "element",
        "runner",
        "mergeClasses",
        "element",
        "mergeClasses",
        "options",
        "options",
        "options",
        "tempClasses",
        "classes",
        "tempClasses",
        "options",
        "animationQueue",
        "element",
        "classes",
        "isStructural",
        "options",
        "start",
        "close",
        "element",
        "handleDestroyedElement",
        "animationQueue",
        "runner",
        "$rootScope",
        "forEach",
        "animationQueue",
        "entry",
        "getRunner",
        "entry",
        "animations",
        "entry",
        "animationQueue",
        "forEach",
        "groupAnimations",
        "animations",
        "animationEntry",
        "animationEntry",
        "animationEntry",
        "invokeFirstDriver",
        "animationEntry",
        "operation",
        "operation",
        "startAnimation",
        "closeFn",
        "startFn",
        "startAnimation",
        "animationRunner",
        "status",
        "closeFn",
        "status",
        "updateAnimationRunners",
        "animationEntry",
        "animationRunner",
        "runner",
        "node",
        "NG_ANIMATE_REF_ATTR",
        "node",
        "NG_ANIMATE_REF_ATTR",
        "node",
        "node",
        "SELECTOR",
        "forEach",
        "items",
        "node",
        "node",
        "NG_ANIMATE_REF_ATTR",
        "attr",
        "attr",
        "anchors",
        "node",
        "anchors",
        "animations",
        "forEach",
        "animations",
        "animation",
        "index",
        "animation",
        "element",
        "animation",
        "animation",
        "getAnchorNodes",
        "node",
        "anchorNodes",
        "enterOrMove",
        "forEach",
        "anchorNodes",
        "anchor",
        "anchor",
        "NG_ANIMATE_REF_ATTR",
        "refLookup",
        "key",
        "refLookup",
        "key",
        "refLookup",
        "key",
        "direction",
        "index",
        "jqLite",
        "anchor",
        "preparedAnimations",
        "animation",
        "forEach",
        "refLookup",
        "operations",
        "key",
        "operations",
        "operations",
        "to",
        "to",
        "index",
        "usedIndicesLookup",
        "indexKey",
        "usedIndicesLookup",
        "indexKey",
        "preparedAnimations",
        "animations",
        "index",
        "animations",
        "animations",
        "to",
        "anchorGroups",
        "lookupKey",
        "anchorGroups",
        "lookupKey",
        "fromAnimation",
        "toAnimation",
        "fromAnimation",
        "toAnimation",
        "cssClassesIntersection",
        "fromAnimation",
        "toAnimation",
        "fromAnimation",
        "toAnimation",
        "group",
        "preparedAnimations",
        "group",
        "preparedAnimations",
        "fromAnimation",
        "preparedAnimations",
        "toAnimation",
        "anchorGroups",
        "lookupKey",
        "to",
        "preparedAnimations",
        "a",
        "b",
        "a",
        "a",
        "b",
        "b",
        "i",
        "a",
        "i",
        "a",
        "i",
        "aa",
        "j",
        "b",
        "j",
        "aa",
        "b",
        "j",
        "matches",
        "aa",
        "matches",
        "animationDetails",
        "drivers",
        "i",
        "i",
        "drivers",
        "i",
        "$injector",
        "driverName",
        "$injector",
        "driverName",
        "factory",
        "animationDetails",
        "driver",
        "driver",
        "element",
        "NG_ANIMATE_CLASSNAME",
        "tempClasses",
        "$$jqLite",
        "element",
        "tempClasses",
        "animation",
        "newRunner",
        "animation",
        "animation",
        "update",
        "animation",
        "update",
        "animation",
        "update",
        "animation",
        "element",
        "getRunner",
        "element",
        "newRunner",
        "getRunner",
        "element",
        "runner",
        "options",
        "runner",
        "rejected",
        "element",
        "handleDestroyedElement",
        "removeRunner",
        "element",
        "applyAnimationClasses",
        "element",
        "options",
        "applyAnimationStyles",
        "element",
        "options",
        "options",
        "tempClasses",
        "$$jqLite",
        "element",
        "tempClasses",
        "element",
        "NG_ANIMATE_CLASSNAME",
        "runner",
        "rejected",
        "angular",
        "$$AnimateChildrenDirective",
        "$$rAFMutexFactory",
        "$$AnimateRunnerFactory",
        "$$AnimateQueueProvider",
        "$$AnimationProvider",
        "$AnimateCssProvider",
        "$$AnimateCssDriverProvider",
        "$$AnimateJsProvider",
        "$$AnimateJsDriverProvider"
    ],
    "literals": [
        "'use strict'",
        "'$$ngAnimateChildren'",
        "'areq'",
        "\"Argument '{0}' is {1}\"",
        "'?'",
        "\"required\"",
        "''",
        "' '",
        "' '",
        "' '",
        "''",
        "' '",
        "''",
        "''",
        "' '",
        "''",
        "''",
        "' '",
        "''",
        "'class'",
        "''",
        "''",
        "'addClass'",
        "'removeClass'",
        "' '",
        "' '",
        "'ngAnimateChildren'",
        "'on'",
        "'true'",
        "''",
        "'-webkit-'",
        "'WebkitTransition'",
        "'webkitTransitionEnd transitionend'",
        "'transition'",
        "'transitionend'",
        "'-webkit-'",
        "'WebkitAnimation'",
        "'webkitAnimationEnd animationend'",
        "'animation'",
        "'animationend'",
        "'Duration'",
        "'Property'",
        "'Delay'",
        "'TimingFunction'",
        "'IterationCount'",
        "'PlayState'",
        "'-'",
        "'+'",
        "'s'",
        "'s'",
        "' linear all'",
        "'s'",
        "'s'",
        "'-'",
        "'s'",
        "''",
        "'paused'",
        "''",
        "'$animateProvider'",
        "'$window'",
        "'$$jqLite'",
        "'$$AnimateRunner'",
        "'$timeout'",
        "'$document'",
        "'$sniffer'",
        "'$$rAF'",
        "\"$$ngAnimateParentKey\"",
        "'-'",
        "'class'",
        "'-'",
        "'infinite'",
        "'-stagger'",
        "'class'",
        "' '",
        "''",
        "''",
        "'ng-'",
        "'-add'",
        "' '",
        "'-remove'",
        "''",
        "' '",
        "' '",
        "'-active'",
        "'all'",
        "''",
        "' '",
        "\"boolean\"",
        "' '",
        "'$$animationProvider'",
        "'$$animateCssDriver'",
        "'ng-animate-shim'",
        "'ng-animate-anchor'",
        "'-anchor'",
        "'ng-anchor-out'",
        "'ng-anchor-in'",
        "'$animateCss'",
        "'$rootScope'",
        "'$$AnimateRunner'",
        "'$rootElement'",
        "'$document'",
        "'$sniffer'",
        "''",
        "' '",
        "' '",
        "' '",
        "'class'",
        "''",
        "'width'",
        "'height'",
        "'top'",
        "'left'",
        "'top'",
        "'left'",
        "'px'",
        "'class'",
        "' '",
        "' '",
        "'out'",
        "'in'",
        "'leave'",
        "'$animateProvider'",
        "'$injector'",
        "'$$AnimateRunner'",
        "'$$rAFMutex'",
        "'$$jqLite'",
        "'class'",
        "''",
        "' '",
        "' '",
        "'leave'",
        "'leave'",
        "'afterLeave'",
        "'before'",
        "'enter'",
        "'move'",
        "'animate'",
        "'setClass'",
        "'addClass'",
        "'removeClass'",
        "'beforeSetClass'",
        "'removeClass'",
        "'beforeRemoveClass'",
        "'addClass'",
        "'beforeAddClass'",
        "'setClass'",
        "'removeClass'",
        "'removeClass'",
        "'addClass'",
        "'addClass'",
        "' '",
        "'$$animationProvider'",
        "'$$animateJsDriver'",
        "'$$animateJs'",
        "'$$AnimateRunner'",
        "'data-ng-animate'",
        "'$ngAnimatePin'",
        "'$animateProvider'",
        "''",
        "''",
        "'leave'",
        "'$$rAF'",
        "'$rootScope'",
        "'$rootElement'",
        "'$document'",
        "'$$HashMap'",
        "'$$animation'",
        "'$$AnimateRunner'",
        "'$templateRequest'",
        "'$$jqLite'",
        "'element'",
        "'not an element'",
        "'parentElement'",
        "'not an element'",
        "' '",
        "' '",
        "' '",
        "'enter'",
        "'move'",
        "'leave'",
        "'skip'",
        "'cancel'",
        "'join'",
        "'animate'",
        "'animate'",
        "'setClass'",
        "'close'",
        "'start'",
        "'['",
        "']'",
        "'$$rAF'",
        "'$q'",
        "'$$rAFMutex'",
        "'catch'",
        "'catch'",
        "'finally'",
        "'finally'",
        "'$animateProvider'",
        "'ng-animate'",
        "'ng-animate-ref'",
        "'$$animationRunner'",
        "'$$jqLite'",
        "'$rootScope'",
        "'$injector'",
        "'$$AnimateRunner'",
        "'enter'",
        "'move'",
        "'leave'",
        "'class'",
        "' '",
        "'$destroy'",
        "'['",
        "']'",
        "'enter'",
        "'move'",
        "'to'",
        "'from'",
        "'out'",
        "'in'",
        "' '",
        "' '",
        "'ng-'",
        "' '",
        "'leave'",
        "'$destroy'",
        "'ngAnimate'",
        "'ngAnimateChildren'",
        "'$$rAFMutex'",
        "'$$AnimateRunner'",
        "'$$animateQueue'",
        "'$$animation'",
        "'$animateCss'",
        "'$$animateCssDriver'",
        "'$$animateJs'",
        "'$$animateJsDriver'"
    ],
    "variables": [
        "noop",
        "extend",
        "jqLite",
        "forEach",
        "isArray",
        "isString",
        "isObject",
        "isUndefined",
        "isDefined",
        "isFunction",
        "isElement",
        "ELEMENT_NODE",
        "COMMENT_NODE",
        "NG_ANIMATE_CHILDREN_DATA",
        "isPromiseLike",
        "styles",
        "className",
        "index",
        "i",
        "elm",
        "domOperation",
        "toAdd",
        "toRemove",
        "classes",
        "ADD_CLASS",
        "REMOVE_CLASS",
        "flags",
        "classes",
        "prop",
        "allow",
        "obj",
        "$$AnimateChildrenDirective",
        "val",
        "CSS_PREFIX",
        "TRANSITION_PROP",
        "TRANSITIONEND_EVENT",
        "ANIMATION_PROP",
        "ANIMATIONEND_EVENT",
        "DURATION_KEY",
        "PROPERTY_KEY",
        "DELAY_KEY",
        "TIMING_KEY",
        "ANIMATION_ITERATION_COUNT_KEY",
        "ANIMATION_PLAYSTATE_KEY",
        "ELAPSED_TIME_MAX_DECIMAL_PLACES",
        "CLOSING_TIME_BUFFER",
        "ONE_SECOND",
        "BASE_TEN",
        "SAFE_FAST_FORWARD_DURATION_VALUE",
        "ANIMATION_DELAY_PROP",
        "ANIMATION_DURATION_PROP",
        "TRANSITION_DELAY_PROP",
        "TRANSITION_DURATION_PROP",
        "DETECT_CSS_PROPERTIES",
        "DETECT_STAGGER_CSS_PROPERTIES",
        "styles",
        "detectedStyles",
        "val",
        "c",
        "maxValue",
        "values",
        "style",
        "TRANSITION_PROP",
        "value",
        "prop",
        "value",
        "value",
        "key",
        "prop",
        "value",
        "cache",
        "entry",
        "entry",
        "$AnimateCssProvider",
        "gcsLookup",
        "gcsStaggerLookup",
        "applyAnimationClasses",
        "parentCounter",
        "KEY",
        "parentNode",
        "parentID",
        "timings",
        "stagger",
        "staggerClassName",
        "bod",
        "cancelLastRAFRequest",
        "rafWaitQueue",
        "width",
        "i",
        "timings",
        "aD",
        "tD",
        "node",
        "temporaryStyles",
        "classes",
        "styles",
        "animationClosed",
        "animationPaused",
        "animationCompleted",
        "runner",
        "runnerHost",
        "maxDelay",
        "maxDelayTime",
        "maxDuration",
        "maxDurationTime",
        "method",
        "isStructural",
        "structuralClassName",
        "addRemoveClassName",
        "setupClasses",
        "fullClassName",
        "activeClasses",
        "hasToStyles",
        "cacheKey",
        "stagger",
        "staggerVal",
        "applyOnlyDuration",
        "transitionStyle",
        "durationStyle",
        "keyframeStyle",
        "itemIndex",
        "isFirst",
        "timings",
        "relativeDelay",
        "flags",
        "startTime",
        "events",
        "playPause",
        "value",
        "maxStagger",
        "key",
        "value",
        "delayStyle",
        "easeProp",
        "easeVal",
        "ev",
        "timeStamp",
        "elapsedTime",
        "$$AnimateCssDriverProvider",
        "NG_ANIMATE_SHIM_CLASS_NAME",
        "NG_ANIMATE_ANCHOR_CLASS_NAME",
        "NG_ANIMATE_ANCHOR_SUFFIX",
        "NG_OUT_ANCHOR_CLASS_NAME",
        "NG_IN_ANCHOR_CLASS_NAME",
        "bodyNode",
        "rootNode",
        "rootBodyElement",
        "clone",
        "startingClasses",
        "anchorClasses",
        "animatorIn",
        "animatorOut",
        "startingAnimator",
        "runner",
        "currentAnimation",
        "styles",
        "coords",
        "value",
        "endingClasses",
        "classes",
        "fromAnimation",
        "toAnimation",
        "anchorAnimations",
        "outElement",
        "inElement",
        "animator",
        "animationRunners",
        "runner",
        "element",
        "options",
        "$$AnimateJsProvider",
        "applyAnimationClasses",
        "classesToAdd",
        "classesToRemove",
        "animations",
        "before",
        "after",
        "afterFn",
        "beforeFn",
        "closeActiveAnimations",
        "chain",
        "animationClosed",
        "runner",
        "args",
        "value",
        "operations",
        "animation",
        "runner",
        "endProgressCb",
        "resolved",
        "onAnimationComplete",
        "cancelled",
        "operations",
        "a",
        "b",
        "runners",
        "matches",
        "flagMap",
        "i",
        "klass",
        "animationFactory",
        "$$AnimateJsDriverProvider",
        "fromAnimation",
        "toAnimation",
        "animationRunners",
        "runner",
        "element",
        "options",
        "classes",
        "NG_ANIMATE_ATTR_NAME",
        "NG_ANIMATE_PIN_DATA",
        "$$AnimateQueueProvider",
        "PRE_DIGEST_STATE",
        "RUNNING_STATE",
        "rules",
        "a",
        "b",
        "activeAnimationsLookup",
        "disabledElementsLookup",
        "animationsEnabled",
        "deregisterWatch",
        "bodyElement",
        "callbackRegistry",
        "classNameFilter",
        "isAnimatableClassName",
        "applyAnimationClasses",
        "targetNode",
        "matches",
        "entries",
        "node",
        "entries",
        "containerNode",
        "isMatch",
        "argCount",
        "hasElement",
        "node",
        "recordExists",
        "node",
        "parent",
        "runner",
        "className",
        "isStructural",
        "skipAnimations",
        "existingAnimation",
        "hasExistingAnimation",
        "newAnimation",
        "skipAnimationFlag",
        "cancelAnimationFlag",
        "joinAnimationFlag",
        "isValidAnimation",
        "counter",
        "animationDetails",
        "animationCancelled",
        "parentElement",
        "isValidAnimation",
        "realRunner",
        "animationDetails",
        "node",
        "children",
        "state",
        "animationDetails",
        "parentNode",
        "animationDetails",
        "bodyElementDetected",
        "rootElementDetected",
        "parentAnimationDetected",
        "animateChildren",
        "parentHost",
        "parentNode",
        "details",
        "value",
        "allowAnimation",
        "oldValue",
        "newValue",
        "$$rAFMutexFactory",
        "passed",
        "$$AnimateRunnerFactory",
        "INITIAL_STATE",
        "DONE_PENDING_STATE",
        "DONE_COMPLETE_STATE",
        "index",
        "count",
        "status",
        "$$AnimationProvider",
        "NG_ANIMATE_CLASSNAME",
        "NG_ANIMATE_REF_ATTR",
        "drivers",
        "RUNNER_STORAGE_KEY",
        "animationQueue",
        "applyAnimationClasses",
        "isStructural",
        "runner",
        "classes",
        "tempClasses",
        "animations",
        "startFn",
        "closeFn",
        "operation",
        "startAnimation",
        "animationRunner",
        "SELECTOR",
        "items",
        "anchors",
        "attr",
        "preparedAnimations",
        "refLookup",
        "element",
        "node",
        "enterOrMove",
        "anchorNodes",
        "direction",
        "key",
        "usedIndicesLookup",
        "anchorGroups",
        "to",
        "index",
        "indexKey",
        "fromAnimation",
        "toAnimation",
        "lookupKey",
        "group",
        "matches",
        "i",
        "aa",
        "j",
        "i",
        "driverName",
        "factory",
        "driver",
        "runner"
    ],
    "comments": [
        "jshint ignore:start",
        "there is no point of stripping anything if the element",
        "is the only element within the jqLite wrapper.",
        "(it's important that we retain the element instance.)",
        "sometimes the split leaves empty string values",
        "incase extra spaces were applied to the options",
        "empty attribute",
        "Detect proper transitionend/animationend event names.",
        "If unprefixed events are not supported but webkit-prefixed are, use the latter.",
        "Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.",
        "Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`",
        "but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.",
        "Register both events in case `window.onanimationend` is not supported because of that,",
        "do the same for `transitionend` as Safari is likely to exhibit similar behavior.",
        "Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit",
        "therefore there is no reason to test anymore for other vendor prefixes:",
        "http://caniuse.com/#search=transition",
        "only numerical-based values have a negative sign or digit as the first value",
        "by setting this to null in the event that the delay is not set or is set directly as 0",
        "then we can still allow for zegative values to be used later on and not mistake this",
        "value for being greater than any other negative value.",
        "it's always safe to consider only second values and omit `ms` values since",
        "getComputedStyle will always handle the conversion for us",
        "we use a negative delay value since it performs blocking",
        "yet it doesn't kill any existing transitions running on the",
        "same element which makes this safe for class-based animations",
        "we keep putting this in multiple times even though the value and the cacheKey are the same",
        "because we're keeping an interal tally of how many duplicate animations are detected.",
        "if we have one or more existing matches of matching elements",
        "containing the same parent + CSS styles (which is how cacheKey works)",
        "then staggering is possible",
        "force the conversion of a null value to zero incase not set",
        "cancels the request",
        "the line below will force the browser to perform a repaint so",
        "that all the animated elements within the animation frame will",
        "be properly updated and drawn on screen. This is required to",
        "ensure that the preparation animation is properly flushed so that",
        "the active state picks up from there. DO NOT REMOVE THIS LINE.",
        "DO NOT OPTIMIZE THIS LINE. THE MINIFIER WILL REMOVE IT OTHERWISE WHICH",
        "WILL RESULT IN AN UNPREDICTABLE BUG THAT IS VERY HARD TO TRACK DOWN AND",
        "WILL TAKE YEARS AWAY FROM YOUR LIFE.",
        "we use a for loop to ensure that if the queue is changed",
        "during this looping then it will consider new requests",
        "there may be a situation where a structural animation is combined together",
        "with CSS classes that need to resolve before the animation is computed.",
        "However this means that there is no explicit CSS code to block the animation",
        "from happening (by setting 0s none in the class name). If this is the case",
        "we need to apply the classes before the first rAF so we know to continue if",
        "there actually is a detected transition or keyframe animation",
        "there is no way we can trigger an animation since no styles and",
        "no classes are being applied which would then trigger a transition",
        "we set the duration so that it will be picked up by getComputedStyle later",
        "this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY",
        "without causing any combination of transitions to kick in. By adding a negative delay value",
        "it forces the setup class' transition to end immediately. We later then remove the negative",
        "transition delay to allow for the transition to naturally do it's thing. The beauty here is",
        "that if there is no transition defined then nothing will happen and this will also allow",
        "other transitions to be stacked on top of each other without any chopping them out.",
        "we need to recalculate the delay value since we used a pre-emptive negative",
        "delay value and the delay value is required for the final event checking. This",
        "property will ensure that this will happen after the RAF phase has passed.",
        "TODO(matsko): for 1.5 change this code to have an animator object for better debugging",
        "this will be set during the start() phase",
        "we don't have access to pause/resume the animation",
        "since it hasn't run yet. AnimateRunner will therefore",
        "set noop functions for resume and pause and they will",
        "later be overridden once the animation is triggered",
        "jshint ignore:line",
        "if the promise has been called already then we shouldn't close",
        "the animation again",
        "There is only one way to remove inline style properties entirely from elements.",
        "By using `removeProperty` this works, but we need to convert camel-cased CSS",
        "styles down to hyphenated values.",
        "the reason why we have this option is to allow a synchronous closing callback",
        "that is fired as SOON as the animation ends (when the CSS is removed) or if",
        "the animation never takes off at all. A good example is a leave animation since",
        "the element must be removed just after the animation is over or else the element",
        "will appear on screen for one animation frame causing an overbearing flicker.",
        "if the preparation function fails then the promise is not setup",
        "even though we only pause keyframe animations here the pause flag",
        "will still happen when transitions are used. Only the transition will",
        "not be paused since that is not possible. If the animation ends when",
        "paused then it will not complete until unpaused or cancelled.",
        "checking the stagger duration prevents an accidently cascade of the CSS delay style",
        "being inherited from the parent. If the transition duration is zero then we can safely",
        "rely that the delay value is an intential stagger delay style.",
        "this will decorate the existing promise runner with pause/resume methods",
        "just incase a stagger animation kicks in when the animation",
        "itself was cancelled entirely",
        "although an expired animation is a failed animation, getting to",
        "this outcome is very easy if the CSS code screws up. Therefore we",
        "should still continue normally as if the animation completed correctly.",
        "Firefox (or possibly just Gecko) likes to not round values up\n           * when a ms measurement is used for the animation",
        "$manualTimeStamp is a mocked timeStamp value which is set\n           * within browserTrigger(). This is only here so that tests can\n           * mock animations properly. Real events fallback to event.timeStamp,\n           * or, if they don't, then a timeStamp is automatically created for them.\n           * We're checking to see if the timeStamp surpasses the expected delay,\n           * but we're using elapsedTime instead of the timeStamp on the 2nd\n           * pre-condition since animations sometimes close off early",
        "we set this flag to ensure that if the transition is paused then, when resumed,",
        "the animation will automatically close itself since transitions cannot be paused.",
        "only browsers that support these properties can render animations",
        "remove all the `ng-` stuff",
        "the user may not end up using the `out` animation and",
        "only making use of the `in` animation or vice-versa.",
        "In either case we should allow this and not assume the",
        "animation is over unless both animations are not used.",
        "in the event that there is no `in` animation",
        "we iterate directly since safari messes up and doesn't return",
        "all the keys for the coods object when iterated",
        "no point in doing anything when there are no elements to animate",
        "CSS-driven animations cannot be cancelled, only ended",
        "structural animations ensure that the CSS classes are always applied",
        "before the detection starts.",
        "we special case the leave animation since we want to ensure that",
        "the element is removed as soon as the animation is over. Otherwise",
        "a flicker might appear or the element may not be removed at all",
        "TODO(matsko): use caching here to speed things up for detection",
        "TODO(matsko): add documentation",
        "by the time...",
        "$animateJs(element, 'enter');",
        "the `classes` argument is optional and if it is not used",
        "then the classes will be resolved from the element's className",
        "property as well as options.addClass/options.removeClass.",
        "the lookupAnimations function returns a series of animation objects that are",
        "matched up with one or more of the CSS classes. These animation objects are",
        "defined via the module.animation factory function. If nothing is detected then",
        "we don't return anything which then makes $animation query the next driver.",
        "TODO(matsko): get rid of this",
        "no matching animations",
        "optional onEnd / onCancel callback",
        "note that all of these animations will run in parallel",
        "TODO(matsko): add documentation",
        "at this point we cannot cancel animations for groups just yet. 1.5+",
        "TODO(matsko): make sure to check for grouped animations and delegate down to normal animations",
        "if the new animation is class-based then we can just tack that on",
        "there is no need to animate anything if no classes are being added and",
        "there is no structural animation that will be triggered",
        "why should we trigger a new structural animation if the element will",
        "be removed from the DOM anyway?",
        "if there is a current animation then skip the class-based animation",
        "there can never be two structural animations running at the same time",
        "if the previous animation is already running, but the new animation will",
        "be triggered, but the new animation is structural",
        "Wait until all directive and route-related templates are downloaded and",
        "compiled. The $templateRequest.totalPendingRequests variable keeps track of",
        "all of the remote templates being currently downloaded. If there are no",
        "templates currently downloading then the watcher will still fire anyway.",
        "Now that all templates have been downloaded, $animate will wait until",
        "the post digest queue is empty before enabling animations. By having two",
        "calls to $postDigest calls we can ensure that the flag is enabled at the",
        "very end of the post digest queue. Since all of the animations in $animate",
        "use $postDigest, it's important that the code below executes at the end.",
        "This basically means that the page is fully downloaded and compiled before",
        "any animations are triggered.",
        "we check for null directly in the event that the application already called",
        ".enabled() with whatever arguments that it provided it with",
        "remember that the classNameFilter is set during the provider/config",
        "stage therefore we can optimize here and setup a helper function",
        "this method has four signatures:",
        "() - global getter",
        "(bool) - global setter",
        "(element) - element getter",
        "(element, bool) - element setter<F37>",
        "() - Global getter",
        "(bool) - Global setter",
        "(element) - Element getter",
        "(element, bool) - Element setter",
        "we create a fake runner with a working promise.",
        "These methods will become available after the digest has passed",
        "there are situations where a directive issues an animation for",
        "a jqLite wrapper that contains only comment nodes... If this",
        "happens then there is no way we can perform an animation",
        "this is a hard disable of all animations for the application or on",
        "the element itself, therefore  there is no need to continue further",
        "past this point if not enabled",
        "there is no point in traversing the same collection of parent ancestors if a followup",
        "animation will be run on the same element that already did all that checking work",
        "a joined animation means that this animation will take over the existing one",
        "so an example would involve a leave animation taking over an enter. Then when",
        "the postDigest kicks in the enter will be ignored.",
        "normalization in this case means that it removes redundant CSS classes that",
        "already exist (addClass) or do not exist (removeClass) on the element",
        "when the options are merged and cleaned up we may end up not having to do",
        "an animation at all, therefore we should check this before issuing a post",
        "digest callback. Structural animations will always run no matter what.",
        "animate (from/to) can be quickly checked first, otherwise we check if any classes are present",
        "the counter keeps track of cancelled animations",
        "if addClass/removeClass is called before something like enter then the",
        "registered parent element may not be present. The code below will ensure",
        "that a final value for parent element is obtained",
        "animate/structural/class-based animations all have requirements. Otherwise there",
        "is no point in performing an animation. The parent node must also be set.",
        "this means that the previous animation was cancelled",
        "even if the follow-up animation is the same event",
        "if another animation did not take over then we need",
        "to make sure that the domOperation and options are",
        "handled accordingly",
        "if the event changed from something like enter to leave then we do",
        "it, otherwise if it's the same then the end result will be the same too",
        "this combined multiple class to addClass / removeClass into a setClass event",
        "so long as a structural event did not take over the animation",
        "this will update the runner's flow-control events based on",
        "the `realRunner` object.",
        "jshint ignore:line",
        "falls through",
        "since animations are detected from CSS classes, we need to flush all parent",
        "class-based animations so that the parent classes are all present for child",
        "animations to properly function (otherwise any CSS selectors may not work)",
        "enter/leave/move always have priority",
        "angular doesn't want to attempt to animate elements outside of the application",
        "therefore we need to ensure that the rootElement is an ancestor of the current element",
        "no point in inspecting the #document element",
        "either an enter, leave or move animation will commence",
        "therefore we can't allow any animations to take place",
        "but if a parent animation is class-based then that's ok",
        "there is no need to continue traversing at this point",
        "angular doesn't want to attempt to animate elements outside of the application",
        "therefore we need to ensure that the rootElement is an ancestor of the current element",
        "we also need to ensure that the element is or will be apart of the body element",
        "otherwise it is pointless to even issue an animation to be rendered",
        "TODO(matsko): document the signature in a better way",
        "there is no animation at the current moment, however",
        "these runner methods will get later updated with the",
        "methods leading into the driver's end/cancel methods",
        "for now they just stop the animation from starting",
        "this data is used by the postDigest code and passed into",
        "the driver step function",
        "we only want there to be one function called within the post digest",
        "block. This way we can group animations for all the animations that",
        "were apart of the same postDigest flush call.",
        "the element was destroyed early on which removed the runner",
        "form its storage. This means we can't animate this element",
        "at all and it already has been closed due to destruction.",
        "now any future animations will be in another postDigest",
        "TODO(matsko): only recognize operation.start()",
        "TODO(matsko): change to reference nodes",
        "only one of these is set therefore we can't have an",
        "anchor animation since all three pieces are required",
        "TODO(matsko): double-check this code",
        "TODO(matsko): change to reference nodes",
        "the anchor animations require that the from and to elements both have at least",
        "one shared CSS class which effictively marries the two elements together to use",
        "the same animation driver and to properly sequence the anchor animation.",
        "we loop in reverse order since the more general drivers (like CSS and JS)",
        "may attempt more elements, but custom drivers are more particular",
        "TODO(matsko): remove this check",
        "jshint ignore:line",
        "global angularAnimateModule: true,\n\n   $$rAFMutexFactory,\n   $$AnimateChildrenDirective,\n   $$AnimateRunnerFactory,\n   $$AnimateQueueProvider,\n   $$AnimationProvider,\n   $AnimateCssProvider,\n   $$AnimateCssDriverProvider,\n   $$AnimateJsProvider,\n   $$AnimateJsDriverProvider,"
    ],
    "docstrings": [
        "* @license AngularJS v1.4.0-rc.1\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT",
        "* @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## Usage\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * <!-- notice the `fold-animation` CSS class -->\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       var animation = $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *\n *       // if no possible animation can be triggered due\n *       // to the combination of options then `animation`\n *       // will be returned as undefined\n *       animation.start().done(doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       var animation = $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *\n *       // if no possible animation can be triggered due\n *       // to the combination of options then `animation`\n *       // will be returned as undefined\n *       animation.start().done(doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animation = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animation = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animation` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and stlyes may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * By calling `animation.start()` we do get back a promise, however, due to the nature of animations we may not want to tap into the default behaviour of\n * animations (since they cause a digest to occur which may slow down the animation performance-wise). Therefore instead of calling `then` to capture when\n * the animation ends be sure to call `done(callback)` (this is the recommended way to use `$animateCss` within JavaScript-animations).\n *\n * The example below should put this into perspective:\n *\n * ```js\n * var animation = $animateCss(element, { ... });\n *\n * // remember that if there is no CSS animation detected on the element\n * // then the value returned from $animateCss will be null\n * if (animation) {\n *   animation.start().done(function() {\n *     // yaay the animation is over\n *     doneCallback();\n *   });\n * } else {\n *   doneCallback();\n * }\n * ```\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transition` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframe` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n * `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occuring on the classes being added and removed.)\n *\n * @return {null|object} an object with a start method and details about the animation. If no animation is detected then a value of `null` will be returned.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.",
        "* @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` then the animation hooks are enabled for an Angular app.\n *\n * <div doc-module-components=\"ngAnimate\"></div>\n *\n * # Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on a element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=true\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; in case the stagger doesn't work then the duration value\n *    must be set to 0 to avoid an accidental CSS inheritance &#42;/\n *   transition-duration: 0s;\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the ainmation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can suppliment for the\n * lack of CSS animations by making use of the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var animation = $animateCss(element, {\n *         event: 'enter'\n *       });\n *\n *       if (animation) {\n *         // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *         var runner = animation.start();\n *         runner.done(doneFn);\n *       } else { //no CSS animation was detected\n *         doneFn();\n *       }\n *     }\n *   }\n * }]\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var animation = $animateCss(element, {\n *         event: 'enter',\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       });\n *\n *       if (animation) {\n *         animation.start().done(doneFn);\n *       } else {\n *         doneFn();\n *       }\n *     }\n *   }\n * }]\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in different views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * ```html\n * <!-- index.html -->\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * <!-- home.html -->\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" ng-animate-ref=\"banner\">\n * </a>\n *\n * <!-- banner-page.html -->\n * <img src=\"./banner.jpg\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will then attempt to trigger a CSS\n * animation on the `.view-animation-anchor` CSS class (notice how `.view-animation` is\n * a shared CSS class on the ng-view element? This means that view-animation will apply to\n * both the enter and leave animations).\n *\n * The two images match since they share the same ref value. ngAnimate will now apply a\n * suffixed version of each of the shared CSS classes with `-anchor`. Therefore we will\n * have a shared class of `view-animation-anchor` which we can use to setup our transition animation.\n *\n * We can now attach a transition onto the `.view-animation-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .view-animation-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * There are two stages for an anchor animation: `out` and `in`. The `out` stage happens first and that\n * is when the element is animated away from its origin. Once that animation is over then the `in` stage\n * occurs which animates the element to its destination. The reason why there are two animations is to\n * give enough time for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .view-animation-anchor.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .view-animation-anchor.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id:1, title: \"Miss Beulah Roob\" },\n            { id:2, title: \"Trent Morissette\" },\n            { id:3, title: \"Miss Ava Pouros\" },\n            { id:4, title: \"Rod Pouros\" },\n            { id:5, title: \"Abdul Rice\" },\n            { id:6, title: \"Laurie Rutherford Sr.\" },\n            { id:7, title: \"Nakia McLaughlin\" },\n            { id:8, title: \"Jordon Blanda DVM\" },\n            { id:9, title: \"Rhoda Hand\" },\n            { id:10, title: \"Alexandrea Sauer\" }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter {\n        transition:0.5s linear all;\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active {\n        transform:translateX(0%);\n      }\n      .view.ng-leave {\n        transition:0.5s linear all;\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .view-anchor {\n        transition:0.5s linear all;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeing-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') ? $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * [greeting-box].on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ### Preventing Collisions With Third Party Libraries\n *\n * Some third-party frameworks place animation duration defaults across many element or className\n * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which\n * is expecting actual animations on these elements and has to wait for their completion.\n *\n * You can prevent this unwanted behavior by using a prefix on all your animation classes:\n *\n * ```css\n * /&#42; prefixed with animate- &#42;/\n * .animate-fade-add.animate-fade-add-active {\n *   transition:1s linear all;\n *   opacity:0;\n * }\n * ```\n *\n * You then configure `$animate` to enforce this prefix:\n *\n * ```js\n * $animateProvider.classNameFilter(/animate-/);\n * ```\n *\n * This also may provide your application with a speed boost since only specific elements containing CSS class prefix\n * will be evaluated for animation when any DOM changes occur in the application.\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)",
        "* @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate $animate to learn more about animations with `$animate`}."
    ],
    "functions": [
        "assertArg",
        "mergeClasses",
        "packageStyles",
        "pendClasses",
        "removeFromArray",
        "stripCommentsFromElement",
        "extractElementNode",
        "$$addClass",
        "$$removeClass",
        "applyAnimationClassesFactory",
        "prepareAnimationOptions",
        "applyAnimationStyles",
        "applyAnimationFromStyles",
        "applyAnimationToStyles",
        "mergeAnimationOptions",
        "resolveElementClasses",
        "splitClassesToLookup",
        "computeCssStyles",
        "parseMaxTime",
        "truthyTimingValue",
        "getCssTransitionDurationStyle",
        "getCssKeyframeDurationStyle",
        "getCssDelayStyle",
        "blockTransitions",
        "blockKeyframeAnimations",
        "applyInlineStyle",
        "createLocalCacheLookup",
        "gcsHashFn",
        "computeCachedCssStyles",
        "computeCachedCssStaggerStyles",
        "waitUntilQuiet",
        "computeTimings",
        "init",
        "endFn",
        "cancelFn",
        "close",
        "applyBlocking",
        "start",
        "triggerAnimationStart",
        "onAnimationExpired",
        "onAnimationProgress",
        "filterCssClasses",
        "getUniqueValues",
        "prepareAnchoredAnimation",
        "endFn",
        "calculateAnchorStyles",
        "prepareOutAnimation",
        "prepareInAnimation",
        "end",
        "prepareFromToAnchorAnimation",
        "endFn",
        "prepareRegularAnimation",
        "applyOptions",
        "onComplete",
        "endAnimations",
        "executeAnimationFn",
        "groupEventedAnimations",
        "packageAnimations",
        "lookupAnimations",
        "endFnFactory",
        "done",
        "prepareAnimation",
        "isAllowed",
        "hasAnimationClasses",
        "normalizeAnimationOptions",
        "findCallbacks",
        "triggerCallback",
        "filterFromRegistry",
        "queueAnimation",
        "notifyProgress",
        "close",
        "closeChildAnimations",
        "clearElementAnimationState",
        "isMatchingElement",
        "closeParentClassBasedAnimations",
        "examineParentAnimation",
        "areAnimationsAllowed",
        "markElementAnimationState",
        "next",
        "onProgress",
        "AnimateRunner",
        "setRunner",
        "removeRunner",
        "getRunner",
        "getAnchorNodes",
        "groupAnimations",
        "cssClassesIntersection",
        "invokeFirstDriver",
        "start",
        "updateAnimationRunners",
        "update",
        "handleDestroyedElement",
        "close"
    ],
    "classes": []
}