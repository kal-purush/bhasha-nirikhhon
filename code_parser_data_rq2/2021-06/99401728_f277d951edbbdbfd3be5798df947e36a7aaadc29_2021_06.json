{
    "identifiers": [
        "NodePath",
        "PluginObj",
        "PluginPass",
        "types",
        "annotateAsPure",
        "path",
        "types",
        "path",
        "path",
        "path",
        "path",
        "path",
        "path",
        "path",
        "origin",
        "classIdentifier",
        "types",
        "allowWrappingDecorators",
        "types",
        "types",
        "i",
        "origin",
        "origin",
        "i",
        "nextStatement",
        "nextStatement",
        "nextExpression",
        "types",
        "nextExpression",
        "nextExpression",
        "TSLIB_DECORATE_HELPER_NAME",
        "allowWrappingDecorators",
        "wrapStatementPaths",
        "nextStatement",
        "hasPotentialSideEffects",
        "nextExpression",
        "nextExpression",
        "left",
        "left",
        "left",
        "classIdentifier",
        "types",
        "nextExpression",
        "types",
        "nextExpression",
        "nextExpression",
        "TSLIB_DECORATE_HELPER_NAME",
        "allowWrappingDecorators",
        "wrapStatementPaths",
        "nextStatement",
        "hasPotentialSideEffects",
        "left",
        "types",
        "left",
        "left",
        "left",
        "classIdentifier",
        "types",
        "left",
        "left",
        "nextExpression",
        "angularStaticsToElide",
        "propertyName",
        "assignmentValue",
        "nextStatement",
        "i",
        "angularStaticsToWrap",
        "propertyName",
        "assignmentValue",
        "wrapStatementPaths",
        "nextStatement",
        "hasPotentialSideEffects",
        "types",
        "path",
        "types",
        "state",
        "state",
        "visitedClasses",
        "classNode",
        "parentPath",
        "parentPath",
        "hasExport",
        "parentPath",
        "path",
        "analyzeClassSiblings",
        "origin",
        "classNode",
        "wrapDecorators",
        "visitedClasses",
        "classNode",
        "hasPotentialSideEffects",
        "wrapStatementPaths",
        "types",
        "statementPath",
        "wrapStatementPaths",
        "wrapStatementNodes",
        "statementPath",
        "statementPath",
        "types",
        "types",
        "classNode",
        "wrapStatementNodes",
        "types",
        "types",
        "classNode",
        "types",
        "types",
        "container",
        "annotateAsPure",
        "replacementInitializer",
        "types",
        "types",
        "types",
        "classNode",
        "replacementInitializer",
        "parentPath",
        "parentPath",
        "declaration",
        "types",
        "types",
        "types",
        "classNode",
        "types",
        "path",
        "declaration",
        "path",
        "types",
        "state",
        "state",
        "wrapDecorators",
        "visitedClasses",
        "classNode",
        "classNode",
        "parentPath",
        "types",
        "parentPath",
        "parentPath",
        "classNode",
        "parentPath",
        "origin",
        "origin",
        "analyzeClassSiblings",
        "origin",
        "parentPath",
        "wrapDecorators",
        "visitedClasses",
        "classNode",
        "hasPotentialSideEffects",
        "wrapStatementPaths",
        "types",
        "statementPath",
        "wrapStatementPaths",
        "wrapStatementNodes",
        "statementPath",
        "statementPath",
        "types",
        "types",
        "types",
        "types",
        "types",
        "classNode",
        "classNode",
        "wrapStatementNodes",
        "types",
        "types",
        "classNode",
        "types",
        "types",
        "container",
        "annotateAsPure",
        "replacementInitializer",
        "parentPath",
        "replacementInitializer"
    ],
    "literals": [
        "'@babel/core'",
        "'@babel/helper-annotate-as-pure'",
        "'__decorate'",
        "'ɵcmp'",
        "'ɵdir'",
        "'ɵfac'",
        "'ɵinj'",
        "'ɵmod'",
        "'ɵpipe'",
        "'ɵprov'",
        "'INJECTOR_KEY'",
        "string",
        "'ctorParameters'",
        "'decorators'",
        "'propDecorators'",
        "string",
        "'class'",
        "'expression'",
        "'left'",
        "'right'",
        "'let'",
        "'default'",
        "'let'",
        "'init'"
    ],
    "variables": [
        "TSLIB_DECORATE_HELPER_NAME",
        "angularStaticsToWrap",
        "angularStaticsToElide",
        "wrapStatementPaths",
        "hasPotentialSideEffects",
        "i",
        "nextStatement",
        "nextExpression",
        "left",
        "propertyName",
        "assignmentValue",
        "visitedClasses",
        "classNode",
        "path",
        "hasExport",
        "origin",
        "wrapStatementNodes",
        "container",
        "replacementInitializer",
        "declaration",
        "classNode",
        "path",
        "origin",
        "wrapStatementNodes",
        "container",
        "replacementInitializer"
    ],
    "comments": [
        "Valid sibling statements for class declarations are only assignment expressions",
        "and TypeScript decorator helper call expressions",
        "Statement cannot be safely wrapped which makes wrapping the class unneeded.",
        "The statement will prevent even a wrapped class from being optimized away.",
        "Valid assignment expressions should be member access expressions using the class",
        "name as the object and an identifier as the property for static fields or only",
        "the class name for decorators.",
        "Statement cannot be safely wrapped which makes wrapping the class unneeded.",
        "The statement will prevent even a wrapped class from being optimized away.",
        "Statement cannot be safely wrapped which makes wrapping the class unneeded.",
        "The statement will prevent even a wrapped class from being optimized away.",
        "Analyze sibling statements for elements of the class that were downleveled",
        "Wrap class and safe static assignments in a pure annotated IIFE",
        "Replace class with IIFE wrapped class",
        "When converted to a variable declaration, the default export must be moved",
        "to a subsequent statement to prevent a JavaScript syntax error.",
        "Class expressions are used by TypeScript to represent downlevel class/constructor decorators.",
        "If not wrapping decorators, they do not need to be processed.",
        "Wrap class and safe static assignments in a pure annotated IIFE",
        "Add the wrapped class directly to the variable declaration"
    ],
    "docstrings": [
        "* @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license",
        "* The name of the Typescript decorator helper function created by the TypeScript compiler.",
        "* The set of Angular static fields that should always be wrapped.\n * These fields may appear to have side effects but are safe to remove if the associated class\n * is otherwise unused within the output.",
        "* An object map of static fields and related value checks for discovery of Angular generated\n * JIT related static fields.",
        "* Provides one or more keywords that if found within the content of a source file indicate\n * that this plugin should be used with a source file.\n *\n * @returns An a string iterable containing one or more keywords.",
        "* Analyze the sibling nodes of a class to determine if any downlevel elements should be\n * wrapped in a pure annotated IIFE. Also determines if any elements have potential side\n * effects.\n *\n * @param origin The starting NodePath location for analyzing siblings.\n * @param classIdentifier The identifier node that represents the name of the class.\n * @param allowWrappingDecorators Whether to allow decorators to be wrapped.\n * @returns An object containing the results of the analysis.",
        "* The set of classed already visited and analyzed during the plugin's execution.\n * This is used to prevent adjusted classes from being repeatedly analyzed which can lead\n * to an infinite loop.",
        "* A babel plugin factory function for adjusting classes; primarily with Angular metadata.\n * The adjustments include wrapping classes with known safe or no side effects with pure\n * annotations to support dead code removal of unused classes. Angular compiler generated\n * metadata static fields not required in AOT mode are also elided to better support bundler-\n * level treeshaking.\n *\n * @returns A babel plugin object instance."
    ],
    "functions": [
        "getKeywords",
        "analyzeClassSiblings",
        "ClassDeclaration",
        "ClassExpression"
    ],
    "classes": []
}