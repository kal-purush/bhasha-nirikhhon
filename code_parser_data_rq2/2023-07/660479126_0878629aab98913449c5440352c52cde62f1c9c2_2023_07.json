{
    "identifiers": [
        "abc",
        "typing",
        "Optional",
        "Sequence",
        "numpy",
        "np",
        "pandas",
        "pd",
        "utils",
        "instruction",
        "output_1",
        "input",
        "output_2",
        "abc",
        "ABC",
        "seed",
        "seed",
        "abc",
        "abstractmethod",
        "df_to_annotate",
        "pd",
        "DataFrame",
        "pd",
        "DataFrame",
        "abc",
        "abstractmethod",
        "df_annotated",
        "pd",
        "DataFrame",
        "pd",
        "DataFrame",
        "BaseProcessor",
        "two_columns_to_switch",
        "Sequence",
        "replace_if_switch_kwargs",
        "replace_if_unswitch_kwargs",
        "random_seed_columns",
        "Optional",
        "Sequence",
        "_switch_column",
        "Optional",
        "kwargs",
        "two_columns_to_switch",
        "len",
        "two_columns_to_switch",
        "ValueError",
        "two_columns_to_switch",
        "replace_if_switch_kwargs",
        "replace_if_unswitch_kwargs",
        "replace_if_switch_kwargs",
        "_switch_column",
        "join",
        "two_columns_to_switch",
        "_switch_column",
        "random_seed_columns",
        "two_columns_to_switch",
        "random_seed_columns",
        "kwargs",
        "df_to_annotate",
        "pd",
        "DataFrame",
        "pd",
        "DataFrame",
        "df_to_annotate",
        "copy",
        "_switch_column",
        "df_to_annotate",
        "apply",
        "x",
        "utils",
        "random_seeded_choice",
        "seed",
        "_switch_column",
        "join",
        "x",
        "random_seed_columns",
        "seed",
        "choices",
        "axis",
        "_switch_or_unswitch",
        "df_to_annotate",
        "is_switch",
        "df_annotated",
        "pd",
        "DataFrame",
        "pd",
        "DataFrame",
        "df_annotated",
        "copy",
        "_switch_or_unswitch",
        "df_annotated",
        "is_switch",
        "df_annotated",
        "drop",
        "columns",
        "_switch_column",
        "df_annotated",
        "property",
        "two_columns_to_switch",
        "property",
        "two_columns_to_switch",
        "df",
        "pd",
        "DataFrame",
        "is_switch",
        "pd",
        "DataFrame",
        "df",
        "col1",
        "copy",
        "df",
        "col2",
        "copy",
        "df",
        "_switch_column",
        "col2",
        "np",
        "where",
        "is_switch_arr",
        "col1_values",
        "col2_values",
        "col1",
        "np",
        "where",
        "is_switch_arr",
        "col2_values",
        "col1_values",
        "is_switch",
        "df",
        "loc",
        "df",
        "loc",
        "is_switch_arr",
        "replace",
        "replace_if_switch_kwargs",
        "df",
        "loc",
        "df",
        "loc",
        "is_switch_arr",
        "replace",
        "replace_if_unswitch_kwargs",
        "df",
        "BaseProcessor",
        "batch_size",
        "padding_example",
        "kwargs",
        "batch_size",
        "padding_example",
        "kwargs",
        "df_to_annotate",
        "pd",
        "DataFrame",
        "pd",
        "DataFrame",
        "batch_size",
        "len",
        "df_to_annotate",
        "batch_size",
        "pd",
        "DataFrame",
        "padding_example",
        "n_to_pad",
        "pd",
        "concat",
        "df_to_annotate",
        "padding",
        "axis",
        "ignore_index",
        "df_out",
        "fillna",
        "df_out",
        "df_annotated",
        "pd",
        "DataFrame",
        "pd",
        "DataFrame",
        "df_annotated",
        "df_annotated",
        "drop",
        "columns",
        "copy"
    ],
    "literals": [
        "\"1+1=\"",
        "\"2\"",
        "\"\"",
        "\"3\"",
        "r\"\"\"Randomly switch the order of two columns.\n\n    Parameters\n    ----------\n    two_columns_to_switch : Sequence[str]\n        The two columns to switch.\n\n    replace_if_swtich_kwargs : dict, optional\n        Arguments to pass to `df.replace` to replace some values in the dataframe when there was a switch.\n\n    replace_if_unswitch_kwargs : dict, optional\n        Arguments to pass to `df.replace` to replace some values in the dataframe when you are undoing a switch.\n        By default, applies the same as `replace_if_switch_kwargs`.\n\n    random_seed_columns : Optional[Sequence[str]], optional\n        The columns to use to seed the random choice of switching or not. If None, will use `columns_to_switch`.\n\n    kwargs :\n        Additional arguments to pass to `BaseProcessor`. E.g. seed.\n\n    Examples\n    --------\n    >>> df = pd.DataFrame([dict(instruction='2+2', output_1='10', output_2='4', preference=2),\n    ...                    dict(instruction='2+3', output_1='5', output_2='7', preference=1)])\n    >>> processor = RandomSwitchTwoColumnsProcessor(two_columns_to_switch=['output_1', 'output_2'],\n    ...                                                replace_if_switch_kwargs={'preference': {1: 2, 2: 1}})\n    >>> processor.preprocess(df)\n        instruction output_1 output_2  preference is_switch_output_1_output_2\n    0         2+2         4       10           1                         True\n    1         2+3         5        7           1                        False\n    >>> (processor.postprocess(processor.preprocess(df)) == df).all(axis=None)\n    True\n    \"\"\"",
        "f\"two_columns_to_switch should have exactly two different columns but {two_columns_to_switch}\"",
        "\"_\"",
        "\"is_switch\"",
        "\"\"",
        "r\"\"\"Pad the dataframe to have a number of examples divisible by `batch_size`.\n\n    Parameters\n    ----------\n    batch_size : int\n        Number of examples to batch in a single prompt.\n\n    padding_example : dict\n        Padding example to use if len(df) not divisible by batch_size.\n\n    kwargs :\n        Additional arguments to pass to `BaseProcessor`. E.g. seed.\n\n    Examples\n    --------\n    >>> df = pd.DataFrame({\"instruction\": [\"solve\", \"write\", \"other 1\"],\n    ...                    \"input\": [\"1+1\", \"'abc'\", \"\"]})\n    >>> processor = PaddingForBatchesProcessor(batch_size=2, padding_example=dict(instruction=\"pad\", input=\"pad_in\"))\n    >>> processor.preprocess(df)\n        instruction   input  is_padding\n    0         solve     1+1       False\n    1         write   'abc'       False\n    2       other 1               False\n    3           pad  pad_in        True\n    >>> (processor.postprocess(processor.preprocess(df)) == df).all(axis=None)\n    True\n    \"\"\"",
        "\"is_padding\"",
        "\"is_padding\"",
        "\"is_padding\"",
        "\"is_padding\"",
        "\"is_padding\""
    ],
    "variables": [
        "DUMMY_EXAMPLE",
        "seed",
        "two_columns_to_switch",
        "replace_if_switch_kwargs",
        "replace_if_unswitch_kwargs",
        "_switch_column",
        "_switch_column",
        "random_seed_columns",
        "random_seed_columns",
        "df_to_annotate",
        "df_to_annotate",
        "df_annotated",
        "df_annotated",
        "df_annotated",
        "col1_values",
        "col2_values",
        "is_switch_arr",
        "df",
        "df",
        "is_switch_arr",
        "is_switch_arr",
        "batch_size",
        "padding_example",
        "n_to_pad",
        "padding",
        "padding",
        "df_out",
        "df_out"
    ],
    "comments": [
        "`switch_column` used for backward compatibility",
        "randomize order of output_1, output_2 base on inputs",
        "we add \"_switch_column\" at the beginning to not use the same seed for all tasks",
        "switching two columns is an involution => no need to use is_switch here",
        "replace might not be an involution e.g. if using a regex",
        "padding if you don't have enough examples"
    ],
    "docstrings": [
        "\"\"\"\nHelper classes for processing the data. Each of those should have a function preprocess and postprocess, which will\nrespectively be called in SingleAnnotator._preprocess and SingleAnnotator._postprocess in reverse order.\n\nNote: not worth to make the changes but all the parsers could have been processors.\n\"\"\"",
        "\"\"\"Base class for a processor.\"\"\"",
        "\"\"\"Process the annotation dataframe before annotations.\"\"\"",
        "\"\"\"Process the annotation dataframe after annotations.\"\"\"",
        "\"\"\"When preprocessing, we select the rows to switch and perform the switch.\"\"\"",
        "\"\"\"When postprocessing, we undo the switch and remove the switch column.\"\"\"",
        "\"\"\"Applies the switch to the dataframe. If `is_switch=False` will undo the switch.\"\"\""
    ],
    "functions": [
        "preprocess",
        "postprocess",
        "preprocess",
        "postprocess",
        "col1",
        "col2",
        "_switch_or_unswitch",
        "preprocess",
        "postprocess"
    ],
    "classes": [
        "BaseProcessor",
        "RandomSwitchTwoColumnsProcessor",
        "PaddingForBatchesProcessor"
    ]
}