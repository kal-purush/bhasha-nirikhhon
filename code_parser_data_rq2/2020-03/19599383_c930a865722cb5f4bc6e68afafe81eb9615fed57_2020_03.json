{
    "identifiers": [
        "collections",
        "OrderedDict",
        "matplotlib",
        "mpl",
        "matplotlib",
        "pyplot",
        "plt",
        "matplotlib",
        "cm",
        "landlab",
        "components",
        "profiler",
        "base_profiler",
        "_BaseProfiler",
        "landlab",
        "core",
        "utils",
        "as_id_array",
        "landlab",
        "utils",
        "flow__distance",
        "calculate_flow__distance",
        "_BaseProfiler",
        "grid",
        "starting_nodes",
        "cmap",
        "grid",
        "plt",
        "get_cmap",
        "cmap",
        "grid",
        "at_node",
        "starting_nodes",
        "property",
        "_data_struct",
        "OrderedDict",
        "i",
        "_starting_nodes",
        "i",
        "_flow_receiver",
        "current_node",
        "current_node",
        "channel_segment",
        "append",
        "current_node",
        "_flow_receiver",
        "current_node",
        "channel_segment",
        "append",
        "current_node",
        "channel_segment",
        "reverse",
        "current_node",
        "i",
        "_data_struct",
        "segment_tuple",
        "as_id_array",
        "channel_segment",
        "_calculate_distances",
        "assign_colors",
        "_create_flat_structures",
        "outlet_id",
        "_data_struct",
        "_data_struct",
        "outlet_id",
        "keys",
        "_nodes",
        "extend",
        "_data_struct",
        "outlet_id",
        "seg",
        "seg",
        "seg_tuples",
        "_distance_along_profile",
        "extend",
        "_data_struct",
        "outlet_id",
        "seg",
        "seg",
        "seg_tuples",
        "_colors",
        "extend",
        "_data_struct",
        "outlet_id",
        "seg",
        "seg",
        "seg_tuples",
        "color_mapping",
        "color_mapping",
        "len",
        "_data_struct",
        "mpl",
        "colors",
        "Normalize",
        "vmin",
        "vmax",
        "num_watersheds",
        "cm",
        "ScalarMappable",
        "norm",
        "norm",
        "cmap",
        "_cmap",
        "outlet_id",
        "mappable",
        "to_rgba",
        "idx",
        "idx",
        "outlet_id",
        "_data_struct",
        "outlet_id",
        "_data_struct",
        "segment_tuple",
        "_data_struct",
        "outlet_id",
        "_data_struct",
        "outlet_id",
        "segment_tuple",
        "color_mapping",
        "outlet_id",
        "calculate_flow__distance",
        "_grid",
        "outlet_id",
        "_data_struct",
        "segment_tuple",
        "_data_struct",
        "outlet_id",
        "_data_struct",
        "outlet_id",
        "segment_tuple",
        "distance_upstream",
        "ids",
        "_data_struct",
        "outlet_id",
        "segment_tuple",
        "d"
    ],
    "literals": [
        "\"TrickleDownProfiler\"",
        "\"flow__link_to_receiver_node\"",
        "\"dtype\"",
        "\"intent\"",
        "\"in\"",
        "\"optional\"",
        "\"units\"",
        "\"-\"",
        "\"mapping\"",
        "\"node\"",
        "\"doc\"",
        "\"ID of link downstream of each node, which carries the discharge\"",
        "\"flow__receiver_node\"",
        "\"dtype\"",
        "\"intent\"",
        "\"in\"",
        "\"optional\"",
        "\"units\"",
        "\"-\"",
        "\"mapping\"",
        "\"node\"",
        "\"doc\"",
        "\"Node array of receivers (node that receives flow from current node)\"",
        "\"viridis\"",
        "\"flow__receiver_node\"",
        "\"ids\"",
        "\"ids\"",
        "\"distances\"",
        "\"color\"",
        "\"color\"",
        "\"ids\"",
        "\"distances\""
    ],
    "variables": [
        "_name",
        "_unit_agnostic",
        "_info",
        "_cmap",
        "_flow_receiver",
        "_starting_nodes",
        "_data_struct",
        "channel_segment",
        "current_node",
        "current_node",
        "segment_tuple",
        "i",
        "_nodes",
        "_distance_along_profile",
        "_colors",
        "seg_tuples",
        "num_watersheds",
        "norm",
        "mappable",
        "color_mapping",
        "distance_upstream",
        "ids",
        "d"
    ],
    "comments": [
        "coding: utf8",
        "! /usr/env/python",
        "march downstream"
    ],
    "docstrings": [
        "\"\"\"trickle_down_profiler.py component to create channel profiles.\"\"\"",
        "\"\"\"Extract and a profile from one or more node IDs to their downstream termini.\n\n    The TrickleDownProfiler extracts channel networks from a landlab grid.\n    Unlike the ChannelProfiler which starts at one or more watershed outlets\n    and works upstream until it reaches the end of the channel (based on\n    a specified threshold, such as drainage area) the TrickleDownProfiler\n    starts at a *starting node* and works its way downhill until it reaches\n    an outlet or sink.\n\n    In order to follow the channel network, the flow connectivity across the\n    grid must already be identified. This is typically done with the\n    FlowAccumulator component. However, this component does not require that the\n    FlowAccumulator was used. Instead it expects that the following at-node\n    grid fields will be present:\n    ::\n\n        'flow__receiver_node'\n        'flow__link_to_receiver_node'\n\n    The TrickleDownProfiler can work on grids that have used route-to-one or\n    route-to-multiple flow directing.\n\n    To understand how this component works it is useful to define the following\n    terms: *outlet*, *starting node*, and *segment*.\n\n    Consider the following grid with 10 columns and 7 rows. ``@`` represents\n    the *starting node*, ``.`` represents the nodes downstream, and the\n    watershed outlet node is indicated by ``o``.\n\n    In this and the following examples, we will use only D4 connectivity. The\n    ChannelProfiler, however, knows nothing of connectivity other than what is\n    implied by the two required grid fields.\n    ::\n\n        X X X X X X X X X X\n        X X X X X X X X X X\n        X X X X X X . . @ X\n        X X X X X X . X X X\n        X X X . . . . X X X\n        X X X . X X X X X X\n        X X X o X X X X X X\n\n    For each starting node, the TrickleDownProfiler follows the network\n    downstream until it reaches the outlet or sink. One or more starting nodes\n    can be used, depending on a user's needs.\n\n    The node IDs and distances upstream of the channel network are stored in\n    ``data_structure``. It is a dictionary with keys indicating the starting\n    node.\n\n    For each starting node, the value in the ``data_structure`` is itself\n    a dictionary with keys that are a segment ID tuple of the\n    ``(dowstream, upstream)`` nodes IDs of each channel segment.\n\n    For our simple example, these are the node IDs:\n    ::\n\n            X  X  X  X  X  X  X  X  X  X\n            X  X  X  X  X  X  X  X  X  X\n            X  X  X  X  X  X 46 47 48  X\n            X  X  X  X  X  X 36  X  X  X\n            X  X  X 23 24 25 26  X  X  X\n            X  X  X 13  X  X  X  X  X  X\n            X  X  X  3  X  X  X  X  X  X\n\n    The starting node is 48 and the outlet node is 3.\n\n    The value associated with the segment ID tuple ``(3, 48)`` is itself a\n    dictionary. It has three key-value pairs. First, ``\"ids\"`` contains a list\n    of the segment node ids ordered from downstream to upstream. It includes\n    the endpoints. Second, ``\"distances\"`` contains a list of distances\n    upstream that mirrors the list in ``\"ids\"``. Finally, ``\"color\"`` is an\n    RGBA tuple indicating the color for the segment.\n\n    By default a unique color will be assigned to each starting node. To change\n    the color, a user can change values stored in ``data_structure``.\n    Additionally, a ``cmap`` keyword argument can provide some user control\n    over the color at the instantiation of the component.\n\n    For example with a starting node of 48, the data structure will look as\n    follows:\n\n    .. code-block:: python\n\n        {48: {\n            (3, 48) : {\n                \"ids\": [3, 13, 23, 24, 25, 26, 36, 46, 47, 48],\n                \"distances\": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n                \"color\": (1, 0, 1, 1),\n                }\n            }\n        }\n\n    Note that the distances upstream are relative to the outlet.\n\n    Next consider an example with two starting nodes, each noted with an ``@``.\n    ::\n\n        X X X X X X X X X X\n        X X X X X X @ X X X\n        X X X X @ X . X X X\n        o . . . . X . X X X\n        X X X X X X . X X X\n        X X X X X X . X X X\n        X X X X X X . . . X\n        X X X X X X X X o X\n\n    And the following node IDs.\n    ::\n\n        X   X   X   X   X   X   X   X   X   X\n        X   X   X   X   X   X  66   X   X   X\n        X   X   X   X  54   X  56   X   X   X\n       40  41  42  43  44   X  46   X   X   X\n        X   X   X   X   X   X  36   X   X   X\n        X   X   X   X   X   X  26   X   X   X\n        X   X   X   X   X   X  16  17  18   X\n        X   X   X   X   X   X   X   X   8   X\n\n    With our starting nodes of 54 and 66 our data structure will look like.\n\n    .. code-block:: python\n\n        {54: {\n            (40, 54) : {\n                \"ids\": [40, 41, 42, 43, 44, 54],\n                \"distances\": [0, 1, 3, 4, 5, 6],\n                \"color\": [ 0.27,  0.  ,  0.33,  1.  ],\n                },\n            }\n        66: {\n            (8, 66) : {\n                \"ids\": [8, 18, 17, 16, 26, 36, 46, 56, 66],\n                \"distances\": [0, 1, 2, 3, 4, 5, 6, 7, 8],\n                \"color\": [ 0.13,  0.57,  0.55,  1.  ],\n                },\n        }\n\n    Examples\n    --------\n\n    Start by importing necessary modules\n\n    >>> import numpy as np\n    >>> from landlab import RasterModelGrid\n    >>> from landlab.components import FlowAccumulator, TrickleDownProfiler\n\n    Create the second example grid we showed above. Note that in order to do\n    this we need to enter the elevations starting from the lower left so the\n    elevation order may seem upside-down. In addition, in this example,\n    elevation is only provided along the profiles. The third line of code below\n    sets all nodes with a value of zero to closed, such that these nodes are\n    igored.\n    >>> z = np.array([ 0,  0,  0,  0,  0,  0,  0,  0,  1,  0,\n    ...                0,  0,  0,  0,  0,  0,  4,  3,  2,  0,\n    ...                0,  0,  0,  8,  7,  6,  5,  0,  0,  0,\n    ...                0,  0,  0,  0,  0,  0,  6,  0,  0,  0,\n    ...                1,  3,  4,  5,  6,  0,  7,  0,  0,  0,\n    ...                0,  4,  0,  0,  7,  0,  8,  0,  0,  0,\n    ...                0,  5,  6,  0,  0,  0,  9,  0,  0,  0,\n    ...                0,  0,  0,  0,  0,  0,  0,  0,  0,  0,], dtype=float)\n\n    >>> mg = RasterModelGrid((8, 10))\n    >>> z = mg.add_field(\"topographic__elevation\", z, at=\"node\")\n    >>> mg.set_nodata_nodes_to_closed(z, 0)\n    >>> fa = FlowAccumulator(mg, flow_director='D4')\n    >>> fa.run_one_step()\n    >>> fa.node_drainage_area.reshape(mg.shape)\n    array([[  0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  11.,   0.],\n           [  0.,   0.,   0.,   0.,   0.,   0.,   9.,  10.,  11.,   0.],\n           [  0.,   0.,   0.,   1.,   2.,   3.,   8.,   0.,   0.,   0.],\n           [  0.,   0.,   0.,   0.,   0.,   0.,   4.,   0.,   0.,   0.],\n           [  8.,   8.,   4.,   3.,   2.,   0.,   3.,   0.,   0.,   0.],\n           [  0.,   3.,   0.,   0.,   1.,   0.,   2.,   0.,   0.,   0.],\n           [  0.,   2.,   1.,   0.,   0.,   0.,   1.,   0.,   0.,   0.],\n           [  0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.]])\n\n    >>> profiler = TrickleDownProfiler(\n    ...     mg,\n    ...     starting_nodes=[54, 66])\n    >>> profiler.run_one_step()\n\n    The keys of the property ``data_structure`` are the IDs of the two outlet\n    nodes.\n\n    >>> profiler.data_structure.keys()\n    odict_keys([54, 66])\n\n    Within the data structure, the value at key 54, is a dictionary of the\n    one segment, each specified by a ``(dowstream, upstream)`` tuple:\n\n    >>> profiler.data_structure[54].keys()\n    dict_keys([(40, 54)])\n\n    The value of the segment between nodes 40 and 54 has the following\n    components:\n\n    >>> profiler.data_structure[54][(40, 54)][\"ids\"]\n    array([40, 41, 42, 43, 44, 54])\n    >>> profiler.data_structure[54][(40, 54)][\"distances\"]\n    array([ 0.,  1.,  2.,  3.,  4.,  5.])\n    >>> np.round(profiler.data_structure[54][(40, 54)][\"color\"], decimals=2)\n    array([ 0.27,  0.  ,  0.33,  1.  ])\n\n    The rest of the ``profile_structure`` encodes information about the second\n    profile which starts at node 66.\n\n    >>> profiler.data_structure[66].keys()\n    dict_keys([(8, 66)])\n\n    >>> profiler.data_structure[66][(8, 66)][\"ids\"]\n    array([ 8, 18, 17, 16, 26, 36, 46, 56, 66])\n    >>> profiler.data_structure[66][(8, 66)][\"distances\"]\n    array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])\n    >>> np.round(profiler.data_structure[66][(8, 66)][\"color\"], decimals=2)\n    array([ 0.13,  0.57,  0.55,  1.  ])\n\n\n    References\n    ----------\n    **Required Software Citation(s) Specific to this Component**\n\n    None Listed\n\n    **Additional References**\n\n    None Listed\n\n    \"\"\"",
        "\"\"\"\n        Parameters\n        ----------\n        grid : Landlab Model Grid instance\n        starting_nodes : iterable\n        cmap : str, optional\n            A valid matplotlib cmap string. Default is \"viridis\".\n\n        \"\"\"",
        "\"\"\"OrderedDict defining the trickle down network.\n\n        The IDs and upstream distance of the channel network nodes are stored\n        in ``data_structure``. It is a dictionary with keys of the outlet node\n        ID.\n\n        For each starting node, the value in the ``data_structure`` is\n        itself a dictionary with keys that are a segment ID tuple of the\n        ``(dowstream, upstream)`` nodes IDs of each channel segment.\n\n        The value associated with the segment ID tuple\n        ``(dowstream, upstream)`` is itself a dictionary. It has three\n        key-value pairs. First, ``\"ids\"`` contains a list of the segment node\n        IDs ordered from downstream to upstream. It includes the endpoints.\n        Second, ``\"distances\"`` contains a list of distances upstream that\n        mirrors the list in ``\"ids\"``. Finally, ``\"color\"`` is an RGBA tuple\n        indicating the color for the segment.\n        \"\"\"",
        "\"\"\"Create the profile_IDs data structure for channel network.\n\n        The bound attribute self._profile structure is the channel segment\n        datastructure. Profile structure is a list of length\n        starting_nodes. Each element of profile_structure is itself a\n        list of length number of stream segments that drain to each of the\n        starting nodes. Each stream segment list contains the node ids of a\n        stream segment from downstream to upstream.\n        \"\"\"",
        "\"\"\"Create expected flattened structures for ids, distances, and colors.\n        \"\"\"",
        "\"\"\"Assign a unique color for each starting node.\n\n        Parameters\n        ----------\n        color_mapping : str\n            Color map name.\n        \"\"\"",
        "\"\"\"Get distances along the network data structure.\"\"\""
    ],
    "functions": [
        "data_structure",
        "_create_profile_structure",
        "_create_flat_structures",
        "assign_colors",
        "_calculate_distances"
    ],
    "classes": [
        "TrickleDownProfiler"
    ]
}