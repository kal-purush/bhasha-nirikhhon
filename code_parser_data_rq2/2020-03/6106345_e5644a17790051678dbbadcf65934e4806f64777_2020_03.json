{
    "identifiers": [
        "collections",
        "logging",
        "os",
        "solv",
        "pulp_rpm",
        "app",
        "models",
        "logging",
        "getLogger",
        "epoch",
        "version",
        "release",
        "version",
        "format",
        "format",
        "epoch",
        "epoch",
        "version",
        "format",
        "release",
        "release",
        "solv_repo",
        "unit",
        "solv_repo",
        "add_solvable",
        "solvable",
        "unit",
        "solv_repo",
        "first_repodata",
        "file_repr",
        "unit",
        "get",
        "file_repr",
        "repodata",
        "str2dir",
        "dir_path",
        "repodata",
        "add_dirstr",
        "solvable",
        "id",
        "solv",
        "SOLVABLE_FILELIST",
        "dirname_id",
        "os",
        "path",
        "basename",
        "dir_path",
        "solvable",
        "name",
        "evr",
        "arch",
        "solvable",
        "repo",
        "pool",
        "pool",
        "str2id",
        "name",
        "pool",
        "str2id",
        "evr",
        "pool",
        "str2id",
        "arch",
        "pool",
        "rel2id",
        "name_id",
        "arch_id",
        "solv",
        "REL_ARCH",
        "pool",
        "rel2id",
        "rel",
        "evr_id",
        "solv",
        "REL_EQ",
        "solvable",
        "add_deparray",
        "solv",
        "SOLVABLE_PROVIDES",
        "rel",
        "unit",
        "get",
        "name",
        "libsolv_formatted_evr",
        "unit",
        "get",
        "unit",
        "get",
        "unit",
        "get",
        "evr",
        "unit",
        "get",
        "arch",
        "unit",
        "get",
        "vendor",
        "vendor",
        "vendor",
        "attribute_name",
        "depunit",
        "unit",
        "get",
        "attribute_name",
        "rpm_dependency_conversion",
        "solvable",
        "depunit",
        "attribute_name",
        "rpm_filelist_conversion",
        "solvable",
        "unit",
        "rpm_basic_deps",
        "solvable",
        "name",
        "evr",
        "arch",
        "solvable",
        "solvable",
        "unit",
        "attr_name",
        "dependency_key",
        "unit",
        "unit",
        "libsolv_formatted_evr",
        "unit",
        "unit",
        "unit",
        "dependency_key",
        "getattr",
        "solv",
        "format",
        "attr_name",
        "upper",
        "solvable",
        "repo",
        "pool",
        "unit_name",
        "startswith",
        "pool",
        "parserpmrichdep",
        "unit_name",
        "pool",
        "Dep",
        "unit_name",
        "unit_flags",
        "unit_flags",
        "solv",
        "REL_EQ",
        "unit_flags",
        "solv",
        "REL_LT",
        "unit_flags",
        "solv",
        "REL_GT",
        "unit_flags",
        "solv",
        "REL_EQ",
        "solv",
        "REL_LT",
        "unit_flags",
        "solv",
        "REL_EQ",
        "solv",
        "REL_GT",
        "ValueError",
        "unit_flags",
        "dep",
        "Rel",
        "rel_flags",
        "pool",
        "Dep",
        "unit_evr",
        "solvable",
        "add_deparray",
        "keyname",
        "dep",
        "unit_id",
        "solvable",
        "repo_id",
        "get_repo",
        "repo_id",
        "ValueError",
        "format",
        "unit_id",
        "repo_id",
        "_mapping_solvable_to_unit",
        "setdefault",
        "solvable",
        "id",
        "unit_id",
        "repo_id",
        "_mapping_unit_to_solvable",
        "setdefault",
        "unit_id",
        "repo_id",
        "solvable",
        "logger",
        "debug",
        "format",
        "unit",
        "unit_id",
        "solvable",
        "solvable",
        "repo",
        "repo_id",
        "repo_id",
        "libsolv_repo",
        "_mapping_repos",
        "setdefault",
        "repo_id",
        "libsolv_repo",
        "repo_id",
        "_mapping_repos",
        "get",
        "repo_id",
        "solvable",
        "_mapping_solvable_to_unit",
        "get",
        "solvable",
        "id",
        "unit_id",
        "repo_id",
        "_mapping_unit_to_solvable",
        "get",
        "unit_id",
        "repo_id",
        "repo_id",
        "unit_id",
        "unit_id",
        "unit_repo_id",
        "_mapping_unit_to_solvable",
        "keys",
        "unit_repo_id",
        "repo_id",
        "solvables",
        "collections",
        "defaultdict",
        "solvable",
        "solvables",
        "get_unit_id",
        "solvable",
        "repo_unit_map",
        "repo_id",
        "add",
        "unit_id",
        "repo_unit_map",
        "solv",
        "Pool",
        "_pool",
        "setarch",
        "UnitSolvableMapping",
        "_pool",
        "mapping",
        "get_repo",
        "COMBINED_TARGET_REPO_NAME",
        "_pool",
        "addfileprovides",
        "_pool",
        "createwhatprovides",
        "repo_version",
        "_load_from_version",
        "repo_version",
        "logger",
        "debug",
        "format",
        "repo_version",
        "repository",
        "repo_version",
        "number",
        "libsolv_repo_name",
        "repo_version",
        "_load_from_version",
        "repo_version",
        "as_target",
        "logger",
        "debug",
        "format",
        "repo_version",
        "repository",
        "repo_version",
        "number",
        "libsolv_repo_name",
        "repo_version",
        "format",
        "repo_version",
        "repository",
        "name",
        "repo_version",
        "number",
        "repo_version",
        "as_target",
        "as_target",
        "COMBINED_TARGET_REPO_NAME",
        "_repo_version_to_libsolv_name",
        "repo_version",
        "mapping",
        "get_repo",
        "libsolv_repo_name",
        "repo",
        "mapping",
        "register_repo",
        "libsolv_repo_name",
        "_pool",
        "add_repo",
        "libsolv_repo_name",
        "repo",
        "add_repodata",
        "repo",
        "first_repodata",
        "repo_version",
        "content",
        "pulp_type",
        "models",
        "Package",
        "get_pulp_type",
        "only",
        "models",
        "Package",
        "objects",
        "pk__in",
        "package_ids",
        "is_modular",
        "values",
        "RPM_FIELDS",
        "rpm",
        "nonmodular_rpms",
        "iterator",
        "chunk_size",
        "rpm_to_solvable",
        "repo",
        "rpm",
        "mapping",
        "register",
        "rpm",
        "solvable",
        "libsolv_repo_name",
        "repodata",
        "internalize",
        "libsolv_repo_name",
        "unit_repo_map",
        "_finalized",
        "repo",
        "units",
        "unit_repo_map",
        "items",
        "unit",
        "units",
        "unit",
        "pulp_type",
        "solvables",
        "append",
        "mapping",
        "get_solvable",
        "unit",
        "pk",
        "repo",
        "_pool",
        "createwhatprovides",
        "solv",
        "Job",
        "SOLVER_INSTALL",
        "solv",
        "Job",
        "SOLVER_SOLVABLE",
        "jobs",
        "_pool",
        "Solver",
        "solver",
        "solve",
        "jobs",
        "problem",
        "problem",
        "raw_problems",
        "problems",
        "previous_problems",
        "problems",
        "problems",
        "attempt",
        "problems",
        "logger",
        "debug",
        "format",
        "join",
        "problems",
        "solver",
        "transaction",
        "transaction",
        "newsolvables",
        "solvables",
        "solvables_to_copy",
        "solvables_to_copy",
        "pop",
        "solvable",
        "name",
        "startswith",
        "_pool",
        "rel2id",
        "_pool",
        "str2id",
        "solvable",
        "name",
        "_pool",
        "str2id",
        "solvable",
        "arch",
        "solv",
        "REL_ARCH",
        "_pool",
        "whatcontainsdep",
        "solv",
        "SOLVABLE_REQUIRES",
        "module_dep",
        "_pool",
        "Job",
        "flags",
        "solvable",
        "id",
        "install_jobs",
        "append",
        "module_install_job",
        "artifact",
        "module_artifacts",
        "_pool",
        "Job",
        "flags",
        "artifact",
        "id",
        "install_jobs",
        "append",
        "artifact_install_job",
        "_pool",
        "Job",
        "flags",
        "solvable",
        "id",
        "install_jobs",
        "append",
        "unit_install_job",
        "run_solver_jobs",
        "install_jobs",
        "result_solvables",
        "update",
        "solvables_copied",
        "mapping",
        "get_units_from_solvables",
        "result_solvables"
    ],
    "literals": [
        "\"combined_target_repo\"",
        "'pk'",
        "'name'",
        "'version'",
        "'release'",
        "'epoch'",
        "'arch'",
        "'rpm_vendor'",
        "'provides'",
        "'requires'",
        "'files'",
        "'pk'",
        "'name'",
        "'stream'",
        "'version'",
        "'context'",
        "'arch'",
        "'profiles'",
        "'dependencies'",
        "'artifacts'",
        "'pk'",
        "'name'",
        "'stream'",
        "'repo_id'",
        "'{}{}{}'",
        "'{}:'",
        "''",
        "'-{}'",
        "''",
        "'files'",
        "'name'",
        "'epoch'",
        "'version'",
        "'arch'",
        "'arch'",
        "'noarch'",
        "'vendor'",
        "'requires'",
        "'provides'",
        "'recommends'",
        "'SOLVABLE_{}'",
        "'('",
        "'EQ'",
        "'LT'",
        "'GT'",
        "'LE'",
        "'GE'",
        "'Unsupported dependency flags %s'",
        "\"Attempting to register unit {} to unregistered repo {}\"",
        "'Loaded unit {unit}, {repo} as {solvable}'",
        "\"Loaded repository '{}' version '{}' as source repo\"",
        "\"Loaded repository '{}' version '{}' into combined target repo\"",
        "\"{}: version={}\"",
        "'pk'",
        "'pk'",
        "\"Depsolver must be finalized before it can be used\"",
        "\"rpm.package\"",
        "'Encountered problems solving: {}'",
        "', '",
        "\"module:\""
    ],
    "variables": [
        "logger",
        "COMBINED_TARGET_REPO_NAME",
        "RPM_FIELDS",
        "MODULE_FIELDS",
        "MODULE_DEFAULTS_FIELDS",
        "solvable",
        "repodata",
        "dir_path",
        "dirname_id",
        "pool",
        "name_id",
        "evr_id",
        "arch_id",
        "rel",
        "rel",
        "name",
        "solvable",
        "name",
        "evr",
        "solvable",
        "evr",
        "arch",
        "solvable",
        "arch",
        "vendor",
        "vendor",
        "solvable",
        "vendor",
        "unit_name",
        "unit_flags",
        "unit_evr",
        "keyname",
        "pool",
        "dep",
        "dep",
        "rel_flags",
        "rel_flags",
        "rel_flags",
        "rel_flags",
        "rel_flags",
        "dep",
        "_mapping_unit_to_solvable",
        "_mapping_solvable_to_unit",
        "_mapping_repos",
        "repo_unit_map",
        "unit_id",
        "repo_id",
        "_finalized",
        "_pool",
        "mapping",
        "installed",
        "_finalized",
        "libsolv_repo_name",
        "libsolv_repo_name",
        "libsolv_repo_name",
        "libsolv_repo_name",
        "repo",
        "repo",
        "repodata",
        "repodata",
        "package_ids",
        "nonmodular_rpms",
        "solvable",
        "_finalized",
        "solvables",
        "result_solvables",
        "flags",
        "previous_problems",
        "attempt",
        "solver",
        "raw_problems",
        "problems",
        "previous_problems",
        "transaction",
        "solvables_to_copy",
        "install_jobs",
        "solvable",
        "module_dep",
        "module_artifacts",
        "module_install_job",
        "artifact_install_job",
        "unit_install_job",
        "solvables_copied"
    ],
    "comments": [
        "The name for the repo inside libsolv which represents the combined set of target/destination",
        "repositories. Libsolv only supports one \"installed\" repo at a time, therefore we need to",
        "combine them and determine what units actually go where afterwards.",
        "Constants for loading data from the database.",
        "This function is sometimes used with dependencies, not just packages we know full details",
        "about. So if there's no specific EVR information, we need to set EVR to None.",
        "Prv: $n . $a = $evr",
        "e.g SOLVABLE_PROVIDES, SOLVABLE_REQUIRES...",
        "the Rich/Boolean dependencies have just the 'name' attribute",
        "this is always in the form: '(foo >= 1.2 with foo < 2.0)'",
        "generic dependencies provide at least a solvable name",
        "in case the flags unit attribute is populated, use it as",
        "a solv.Rel object to denote solvable--dependency",
        "relationship dependency in this case is a relationship",
        "towards the dependency made from the 'flags', e.g:",
        "solv.REL_EQ, and the evr fields",
        "register the constructed solvable dependency",
        "def module_unit_to_solvable(solv_repo, unit):",
        "\"\"\"Convert a Pulp Module in dict representation to a libsolv solvable.",
        ":param solv_repo: the repository the unit is being added into",
        ":type solv_repo: solv.Repo",
        ":param unit: the unit being converted",
        ":type unit: pulp_rpm.plugins.models.Model",
        ":return: the solvable created.",
        ":rtype: solv.Solvable",
        "\"\"\"",
        "solvable = solv_repo.add_solvable()",
        "pool = solvable.repo.pool",
        "def module_solvable_name(unit):",
        "\"\"\"",
        "Create a solvable name from module attributes: module:<name>:<stream>:<version>:<context>",
        "\"\"\"",
        "return 'module:{name}:{stream}:{version!s}:{context}'.format(",
        "name=unit.get('name').encode('utf-8'),",
        "stream=unit.get('stream').encode('utf-8'),",
        "version=unit.get('version'),",
        "context=unit.get('context').encode('utf-8'),",
        ")",
        "def module_basic_deps(pool, solvable, solvable_name, name, stream, version, arch):",
        "\"\"\"",
        "Create the basic module `Provides:` relations",
        "\"\"\"",
        "# Prv: module:$n:$s:$v:$c . $a",
        "solvable.nsvca_rel = pool.rel2id(",
        "pool.str2id(solvable_name),",
        "pool.str2id(arch), solv.REL_ARCH",
        ")",
        "solvable.add_deparray(solv.SOLVABLE_PROVIDES, solvable.nsvca_rel)",
        "# Prv: module()",
        "dep = pool.Dep('module()')",
        "solvable.add_deparray(solv.SOLVABLE_PROVIDES, dep)",
        "# Prv: module($n)",
        "dep_n = pool.Dep('module({})'.format(name))",
        "solvable.add_deparray(solv.SOLVABLE_PROVIDES, dep_n)",
        "# Prv: module($n:$s)",
        "dep_ns = pool.Dep('module({}:{})'.format(name, stream))",
        "solvable.add_deparray(solv.SOLVABLE_PROVIDES, dep_ns)",
        "# Prv: module($n:$s) = $v",
        "dep_ns_v = dep_n.Rel(solv.REL_EQ, pool.Dep(str(version)))",
        "solvable.add_deparray(solv.SOLVABLE_PROVIDES, dep_ns_v)",
        "def module_artifacts_conversion(pool, module_solvable, name, evr, arch):",
        "# propagate Req: module:$n:$s:$v:$c . $a to the modular RPM i.e",
        "# make the rpm require this module",
        "name_id = pool.str2id(name)",
        "evr_id = pool.str2id(evr)",
        "arch_id = pool.str2id(arch)",
        "# $n.$a = $evr",
        "rel = pool.rel2id(name_id, arch_id, solv.REL_ARCH)",
        "rel = pool.rel2id(rel, evr_id, solv.REL_EQ)",
        "selection = pool.matchdepid(",
        "rel, solv.SOLVABLE_NAME | solv.SOLVABLE_ARCH | solv.SOLVABLE_EVR,",
        "solv.SOLVABLE_PROVIDES",
        ")",
        "for rpm_solvable in selection.solvables():",
        "# Make the artifact require this module",
        "rpm_solvable.add_deparray(solv.SOLVABLE_REQUIRES, module_solvable.nsvca_rel)",
        "# Provide: modular-package()",
        "rpm_solvable.add_deparray(solv.SOLVABLE_PROVIDES, pool.Dep('modular-package()'))",
        "solvable_name = module_solvable_name(unit)",
        "solvable.name = solvable_name",
        "solvable.evr = ''",
        "arch = unit.get('arch', 'noarch').encode('utf-8')",
        "solvable.arch = arch",
        "name = unit.get('name')",
        "if name:",
        "name = name.encode('utf-8')",
        "stream = unit.get('stream')",
        "if stream:",
        "stream = stream.encode('utf-8')",
        "version = unit.get('version')",
        "if not arch:",
        "arch = 'noarch'.encode('utf-8')",
        "module_basic_deps(pool, solvable, solvable_name, name, stream, version, arch)",
        "for artifact in unit.get('artifacts', []):",
        "nevra_tuple = parse.rpm.nevra(artifact)",
        "artifact_name = nevra_tuple[0]",
        "artifact_epoch = nevra_tuple[1]",
        "artifact_version = nevra_tuple[2]",
        "artifact_release = nevra_tuple[3]",
        "artifact_arch = nevra_tuple[4] if nevra_tuple[4] else 'noarch'",
        "if artifact_name is not None:",
        "artifact_name = artifact_name.encode('utf-8')",
        "if artifact_arch is not None:",
        "artifact_arch = artifact_arch.encode('utf-8')",
        "artifact_evr = libsolv_formatted_evr(artifact_epoch, artifact_version, artifact_release)",
        "module_artifacts_conversion(pool, solvable, artifact_name, artifact_evr, artifact_arch)",
        "module_dependencies_conversion(pool, solvable, unit.get('dependencies', []))",
        "pool.createwhatprovides()  # TODO: It would be great to do this less often",
        "return solvable",
        "def module_dependencies_conversion(pool, module_solvable, dependency_list):",
        "\"\"\"",
        "Process the module dependency list.",
        "So for example for following input:",
        "dependency_list = [{'gtk': ['1'], 'foo': ['1']}]",
        "The resulting solv.Dep expression will be:",
        "((module(gtk) with module(gtk:1)) and (module(foo) with module(foo:1)))",
        "This Dep expression is then applied to the REQUIRES: deparray of the module solvable.",
        ":param pool: The libsolv pool that owns the module",
        ":type pool: solv.Pool",
        ":param module_solvable: A solvable representing the module",
        ":type module_solvable: solv.Solvable",
        ":param dependency_list: List of dictionaries representing modulemd dependency data.",
        ":type dependency_list: list",
        "\"\"\"",
        "# A near exact copy of the algorithm here:",
        "# https://pagure.io/fm-orchestrator/blob/db03f0a7f530cc2bf2f8971f085a9e6b71595d70/f/",
        "# module_build_service/mmd_resolver.py#_53",
        "def stream_dep(name, stream):",
        "\"\"\"",
        "Every name:stream combination from dict in `deps` list is expressed as `solv.Dep`",
        "instance and is represented internally in solv with \"module(name:stream)\".",
        "This is parallel to RPM-world \"Provides: perl(foo)\" or \"Requires: perl(foo)\",",
        "but in this method, we are only constructing the condition after the \"Provides:\"",
        "or \"Requires:\". This method creates such solve.Dep().",
        "\"\"\"",
        "return pool.Dep(\"module({}:{})\".format(name, stream))",
        "def dep_or_rel(dep, op, rel):",
        "\"\"\"",
        "There are relations between modules in `deps`. For example:",
        "deps = [{'gtk': ['1'], 'foo': ['1']}]\" means \"gtk:1 and foo:1\" are both required.",
        "deps = [{'gtk': ['1', '2']}\"] means \"gtk:1 or gtk:2\" are required.",
        "This method helps creating such relations using following syntax:",
        "dep_or_rel(solv.Dep, solve.REL_OR, stream_dep(name, stream))",
        "dep_or_rel(solv.Dep, solve.REL_AND, stream_dep(name, stream))",
        "dep_or_rel(solv.Dep, solve.REL_WITH, stream_dep(name, stream))",
        "dep_or_rel(solv.Dep, solve.REL_WITHOUT, stream_dep(name, stream))",
        "\"\"\"",
        "dep.Rel(op, rel) if dep is not None else rel",
        "# Check each dependency dict in dependency_list and generate the solv requirements.",
        "reqs = None",
        "for dep_dict in dependency_list:",
        "require = None",
        "for name, streams in dep_dict.items():",
        "if name == 'platform':",
        "# no need to fake the platform (streams) later on",
        "continue",
        "name = name.encode('utf8')",
        "# The req_pos will store solv.Dep expression for \"positive\" requirements.",
        "# That is the case of 'gtk': ['1', '2'].",
        "# The req_neg will store negative requirements like 'gtk': ['-1', '-2'].",
        "req_pos = req_neg = None",
        "# For each stream in `streams` for this dependency, generate the",
        "# module(name:stream) solv.Dep and add REL_OR relations between them.",
        "for stream in streams:",
        "stream = stream.encode('utf8')",
        "if stream.startswith(\"-\"):",
        "req_neg = dep_or_rel(req_neg, solv.REL_OR, stream_dep(name, stream[1:]))",
        "else:",
        "req_pos = dep_or_rel(req_pos, solv.REL_OR, stream_dep(name, stream))",
        "# Generate the module(name) solv.Dep.",
        "req = pool.Dep(\"module({})\".format(name))",
        "# Use the REL_WITH for positive requirements and REL_WITHOUT for negative",
        "# requirements.",
        "if req_pos is not None:",
        "req = req.Rel(solv.REL_WITH, req_pos)",
        "elif req_neg is not None:",
        "req = req.Rel(solv.REL_WITHOUT, req_neg)",
        "# And in the end use AND between the last name:[streams] and the current one.",
        "require = dep_or_rel(require, solv.REL_AND, req)",
        "# NOTE: In the original algorithm, this was an OR operation. We don't want only one",
        "# set of deps (for one platform), we want the deps for all platforms. Hence, solv.REL_AND.",
        "reqs = dep_or_rel(reqs, solv.REL_AND, require)",
        "module_solvable.add_deparray(solv.SOLVABLE_REQUIRES, reqs)",
        "def module_defaults_unit_to_solvable(solv_repo, unit):",
        "\"\"\"Convert a Pulp Module Default dict to a libsolv solvable.",
        ":param solv_repo: the repository the unit is being added into",
        ":type solv_repo: solv.Repo",
        ":param unit: the unit being converted",
        ":type unit: pulp_rpm.plugins.models.Model",
        ":return: the solvable created.",
        ":rtype: solv.Solvable",
        "\"\"\"",
        "solvable = solv_repo.add_solvable()",
        "solvable.evr = ''",
        "# a module default has no arch, use 'noarch'",
        "solvable.arch = 'noarch'",
        "name = unit.get('name')",
        "if name is not None:",
        "name = name.encode('utf-8')",
        "stream = unit.get('stream')",
        "if stream is not None:",
        "stream = stream.encode('utf-8')",
        "solvable.name = 'module-default:{}'.format(name)",
        "pool = solvable.repo.pool",
        "def module_defaults_basic_deps(solvable, name, stream):",
        "\"\"\"",
        "Links a module and its default with dependencies.",
        "\"\"\"",
        "# we are making all modules require the module-default regardless of they are default",
        "# since the module-default can cary profile information",
        "module_depid = pool.Dep('module({})'.format(name), 0)",
        "module_default_depid = pool.Dep(solvable.name)",
        "if not module_depid:",
        "return",
        "# tell libsolv that this solvable provides the module-default for the module name",
        "solvable.add_deparray(solv.SOLVABLE_PROVIDES, module_default_depid)",
        "pool.createwhatprovides()",
        "for module in pool.whatprovides(module_depid):",
        "# module default metadata doesn't have to specify a stream, we only want to make",
        "# module:name:stream:{ver}:{ctx} provide the default when it does. However, in either",
        "# case we want the modules to require the module-default because it can carry",
        "# important profile information.",
        "if stream:",
        "# mark the related module so it can be queried as",
        "# '(module() with module-default())' i.e such that it's easy visible through",
        "# a pool.whatprovides that it has a default",
        "module.add_deparray(solv.SOLVABLE_PROVIDES, pool.Dep('module-default()'))",
        "# mark the module such that it requires its default i.e this solvable",
        "module.add_deparray(solv.SOLVABLE_REQUIRES, module_default_depid)",
        "# Note: Since we're copying the module default metadata as-is without modification or",
        "# regeneration, that means that \"profiles\" may be copied for streams that do not exist.",
        "# We think this is probably OK but if it is not, the solution is to \"require\" all streams",
        "# for which a profile exists.",
        "module_defaults_basic_deps(solvable, name, stream)",
        "return solvable",
        "Stores data in the form (pulp_unit_id, pulp_repo_id): solvable",
        "Stores data in the form solvable_id: (pulp_unit_id, pulp_repo_id)",
        "Stores data in the form pulp_repo_id: libsolv_repo_id",
        "prevent https://github.com/openSUSE/libsolv/issues/267",
        "modular_rpms = models.Package.objects.get(pk__in=content, is_modular=True)",
        "modules = models.Module.objects.get(pk__in=content)",
        "modulemd_defaults = models.ModulemdDefaults.objects.get(pk__in=content)",
        "Need to call pool->addfileprovides(), pool->createwhatprovides() after loading new repo",
        "def _handle_nothing_provides(self, info):",
        "\"\"\"Handle a case where nothing provides a given requirement.",
        "Some units may depend on other units outside the repo, and that will cause issues with",
        "the solver. We need to create some dummy packages to fulfill those provides so that the",
        "solver can continue. Essentially we pretend the missing dependencies are already",
        "installed.",
        ":param info: A class describing why the rule was broken",
        ":type info: solv.RuleInfo",
        "\"\"\"",
        "target_repo = self.mapping.get_repo(COMBINED_TARGET_REPO_NAME)",
        "if not target_repo:",
        "return",
        "dummy = target_repo.add_solvable()",
        "dummy.name = 'dummy-provides:{}'.format(str(info.dep))",
        "dummy.arch = 'noarch'",
        "dummy.evr = ''",
        "dummy.add_deparray(solv.SOLVABLE_PROVIDES, info.dep)",
        "self._pool.createwhatprovides()",
        "_LOGGER.debug('Created dummy provides: {name}', name=info.dep.str())",
        "def _handle_same_name(self, info, jobs):",
        "\"\"\"Handle a case where multiple versions of a package are \"installed\".",
        "Libsolv by default will make the assumption that you can't \"install\" multiple versions of",
        "a package, so in cases where we create that situation, we need to pass a special flag.",
        "\"\"\"",
        "def locate_solvable_job(solvable, flags, jobs):",
        "for idx, job in enumerate(jobs):",
        "if job.what == solvable.id and job.how == flags:",
        "_LOGGER.debug('Found job: %s', str(job))",
        "return idx",
        "def enforce_solvable_job(solvable, flags, jobs):",
        "idx = locate_solvable_job(solvable, flags, jobs)",
        "if idx is not None:",
        "return",
        "enforce_job = self._pool.Job(flags, solvable.id)",
        "jobs.append(enforce_job)",
        "_LOGGER.debug('Added job %s', enforce_job)",
        "install_flags = solv.Job.SOLVER_INSTALL | solv.Job.SOLVER_SOLVABLE",
        "enforce_flags = install_flags | solv.Job.SOLVER_MULTIVERSION",
        "enforce_solvable_job(info.solvable, enforce_flags, jobs)",
        "enforce_solvable_job(info.othersolvable, enforce_flags, jobs)",
        "def _handle_problems(self, problems, jobs):",
        "\"\"\"Handle problems libsolv finds during the depsolving process that can be worked around.",
        "\"\"\"",
        "for problem in problems:",
        "for problem_rule in problem.findallproblemrules():",
        "for info in problem_rule.allinfos():",
        "if info.type == solv.Solver.SOLVER_RULE_PKG_NOTHING_PROVIDES_DEP:",
        "# No solvable provides the dep",
        "if not self.ignore_missing:",
        "continue",
        "self._handle_nothing_provides(info)",
        "elif info.type == solv.Solver.SOLVER_RULE_PKG_REQUIRES:",
        "# A solvable provides the dep but could not be installed for some reason",
        "continue",
        "elif info.type == solv.Solver.SOLVER_RULE_INFARCH:",
        "# The solver isn't allowed to rely on packages of an inferior architecture",
        "# ie. i686 when x86_64 is being solved for",
        "continue",
        "elif info.type == solv.Solver.SOLVER_RULE_PKG_SAME_NAME:",
        "# The deps can only be fulfilled by multiple versions of a package,",
        "# but installing multiple versions of the same package is not allowed.",
        "self._handle_same_name(info, jobs)",
        "else:",
        "_LOGGER.warning(",
        "'No workaround available for problem \\'%s\\'. '",
        "'You may refer to the libsolv Solver class documentation '",
        "'for more details. See https://github.com/openSUSE/'",
        "'libsolv/blob/master/doc/libsolv-bindings.txt'",
        "'#the-solver-class.', problem_rule.info().problemstr()",
        ")",
        "self._pool.createwhatprovides()",
        "self._handle_problems(raw_problems, jobs)  TODO",
        "The solver is simply ignoring the problems encountered and proceeds associating",
        "any new solvables/units. This might be reported back to the user one day over",
        "the REST API.",
        "Take one solvable",
        "If the solvable being installed is a module, try to install it and all of its",
        "modular artifact dependencies",
        "If the unit being copied is not a module, just install it alone",
        "Depsolv using the list of unit install jobs, add them to the results"
    ],
    "docstrings": [
        "\"\"\"Create an epoch-version-release string from the separate values.\n\n    Pulp stores epoch-version-release separately, libsolv uses them together.\n    Convert from Pulp separate values to a combined EVR formatted as libsolv expects.\n    \"\"\"",
        "\"\"\"Convert a Pulp RPM dict to a libsolv solvable.\n\n    Args:\n        solv_repo (solv.Repo): The libsolv repository the unit is being created in.\n        unit (dict): The unit being converted.\n\n    Returns:\n        (solv.Solvable) The solvable created.\n\n    \"\"\"",
        "\"\"\"A specific, rpm-unit-type filelist attribute conversion.\"\"\"",
        "\"\"\"Set the solvable dependencies.\n\n    The dependencies of a unit are stored as a list of dictionaries,\n    containing following values:\n            name: <unit name> or a rich dep string; mandatory\n            version: version of the dependency; optional\n            epoch: epoch of the dependency; optional\n            release: release of the dependency; optional\n            flags: AND/OR; optional; if missing meaning by default AND\n\n    These values are parsed by librpm.\n    There are two cases how libsolv addresses the dependencies:\n\n    * rich: the name of the dependency contains all required information:\n        '(foo >= 1.0-3 AND bar != 0.9)'\n        all the other attribute values are ignored\n\n    * generic: the name, version, epoch, release and flags attributes\n        are processed explicitly\n\n    The dependency list is either of the provides, requires or the weak\n    dependencies, the current case being stored under self.attr_name.\n\n    Libsolv tracks a custom Dep object to represent a dependency of a\n    solvable object; these are created in the pool object:\n\n        dependency = pool.Dep('foo')\n\n    The relationship to the solvable is tracked by a Rel pool object:\n\n        relationship = pool.Rel(solv.REL_AND, pool.Dep(evr))\n\n    where the evr is the 'epoch:version-release' string. The relationship\n    is then recorded on the solvable explicitly by:\n\n        solvable.add_deparray(solv.SOLVABLE_PROVIDES, relationship)\n\n    If no explict relationship is provided in the flags attribute,\n    the dependency can be used directly:\n\n        solvable.add_deparray(solv.SOLVABLE_PROVIDES, dependency)\n\n    Args:\n        solvable (solvable): a libsolv solvable object\n        unit (dict): the content unit to get the dependencies from\n\n    \"\"\"",
        "\"\"\"Map libsolv solvables to Pulp units and repositories.\n\n    Translate between what libsolv understands, solvable IDs in a pool, and what Pulp understands,\n    units and repositories.\n    \"\"\"",
        "\"\"\"Mapping Init.\"\"\"",
        "\"\"\"Store the matching of a unit-repo pair to a solvable inside of the mapping.\n        \"\"\"",
        "\"\"\"Store the repo (Pulp) - repo (libsolv) pair.\n        \"\"\"",
        "\"\"\"Return the repo from the mapping.\n        \"\"\"",
        "\"\"\"Get the (unit, repo_id) pair for a given solvable.\n        \"\"\"",
        "\"\"\"Fetch the libsolv solvable associated with a unit-repo pair.\n        \"\"\"",
        "\"\"\"Get back unit ids of all units that were in a repo based on the mapping.\n        \"\"\"",
        "\"\"\"Map a list of solvables into their Pulp units, keyed by the repo they came from.\n        \"\"\"",
        "\"\"\"A Solver object that can speak in terms of Pulp units.\n    \"\"\"",
        "\"\"\"Solver Init.\"\"\"",
        "\"\"\"Finalize the solver - a finalized solver is ready for depsolving.\n\n        Libsolv needs to perform some scans/hashing operations before it can do certain things.\n        For more details see:\n        https://github.com/openSUSE/libsolv/blob/master/doc/libsolv-bindings.txt\n        \"\"\"",
        "\"\"\"Load the provided Pulp repo as a source repo.\n\n        All units in the repo will be available to be \"installed\", or copied.\n        \"\"\"",
        "\"\"\"Load the provided Pulp repo into the combined target repo.\n\n        All units in the repo will be added to the combined target repo, the contents of which\n        are considered \"installed\" by the solver.\n        \"\"\"",
        "\"\"\"Produce a name to use for the libsolv repo from the repo version.\"\"\"",
        "\"\"\"\n        Generate solvables from Pulp units and add them to the mapping.\n\n        In some circumstances, we want to load multiple Pulp \"repos\" together into one libsolv\n        \"repo\", because libsolv can only have one repo be \"installed\" at a time. Therefore, when\n        the override_repo_name is specified, the created solvables are associated with the\n        override repo, but the mapping stores them with their original Pulp repo_id.\n\n        Args:\n            override_repo_name (str): Override name to use when adding solvables to a libsolv repo\n        \"\"\"",
        "\"\"\"Resolve the total set of packages needed for the packages passed in, as DNF would.\n\n        Find the set of dependent units and return them in a dictionary where\n        the key is the repository the set of units came from.\n\n        Find the RPM dependencies that need to be copied to satisfy copying the provided units,\n        taking into consideration what units are already present in the target repository.\n\n        Create libsolv jobs to install each one of the units passed in, collect and combine the\n        results. For modules, libsolv jobs are created to install each of their artifacts\n        separately.\n\n        A libsolv \"Job\" is a request for the libsolv sat solver to process. For instance a job with\n        the flags SOLVER_INSTALL | SOLVER_SOLVABLE will tell libsolv to solve an installation of\n        a package which is specified by solvable ID, as opposed to by name, or by pattern, which\n        are other options available.\n\n        See: https://github.com/openSUSE/libsolv/blob/master/doc/libsolv-bindings.txt#the-job-class\n\n        Args:\n            unit_repo_map: (dict) An iterable oflibsolv_repo_name =\n\n        Returns: (dict) A dictionary of form {'repo_id': set(unit_ids**)}\n        \"\"\"",
        "\"\"\"Execute the libsolv jobs, return results.\n\n            Take a list of jobs, get a solution, return the set of solvables that needed to\n            be installed.\n            \"\"\""
    ],
    "functions": [
        "libsolv_formatted_evr",
        "rpm_to_solvable",
        "rpm_filelist_conversion",
        "rpm_basic_deps",
        "rpm_dependency_conversion",
        "register",
        "register_repo",
        "get_repo",
        "get_unit_id",
        "get_solvable",
        "get_repo_units",
        "get_units_from_solvables",
        "finalize",
        "load_source_repo",
        "load_target_repo",
        "_repo_version_to_libsolv_name",
        "_load_from_version",
        "resolve_dependencies",
        "run_solver_jobs"
    ],
    "classes": [
        "UnitSolvableMapping",
        "Solver"
    ]
}