{
    "identifiers": [
        "concurrency",
        "arrayblockingqueues",
        "java",
        "util",
        "java",
        "util",
        "concurrent",
        "ArrayBlockingQueue",
        "java",
        "util",
        "concurrent",
        "Callable",
        "java",
        "util",
        "concurrent",
        "ExecutionException",
        "java",
        "util",
        "concurrent",
        "ExecutorService",
        "java",
        "util",
        "concurrent",
        "Executors",
        "java",
        "util",
        "concurrent",
        "Future",
        "java",
        "util",
        "concurrent",
        "locks",
        "ReentrantLock",
        "concurrency",
        "producerconsumer",
        "ThreadColor",
        "EOF",
        "args",
        "buffer",
        "executorService",
        "Executors",
        "newFixedThreadPool",
        "producer",
        "buffer",
        "ANSI_CYAN",
        "consumer1",
        "buffer",
        "ANSI_PURPLE",
        "consumer2",
        "buffer",
        "ANSI_GREEN",
        "executorService",
        "execute",
        "producer",
        "executorService",
        "execute",
        "consumer1",
        "executorService",
        "execute",
        "consumer2",
        "future",
        "executorService",
        "submit",
        "Override",
        "ANSI_RED",
        "future",
        "get",
        "ex",
        "ex",
        "executorService",
        "shutdown",
        "buffer",
        "color",
        "buffer",
        "color",
        "buffer",
        "buffer",
        "color",
        "color",
        "Override",
        "random",
        "nums",
        "num",
        "nums",
        "color",
        "num",
        "buffer",
        "put",
        "num",
        "sleep",
        "random",
        "nextInt",
        "e",
        "buffer",
        "put",
        "e",
        "buffer",
        "color",
        "buffer",
        "color",
        "buffer",
        "buffer",
        "color",
        "color",
        "Override",
        "counter",
        "buffer",
        "buffer",
        "isEmpty",
        "buffer",
        "peek",
        "equals",
        "AnotherMain",
        "EOF",
        "color",
        "color",
        "buffer",
        "take",
        "e"
    ],
    "literals": [
        "\"EOF\"",
        "\" I;m being printed from the callable class\"",
        "\"This is a callable result\"",
        "\"Something went wrong\"",
        "\"Thread running the task was interrupted\"",
        "\"1\"",
        "\"2\"",
        "\"3\"",
        "\"4\"",
        "\"5\"",
        "\"Adding...\"",
        "\"Producer was interrupted\"",
        "\"EOF\"",
        "\"Exiting\"",
        "\"Removed \""
    ],
    "variables": [
        "buffer",
        "color",
        "buffer",
        "color"
    ],
    "comments": [
        "TODO Auto-generated method stub",
        "List<String> buffer = new ArrayList<>();",
        "ReentrantLock bufferLock = new ReentrantLock();",
        "It's a queue, works as FIFO, so that's we use put,take,peek",
        "new Thread(producer).start();",
        "new Thread(consumer1).start();",
        "new Thread(consumer2).start();",
        "TODO Auto-generated method stub",
        "TODO Auto-generated method stub",
        "add and remove can throw exceptions",
        "put add a block, also is a thread-safe method",
        "bufferLock.lock();",
        "try {",
        "buffer.add(num);",
        "} finally {",
        "bufferLock.unlock();",
        "}",
        "bufferLock.lock();",
        "try {",
        "buffer.add(\"EOF\");",
        "} finally {",
        "bufferLock.unlock();",
        "}",
        "TODO Auto-generated method stub",
        "Correct aproach",
        "bufferLock.lock();",
        "if (bufferLock.tryLock()) {",
        "try {",
        "if (buffer.isEmpty()) {",
        "continue;",
        "}",
        "System.out.println(color+\"The counter = \" + counter);",
        "counter =0;",
        "if (buffer.get(0).equals(AnotherMain.EOF)) {",
        "System.out.println(color + \"Exiting\");",
        "break;",
        "} else {",
        "System.out.println(color + \"Removed \" + buffer.remove(0));",
        "}",
        "} finally {",
        "bufferLock.unlock();",
        "}",
        "}else {",
        "counter++;",
        "}",
        "ReentrantLock lock1;",
        "public void methodA() {",
        "lock1.lock();",
        "methodB();",
        "[more code]",
        "lock1.unlock();",
        "}",
        "",
        "public void methodB() {",
        "[some code]",
        "lock1.lock();",
        "[more code]",
        "lock1.unlock();",
        "[more code]",
        "}"
    ],
    "docstrings": [
        "* Error because hold the lock to much time and have too many lock the if\n\t\t\t * statement with the empty makes the loop continues without unlocking Example\n\t\t\t * explanation down\n\t\t\t * \n\t\t\t * \n\t\t\t * bufferLock.lock(); if (buffer.isEmpty()) { continue; } if\n\t\t\t * (buffer.get(0).equals(AnotherMain.EOF)) { System.out.println(color +\n\t\t\t * \"Exiting\"); break; } else { System.out.println(color + \"Removed \" +\n\t\t\t * buffer.remove(0)); } bufferLock.unlock();",
        "* One approach\n\t\t\t * \n\t\t\t * bufferLock.lock(); if (buffer.isEmpty()) { bufferLock.unlock(); continue; }\n\t\t\t * if (buffer.get(0).equals(AnotherMain.EOF)) { System.out.println(color +\n\t\t\t * \"Exiting\"); bufferLock.unlock(); break; } else { System.out.println(color +\n\t\t\t * \"Removed \" + buffer.remove(0)); } bufferLock.unlock();\n\t\t\t *"
    ],
    "functions": [
        "main",
        "call",
        "MyProducer",
        "run",
        "MyConsumer",
        "run"
    ],
    "classes": [
        "AnotherMain",
        "MyProducer",
        "MyConsumer"
    ]
}