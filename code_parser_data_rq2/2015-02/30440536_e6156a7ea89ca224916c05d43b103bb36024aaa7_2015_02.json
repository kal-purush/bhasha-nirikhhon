{
    "identifiers": [
        "nQueenProblem",
        "java",
        "util",
        "Random",
        "fitness",
        "permutation",
        "size",
        "permutation",
        "permutation",
        "permutation",
        "size",
        "permutation",
        "length",
        "i",
        "i",
        "size",
        "i",
        "j",
        "j",
        "size",
        "j",
        "permutation",
        "j",
        "permutation",
        "i",
        "j",
        "permutation",
        "j",
        "permutation",
        "i",
        "j",
        "fitness",
        "fitness",
        "fitness",
        "size",
        "permutation",
        "Util",
        "getPermutation",
        "size",
        "test",
        "permutation",
        "fitness",
        "test",
        "fitness",
        "size",
        "size",
        "other",
        "position",
        "newPermutation",
        "other",
        "size",
        "i",
        "i",
        "position",
        "i",
        "newPermutation",
        "i",
        "permutation",
        "i",
        "j",
        "position",
        "j",
        "size",
        "scrollOther",
        "scrollOther",
        "other",
        "size",
        "scrollOther",
        "scrollThis",
        "scrollThis",
        "position",
        "scrollThis",
        "permutation",
        "scrollThis",
        "permutation",
        "scrollOther",
        "scrollThis",
        "position",
        "scrollThis",
        "position",
        "newPermutation",
        "j",
        "other",
        "permutation",
        "scrollOther",
        "j",
        "child",
        "newPermutation",
        "child",
        "other",
        "position",
        "floor",
        "random",
        "size",
        "crossover",
        "other",
        "position",
        "i",
        "j",
        "newJ",
        "permutation",
        "i",
        "newI",
        "permutation",
        "j",
        "mutatedPermutation",
        "size",
        "x",
        "x",
        "size",
        "x",
        "mutatedPermutation",
        "x",
        "permutation",
        "x",
        "mutatedPermutation",
        "i",
        "newI",
        "mutatedPermutation",
        "j",
        "newJ",
        "mutatedPermutation",
        "size",
        "i",
        "floor",
        "size",
        "random",
        "j",
        "j",
        "i",
        "j",
        "floor",
        "size",
        "random",
        "mutate",
        "i",
        "j",
        "fitness",
        "other",
        "fitness",
        "other",
        "fitness",
        "writePermutation",
        "writePermutation",
        "append",
        "i",
        "i",
        "size",
        "i",
        "writePermutation",
        "append",
        "permutation",
        "i",
        "i",
        "size",
        "writePermutation",
        "append",
        "writePermutation",
        "append",
        "permString",
        "writePermutation",
        "toString",
        "permString",
        "writePermutation",
        "writePermutation",
        "append",
        "writePermutation",
        "append",
        "permutationToString",
        "writePermutation",
        "append",
        "writePermutation",
        "append",
        "fitness",
        "writePermutation",
        "append",
        "writePermutation",
        "append",
        "size",
        "writePermutation",
        "toString",
        "args",
        "i",
        "i",
        "i",
        "Sam",
        "floor",
        "i",
        "test",
        "Sam",
        "toString",
        "test"
    ],
    "literals": [
        "\",\"",
        "\"}\"",
        "\"Permutation: \"",
        "\", Fitness\"",
        "\", size \""
    ],
    "variables": [
        "permutation",
        "size"
    ],
    "comments": [
        "10",
        "REPLACE THE BODY OF THIS METHOD WITH YOUR OWN IMPLEMENTATION",
        "Gets the fitness using the",
        "REPLACE THE BODY OF THIS METHOD WITH YOUR OWN IMPLEMENTATION",
        "Step 1",
        "Step 2 (j is the starting point to add new values",
        "Step 3",
        "Step 4",
        "Step 5",
        "REPLACE THE BODY OF THIS METHOD WITH YOUR OWN IMPLEMENTATION",
        "REPLACE THE BODY OF THIS METHOD WITH YOUR OWN IMPLEMENTATION"
    ],
    "docstrings": [
        "* An <code>Individual</code> (a chromosome) is a candidate solution for a given\n * problem. Its representation depends on the specific problem to be solved. Two\n * individuals can be combined (see method crossover) to produce a new\n * offspring. As with natural chromosomes, these artificial ones suffer\n * mutations. Each chromosome has a fitness value that indicates the quality of\n * this solution.\n * <p/>\n * \n * A <code>Population</code> is a collection of chromosomes. At each iteration\n * (generation), the genetic algorithm selects chromosomes for reproduction. The\n * offsprings are inserted into the population, and the least fitted individuals\n * are eliminated. Thus, the size of the population is fixed.\n * <p/>\n * \n * For this assignment, an <code>Individual</code> represents a solution to the\n * <code>n</code>-Queens problem. As introduced in the assignment description, a\n * candidate solution is represented by a permutation of size <code>n</code>,\n * such that attribute <code>i</code> represents the row for the queen found at\n * column <code>i</code>.\n * <p/>\n * \n * Not all permutations are valid solutions to <code>n</code>-Queens problem. A\n * permutation is a valid solution if no two queens can attack each other. Two\n * queens are attacking each other if they are on the same row or column, which\n * is impossible given this representation, but also if they are found on the\n * same minor or major diagonal.\n * <p/>\n *\n * Herein, we define the fitness value of an individual as the number of pairs\n * of queens attacking each other.\n * <p/>\n * You must complete the implementation of the class <code>Individual</code>\n * following all the directives.\n *\n * @author Marcel Turcotte (turcotte@eecs.uottawa.ca)",
        "* i represents the column of the queen currently being looked at\n\t\t  * j represents the \"position\", which is column being looked at.\n\t\t  * permutation[j] is the queen in the column being looked at\n\t\t  * permutation[i] is the row of the queen being looked at.\n\t\t  * i-j represents the horizontal distance between columns\n\t\t  * permutation i-permutation j is the vertical distance between the rows.\n\t\t  * if the absolute value of the vertical distance between 2 queens\n\t\t  * is equal to the absolute value of the horizontal distance between queens\n\t\t  * then the the queens are diagonal to each other.\n\t\t  * The code test if the queen at (i,permutation[i]) is diagonal to the queen at (j, permutation[j])\n\t\t  * if so the queens are attacking each other so the fitness score goes up.\n\t\t  * Due to the way permutations are defined, this is the only way a permutation can allow 2 queens to attack each other.",
        "*  We are counting queen A attacking queen B and queen B attacking queen a as one attack, so it \n *  only increase the fitness score by 1 for every 2 queens threatening each other.",
        "* Creates an <code>Individual</code> using the provided permutation. The method\n     * must copy the values of the permutation into a new array. This constructor\n     * is primarily used for testing.\n     * \n     * @param permutation used to initialize the attributes of this <code>Individual</code>",
        "* Returns the offspring resulting from the crossover of <code>this</code>\n     * <code>Individual</code> and <code>other</code>. The result must be a valid\n     * permutation!\n     * <p/>\n     * \n     * In particular, the naive solution consisting of taking the first\n     * <code>position-1</code> attributes of this <code>Individual</code> and\n     * the last <code>size-position</code> attributes of <code>other</code> would\n     * not generate a valid permutation in most cases.\n     * <p/>\n     *  \n     * Instead, we are proposing that the first <code>position-1</code> attributes \n     * of this <code>Individual</code> are copied to the offspring, then the\n     * missing values will be selected from <code>other</code>, whilst preserving\n     * their order of appearance in <code>other</code>.\n     * <p/>\n     * \n     * This method is primarily used for testing.\n     * \n     * @param other a reference to an <code>Individual</code>\n     * @param position the location of the crossover\n     * @return the offspring resulting from the crossover of <code>this</code> and <code>other</code>",
        "* first step is to copy the values before the position into a new permutation.\n     * Second step Use the position as a starting point to add more values to the new permutation.\n     * Third step compare all values in the original permutation to each value in the other permutation.\n     * Fourth step if there is a match, move on to the next other permutation value to test.\n     * Fifth step If no match found after comparing all values in the original permutation, add the other value \n     * the new permutation and increase the starting point to the next value in the new matrix (add 1)/.",
        "* Returns the offspring resulting from the crossover of <code>this</code>\n     * <code>Individual</code> and <code>other</code>. The method randomly selects the\n     * position of the crossover. The result must be a valid permutation!\n     * <p/>\n     * \n     * In particular, the naive solution consisting of taking the first\n     * <code>position-1</code> attributes of this <code>Individual</code> and the last\n     * <code>size-position</code> attributes of <code>other</code> would not generate a\n     * valid permutation in most cases.\n     * <p/>\n     * \n     * Instead, we are proposing that the first <code>position-1</code> attributes\n     * of this <code>Individual</code> are copied to the offspring, then the missing\n     * values will be selected from <code>other</code>, whilst preserving their\n     * order of appearance in <code>other</code>.\n     * <p/>\n     * \n     * This method is used by <code>Population</code>.\n     * \n     * @param other a reference to an <code>Individual</code>\n     * @return the offspring resulting from the crossover of <code>this</code> and <code>other</code>",
        "* Randomizes the position of the cross over point to anywhere along the permutation.",
        "* Returns the offspring resulting from the crossover of <code>this</code>\n\t * <code>Individual</code> and <code>other</code>. The method randomly selects the\n\t * position of the crossover. The result must be a valid permutation!\n\t * <p/>\n\t * \n\t * In particular, the naive solution consisting of taking the first\n\t * <code>position-1</code> attributes of this <code>Individual</code> and the last\n\t * <code>size-position</code> attributes of <code>other</code> would not generate a\n\t * valid permutation in most cases.\n\t * <p/>\n\t * \n\t * Instead, we are proposing that the first <code>position-1</code> attributes\n\t * of this <code>Individual</code> are copied to the offspring, then the missing\n\t * values will be selected from <code>other</code>, whilst preserving their\n\t * order of appearance in <code>other</code>.\n\t * <p/>\n\t * \n\t * This method is used by <code>Population</code>.\n\t * \n\t * @param other a reference to an <code>Individual</code>\n\t * @return the offspring resulting from the crossover of <code>this</code> and <code>other</code>",
        "* Returns the offspring resulting from applying a mutation\n     * to this <code>Individual</code>. In order to make sure that \n     * the result is valid permutation, the method exchanges\n     * the value of two randomly selected attributes.\n     * <p/>\n     * \n     * This method is called by <code>Population</code>.\n     * \n     * @return the offspring resulting from exchanging two randomly selected attributes",
        "* Returns the fitness value of <code>this Individual</code>, which\n     * is defined as the number of pairs of queens attacking each\n     * other.\n     * \n     * @return the fitness value of <code>this Individual</code>.",
        "* Returns a negative integer, zero, or a positive integer as the fitness of this <code>Individual</code> is\n     * less than, equal to, or greater than the fitness of the specified <code>Individual</code>. \n     * \n     * @param other <code>Individual</code> to be compared\n     * @return a negative integer, zero, or a positive integer as the fitness of this <code>Individual</code> \n     *         is less than, equal to, or greater than the fitness of the specified <code>Individual</code>.",
        "* (non-Javadoc)\n     * @see java.lang.Object#toString()\n     * This creates a string of the permutation. A permutation of a b c d e\n     * becomes {a,b,c,d,e}",
        "* Returns a string representation of this <code>Individual</code>.\n     * \n     * @return a string representation of this <code>Individual</code>",
        "* Runs a series of tests.\n     * \n     * @param args command line parameters of the program"
    ],
    "functions": [
        "Individual",
        "Individual",
        "Individual",
        "crossover",
        "Individual",
        "recombine",
        "Individual",
        "mutate",
        "Individual",
        "mutate",
        "getFitness",
        "compareTo",
        "permutationToString",
        "toString",
        "main"
    ],
    "classes": [
        "Individual"
    ]
}