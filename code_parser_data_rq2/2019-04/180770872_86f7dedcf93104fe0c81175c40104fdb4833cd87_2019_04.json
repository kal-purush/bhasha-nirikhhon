{
    "identifiers": [],
    "literals": [],
    "variables": [],
    "comments": [
        "¯\\_(ツ)_/¯"
    ],
    "docstrings": [
        "* Задание: написать построитель SQL-запросов.\n * Данный модуль должен экспортировать функцию `query`, вызов которой должен возвращать новый экземпляр объекта query.\n * Например:\n * const q1 = query();\n * const q2 = query();\n * console.log(Object.is(q1, q2)) // false\n *\n * В качестве аргументов query может передаваться имя таблицы.\n * Тогда при дальнейшем составлении запроса вызовы метода from(tableName) игнорируются.\n *\n * У возвращаемого объекта должны быть следующие методы:\n *\n * select(arg1, arg2 ... argN) - может принимать список полей для выборки.\n * Аргументы должны иметь тип String. Если ни одного аргумента не передано должны быть получены все поля таблицы\n * Например:\n * q.select().from('users')\n * > SELECT * FROM users\n * q.select('id', 'name').from('users')\n * > SELECT id, name FROM users\n *\n * from(tableName: String) - указывает из какой таблицы получать данные.\n *\n * where(fieldName: String) - служит для задания условия фильтрации.\n * При множественном вызове метода where в одном запросе условия должны объединяться через логическое \"И\".\n * Метод where должен возвращать объект имеющий следующие методы:\n * orWhere(fieldName: String) - делает то же самое что where, но объединяет через \"ИЛИ\".\n * Метод where должен возвращать объект имеющий следующие методы:\n *\n * equals(value: any) - условие равенства\n * Например: SELECT * FROM student WHERE age = 42;\n *\n * in(values: array) - позволяет определить, совпадает ли значение объекта со значением в списке\n * Например: SELECT * FROM offices WHERE city IN ('Minsk', 'Nicosia', 'Seattle');\n *\n * gt(value: any) - условие больше '>'\n * gte(value: any) - условие больше или равно '>='\n * lt(value: any) -  условие меньше '<'\n * lte(value: any) -  условие меньше или равно '<='\n * between(from: any, to: any) -  условие нахождения значения поля в заданном диапазоне:\n * SELECT * FROM products WHERE price BETWEEN 4.95 AND 9.95;\n *\n * isNull() - условие отсутствия значения у поля\n *\n * not() - служит для задания противоположного.\n * После вызова not можно вызывать только те же методы, которые использует where для сравнения.\n *\n * q.select().from('users').where('name').not().equals('Vasya')\n *\n * Вызов not не может быть вызван более одного раза подряд:\n * q.select().from('users').where('name').not().not().equals('Vasya')\n *\n * Внимание: методы сравнения не могут быть вызваны до вызова метода where()!\n *\n * Получения строчного представления сконструированного SQL-запроса должно происходить при\n * вызове метода toString() у объекта query.\n * В конце строки SQL-запроса должен быть символ ';'\n *\n * Дополнительные задания:\n *\n * 1. Добавить в сигнатуру функии query второй опциональный аргумент options типа Object.\n * Если в options есть поле escapeNames со значением true, названия полей и таблиц должны быть обёрнуты в двойные кавычки:\n *\n * const q = query({escapeNames: true});\n * q.select('name').from('people').toString()\n * > SELECT \"name\" FROM \"people\";\n\n * const q = query('books', {escapeNames: true});\n * q.select('title').toString()\n * > SELECT \"title\" FROM \"books\";\n *\n * 2. Добавить возможность передавать в условия методов сравнения в качестве значения экземпляр запроса query.\n *\n * const q1 = query('users');\n * const admins = q1.select('id').where('role').equals('admin');\n * const q2 = query('posts');\n * const posts = q2.select().where('author_id').in(admins);\n * posts.toString();\n * > SELECT * FROM posts WHERE author_id IN (SELECT id FROM users WHERE role = 'admin');\n *\n * 3. Реализовать функциональность создания INSERT и DELETE запросов. Написать для них тесты."
    ],
    "functions": [
        "query"
    ],
    "classes": []
}