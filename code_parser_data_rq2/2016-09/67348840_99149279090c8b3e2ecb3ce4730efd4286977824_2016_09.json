{
    "identifiers": [
        "misc",
        "player_list",
        "strat_mat",
        "payoff_mat",
        "check_validity",
        "player_list",
        "strat_mat",
        "payoff_mat",
        "player_list",
        "strat_mat",
        "combine",
        "strat_mat",
        "payoff_mat",
        "make_matrix_dict",
        "make_br_dict",
        "make_wd_dict",
        "make_sd_dict",
        "make_player_symbol_dict",
        "make_strat_symbol_dict",
        "make_pure_ne_list",
        "make_mixed_ne_list",
        "make_logical_payoff_mat",
        "player_list",
        "strat_mat",
        "payoff_mat",
        "len",
        "player_list",
        "len",
        "strat_mat",
        "len",
        "payoff_mat",
        "len",
        "player_list",
        "len",
        "strat_mat",
        "strat_combo",
        "Payoff_Dict",
        "player_list",
        "payoff_mat",
        "strat_combo",
        "strat_combo",
        "strats_combined_list",
        "matrix_dict",
        "player",
        "other_strats",
        "player_list",
        "index",
        "player",
        "strats_combined",
        "strats_combined_list",
        "other_strats",
        "strats_combined",
        "player_offset",
        "strats_combined",
        "player_offset",
        "context_list",
        "append",
        "strats_combined",
        "strats_combined",
        "context_list",
        "br_payoff",
        "br_payoff",
        "matrix_dict",
        "strats_combined",
        "get_payoff",
        "player",
        "matrix_dict",
        "strats_combined",
        "get_payoff",
        "player",
        "strats_combined",
        "context_list",
        "br_payoff",
        "matrix_dict",
        "strats_combined",
        "get_payoff",
        "player",
        "br_list",
        "append",
        "strats_combined",
        "player_offset",
        "br_list",
        "player",
        "player_list",
        "player",
        "combine",
        "strat_mat",
        "player",
        "strat_mat",
        "player",
        "combo",
        "other_players_combos",
        "br",
        "make_br_list",
        "player",
        "combo",
        "br_dict",
        "player",
        "add",
        "br",
        "br_dict",
        "player",
        "first_strat",
        "second_strat",
        "combine",
        "strat_mat",
        "player",
        "strat_mat",
        "player",
        "combo",
        "other_players_combos",
        "combo",
        "player",
        "first_strat",
        "combo",
        "player",
        "combo",
        "player",
        "second_strat",
        "combo",
        "player",
        "matrix_dict",
        "first_combo",
        "get_payoff",
        "player",
        "matrix_dict",
        "second_combo",
        "get_payoff",
        "player",
        "matrix_dict",
        "first_combo",
        "get_payoff",
        "player",
        "matrix_dict",
        "second_combo",
        "get_payoff",
        "player",
        "flag",
        "player",
        "player_list",
        "itertools",
        "combinations",
        "strat_mat",
        "player",
        "comparison",
        "strats_compared",
        "check_weak_dominance",
        "player",
        "comparison",
        "comparison",
        "wd_list",
        "append",
        "comparison",
        "check_weak_dominance",
        "player",
        "comparison",
        "comparison",
        "wd_list",
        "append",
        "comparison",
        "player",
        "wd_list",
        "wd_dict",
        "player",
        "first_strat",
        "second_strat",
        "combine",
        "strat_mat",
        "player",
        "strat_mat",
        "player",
        "combo",
        "other_players_combos",
        "combo",
        "player",
        "first_strat",
        "combo",
        "player",
        "combo",
        "player",
        "second_strat",
        "combo",
        "player",
        "matrix_dict",
        "first_combo",
        "get_payoff",
        "player",
        "matrix_dict",
        "second_combo",
        "get_payoff",
        "player",
        "player",
        "player_list",
        "itertools",
        "combinations",
        "strat_mat",
        "player",
        "comparison",
        "strats_compared",
        "check_strict_dominance",
        "player",
        "comparison",
        "comparison",
        "sd_list",
        "append",
        "comparison",
        "check_strict_dominance",
        "player",
        "comparison",
        "comparison",
        "sd_list",
        "append",
        "comparison",
        "player",
        "sd_list",
        "sd_dict",
        "player",
        "player_list",
        "strat",
        "strat",
        "strat_mat",
        "player",
        "strat",
        "wd_dict",
        "player",
        "strat",
        "considered_strats",
        "strat",
        "len",
        "considered_strats",
        "symbol",
        "player_symbol_list",
        "end_symbol",
        "symbol",
        "player_symbol_list",
        "append",
        "end_symbol",
        "ALPHABET",
        "player",
        "NUMBERS",
        "strat",
        "player_symbol_list",
        "append",
        "symbol",
        "player",
        "player_symbol_list",
        "player_symbol_dict",
        "player",
        "player_list",
        "strat",
        "strat",
        "strat_mat",
        "player",
        "strat",
        "wd_dict",
        "player",
        "strat",
        "considered_strats",
        "strat",
        "len",
        "considered_strats",
        "symbol",
        "player_symbol_list",
        "end_symbol",
        "symbol",
        "strat",
        "ALPHABET",
        "player",
        "NUMBERS",
        "strat",
        "strat",
        "player_symbol_list",
        "append",
        "symbol",
        "symbol_dict",
        "collections",
        "Counter",
        "player",
        "player_list",
        "combine",
        "strat_mat",
        "player",
        "strat_mat",
        "player",
        "combo",
        "other_players_combos",
        "br",
        "make_br_list",
        "player",
        "combo",
        "combo",
        "combo_copy",
        "insert",
        "player",
        "br",
        "candidates_counter",
        "combo_copy",
        "pure_equilibrium",
        "candidates_counter",
        "most_common",
        "pure_equilibrium",
        "len",
        "player_list",
        "pure_equilibrium_list",
        "append",
        "pure_equilibrium",
        "pure_equilibrium_list",
        "player",
        "other_symbol_lists_combined",
        "player_symbol",
        "player_symbol_dict",
        "player",
        "symbol_combo",
        "other_symbol_lists_combined",
        "symbol",
        "symbol_combo",
        "strat_profile",
        "append",
        "symbol_dict",
        "symbol",
        "strat_profile",
        "insert",
        "player",
        "symbol_dict",
        "player_symbol",
        "matrix_dict",
        "strat_profile",
        "get_payoff",
        "player",
        "coefficient",
        "equation_symbol",
        "symbol_combo",
        "primary",
        "equation_symbol",
        "term",
        "primary",
        "term_list",
        "append",
        "term",
        "term_list",
        "player",
        "player_list",
        "combine",
        "symbol_mat",
        "player",
        "symbol_mat",
        "player",
        "make_term_list",
        "player",
        "other_symbol_lists_combined",
        "term",
        "term_list",
        "term",
        "len",
        "term_list",
        "term",
        "equation",
        "term_list",
        "term",
        "equation_list",
        "append",
        "equation",
        "equation_list",
        "solution_list",
        "symbol",
        "unique_symbol_list",
        "initial",
        "res_mat",
        "append",
        "solution_list",
        "symbol",
        "symbol",
        "unique_symbol_list",
        "symbol",
        "res_mat",
        "append",
        "sum",
        "res_mat",
        "res_mat",
        "append",
        "res_mat",
        "append",
        "solution_list",
        "symbol",
        "res_mat",
        "append",
        "solution_list",
        "symbol",
        "res_mat",
        "append",
        "sum",
        "res_mat",
        "res_mat",
        "solution",
        "prob",
        "solution",
        "prob",
        "player",
        "player_list",
        "symbol",
        "player_symbol_dict",
        "player",
        "symbol_list",
        "append",
        "symbol",
        "symbol_mat",
        "append",
        "symbol_list",
        "player",
        "player_list",
        "symbol",
        "player_symbol_dict",
        "player",
        "strat_list",
        "append",
        "symbol_dict",
        "symbol",
        "strat_mat",
        "append",
        "strat_list",
        "symbol_list",
        "symbol_mat",
        "symbol",
        "symbol_list",
        "len",
        "symbol",
        "unique_symbol_list",
        "append",
        "symbol",
        "make_equation_list",
        "len",
        "equation_list",
        "solve",
        "equation_list",
        "unique_symbol_list",
        "solution_tuple",
        "solution_tuple",
        "solution_mat",
        "symbol",
        "symbol",
        "unique_symbol_list",
        "symbol",
        "solution_mat",
        "properly_format",
        "solution_list",
        "solution_list",
        "solution_mat",
        "solution_list",
        "solution_mat",
        "strat_list",
        "solution",
        "strat_mat",
        "solution_list",
        "is_mixed",
        "solution",
        "mixed_ne",
        "append",
        "Mixed_Strat",
        "strat_list",
        "solution",
        "len",
        "mixed_ne",
        "mixed_ne_list",
        "append",
        "mixed_ne",
        "mixed_ne_list",
        "mixed_ne",
        "player",
        "player_list",
        "mixed_strat",
        "mixed_ne",
        "strat_prob",
        "strat_prob",
        "mixed_strat",
        "strat_prob_list",
        "strat_prob",
        "strat_prob",
        "mixed_strat",
        "strat_prob_list",
        "player_strat_list",
        "append",
        "strat_list",
        "player_prob_list",
        "append",
        "prob_list",
        "combine",
        "player_strat_list",
        "prob_combo",
        "combine",
        "player_prob_list",
        "prob_combo_list",
        "append",
        "functools",
        "reduce",
        "x",
        "y",
        "x",
        "y",
        "prob_combo",
        "strat_combo",
        "prob_combo",
        "strat_combo_list",
        "prob_combo_list",
        "player",
        "player_list",
        "prob_combo",
        "matrix_dict",
        "strat_combo",
        "get_payoff",
        "player",
        "mixed_payoff_list",
        "player",
        "player_payoff",
        "mixed_payoff_list",
        "pure_ne",
        "pure_ne_list",
        "logical_payoff_mat",
        "append",
        "matrix_dict",
        "pure_ne",
        "payoff_list",
        "mixed_ne",
        "mixed_ne_list",
        "logical_payoff_mat",
        "append",
        "make_mixed_payoff_list",
        "mixed_ne",
        "logical_payoff_mat",
        "logical_payoff_mat",
        "strat_list",
        "strats_combined_list",
        "show_strats",
        "strat_list",
        "sep",
        "end",
        "player",
        "matrix_dict",
        "strat_list",
        "player_list",
        "matrix_dict",
        "strat_list",
        "get_payoff",
        "player",
        "player",
        "end",
        "player",
        "player_list",
        "combine",
        "strat_mat",
        "player",
        "strat_mat",
        "player",
        "combo",
        "other_players_combos",
        "player",
        "show_strats",
        "combo",
        "end",
        "br",
        "make_br_list",
        "player",
        "combo",
        "br",
        "end",
        "end",
        "ne",
        "pure_ne_list",
        "show_strats",
        "ne",
        "end",
        "end",
        "ne",
        "mixed_ne_list",
        "ne",
        "end"
    ],
    "literals": [
        "\"ERROR\"",
        "\"strats:\"",
        "\" and \"",
        "\"yield\"",
        "\" \"",
        "\"for\"",
        "\", \"",
        "\"best response(s) for player\"",
        "\"to strat(ies)\"",
        "\"are: \"",
        "\"\"",
        "\", \"",
        "\"pure-strat nash equilibrium(a): \"",
        "\"\"",
        "\" and \"",
        "\", \"",
        "\"mixed-strat nash equilibrium(a): \"",
        "\"\"",
        "\", \"",
        "\"\\n\""
    ],
    "variables": [
        "player_list",
        "strat_mat",
        "strats_combined_list",
        "payoff_mat",
        "matrix_dict",
        "br_dict",
        "wd_dict",
        "sd_dict",
        "player_symbol_dict",
        "symbol_dict",
        "pure_ne_list",
        "mixed_ne_list",
        "logical_payoff_mat",
        "matrix_dict",
        "br_list",
        "br_payoff",
        "player_offset",
        "context_list",
        "br_payoff",
        "br_dict",
        "br_dict",
        "other_players_combos",
        "other_players_combos",
        "flag",
        "first_combo",
        "second_combo",
        "flag",
        "wd_dict",
        "wd_list",
        "strats_compared",
        "wd_dict",
        "other_players_combos",
        "first_combo",
        "second_combo",
        "sd_dict",
        "sd_list",
        "strats_compared",
        "sd_dict",
        "player_symbol_dict",
        "player_symbol_list",
        "end_symbol",
        "considered_strats",
        "symbol",
        "player_symbol_dict",
        "symbol_dict",
        "player_symbol_list",
        "end_symbol",
        "considered_strats",
        "symbol_dict",
        "end_symbol",
        "symbol",
        "symbol_dict",
        "symbol",
        "pure_equilibrium_list",
        "candidates_counter",
        "other_players_combos",
        "combo_copy",
        "term_list",
        "term",
        "strat_profile",
        "coefficient",
        "primary",
        "equation_list",
        "other_symbol_lists_combined",
        "term_list",
        "equation",
        "res_mat",
        "initial",
        "initial",
        "mixed_ne_list",
        "symbol_mat",
        "strat_mat",
        "unique_symbol_list",
        "symbol_list",
        "strat_list",
        "equation_list",
        "solution_mat",
        "solution_mat",
        "unique_symbol_list",
        "solution_mat",
        "mixed_ne",
        "mixed_payoff_list",
        "player_strat_list",
        "player_prob_list",
        "strat_list",
        "prob_list",
        "strat_combo_list",
        "prob_combo_list",
        "player_payoff",
        "logical_payoff_mat",
        "other_players_combos"
    ],
    "comments": [
        "module for Matrix_Single",
        "following class simulates a single-stage matrix game",
        "argument players expected to be a list of string",
        "with 1 to 1 correspondence with strat_mat such that",
        "player[0]'s strats are strat_mat[0]",
        "argument strat_mat expected to be a mat of Strat",
        "argument payoff_mat expected to be a mat of float",
        "with a len equal to that of the product of the len of",
        "every list of Strategy within strat_mat",
        "following function checks if the constructor arguments are comprehensible",
        "FUNCTION DOES NOT THROW EXCEPTIONS YET",
        "arguments here expected to be the same as __init__ arguments of the same name",
        "PLACEHOLDER CODE. THROW AN EXCEPTION HERE",
        "following code maps combined strats to payoff",
        "return value is a dict of the form list of Strategy: list of float",
        "following function finds BR sub i(s sub -i), or best s sub i for the player to",
        "choose, given player i and s sub -i",
        "argument player expected to be a string in self.player_list",
        "argument other_strats expected to be list of Stratgey",
        "with one strategy for every player but i: s sub -i",
        "following code creates a list of all possible s with every s sub i",
        "(i is player) and s sub -i being other_strats.",
        "naturally, the len of context_list is the number of strats player has",
        "end",
        "following code finds the highest U(s), where s is generated by previous code block,",
        "then goes through context_list and finds the U(s) that matches the highest U(s)",
        "found U(s) are s with BR sub i(s sub -i) and have their s sub i appended to br_list",
        "because there may be multiple highest U(s), this step is necessary",
        "end",
        "return value is a list of Strat where each strategy is player's strategy",
        "following function links players to their best responses in a dict",
        "following code goes through all s sub -i for each player i",
        "dictionary values are sets to avoid duplicate entries",
        "end",
        "return value is a dict of the form player: list of Strat",
        "following function links players to their weakly dominated (wd) strategies",
        "following function checks if, for a certain player",
        "first_strat weakly dominates second_strat.",
        "following function is also nested within make_wd_dict",
        "argument first_strat expected to be Strat",
        "argument second_strat expected to be Strat that is",
        "not the same as first_strat",
        "following code generates all possible s sub -i",
        "then compares first_strat: s sub ij, and second strat: s sub ik",
        "s sub ij >= s sub ik for all s sub -i, and s sub ij > s sub ik",
        "for at least one s sub -i for s sub ij to weakly dominate s sub ik",
        "end",
        "return value is a boolean",
        "end nested function",
        "following code goes through all players, for each player i",
        "it creates all combinations of two strategies picked from s sub i,",
        "s sub ij and s sub ik, and checks if s sub ij weakly dominates s sub ik,",
        "or vice versa. the dominant strategy becomes the player's dict value",
        "end",
        "return value is a dict of the form player : list of Strat",
        "following function links players to their strictly dominated (sd) strategies",
        "following function checks if, for a certain player",
        "first_strat strictly dominates second_strat.",
        "following function is also nested within make_sd_dict",
        "argument first_strat expected to be Strat",
        "argument second_strat expected to be Strat that is",
        "not the same as first_strat",
        "following code generates all possible s sub -i",
        "then compares first_strat: s sub ij, and second strat: s sub ik",
        "s sub ij > s sub ik for all s sub -i for s sub ij to strictly dominate s sub ik",
        "end",
        "end nested function",
        "following code goes through all players, for each player i",
        "it creates all combinations of two strategies picked from s sub i,",
        "s sub ij and s sub ik, and checks if s sub ij strictly dominates s sub ik,",
        "or vice versa. the dominant strategy becomes the player's dict value",
        "end",
        "return value is a dict of the form player: list of Strat",
        "following function links a player to their Sympy symbols",
        "for each strat a player has, that strat has a distinct Sympy symbol",
        "form is a0, a1, a2...for player 1, b0, b1, b2... for player 2 and so on",
        "a player's final strat (what comes last) does not get its own symbol",
        "but it is represented by 1 - n0 - n1 - n2... (where n could be a, b, etc.)",
        "following code goes through all players i and for each i scraps",
        "s sub ij if s sub ij is not weakly dominated (implicitly meaning if",
        "it is not strictly dominated either) to make s' sub i",
        "following code goes through each s' sub i and creates a corresponding symbol",
        "if s' sub i is not at the end, else it goes through all the symbols in",
        "player_symbol_list and creates 1 - s' sub ia - s' sub ib...",
        "end",
        "end",
        "return value is a dict of the form player: list of Symbol",
        "following function links sympy Symbols to all strats of all players",
        "form is the same as self.make_player_symbol_dict",
        "the difference between this function and self.make_player_symbol_dict is that",
        "this maps Symbols directly to strats, 1 to 1",
        "whereas self.make_player_symbol_dict maps 1 player to all their Symbols",
        "following code goes through all players i and for each i scraps",
        "s sub ij if s sub ij is weakly dominated (implicitly meaning if",
        "it is not strictly dominated either) to make s' sub i",
        "following code goes through each s' sub i and creates a corresponding symbol",
        "if s' sub i is not at the end, else it goes through all the symbols in",
        "player_symbol_list and creates 1 - s' sub ia - s' sub ib...",
        "unlike in make_player_symbol_dict, this put the symbols",
        "into a dict of the form Symbol: Strat",
        "end",
        "end",
        "return value is a dict of the form Symbol: Strat",
        "following function finds the pure-strat NE of this matrix subgame",
        "following code goes through all the possible s sub -i for each player i",
        "then inserts BR sub i(s sub -i) into the proper position to make s, a complete",
        "strategy profile, before incrementing that s in a Counter. Since NE are",
        "exclusively made up of BRs, they will have the highest \"score\".",
        "casting to list is done for mutability, to allow an insertion",
        "casting back to a tuple is to allow the counter to accept it",
        "end",
        "following code goes through all entries in the counter, from",
        "highest to lowest score. Since candidates are scored by number of",
        "BRs, all NE have a score that is the number of players. thus, the code",
        "can stop searching when it sees a score lower than the player count",
        "return value is a matrix of Strat",
        "following function finds the mixed-strat NE of this matrix subgame",
        "following function creates a system of equations for sympy.solve()",
        "to find the solution values for.",
        "following function is also nested within make_mixed_ne_list",
        "following function creates terms, or sums of primaries, which are mononomials.",
        "following function is also nested within make_equation_list",
        "argument player expected to be an enumeration: (int, string)",
        "argument other_symbol_lists_combined expected to be mat of Strategy",
        "following code goes through all s sub j,k,l..., for all s sub -i,",
        "for all s sub i, all in symbol form. for each iteration of s sub -i, this function",
        "constructs a strategy profile s sub i + s sub -i and creates a mononomial",
        "from multiplying the U sub i(s) by the symbols in s sub -i. It adds this mononomial",
        "to the one created in the next iteration of s sub -i until a term is made.",
        "a term is made for each iteration of s sub i",
        "end",
        "return value is a list of Add, which can be thought of as a summation of a",
        "list of Mul. the len of term_list is equal to the number of i's strats",
        "end nested function",
        "following code creates all s sub -i for each player i so make_term_list can",
        "generate a term list for each i",
        "following code goes through each term in term_list, creating the expressions",
        "term[0] - term[1], term[1] - term[2]...term[n-1] - term[n]. For sympy.solve,",
        "x - y means x = y, so this checks if term[0] == term[1]...term[n-1] == term[n]",
        "these expressions are put into equation_list",
        "end",
        "end",
        "return value is Add which can be thought of as a summation of a list of make_term_list",
        "end nested function",
        "following function properly formats a list of solve() solutions",
        "to be congruent with a list of Symbol. in short, it organizes solutions",
        "by player and adds the extra symbols.",
        "following function is also nested within make_mixed_ne_list",
        "argument solution_list expected to be a list of floats x, such that 0 <= x <= 1",
        "following code goes through each that was used for the sympy equation",
        "and splits solution_list into multiple sub-lists, creating a res_mat such that",
        "there is a 1 to 1 correspondence between res_mat and symbol_mat, and that each",
        "solution is paired with the right symbol",
        "following code detects when all the symbols for a certain player i are",
        "accounted for and another player's i* symbols are coming up",
        "before packaging all the old player's solutions into a list, it",
        "creates a 1 - i's symbols symbol to pad the list, to accound for i's",
        "last strategy that is only played when all other strategies aren't",
        "end",
        "end",
        "return value is a matrix of floats, solutions organized by player",
        "end nested function",
        "following funtions determine if a would-be mixed strategy is really mixed or not.",
        "following function is also nested within make_mixed_ne_list",
        "argument solution expected to be a list of floats x, such that 0 <= x <= 1",
        "end nested function",
        "following code creates lists that are ordered with respect to each other",
        "and have a 1 to 1 correspondence, ex. symbol_mat[0] holds i's symbols, and",
        "strat_mat[0] holds i's strats.",
        "difference betwee unique_symbol_list and symbol_mat is that unique_symbol_list",
        "does not include the 1 - s sub i symbol, because solve would not comprehend it",
        "end",
        "following code runs if there is no mixed equilibrium",
        "end",
        "following code solves the system of equations created by make_equation_list,",
        "makes everything mutable, and formats the strat_mat to link with solution_mat",
        "from there it creates mixed NE for mixed_ne_list",
        "end",
        "return value is a list of Mixed_Strat",
        "following function returns the payoff for each player in a mixed ne",
        "argument mixed_ne expected to be an element of self.mixed_ne_list",
        "following code put all combinations of strat prob pairs for the mixed ne",
        "into player_strat_list and player_prob_list",
        "end",
        "following code takes the product of the floats in each prob_combo and",
        "puts it into prob_combo_list (1 to 1 correspondence with strat_combo_list)",
        "end",
        "following code multiplies the probability that a strat combo will be played by",
        "the payoff of the strat combo for player i, then adds that to player i's position",
        "in mixed_payoff_list; for each strat_combo, for each player",
        "end",
        "return value is a list of payoff, with a 1 to 1 correspondence with self.player_list",
        "following function returns the payoff that would be given to each player",
        "assuming all players play this game logically",
        "return value is a matrix of payoff",
        "following function returns the payoffs of the tree single, played logically",
        "that is, the payoffs if the acting player plays a BR",
        "return value is a payoff",
        "following function prints relevant information",
        "following code prints all strategy combinations and their yields to each player",
        "in the form \"s yields U sub i(s) for i, U sub j(s) for j...\"",
        "end",
        "following code goes through all s sub -i for each player i",
        "and prints the BR sub i(s sub -i) for each s sub -i",
        "end",
        "following code prints out all NE, pure and mixed",
        "end"
    ],
    "docstrings": [],
    "functions": [
        "check_validity",
        "make_matrix_dict",
        "make_br_list",
        "make_br_dict",
        "make_wd_dict",
        "check_weak_dominance",
        "make_sd_dict",
        "check_strict_dominance",
        "make_player_symbol_dict",
        "make_strat_symbol_dict",
        "make_pure_ne_list",
        "make_mixed_ne_list",
        "make_equation_list",
        "make_term_list",
        "properly_format",
        "is_mixed",
        "make_mixed_payoff_list",
        "make_logical_payoff_mat",
        "get_logical_payoff_mat",
        "print_state"
    ],
    "classes": [
        "Matrix_Single"
    ]
}