{
    "identifiers": [
        "Injectable",
        "Observable",
        "Observer",
        "Subscription",
        "BehaviorSubject",
        "Subject",
        "StompConfig",
        "Stomp",
        "StompSubscription",
        "StompHeaders",
        "StompState",
        "Injectable",
        "Stomp",
        "Stomp",
        "BehaviorSubject",
        "StompState",
        "currentState",
        "currentState",
        "StompState",
        "Subject",
        "value",
        "value",
        "Stomp",
        "Stomp",
        "StompState",
        "StompState",
        "StompState",
        "StompState",
        "queueName",
        "message",
        "headers",
        "queueName",
        "headers",
        "message",
        "message",
        "queueName",
        "message",
        "headers",
        "queuedMessages",
        "queuedMessage",
        "queuedMessages",
        "queuedMessage",
        "queuedMessage",
        "queuedMessage",
        "queuedMessage",
        "queueName",
        "headers",
        "Stomp",
        "queueName",
        "headers",
        "headers",
        "Observable",
        "messages",
        "Stomp",
        "stompConnectedSubscription",
        "queueName",
        "stompSubscription",
        "queueName",
        "message",
        "Stomp",
        "messages",
        "message",
        "headers",
        "queueName",
        "stompConnectedSubscription",
        "StompState",
        "queueName",
        "stompSubscription",
        "queueName",
        "coldObservable",
        "args",
        "args",
        "StompState",
        "error",
        "Stomp",
        "error",
        "error",
        "error",
        "Stomp",
        "error",
        "error",
        "StompState"
    ],
    "literals": [
        "'@angular/core'",
        "'rxjs/Rx'",
        "'rxjs/BehaviorSubject'",
        "'rxjs/Subject'",
        "'./stomp.config'",
        "'@stomp/stompjs'",
        "'@stomp/stompjs'",
        "'./stomp-headers'",
        "'./stomp-state'",
        "string",
        "string",
        "string",
        "'string'",
        "'Connecting...'",
        "string",
        "string",
        "Not connected, queueing ${message}",
        "string",
        "string",
        "Will try sending queued messages ${queuedMessages}",
        "Attempting to send ${queuedMessage}",
        "string",
        "Request to subscribe ${queueName}",
        "'ack'",
        "'ack'",
        "'auto'",
        "Will subscribe to ${queueName}",
        "Stop watching connection state (for ${queueName})",
        "Will unsubscribe from ${queueName} at Stomp",
        "Stomp not connected, no need to unsubscribe from ${queueName} at Stomp",
        "'Connected'",
        "string",
        "'object'",
        "Error: ${error}"
    ],
    "variables": [
        "queuedMessages",
        "coldObservable",
        "stompSubscription",
        "stompConnectedSubscription"
    ],
    "comments": [
        "Setup sending queuedMessages",
        "Set configuration",
        "Initialize STOMP Client",
        "disconnect if connected",
        "url takes precedence over socketFn",
        "Configure client heart-beating",
        "Auto reconnect",
        "Set function to debug print messages",
        "Attempt connection, passing in a callback",
        "Disconnect if connected. Callback will set CLOSED state",
        "Notify observers that we are disconnecting!",
        "Send queued messages",
        "Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n     *\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n     * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n     * successfully reconnects.\n     *\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n     *\n     * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n     * the message subscriber.",
        "By default auto acknowledgement of messages",
        "cleanup function, will be called when no subscribers are left",
        "Callback run on successfully connecting to server",
        "Indicate our connected state to observers",
        "Handle errors from stomp.js",
        "Trigger the error subject",
        "Check for dropped connection and try reconnecting",
        "Reset state indicator"
    ],
    "docstrings": [
        "* Angular2 STOMP Raw Service using @stomp/stomp.js\n *\n * @description This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you will like to pass the configuration as a dependency,\n * please use StompService class.",
        "* State of the STOMPService\n   *\n   * It is a BehaviorSubject and will emit current status immediately. This will typically get\n   * used to show current status to the end user.",
        "* Will trigger when connection is established. Use this to carry out initialization.\n   * It will trigger every time a (re)connection occurs. If it is already connected\n   * it will trigger immediately. You can safely ignore the value, as it will always be\n   * StompState.CONNECTED",
        "* Will trigger when an error occurs. This Subject can be used to handle errors from\n   * the stomp broker.",
        "* Internal array to hold locally queued messages when STOMP broker is not connected.",
        "* Configuration",
        "* STOMP Client from @stomp/stomp.js",
        "* Constructor\n   *\n   * See README and samples for configuration examples",
        "* Perform connection to STOMP broker",
        "* Disconnect the connection to the STOMP broker and clean up,\n   * not sure how this method will get called, if ever.\n   * Call this method only if you know what you are doing.",
        "* The current connection status with the STOMP broker\n   * @returns {boolean}",
        "* Send a message to a named destination. The message must be string.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. Attempt\n   * will be made to publish queued messages as soon as the broker gets connected.\n   *\n   * @param queueName\n   * @param message\n   * @param headers",
        "* Subscribe to server message queues\n   *\n   * This method can safely be called even when STOMP broker is not connected. Further\n   * if the underlying STOMP connection drops and reconnects, it will resubscribe transparently.\n   *\n   * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you\n   * do not understand what it means, please leave it as is.\n   *\n   * Please note, however, while working with temporary queues, where the subscription request\n   * creates the\n   * underlying queue, during reconnect it might miss messages. This issue is not specific\n   * to this library but the way STOMP brokers are designed to work.\n   *\n   * @param queueName\n   * @param headers\n   * @returns {Observable<Stomp.Message>}",
        "* These variables will be used as part of the closure and work their magic during unsubscribe",
        "* Important - convert it to hot Observable - otherwise, if the user code subscribes\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339",
        "* Callback Functions\n   *\n   * Note the method signature: () => preserves lexical scope\n   * if we need to use this.x inside the function"
    ],
    "functions": [
        "config",
        "initStompClient",
        "initAndConnect",
        "disconnect",
        "connected",
        "publish",
        "sendQueuedMessages",
        "subscribe"
    ],
    "classes": [
        "StompRService"
    ]
}