{
    "identifiers": [
        "InlineElementFactory",
        "PartialInlineElement",
        "contains",
        "getTagOfNode",
        "isBlockElement",
        "isDocumentPosition",
        "isNodeAfter",
        "shouldSkipNode",
        "BlockElement",
        "DocumentPosition",
        "InlineElement",
        "EditorPoint",
        "NodeBoundary",
        "NodeType",
        "getFirstLeafNode",
        "getLastLeafNode",
        "getLeafSibling",
        "getPreviousLeafSibling",
        "getNextLeafSibling",
        "rootNode",
        "node",
        "inlineElementFactory",
        "node",
        "getBlockElementAtNode",
        "rootNode",
        "node",
        "inlineElementFactory",
        "parentBlock",
        "inlineElementFactory",
        "node",
        "rootNode",
        "parentBlock",
        "rootNode",
        "inlineElementFactory",
        "getFirstLeafNode",
        "rootNode",
        "node",
        "getInlineElementAtNode",
        "rootNode",
        "node",
        "inlineElementFactory",
        "rootNode",
        "inlineElementFactory",
        "getLastLeafNode",
        "rootNode",
        "node",
        "getInlineElementAtNode",
        "rootNode",
        "node",
        "inlineElementFactory",
        "rootNode",
        "inlineElement",
        "inlineElementFactory",
        "isNext",
        "inlineElement",
        "inlineElement",
        "PartialInlineElement",
        "inlineElement",
        "result",
        "inlineElement",
        "inlineElement",
        "startNode",
        "getLeafSibling",
        "rootNode",
        "startNode",
        "isNext",
        "result",
        "startNode",
        "getInlineElementAtNode",
        "rootNode",
        "startNode",
        "inlineElementFactory",
        "result",
        "rootNode",
        "inlineElement",
        "inlineElementFactory",
        "getNextPreviousInlineElement",
        "rootNode",
        "inlineElement",
        "inlineElementFactory",
        "rootNode",
        "inlineElement",
        "inlineElementFactory",
        "getNextPreviousInlineElement",
        "rootNode",
        "inlineElement",
        "inlineElementFactory",
        "rootNode",
        "position",
        "inlineElementFactory",
        "position",
        "position",
        "containerNode",
        "offset",
        "NodeBoundary",
        "containerNode",
        "getPreviousLeafSibling",
        "rootNode",
        "containerNode",
        "containerNode",
        "NodeType",
        "offset",
        "containerNode",
        "isPartial",
        "containerNode",
        "shouldSkipNode",
        "containerNode",
        "containerNode",
        "getPreviousLeafSibling",
        "rootNode",
        "containerNode",
        "inlineElement",
        "containerNode",
        "getInlineElementAtNode",
        "rootNode",
        "containerNode",
        "inlineElementFactory",
        "isPartial",
        "isPartial",
        "inlineElement",
        "inlineElement",
        "position",
        "isPartial",
        "inlineElement",
        "inlineElement",
        "PartialInlineElement",
        "inlineElement",
        "position",
        "inlineElement",
        "rootNode",
        "editorPoint",
        "inlineElementFactory",
        "editorPoint",
        "editorPoint",
        "containerNode",
        "containerNode",
        "NodeType",
        "offset",
        "containerNode",
        "containerNode",
        "NodeType",
        "offset",
        "NodeBoundary",
        "containerNode",
        "getNextLeafSibling",
        "rootNode",
        "containerNode",
        "containerNode",
        "NodeType",
        "offset",
        "NodeBoundary",
        "offset",
        "containerNode",
        "isPartial",
        "containerNode",
        "shouldSkipNode",
        "containerNode",
        "containerNode",
        "getNextLeafSibling",
        "rootNode",
        "containerNode",
        "inlineElement",
        "containerNode",
        "getInlineElementAtNode",
        "rootNode",
        "containerNode",
        "inlineElementFactory",
        "isPartial",
        "isPartial",
        "inlineElement",
        "inlineElement",
        "editorPoint",
        "isPartial",
        "inlineElement",
        "inlineElement",
        "PartialInlineElement",
        "inlineElement",
        "editorPoint",
        "inlineElement",
        "node",
        "getTagOfNode",
        "node",
        "node",
        "containerBlockNode",
        "blockOrBrEncountered",
        "headNode",
        "headNode",
        "isBlockElement",
        "previousSibling",
        "isBrElement",
        "previousSibling",
        "blockOrBrEncountered",
        "headNode",
        "previousSibling",
        "blockOrBrEncountered",
        "headNode",
        "parentNode",
        "containerBlockNode",
        "parentNode",
        "parentPreviousSibiling",
        "parentNode",
        "parentNode",
        "parentNode",
        "parentPreviousSibiling",
        "parentPreviousSibiling",
        "parentPreviousSibiling",
        "parentPreviousSibiling",
        "parentPreviousSibiling",
        "isBlockElement",
        "parentPreviousSibiling",
        "isBrElement",
        "parentPreviousSibiling",
        "blockOrBrEncountered",
        "headNode",
        "parentPreviousSibiling",
        "headNode",
        "node",
        "containerBlockNode",
        "blockOrBrEncountered",
        "tailNode",
        "tailNode",
        "isBlockElement",
        "nextSibling",
        "isBr",
        "isBrElement",
        "nextSibling",
        "blockOrBrEncountered",
        "isBr",
        "tailNode",
        "nextSibling",
        "tailNode",
        "nextSibling",
        "blockOrBrEncountered",
        "tailNode",
        "parentNode",
        "containerBlockNode",
        "parentNode",
        "parentNextSibiling",
        "parentNode",
        "parentNode",
        "parentNode",
        "parentNextSibiling",
        "parentNextSibiling",
        "parentNextSibiling",
        "parentNextSibiling",
        "parentNextSibiling",
        "isBlockElement",
        "parentNextSibiling",
        "isBr",
        "isBrElement",
        "parentNextSibiling",
        "blockOrBrEncountered",
        "isBr",
        "tailNode",
        "parentNextSibiling",
        "tailNode",
        "parentNextSibiling",
        "tailNode",
        "rootNode",
        "inlineElementFactory",
        "isFirst",
        "isFirst",
        "node",
        "node",
        "node",
        "node",
        "getChild",
        "rootNode",
        "node",
        "getChild",
        "node",
        "node",
        "getChild",
        "node",
        "node",
        "getBlockElementAtNode",
        "rootNode",
        "node",
        "inlineElementFactory",
        "rootNode",
        "inlineElementFactory",
        "getFirstLastBlockElement",
        "rootNode",
        "inlineElementFactory",
        "rootNode",
        "inlineElementFactory",
        "getFirstLastBlockElement",
        "rootNode",
        "inlineElementFactory",
        "rootNode",
        "blockElement",
        "inlineElementFactory",
        "isNext",
        "isNext",
        "element",
        "element",
        "element",
        "element",
        "blockElement",
        "getLeafSibling",
        "rootNode",
        "getNode",
        "blockElement",
        "isNext",
        "result",
        "leaf",
        "getBlockElementAtNode",
        "rootNode",
        "leaf",
        "inlineElementFactory",
        "result",
        "rootNode",
        "blockElement",
        "inlineElementFactory",
        "getNextPreviousBlockElement",
        "rootNode",
        "blockElement",
        "inlineElementFactory",
        "rootNode",
        "blockElement",
        "inlineElementFactory",
        "getNextPreviousBlockElement",
        "rootNode",
        "blockElement",
        "inlineElementFactory",
        "containerNode",
        "inlineElementFactory",
        "getFirstInlineElement",
        "getLastInlineElement",
        "startInline",
        "allInlines",
        "startInline",
        "startInline",
        "getNextInlineElement",
        "startInline",
        "allInlines",
        "blockElement",
        "blockElement",
        "blockElement",
        "isNodeAfter",
        "blockElement",
        "inlineElement",
        "inlineElement",
        "node",
        "node",
        "documentPosition",
        "DocumentPosition",
        "isDocumentPosition",
        "documentPosition",
        "DocumentPosition",
        "rootNode",
        "startNode",
        "endNode",
        "inlineElementFactory",
        "currentNode",
        "currentNode",
        "allNodes",
        "currentNode",
        "currentNode",
        "currentNode",
        "currentNode",
        "allNodes",
        "getInlineElementAtNode",
        "getInlineElementAtNode",
        "startInline",
        "allInlines",
        "startInline",
        "startInline",
        "getNextInlineElement",
        "startInline",
        "allInlines",
        "blockElement",
        "blockElement",
        "blockElement",
        "blockElement",
        "isNodeAfter",
        "blockElement",
        "inlineElement",
        "inlineElement",
        "node",
        "node",
        "node",
        "inBlock",
        "node",
        "node",
        "isDocumentPosition",
        "startComparision",
        "DocumentPosition",
        "isDocumentPosition",
        "startComparision",
        "DocumentPosition",
        "isDocumentPosition",
        "endComparision",
        "DocumentPosition",
        "isDocumentPosition",
        "endComparision",
        "DocumentPosition",
        "inBlock",
        "inOrAfterStart",
        "inOrBeforeEnd",
        "inBlock",
        "rootNode",
        "node",
        "inlineElementFactory",
        "node",
        "contains",
        "rootNode",
        "node",
        "isBlockElement",
        "node",
        "NodeBlockElement",
        "node",
        "inlineElementFactory",
        "node",
        "isBlockElement",
        "containerBlockNode",
        "containerBlockNode",
        "containerBlockNode",
        "findHeadLeafNodeInBlock",
        "node",
        "containerBlockNode",
        "findTailLeafNodeInBlock",
        "node",
        "containerBlockNode",
        "headNode",
        "parentNode",
        "headNode",
        "parentNode",
        "containerBlockNode",
        "contains",
        "parentNode",
        "tailNode",
        "headNode",
        "parentNode",
        "parentNode",
        "parentNode",
        "parentNode",
        "tailNode",
        "parentNode",
        "tailNode",
        "parentNode",
        "containerBlockNode",
        "contains",
        "parentNode",
        "headNode",
        "tailNode",
        "parentNode",
        "parentNode",
        "parentNode",
        "headNode",
        "tailNode",
        "blockElement",
        "StartEndBlockElement",
        "rootNode",
        "headNode",
        "tailNode",
        "inlineElementFactory",
        "parentNode",
        "headNode",
        "parentNode",
        "headNode",
        "parentNode",
        "tailNode",
        "parentNode",
        "containerBlockNode",
        "containerBlockNode",
        "rootNode",
        "headNode",
        "tailNode",
        "parentNode",
        "headNode",
        "tailNode",
        "parentNode",
        "parentNode",
        "parentNode",
        "blockElement",
        "headNode",
        "tailNode",
        "isBlockElement",
        "headNode",
        "NodeBlockElement",
        "headNode",
        "inlineElementFactory",
        "StartEndBlockElement",
        "rootNode",
        "headNode",
        "tailNode",
        "inlineElementFactory",
        "blockElement",
        "NodeBlockElement",
        "StartEndBlockElement",
        "getBlockElementAtNode",
        "getFirstBlockElement",
        "getLastBlockElement",
        "getNextBlockElement",
        "getPreviousBlockElement",
        "getFirstInlineElement",
        "getLastInlineElement",
        "getInlineElementAtNode",
        "getNextInlineElement",
        "getPreviousInlineElement",
        "getInlineElementBeforePoint",
        "getInlineElementAfterPoint"
    ],
    "literals": [
        "'../inlineElements/InlineElementFactory'",
        "'../inlineElements/PartialInlineElement'",
        "'../utils/contains'",
        "'../utils/getTagOfNode'",
        "'../utils/isBlockElement'",
        "'../utils/isDocumentPosition'",
        "'../utils/isNodeAfter'",
        "'../domWalker/shouldSkipNode'",
        "'roosterjs-editor-types'",
        "'../domWalker/getLeafNode'",
        "'../domWalker/getLeafSibling'",
        "'BR'",
        "string",
        "string"
    ],
    "variables": [
        "parentBlock",
        "node",
        "node",
        "result",
        "startNode",
        "inlineElement",
        "containerNode",
        "offset",
        "isPartial",
        "inlineElement",
        "containerNode",
        "offset",
        "isPartial",
        "headNode",
        "node",
        "blockOrBrEncountered",
        "previousSibling",
        "parentPreviousSibiling",
        "parentNode",
        "tailNode",
        "node",
        "blockOrBrEncountered",
        "isBr",
        "nextSibling",
        "parentNextSibiling",
        "parentNode",
        "getChild",
        "node",
        "getNode",
        "result",
        "leaf",
        "allInlines",
        "startInline",
        "documentPosition",
        "currentNode",
        "allNodes",
        "allInlines",
        "startInline",
        "inBlock",
        "startComparision",
        "endComparision",
        "inOrAfterStart",
        "inOrBeforeEnd",
        "blockElement",
        "containerBlockNode",
        "headNode",
        "tailNode",
        "parentNode"
    ],
    "comments": [
        "Get the inline element at a node",
        "An inline element has to be in a block element, get the block first and then resolve through the factory",
        "Get first inline element",
        "getFirstLeafNode can return null for empty container",
        "do check null before passing on to get inline from the node",
        "Get last inline element",
        "getLastLeafNode can return null for empty container",
        "do check null before passing on to get inline from the node",
        "if current is partial, get the the other half of the inline unless it is no more",
        "Get a leaf node after startNode and use that base to find next inline",
        "Get next inline element",
        "isNext",
        "Get previous inline element",
        "isNext",
        "Get inline element before an editor point",
        "This is mostly used when users want to get the inline element before selection/cursor",
        "There is a good possibility that the cursor is in middle of an inline element (i.e. mid of a text node)",
        "in this case, we only want to return what is before cursor (a partial of an inline) to indicate",
        "that we're in middle. The logic is largely to detect if the editor point runs across an inline element",
        "The point is at the begin of container element",
        "Run across a text node",
        "if the inline element we get in the end wraps around the point (contains), this has to be a partial",
        "Similar to getInlineElementBeforePoint, to get inline element after an editor point",
        "The point is at the end of container element",
        "Run across a text node, this inline has to be partial",
        "if the inline element we get in the end wraps (contains) the editor point, this has to be a partial",
        "the point runs across a test node in a link",
        "Checks if the node is a BR",
        "Given a node and container block, identify the first leaf (head) node",
        "A leaf node is defined as deepest first node in a block",
        "i.e. <div><span style=\"font-family: Arial\">abc</span></div>, abc is the head leaf of the block",
        "Often <br> or a child <div> is used to create a block. In that case, the leaf after the sibling div or br should be the head leaf",
        "i.e. <div>123<br>abc</div>, abc is the head of a block because of a previous sibling <br>",
        "i.e. <div><div>123</div>abc</div>, abc is also the head of a block because of a previous sibling <div>",
        "To identify the head leaf of a block, we basically start from a node, go all the way towards left till a sibling <div> or <br>",
        "in DOM tree traversal, it is three traversal:",
        "1) previous sibling traversal",
        "2) parent traversal looking for a previous sibling from parent",
        "3) last child traversal, repeat from 1-3",
        "1) previous sibling traversal",
        "move to previous sibling",
        "break if a block or BR is seen",
        "2) parent traversal looking for a previous sibling from parent",
        "3) last child traversal",
        "parentPreviousSibiling is the seed for traversal",
        "Check if it is a block or <br>, if so, stop right away. Otherwise, repeat the traversal",
        "This is similar to findHeadLeafNodeInBlock, but the other direction to identify the last leaf (tail) node",
        "One difference from findHeadLeafNodeInBlock, when it sees a <br>, the <br> should be used as tail.",
        "In another word, we consider <br> to be part of a block as ending node",
        "1) next sibling traversal",
        "if br, consider it to be ending node for a block",
        "move to next sibling",
        "2) parent traversal looking for a next sibling from parent",
        "3) first child traversal",
        "parentPreviousSibiling is the seed for traversal",
        "Check if it is a block or <br>, if so, stop right away. Otherwise, repeat the traversal",
        "Get the first block element",
        "NOTE: this can return null for empty container",
        "isFirst",
        "Get the last block element",
        "NOTE: this can return null for empty container",
        "isFirst",
        "Get a leaf node after block's end element and use that base to find next block",
        "TODO: this code is used to identify block, maybe we shouldn't exclude those empty nodes",
        "We can improve this later on",
        "Get next block",
        "isNext",
        "Get previous block",
        "isNext",
        "This presents a content block that can be reprented by a single html block type element.",
        "In most cases, it corresponds to an HTML block level element, i.e. P, DIV, LI, TD etc.",
        "Get the text content in the block",
        "Get the start node of the block",
        "For NodeBlockElement, start and end essentially refers to same node",
        "Get the end node of the block",
        "For NodeBlockElement, start and end essentially refers to same node",
        "Get all nodes represented in a Node array",
        "Get the first inline element in the block",
        "Get the last inline element in the block",
        "Gets all inline in the block",
        "Checks if it refers to same block",
        "Ideally there is only one unique way to generate a block so we only need to compare the startNode",
        "Checks if a block is after the current block",
        "if the block's startNode is after current node endEnd, we say it is after",
        "Checks if an inline element falls within the block",
        "Checks if a certain html node is within the block",
        "if it is same node or it is being contained, we say it is contained.",
        "This reprents a block that is identified by a start and end node",
        "This is for cases like <ced>Hello<BR>World</ced>",
        "in that case, Hello<BR> is a block, World is another block",
        "Such block cannot be represented by a NodeBlockElement since they don't chained up",
        "to a single parent node, instead they have a start and end",
        "This start and end must be in same sibling level and have same parent in DOM tree",
        "Gets the text content",
        "Get all nodes represented in a Node array",
        "NOTE: this only works for balanced node -- start and end is at same level",
        "get a node array from start and end and do DIV wrapping",
        "Gets the start node",
        "Gets the end node",
        "Gets first inline",
        "Gets last inline",
        "Gets all inline in the block",
        "Checks equals of two blocks",
        "Checks if another block is after this current",
        "Checks if an inline falls inside me",
        "Checks if an Html node is contained within the block",
        "This produces a block element from a a node",
        "It needs to account for various HTML structure. Examples:",
        "1) <ced><div>abc</div></ced>",
        "This is most common the case, user passes in a node pointing to abc, and get back a block representing <div>abc</div>",
        "2) <ced><p><br></p></ced>",
        "Common content for empty block for email client like OWA, user passes node pointing to <br>, and get back a block representing <p><br></p>",
        "3) <ced>abc</ced>",
        "Not common, but does happen. It is still a block in user's view. User passes in abc, and get back a start-end block representing abc",
        "NOTE: abc could be just one node. However, since it is not a html block, it is more appropriate to use start-end block although they point to same node",
        "4) <ced><div>abc<br>123</div></ced>",
        "A bit tricky, but can happen when user use Ctrl+Enter which simply inserts a <BR> to create a link break. There're two blocks:",
        "block1: 1) abc<br> block2: 123",
        "5) <ced><div>abc<div>123</div></div></ced>",
        "Nesting div and there is text node in same level as a DIV. Two blocks: 1) abc 2) <div>123</div>",
        "6) <ced<div>abc<span>123<br>456</span></div></ced>",
        "This is really tricky. Essentially there is a <BR> in middle of a span breaking the span into two blocks;",
        "block1: abc<span>123<br> block2: 456",
        "In summary, given any arbitary node (leaf), to identify the head and tail of the block, following rules need to be followed:",
        "1) to identify the head, it needs to crawl DOM tre left/up till a block node or BR is encountered",
        "2) same for identifying tail",
        "3) should also apply a block ceiling, meaning as it crawls up, it should stop at a block node",
        "TODO: assert node to be a leaf node",
        "if the node is already a block, return right away",
        "Identify the containing block. This serves as ceiling for traversing down below",
        "NOTE: this container block could be just the rootNode,",
        "which cannot be used to create block element. We will special case handle it later on",
        "Find the head and leaf node in the block",
        "TODO: assert headNode and tailNode to be leaf, and are within containerBlockNode",
        "At this point, we have the head and tail of a block, here are some examples and where head and tail point to",
        "1) <ced><div>hello<br></div></ced>, head: hello, tail: <br>",
        "2) <ced><div>hello<span style=\"font-family: Arial\">world</span></div></ced>, head: hello, tail: world",
        "Both are actually completely and exclusively wrapped in a parent div, and can be represented with a Node block",
        "So we shall try to collapse as much as we can to the nearest common ancester",
        "this is an indication that the nearest common ancester has been reached",
        "Do same for the tail",
        "this is an indication that the nearest common ancester has been reached",
        "Un-balanced start and end, create a start-end block",
        "Balanced start and end (point to same parent), need to see if further collapsing can be done",
        "Has reached the container block",
        "If the container block is not the root, use the container block",
        "Continue collapsing to parent",
        "If head and tail are same and it is a block element, create NodeBlock, otherwise start-end block"
    ],
    "docstrings": [],
    "functions": [
        "getInlineElementAtNode",
        "getFirstInlineElement",
        "getLastInlineElement",
        "getNextPreviousInlineElement",
        "getNextInlineElement",
        "getPreviousInlineElement",
        "getInlineElementBeforePoint",
        "getInlineElementAfterPoint",
        "isBrElement",
        "findHeadLeafNodeInBlock",
        "findTailLeafNodeInBlock",
        "getFirstLastBlockElement",
        "getFirstBlockElement",
        "getLastBlockElement",
        "getNextPreviousBlockElement",
        "getNextBlockElement",
        "getPreviousBlockElement",
        "getTextContent",
        "getStartNode",
        "getEndNode",
        "getContentNodes",
        "getFirstInlineElement",
        "getLastInlineElement",
        "getInlineElements",
        "equals",
        "isAfter",
        "isInBlock",
        "contains",
        "getTextContent",
        "getContentNodes",
        "getStartNode",
        "getEndNode",
        "getFirstInlineElement",
        "getLastInlineElement",
        "getInlineElements",
        "equals",
        "isAfter",
        "isInBlock",
        "contains",
        "getBlockElementAtNode"
    ],
    "classes": [
        "NodeBlockElement",
        "StartEndBlockElement"
    ]
}