{
    "identifiers": [
        "stream",
        "yargs",
        "types",
        "stream",
        "stream",
        "Buffer",
        "opts",
        "opts",
        "opts",
        "opts",
        "opts",
        "opts",
        "buffer",
        "buffer",
        "i",
        "l",
        "i",
        "buffer",
        "i",
        "buffer",
        "i",
        "buffer",
        "cursor",
        "i",
        "buffer",
        "i",
        "buffer",
        "i",
        "i",
        "cursor",
        "i",
        "buffer",
        "i",
        "buffer",
        "cursor",
        "i",
        "cursor",
        "i",
        "buffer",
        "cursor",
        "chunk",
        "encoding",
        "callback",
        "error",
        "outputChunk",
        "Buffer",
        "chunk",
        "buffer",
        "callback",
        "callback",
        "error",
        "callback",
        "stream",
        "opts",
        "stream",
        "opts",
        "chunk",
        "encoding",
        "callback",
        "error",
        "outputChunk",
        "callback",
        "chunk",
        "value",
        "value",
        "value",
        "value",
        "value",
        "schemas",
        "types",
        "types",
        "schema",
        "schemas",
        "i",
        "i",
        "schema",
        "schema",
        "schemas",
        "types",
        "value",
        "types",
        "valueType",
        "value",
        "schemas",
        "find",
        "schemas",
        "schema",
        "schema",
        "types",
        "schemas",
        "schema",
        "types",
        "schema",
        "key",
        "value",
        "value",
        "key",
        "object_schema",
        "key",
        "union",
        "object_schema",
        "key",
        "value",
        "key",
        "types",
        "schema",
        "value",
        "item",
        "array_schema",
        "union",
        "array_schema",
        "item",
        "schemas",
        "values",
        "types",
        "values",
        "accumulator_schemas",
        "value",
        "union",
        "accumulator_schemas",
        "value",
        "readable_stream",
        "stream",
        "callback",
        "error",
        "schemas",
        "types",
        "types",
        "readable_stream",
        "value",
        "accumulator_schemas",
        "union",
        "accumulator_schemas",
        "value",
        "error",
        "callback",
        "error",
        "callback",
        "accumulator_schemas",
        "yargs",
        "argvparser",
        "argv",
        "argvparser",
        "argv",
        "require",
        "generalizeStream",
        "process",
        "Splitter",
        "JSONParser",
        "error",
        "schemas",
        "schemas"
    ],
    "literals": [
        "'stream'",
        "'yargs'",
        "'./types'",
        "string",
        "'_readableState'",
        "string",
        "string",
        "string",
        "string",
        "string",
        "'undefined'",
        "'null'",
        "'array'",
        "string",
        "'undefined'",
        "'object'",
        "'array'",
        "'data'",
        "'error'",
        "'end'",
        "'Usage: generalize <objects.json'",
        "'print this help message'",
        "'print version'",
        "'help'",
        "'help'",
        "'./package'"
    ],
    "variables": [
        "cursor",
        "i",
        "l",
        "buffer",
        "i",
        "schema",
        "schema",
        "object_schema",
        "array_schema",
        "accumulator_schemas",
        "argvparser",
        "argv"
    ],
    "comments": [
        "<reference path=\"./type_declarations/index.d.ts\" />",
        "split_string, if provided, should be exactly one character long",
        "split_byte, if provided, will override split_string (they are mutually exclusive options)",
        "Splitter is a stream.Transform that rechunks a stream into sub-buffers.\nThe output (readable) part is set to objectMode true, and emits Buffer objects.\nThe input (writable) part should be plain buffers (have no encoding).\n\nBy default, it splits on the universal newline (\\r, \\r\\n, or \\n).\nThe split byte can be specified in the options.\n\n_writableState.decodeStrings defaults to true, so we should get Buffers\nregardless of what's pushed in. If `opts.decodeStrings` is set to `false`,\nthe behavior is undefined. (TODO: force decodeStrings: true maybe?)\n\nIn other words, the Splitter should have the following values:\n\n    {\n      _writableState: {\n        decodeStrings: true,\n        objectMode: false\n      },\n      _readableState: {\n        objectMode: true\n      }\n    }",
        "null indicates smart handling of \\r and \\n characters",
        "if we are given a split string, use the byte code of the first character to split",
        "throws if opts.split_string is not a string",
        "split_byte overrides split_string",
        "we set the readable side to objectMode, in any case, so that the",
        "individual buffers we emit will not be fused to each other",
        "Decide where the split points are and push chunks onto the stream for\n  downstream reading.",
        "smart handling of \\r and \\n",
        "'\\r\\n'",
        "naive handling with given split byte",
        "set the internal buffer to just the unused part of the buffer",
        "If this._writableState.decodeStrings is true, which it should be, `chunk`\n  will be just a buffer, which is what we want.\n\n  Node.js 'stream' API calls _transform and _flush.\n  In Splitter, both _flush and _transform call flushBuffer, which does most of\n  the downstream pushing, but _flush also pushes the final chunk if there is\n  one.",
        "chunk is actually going to be a Buffer",
        "chunk will be a Buffer, and either one is fine by JSON.parse, but to",
        "appease TypeScript, type assert that it's <any>",
        "Returns one of the seven primitive JSON schema types, or 'undefined':\n  array, boolean, integer, number, null, object, string, undefined\n(Except it does not actually ever return 'integer'.)",
        "TODO: Ensure that the only other possibilities are 'object', 'boolean', 'number', and 'string'",
        "Return the schema in schemas such that schema.type == `type`, or `undefined`\nif no schema matches.",
        "TODO: handle this case. What should I do with an array of values like",
        "`['laugh', 100, undefined]`? change all of the schemas to optional?",
        "schemas.forEach(schema => schema.optional = true);",
        "find a pre-existing schema, if there is one",
        "if the schema is unset, there's no precedent, so it's easy",
        "merge into existing schema.",
        "only the nested types, object and array (below), require merging.",
        "should we actually do the `hasOwnProperty` check?",
        "throw new Error('array merge not yet supported');",
        "otherwise, nothing needs to be done.",
        "The given readable stream should emit 'data' events that are native Javascript\nvalues/objects.",
        "split input on newlines and parse each one as JSON"
    ],
    "docstrings": [],
    "functions": [
        "flushBuffer",
        "_transform",
        "_flush",
        "_transform",
        "valueType",
        "find",
        "union",
        "generalizeArray",
        "generalizeStream",
        "main"
    ],
    "classes": [
        "Splitter",
        "JSONParser"
    ]
}