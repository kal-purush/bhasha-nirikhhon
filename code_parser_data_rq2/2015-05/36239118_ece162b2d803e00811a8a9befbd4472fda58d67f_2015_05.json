{
    "identifiers": [
        "Thenable",
        "BaseError",
        "Transform",
        "reader",
        "value",
        "ender",
        "error",
        "reason",
        "value",
        "error",
        "reason",
        "BaseError",
        "done",
        "value",
        "error",
        "value",
        "value",
        "value",
        "valuePromise",
        "writeDone",
        "writeDone",
        "error",
        "error",
        "error",
        "valuePromise",
        "writeDone",
        "writeDone",
        "reader",
        "value",
        "ender",
        "error",
        "ender",
        "ender",
        "err",
        "err",
        "err",
        "reader",
        "ender",
        "reason",
        "reason",
        "mapper",
        "value",
        "Stream",
        "output",
        "mapper",
        "output",
        "filterer",
        "value",
        "Stream",
        "output",
        "filterer",
        "output",
        "writable",
        "value",
        "writable",
        "value",
        "error",
        "writable",
        "error",
        "writable",
        "transformer",
        "Stream",
        "transformer",
        "output",
        "output",
        "writer",
        "loop",
        "writer",
        "v",
        "v",
        "v",
        "loop",
        "loop",
        "mapper",
        "value",
        "Stream",
        "input",
        "mapper",
        "input",
        "filterer",
        "value",
        "Stream",
        "input",
        "filterer",
        "input",
        "data",
        "Stream",
        "aborter",
        "error",
        "error",
        "stream",
        "error",
        "loop",
        "i",
        "data",
        "stream",
        "aborter",
        "stream",
        "data",
        "i",
        "loop",
        "aborter",
        "loop",
        "stream",
        "writer",
        "noop",
        "noop",
        "writer",
        "WriteAfterEndError",
        "writer",
        "writer",
        "writer",
        "fulfilled",
        "writer",
        "fulfilled",
        "eof",
        "writer",
        "writer",
        "writer",
        "Stream"
    ],
    "literals": [
        "\"use strict\"",
        "\"ts-promise\"",
        "\"assert\"",
        "\"./Transform\"",
        "\"WriteAfterEndError\"",
        "\"stream already ended\"",
        "\"eof\"",
        "\"cannot write void value, use end() instead\"",
        "\"already have a reader\""
    ],
    "variables": [
        "eof",
        "valuePromise",
        "writeDone",
        "valuePromise",
        "writeDone",
        "output",
        "output",
        "output",
        "loop",
        "input",
        "input",
        "stream",
        "i",
        "aborter",
        "loop",
        "writer",
        "writer",
        "writer",
        "fulfilled"
    ],
    "comments": [
        "<reference path=\"./typings/tsd.d.ts\" />",
        "TODO Update following doc comment when we decide to no longer allow stream",
        "end with void-promise.",
        "no-op",
        "Technically, we could allow this to signal EOF or allow void",
        "values to be written, but it's a common programming error to",
        "forget to return a value, so let's be explicit.",
        "NOTE: This behaviour may change in the future",
        "TODO Experimental",
        "TODO Experimental",
        "TODO Experimental",
        "TODO Or `writer: (write, end) => ...`-style callback?",
        "TODO if write/end return an error, promise is rejected, but stream",
        "may still be open. Not ideal for an 'easy' helper like writeEach()",
        "TODO Experimental",
        "TODO Not sure whether a 'reverse' function confuses more than it helps",
        "TODO Experimental",
        "TODO Not sure whether a 'reverse' function confuses more than it helps",
        "TODO: consider rewriting to use .forEach()",
        "TODO",
        "- Explode?",
        "- maybe only have `static into<T>(writable, data): Promise<void>`?",
        "- allow passing an end-callback?",
        "- expect people to listen for ended()?",
        "If aborted, abort all writers, end reader",
        "TODO: wait for _readBusy to be done before calling _ender?",
        "Defeats the purpose of a fast cancellation, but violates the",
        "'contract' of not calling one of the callbacks before the",
        "previous one has finished.",
        "TODO: better way to handle this?",
        "If waiting for a reader/ender, wait some more or handle it",
        "TODO: prevent unnecessary pumps",
        "If ended, reject any pending and future writes with an error",
        "Wait until both written value(s) and a reader are available",
        "write(), end() and forEach() will pump us again",
        "Wait until written value is available",
        "TODO: prevent unnecessary pumps",
        "Determine whether we should call the reader or the ender",
        "EOF or error"
    ],
    "docstrings": [
        "* Promise-based object stream with seamless support for back-pressure and error\n * handling, written in Typescript.\n *\n * Copyright (C) 2015 Martin Poelstra\n * License: MIT",
        "* Thrown when writing to an already-ended stream.\n *\n * Note that a stream can be ended by calling `end()`, but also by writing a\n * rejected promise, or a void-promise.",
        "* Special internal value to indicate 'normal' stream end.",
        "* Written value-promise and a function to resolve the corresponding `write()`\n * call's return promise.",
        "* Promise for value passed to `write()`",
        "* Resolver `write()`'s returned promise",
        "* Object stream with seamless support for backpressure, ending and error\n * handling.",
        "* Writers waiting for `_reader` to retrieve and process their value.",
        "* Read handler that is called for every written value, as set by\n\t * `forEach()`.",
        "* End handler that is called when the stream is ended or aborted, as set by\n\t * `forEach()`. Note that `forEach()` installs a default handler if the user\n\t * did not supply one.\n\t * In case of an aborted stream, this property is unset by `_pump()` after\n\t * it has been called.",
        "* When a written value is being processed by the `_reader`, this property\n\t * is set to a promise that resolves when the reader's returned Thenable is\n\t * resolved (or rejected).",
        "* Set to the error passed to `end()` (or the special value `eof`) when the\n\t * stream was ended by writer, but the operation is not yet confirmed by\n\t * the `_ender`. Unset when `_ended` is set.",
        "* Set to the error passed to `end()` (or the special value `eof`) when the\n\t * stream has ended, and the operation was confirmed by the `_ender`.",
        "* Set to a rejected promise when the stream is explicitly `abort()`'ed.",
        "* Resolved after end-of-stream has been processed by `_ender`.\n\t * TODO Experimental",
        "* Write value (or promise for value) to stream.\n\t *\n\t * Writer is blocked until the value is read by the read handler passed to\n\t * `forEach()`, and the value returned by that read handler is resolved.\n\t *\n\t * It is an error to write an `undefined` value (as this is a common\n\t * programming error).\n\t *\n\t * When the written value is a promise that resolves to a rejection, the\n\t * stream will be ended with that error and any further writes will lead to\n\t * a `WriteAfterEndError`.\n\t *\n\t * When the written value is a promise that resolves to `undefined` this is\n\t * equivalent to calling end().\n\t * NOTE: Ending by writing a void-promise may be subject to change.\n\t *\n\t * If the read handler throws an error or returns a rejected promise, the\n\t * promise returned by `write()` will be rejected. It is still possible to\n\t * write another value after that, or e.g. `end()` the stream with an error.\n\t *\n\t * @param value Value to write, or promise for it\n\t * @return Void-promise that resolves when value was processed by reader",
        "* End the stream, optionally passing an error.\n\t *\n\t * Any pending writes first still be processed by the reader passed to\n\t * `forEach()` before passing the end-of-stream to its end handler.\n\t *\n\t * The returned promise will resolve after the end handler has finished\n\t * processing. It is rejected if the read handler throws an error or returns\n\t * a rejected Thenable.\n\t *\n\t * All calls to `write()` after `end()` will be rejected with a\n\t * `WriteAfterEndError`.\n\t *\n\t * Note that `write()`ing a rejected promise will also end the stream, and\n\t * a subsequent call to `end()` will also return a `WriteAfterEndError`\n\t * rejection.\n\t *\n\t * @param  error Optional Error to pass to `forEach()` end handler\n\t * @return Void-promise that resolves when end-handler has processed the\n\t *         end-of-stream",
        "* Read all values from stream, optionally waiting for explicit stream end.\n\t *\n\t * `reader` will be called for every written value, `ender` will be called\n\t * once when the stream has ended.\n\t *\n\t * `ender` receives the error in case the stream was `end()`'ed with and\n\t * error or `abort()`'ed, or `undefined` in case of a normal stream end.\n\t *\n\t * Both callbacks can return a promise to indicate when the value (or\n\t * end-of-stream condition) has been completely processed. This ensures that\n\t * a fast writer can never overload a slow reader, and is called\n\t * 'backpressure'.\n\t *\n\t * The corresponding `write()` or `end()` operation is blocked until the\n\t * value returned from the callback is resolved. If the callback throws an\n\t * error or the returned promise resolves to a rejection, the promise\n\t * returned by write call will be rejected with it.\n\t *\n\t * It is guaranteed that the reader is never called again before its\n\t * previously returned promise is resolved/rejected.\n\t * The ender will also typically be called after all reads have finished,\n\t * but may be called while a read is still 'pending' when `abort()` is\n\t * called.\n\t *\n\t * If no `ender` is given, a default end handler is installed that returns\n\t * any stream end errors to the writer.\n\t *\n\t * @param reader Callback called with every written value\n\t * @param ender  Callback called when stream ended",
        "* Abort the stream with an error.\n\t * This will abort any pending and future writes, and signal stream end with\n\t * this error to `forEach()`'s end handler.\n\t *\n\t * If the stream's end handler has already been called, the abort is\n\t * ignored.",
        "* Run all input values through a mapping callback, which must produce a new\n\t * value (or promise for a value), similar to e.g. `Array`'s `map()`.\n\t *\n\t * Stream end in the input stream (normal or with error) will be passed to\n\t * the returned stream.\n\t *\n\t * @param mapper Callback which receives each value from this stream, and\n\t *               must produce a new value (or promise for a value).\n\t * @return New stream with mapped values.",
        "* Run all input values through a filtering callback. If the filter callback\n\t * returns a truthy value (or a promise for a truthy value), the input value\n\t * is written to the output stream, otherwise it is ignored.\n\t * Similar to e.g. `Array`'s `filter()`.\n\t *\n\t * Stream end in the input stream (normal or with error) will be passed to\n\t * the returned stream.\n\t *\n\t * @param filterer Callback which receives each value from this stream,\n\t *                 input value is written to output if callback returns a\n\t *                 (promise for) a truthy value.\n\t * @return New stream with filtered values.",
        "* Read all values and end-of-stream from this stream, writing them to\n\t * `writable`.\n\t *\n\t * @param  writable Destination stream\n\t * @return The stream passed in, for easy chaining",
        "* Return a Stream for all values in the input array.\n\t *\n\t * If a reader returns an error, the stream will be aborted with that error.\n\t * TODO: this behavior may be subject to change\n\t *\n\t * @param data Input array\n\t * @return Stream for all values in the input array",
        "* Bound callback to be passed as handlers to Promise.then()",
        "* Pump written values to `_reader` and `_ender`, resolve results of\n\t * `write()` and `end()`."
    ],
    "functions": [
        "noop",
        "write",
        "end",
        "forEach",
        "abort",
        "ended",
        "pipe",
        "transform",
        "writeEach",
        "mappedBy",
        "filterBy",
        "_pump"
    ],
    "classes": [
        "WriteAfterEndError",
        "Stream"
    ]
}