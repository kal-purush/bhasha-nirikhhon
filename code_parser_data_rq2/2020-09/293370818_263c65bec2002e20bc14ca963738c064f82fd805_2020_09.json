{
    "identifiers": [
        "numpy",
        "np",
        "utils",
        "get_msb",
        "clear_k_bit",
        "bit_count",
        "kth_bit_set",
        "a1",
        "a2",
        "a1",
        "a2",
        "n",
        "n",
        "get_msb",
        "p",
        "p",
        "p",
        "mx",
        "clear_k_bit",
        "p1",
        "f1",
        "f2",
        "bit_count",
        "f1",
        "bit_count",
        "f2",
        "f1",
        "f2",
        "f1",
        "f2",
        "f1",
        "f2",
        "make_xtime_table",
        "f1",
        "f2",
        "k",
        "kth_bit_set",
        "k",
        "f2",
        "ff_add",
        "product",
        "xtime_table",
        "k",
        "product",
        "f1",
        "f2",
        "f1",
        "f1",
        "f2",
        "xtime",
        "p",
        "p",
        "idx",
        "f2",
        "xtime_table",
        "np",
        "array",
        "s",
        "col",
        "s",
        "col",
        "mix_column",
        "s_col",
        "s_p_col",
        "col",
        "col",
        "i",
        "ax",
        "i",
        "transformed_bytes",
        "append",
        "ff_add",
        "ff_add",
        "ff_multiply",
        "s0",
        "a0",
        "ff_multiply",
        "s1",
        "a1",
        "ff_add",
        "ff_multiply",
        "s2",
        "a2",
        "ff_multiply",
        "s3",
        "a3",
        "transformed_bytes"
    ],
    "literals": [],
    "variables": [
        "mx",
        "p",
        "p1",
        "f1",
        "f2",
        "f1",
        "xtime_table",
        "product",
        "product",
        "xtime_table",
        "xtime_table",
        "p",
        "idx",
        "p",
        "xtime_table",
        "idx",
        "ax",
        "s_col",
        "s_p_col",
        "s",
        "col",
        "transformed_bytes",
        "s0",
        "s1",
        "s2",
        "s3",
        "a0",
        "a1",
        "a2",
        "a3"
    ],
    "comments": [
        "FF addition and subtraction with XOR",
        "Multiply n by x (ie 00000010 or 02)",
        "If the MSB is the 8th bit or lower",
        "Return because we're already reduced.",
        "Reduce by XOR the polynomial m(x) = x^8 + x^4 + x^3 + x + 1",
        "Drop the 9th bit and return",
        "Optimized by choosing the factor with fewer bytes as multiplier",
        "Make the table with all the xtime values for f1",
        "Check each bit of f2",
        "If k bit of f2 is set, that represent a polynomial value of x^k",
        "Add it to the product",
        "Return the product",
        "Xtime table will have 8 elements, corresponding with 8 bits",
        "First element is f1 multiplicand",
        "Keep track of where to place the xtime result in the table",
        "Compute Xtime until f2 multiplier can't be divided anymore",
        "Compute xtime of number",
        "Add it to table at correct index",
        "Increment index",
        "Divide f2",
        "Return the xtime table",
        "a(x) = {03}x^3 + {01}x^2 + {01}x + {02}",
        "Calculate value for each element in s column and return s' column",
        "Replace s column with s' column",
        "Unpack the state column values",
        "We need to calculate each element in col using all elements in col",
        "s'(x) = a(x) x s(x)",
        "a0, a1, a2, a3 = map(int, self.ax[i])"
    ],
    "docstrings": [
        "\"\"\"Performs finite field addition of two integers.\n\n        If a1 and a2 aren't integers, try to cast into base16 integer.\n        Addition of two elements in a finite field is achieved by adding\n        the coefficients for the corresponding powers in the polynomial for\n        the two elements. Addition can be performed with XOR (i.e. modulo 2).\n        Identical to polynomial subtraction.\n\n        Example\n        -------\n        x6 is the same as x^6.\n        (x6 + x4 + x2 + x + 1) + (x7 + x + 1) = x7 + x6 + x4 + x2\n        {01010111}             + {10000011}   = {11010100}\n        {0x57}               XOR {0x83}       =  {0xd4}\n\n        Parameters\n        ----------\n        :param a1: addend 1\n        :param a2: addend 2\n        :return: a1 XOR a2\n        \"\"\"",
        "\"\"\"Performs finite field multiplication by x.\n\n        Multiplying the binary polynomial (b) by polynomial x results in\n        *(xn == x^n)\n        b7x8 + b6x7 + b5x6 + b4x5 + b3x4 + b2x3 + b1x2 + b0x\n\n        The result of x * b(x) is obtained by reducing the above result modulo x.\n        If b7 = 0, the result is already reduced. If b7 = 1, the result must be XOR\n        with polynomial m(x).\n\n        It  follows  that  multiplication  by  x  (i.e.,{00000010}  or  {02})  can\n        be  implemented  at  the  byte  level  as  a  left  shift  and  a  subsequent\n        conditional  bitwise  XOR  with  {1b}\n\n        Multiplication by higher powers of x can be implemented by repeated application\n        of xtime(). By adding intermediate results, multiplication by any constant can\n        be implemented.\n\n        :param n: binary polynomial to be multiplied by x\n        :return: n(x) * x\n        \"\"\"",
        "\"\"\"Performs finite filed multiplication between two numbers.\n\n        Multiplication in GF(2^8) corresponds  with  the multiplication of polynomials\n        modulo an irreducible polynomial of degree 8 (i.e. mx(x)). This can be implemented\n        using xtime() and adding intermediate results.\n\n        :param f1: factor1\n        :param f2: factor2\n        :return: f1 * f2 GF(2^8)\n        \"\"\"",
        "\"\"\"Creates a table of xtime results.\n\n        When multiplying by higher powers of x, the product is found by\n        adding together intermediate xtime results.\n\n        :param f1: factor\n        :param f2: factor\n        :return: a list of xtime results\n        \"\"\"",
        "\"\"\"\n\n        sub_bytes() is a non-linear byte substitution that operates\n        independently on each byte of the State using a substitution\n        table (S-box).\n\n        This S-box, which is invertible, is constructed by composing\n        two transformations:\n            1. Take the multiplicative inverse of GF(2^8); the element\n            {00} is mapped to itself.\n            2. Apply the following affine transformation (over GF(2)):\n                * See FIPS197\n        :return:\n        \"\"\"",
        "\"\"\"\n\n        The bytes in the last three rows of the state are cyclically shifted\n        over different number of bytes (offsets). The first row, r = 0, is not\n        shifted.\n\n        :return:\n        \"\"\"",
        "\"\"\"Transforms the state matrix column-by-column.\n\n        The mix_columns() transformation operates on the State\n        column-by-column, treating each column as a four-term\n        polynomial.\n\n        Columns are considered as polynomial over\n        GF(2^8) and multiplied modulo x^4 + 1 with a(x) where\n        a(x) = {03}x^3 + {01}x^2 + {01}x + {02}\n\n        This can be seen as matrix multiplication; let\n            s'(x) = a(x) ffmult s(x)\n\n        :param s: 4 x 4 state matrix\n        :return: None, modifies original matrix to be s'(x)\n        \"\"\"",
        "\"\"\"Transforms each column item by multiply modulo x4 + 1 with a(x)\n\n        This is a helper method for mix_columns(). The arithmetic\n        is done here. For each item in the column, calculate the\n        transformed value by multiplying each column element by\n        each row element of a(x). The column elements can be\n        thought of as row index for a(x).\n\n        :param col: a list of state column values\n        :return: a list of transformed state column values\n        \"\"\"",
        "\"\"\"\n\n        A Round Key is added to the State by a simple bitwise XOR operation.\n        Each Round Key consists of Nb words from the key schedule. Those Nb words\n        are each added into the columns of the state.\n\n        :return:\n        \"\"\"",
        "\"\"\"\n\n        Takes four-byte input word and applies the S-box to each\n        of the four bytes to produce an output word.\n\n        :return:\n        \"\"\"",
        "\"\"\"\n\n        Takes a word[a0, a1, a2, a3] as input, performs a cyclic permutation,\n        then returns the word[a1, a2, a3, a0]\n\n        :return:\n        \"\"\""
    ],
    "functions": [
        "ff_add",
        "xtime",
        "ff_multiply",
        "make_xtime_table",
        "sub_bytes",
        "shift_rows",
        "mix_columns",
        "mix_column",
        "add_round_key",
        "inv_sub_bytes",
        "inv_shift_rows",
        "inv_mix_columns",
        "sub_word",
        "rot_word"
    ],
    "classes": [
        "PyAES"
    ]
}