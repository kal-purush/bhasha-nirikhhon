{
    "identifiers": [
        "SelectableValue",
        "Observable",
        "LiveChannelScope",
        "msg",
        "LiveChannelConnectionState",
        "msg",
        "path"
    ],
    "literals": [
        "'./select'",
        "'rxjs'",
        "'ds'",
        "'plugin'",
        "'grafana'",
        "string",
        "string",
        "string",
        "'pending'",
        "'connected'",
        "'disconnected'",
        "'shutdown'",
        "'invalid'",
        "string",
        "'status'",
        "'message'",
        "'join'",
        "'leave'",
        "string",
        "string",
        "string",
        "string"
    ],
    "variables": [],
    "comments": [
        "namespace = data source ID",
        "namespace = plugin name (singleton works for apps too)",
        "namespace = feature",
        "convert the raw stream message into a message that should be broadcast",
        "The connection is not yet established",
        "Connected to the channel",
        "Disconnected from the channel.  The channel will reconnect when possible",
        "Was at some point connected, and will not try to reconnect",
        "Channel configuraiton was invalid and will not connect",
        "The fully qualified channel id: ${scope}/${namespace}/${path}",
        "The scope for this channel",
        "datasourceId/plugin name/feature depending on scope",
        "additional qualifier",
        "Unix timestamp for when the channel connected",
        "Static definition of the channel definition.  This may describe the channel usage"
    ],
    "docstrings": [
        "* The channel id is defined as:\n *\n *   ${scope}/${namespace}/${path}\n *\n * The scope drives how the namespace is used and controlled",
        "* @experimental",
        "* The path definition.  either static, or it may contain variables identifed with {varname}",
        "* An optional description for the channel",
        "* When variables exist, this list will identify each one",
        "* The channel keeps track of who else is connected to the same channel",
        "* This method will be defined if it is possible to publish in this channel.\n   * The function will return true/false if the current user can publish",
        "* @experimental",
        "* {scope}/{namespace}/{path}",
        "* unix millies timestamp for the last status change",
        "* flag if the channel is activly connected to the channel.\n   * This may be false while the connections get established or if the network is lost\n   * As long as the `shutdown` flag is not set, the connection will try to reestablish",
        "* The last error.\n   *\n   * This will remain in the status until a new message is succesfully recieved from the channel",
        "* @experimental",
        "* @experimental",
        "* @experimental",
        "* Watch all events in this channel",
        "* For channels that support presense, this will request the current state from the server.\n   *\n   * Join and leave messages will be sent to the open stream",
        "* Write a message into the channel\n   *\n   * NOTE: This feature is supported by a limited set of channels",
        "* This will close and terminate this channel",
        "* @experimental",
        "* Get the channel handler for the path, or throw an error if invalid",
        "* Return a list of supported channels"
    ],
    "functions": [],
    "classes": []
}