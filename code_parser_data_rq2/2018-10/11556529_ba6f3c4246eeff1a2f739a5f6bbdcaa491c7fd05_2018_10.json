{
    "identifiers": [
        "java",
        "lang",
        "java",
        "lang",
        "java",
        "util",
        "Objects",
        "java",
        "util",
        "concurrent",
        "atomic",
        "AtomicInteger",
        "java",
        "util",
        "concurrent",
        "atomic",
        "AtomicLong",
        "java",
        "util",
        "Supplier",
        "threadLocalHashCode",
        "nextHashCode",
        "nextHashCode",
        "HASH_INCREMENT",
        "lastIdentityCode",
        "threadLocalIdentity",
        "lastIdentityCode",
        "getAndIncrement",
        "nextHashCode",
        "getAndAdd",
        "HASH_INCREMENT",
        "supplier",
        "supplier",
        "t",
        "currentThread",
        "getMap",
        "t",
        "e",
        "getEntry",
        "e",
        "SuppressWarnings",
        "result",
        "e",
        "value",
        "result",
        "setInitialValue",
        "value",
        "initialValue",
        "t",
        "currentThread",
        "getMap",
        "t",
        "value",
        "createMap",
        "t",
        "value",
        "value",
        "value",
        "t",
        "currentThread",
        "getMap",
        "t",
        "value",
        "createMap",
        "t",
        "value",
        "m",
        "getMap",
        "currentThread",
        "m",
        "m",
        "remove",
        "t",
        "t",
        "threadLocals",
        "t",
        "firstValue",
        "t",
        "threadLocals",
        "firstValue",
        "parentMap",
        "parentMap",
        "parentValue",
        "supplier",
        "supplier",
        "supplier",
        "Objects",
        "requireNonNull",
        "supplier",
        "Override",
        "supplier",
        "get",
        "value",
        "threadLocalIdentity",
        "cachedThreadLocalHashCode",
        "isDead",
        "k",
        "v",
        "k",
        "entryQueue",
        "value",
        "v",
        "threadLocalIdentity",
        "k",
        "threadLocalIdentity",
        "cachedThreadLocalHashCode",
        "k",
        "threadLocalHashCode",
        "isDead",
        "isDead",
        "isEnqueued",
        "entryQueue",
        "INITIAL_CAPACITY",
        "table",
        "size",
        "threshold",
        "len",
        "threshold",
        "len",
        "i",
        "len",
        "i",
        "len",
        "i",
        "i",
        "len",
        "i",
        "i",
        "len",
        "firstKey",
        "firstValue",
        "table",
        "INITIAL_CAPACITY",
        "i",
        "firstKey",
        "threadLocalHashCode",
        "INITIAL_CAPACITY",
        "table",
        "i",
        "firstKey",
        "firstValue",
        "size",
        "setThreshold",
        "INITIAL_CAPACITY",
        "parentMap",
        "parentTable",
        "parentMap",
        "table",
        "len",
        "parentTable",
        "length",
        "setThreshold",
        "len",
        "table",
        "len",
        "j",
        "j",
        "len",
        "j",
        "e",
        "parentTable",
        "j",
        "e",
        "SuppressWarnings",
        "key",
        "e",
        "get",
        "key",
        "value",
        "key",
        "childValue",
        "e",
        "value",
        "c",
        "key",
        "value",
        "h",
        "key",
        "threadLocalHashCode",
        "len",
        "table",
        "h",
        "h",
        "nextIndex",
        "h",
        "len",
        "table",
        "h",
        "c",
        "size",
        "key",
        "i",
        "key",
        "threadLocalHashCode",
        "table",
        "length",
        "e",
        "table",
        "i",
        "e",
        "e",
        "isDead",
        "e",
        "threadLocalIdentity",
        "key",
        "threadLocalIdentity",
        "e",
        "getEntryAfterMiss",
        "key",
        "i",
        "e",
        "key",
        "i",
        "e",
        "tab",
        "table",
        "len",
        "tab",
        "length",
        "e",
        "e",
        "isDead",
        "e",
        "threadLocalIdentity",
        "key",
        "threadLocalIdentity",
        "e",
        "e",
        "isDead",
        "expungeStaleEntry",
        "i",
        "i",
        "nextIndex",
        "i",
        "len",
        "e",
        "tab",
        "i",
        "key",
        "value",
        "tab",
        "table",
        "len",
        "tab",
        "length",
        "i",
        "key",
        "threadLocalHashCode",
        "len",
        "e",
        "tab",
        "i",
        "e",
        "e",
        "tab",
        "i",
        "nextIndex",
        "i",
        "len",
        "e",
        "isDead",
        "e",
        "threadLocalIdentity",
        "key",
        "threadLocalIdentity",
        "e",
        "value",
        "value",
        "e",
        "isDead",
        "replaceStaleEntry",
        "key",
        "value",
        "i",
        "tab",
        "i",
        "key",
        "value",
        "sz",
        "size",
        "cleanSomeSlots",
        "i",
        "sz",
        "sz",
        "threshold",
        "rehash",
        "key",
        "tab",
        "table",
        "len",
        "tab",
        "length",
        "i",
        "key",
        "threadLocalHashCode",
        "len",
        "e",
        "tab",
        "i",
        "e",
        "e",
        "tab",
        "i",
        "nextIndex",
        "i",
        "len",
        "e",
        "threadLocalIdentity",
        "key",
        "threadLocalIdentity",
        "e",
        "clear",
        "expungeStaleEntry",
        "i",
        "key",
        "value",
        "staleSlot",
        "tab",
        "table",
        "len",
        "tab",
        "length",
        "e",
        "slotToExpunge",
        "staleSlot",
        "i",
        "prevIndex",
        "staleSlot",
        "len",
        "e",
        "tab",
        "i",
        "i",
        "prevIndex",
        "i",
        "len",
        "e",
        "isDead",
        "slotToExpunge",
        "i",
        "i",
        "nextIndex",
        "staleSlot",
        "len",
        "e",
        "tab",
        "i",
        "i",
        "nextIndex",
        "i",
        "len",
        "e",
        "threadLocalIdentity",
        "key",
        "threadLocalIdentity",
        "e",
        "value",
        "value",
        "tab",
        "i",
        "tab",
        "staleSlot",
        "tab",
        "staleSlot",
        "e",
        "slotToExpunge",
        "staleSlot",
        "slotToExpunge",
        "i",
        "cleanSomeSlots",
        "expungeStaleEntry",
        "slotToExpunge",
        "len",
        "e",
        "isDead",
        "slotToExpunge",
        "staleSlot",
        "slotToExpunge",
        "i",
        "tab",
        "staleSlot",
        "value",
        "tab",
        "staleSlot",
        "threadLocalIdentity",
        "tab",
        "staleSlot",
        "key",
        "value",
        "slotToExpunge",
        "staleSlot",
        "cleanSomeSlots",
        "expungeStaleEntry",
        "slotToExpunge",
        "len",
        "staleSlot",
        "tab",
        "table",
        "len",
        "tab",
        "length",
        "tab",
        "staleSlot",
        "value",
        "tab",
        "staleSlot",
        "threadLocalIdentity",
        "tab",
        "staleSlot",
        "size",
        "e",
        "entryQueue",
        "poll",
        "e",
        "e",
        "isDead",
        "i",
        "i",
        "nextIndex",
        "staleSlot",
        "len",
        "e",
        "tab",
        "i",
        "i",
        "nextIndex",
        "i",
        "len",
        "e",
        "isDead",
        "e",
        "value",
        "e",
        "threadLocalIdentity",
        "tab",
        "i",
        "size",
        "h",
        "e",
        "cachedThreadLocalHashCode",
        "len",
        "h",
        "i",
        "tab",
        "i",
        "tab",
        "h",
        "h",
        "nextIndex",
        "h",
        "len",
        "tab",
        "h",
        "e",
        "i",
        "i",
        "n",
        "removed",
        "tab",
        "table",
        "len",
        "tab",
        "length",
        "i",
        "nextIndex",
        "i",
        "len",
        "e",
        "tab",
        "i",
        "e",
        "e",
        "isDead",
        "n",
        "len",
        "removed",
        "i",
        "expungeStaleEntry",
        "i",
        "n",
        "removed",
        "expungeStaleEntries",
        "size",
        "threshold",
        "threshold",
        "resize",
        "e",
        "entryQueue",
        "poll",
        "e",
        "e",
        "isDead",
        "oldTab",
        "table",
        "oldLen",
        "oldTab",
        "length",
        "newLen",
        "oldLen",
        "newTab",
        "newLen",
        "count",
        "j",
        "j",
        "oldLen",
        "j",
        "e",
        "oldTab",
        "j",
        "e",
        "e",
        "isDead",
        "e",
        "value",
        "e",
        "threadLocalIdentity",
        "h",
        "e",
        "cachedThreadLocalHashCode",
        "newLen",
        "newTab",
        "h",
        "h",
        "nextIndex",
        "h",
        "newLen",
        "newTab",
        "h",
        "e",
        "count",
        "setThreshold",
        "newLen",
        "size",
        "count",
        "table",
        "newTab",
        "tab",
        "table",
        "len",
        "tab",
        "length",
        "j",
        "j",
        "len",
        "j",
        "e",
        "tab",
        "j",
        "e",
        "e",
        "isDead",
        "expungeStaleEntry",
        "j"
    ],
    "literals": [
        "\"unchecked\"",
        "\"unchecked\""
    ],
    "variables": [
        "supplier",
        "value",
        "threadLocalIdentity",
        "cachedThreadLocalHashCode",
        "isDead",
        "table",
        "threshold",
        "e",
        "i"
    ],
    "comments": [
        "Copyright 2018 Azul Systems, Inc. All Rights Reserved.",
        "Default to 0",
        "We don't use a fast path as with get() because it is at",
        "least as common to use set() to create new entries as",
        "it is to replace existing ones, in which case, a fast",
        "path would fail more often than not.",
        "Back up to check for prior stale entry in current run.",
        "We clean out whole runs at a time to avoid continual",
        "incremental rehashing due to garbage collector freeing",
        "up refs in bunches (i.e., whenever the collector runs).",
        "Find either the key or trailing null slot of run, whichever",
        "occurs first",
        "If we find key, then we need to swap it",
        "with the stale entry to maintain hash table order.",
        "The newly stale slot, or any other stale slot",
        "encountered above it, can then be sent to expungeStaleEntry",
        "to remove or rehash all of the other entries in run.",
        "Start expunge at preceding stale entry if it exists",
        "If we didn't find stale entry on backward scan, the",
        "first stale entry seen while scanning for key is the",
        "first still present in the run.",
        "If key not found, put new entry in stale slot",
        "If there are any other stale entries in run, expunge them",
        "expunge entry at staleSlot",
        "Take this opportunity to clean one queue entry",
        "Rehash until we encounter null",
        "Unlike Knuth 6.4 Algorithm R, we must scan until",
        "null because multiple entries could have been stale.",
        "Use lower threshold for doubling to avoid hysteresis",
        "Take this opportunity to clean up the queue.",
        "Help the GC"
    ],
    "docstrings": [
        "* Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.",
        "* This class provides thread-local variables.  These variables differ from\n * their normal counterparts in that each thread that accesses one (via its\n * {@code get} or {@code set} method) has its own, independently initialized\n * copy of the variable.  {@code ThreadLocal} instances are typically private\n * static fields in classes that wish to associate state with a thread (e.g.,\n * a user ID or Transaction ID).\n *\n * <p>For example, the class below generates unique identifiers local to each\n * thread.\n * A thread's id is assigned the first time it invokes {@code ThreadId.get()}\n * and remains unchanged on subsequent calls.\n * <pre>\n * import java.util.concurrent.atomic.AtomicInteger;\n *\n * public class ThreadId {\n *     // Atomic integer containing the next thread ID to be assigned\n *     private static final AtomicInteger nextId = new AtomicInteger(0);\n *\n *     // Thread local variable containing each thread's ID\n *     private static final ThreadLocal&lt;Integer&gt; threadId =\n *         new ThreadLocal&lt;Integer&gt;() {\n *             &#64;Override protected Integer initialValue() {\n *                 return nextId.getAndIncrement();\n *         }\n *     };\n *\n *     // Returns the current thread's unique ID, assigning it if necessary\n *     public static int get() {\n *         return threadId.get();\n *     }\n * }\n * </pre>\n * <p>Each thread holds an implicit reference to its copy of a thread-local\n * variable as long as the thread is alive and the {@code ThreadLocal}\n * instance is accessible; after a thread goes away, all of its copies of\n * thread-local instances are subject to garbage collection (unless other\n * references to these copies exist).\n *\n * @author  Josh Bloch and Doug Lea\n * @since   1.2",
        "* ThreadLocals rely on per-thread linear-probe hash maps attached\n     * to each thread (Thread.threadLocals and\n     * inheritableThreadLocals).  The ThreadLocal objects act as keys,\n     * searched via threadLocalHashCode.  This is a custom hash code\n     * (useful only within ThreadLocalMaps) that eliminates collisions\n     * in the common case where consecutively constructed ThreadLocals\n     * are used by the same threads, while remaining well-behaved in\n     * less common cases.",
        "* The next hash code to be given out. Updated atomically. Starts at\n     * zero.",
        "* The difference between successively generated hash codes - turns\n     * implicit sequential thread-local IDs into near-optimally spread\n     * multiplicative hash values for power-of-two-sized tables.",
        "* For Zing, each ThreadLocal is given a unique Long identifier,\n     * It relies on the 64 bit identity long not overflowing, but\n     * even if ThreadLocals were created as fast as possible, and even \n     * if AtomicLong.getAndIncrement() took only 1/4 of a nanosecond, it would take 136 \n     * years for an overflow to happen and for an identity long to repeat.\n     * the need for this is we would want to reduce the usage\n     * of ThreadLocalMap.Entry.get() as much as possible. Instead of comparing key versus\n     * Entry.get() we compare the threadLocalIdentity with cached threadLocalIdentity in Entry\n     * for equality test.",
        "* Returns the next hash code.",
        "* Returns the current thread's \"initial value\" for this\n     * thread-local variable.  This method will be invoked the first\n     * time a thread accesses the variable with the {@link #get}\n     * method, unless the thread previously invoked the {@link #set}\n     * method, in which case the {@code initialValue} method will not\n     * be invoked for the thread.  Normally, this method is invoked at\n     * most once per thread, but it may be invoked again in case of\n     * subsequent invocations of {@link #remove} followed by {@link #get}.\n     *\n     * <p>This implementation simply returns {@code null}; if the\n     * programmer desires thread-local variables to have an initial\n     * value other than {@code null}, {@code ThreadLocal} must be\n     * subclassed, and this method overridden.  Typically, an\n     * anonymous inner class will be used.\n     *\n     * @return the initial value for this thread-local",
        "* Creates a thread local variable. The initial value of the variable is\n     * determined by invoking the {@code get} method on the {@code Supplier}.\n     *\n     * @param <S> the type of the thread local's value\n     * @param supplier the supplier to be used to determine the initial value\n     * @return a new thread local variable\n     * @throws NullPointerException if the specified supplier is null\n     * @since 1.8",
        "* Creates a thread local variable.\n     * @see #withInitial(java.util.function.Supplier)",
        "* Returns the value in the current thread's copy of this\n     * thread-local variable.  If the variable has no value for the\n     * current thread, it is first initialized to the value returned\n     * by an invocation of the {@link #initialValue} method.\n     *\n     * @return the current thread's value of this thread-local",
        "* Variant of set() to establish initialValue. Used instead\n     * of set() in case user has overridden the set() method.\n     *\n     * @return the initial value",
        "* Sets the current thread's copy of this thread-local variable\n     * to the specified value.  Most subclasses will have no need to\n     * override this method, relying solely on the {@link #initialValue}\n     * method to set the values of thread-locals.\n     *\n     * @param value the value to be stored in the current thread's copy of\n     *        this thread-local.",
        "* Removes the current thread's value for this thread-local\n     * variable.  If this thread-local variable is subsequently\n     * {@linkplain #get read} by the current thread, its value will be\n     * reinitialized by invoking its {@link #initialValue} method,\n     * unless its value is {@linkplain #set set} by the current thread\n     * in the interim.  This may result in multiple invocations of the\n     * {@code initialValue} method in the current thread.\n     *\n     * @since 1.5",
        "* Get the map associated with a ThreadLocal. Overridden in\n     * InheritableThreadLocal.\n     *\n     * @param  t the current thread\n     * @return the map",
        "* Create the map associated with a ThreadLocal. Overridden in\n     * InheritableThreadLocal.\n     *\n     * @param t the current thread\n     * @param firstValue value for the initial entry of the map",
        "* Factory method to create map of inherited thread locals.\n     * Designed to be called only from Thread constructor.\n     *\n     * @param  parentMap the map associated with parent thread\n     * @return a map containing the parent's inheritable bindings",
        "* Method childValue is visibly defined in subclass\n     * InheritableThreadLocal, but is internally defined here for the\n     * sake of providing createInheritedMap factory method without\n     * needing to subclass the map class in InheritableThreadLocal.\n     * This technique is preferable to the alternative of embedding\n     * instanceof tests in methods.",
        "* An extension of ThreadLocal that obtains its initial value from\n     * the specified {@code Supplier}.",
        "* ThreadLocalMap is a customized hash map suitable only for\n     * maintaining thread local values. No operations are exported\n     * outside of the ThreadLocal class. The class is package private to\n     * allow declaration of fields in class Thread.  To help deal with\n     * very large and long-lived usages, the hash table entries use\n     * WeakReferences for keys. However, since reference queues are not\n     * used, stale entries are guaranteed to be removed only when\n     * the table starts running out of space.",
        "* The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as \"stale entries\" in the code that follows.",
        "The value associated with this ThreadLocal.",
        "* The initial capacity -- MUST be a power of two.",
        "* The table, resized as necessary.\n         * table.length MUST always be a power of two.",
        "* The number of entries in the table.",
        "* The next size value at which to resize.",
        "* Set the resize threshold to maintain at worst a 2/3 load factor.",
        "* Increment i modulo len.",
        "* Decrement i modulo len.",
        "* Construct a new map initially containing (firstKey, firstValue).\n         * ThreadLocalMaps are constructed lazily, so we only create\n         * one when we have at least one entry to put in it.",
        "* Construct a new map including all Inheritable ThreadLocals\n         * from given parent map. Called only by createInheritedMap.\n         *\n         * @param parentMap the map associated with parent thread.",
        "* Get the entry associated with key.  This method\n         * itself handles only the fast path: a direct hit of existing\n         * key. It otherwise relays to getEntryAfterMiss.  This is\n         * designed to maximize performance for direct hits, in part\n         * by making this method readily inlinable.\n         *\n         * @param  key the thread local object\n         * @return the entry associated with key, or null if no such",
        "* Version of getEntry method for use when key is not found in\n         * its direct hash slot.\n         *\n         * @param  key the thread local object\n         * @param  i the table index for key's hash code\n         * @param  e the entry at table[i]\n         * @return the entry associated with key, or null if no such",
        "* Set the value associated with key.\n         *\n         * @param key the thread local object\n         * @param value the value to be set",
        "* Remove the entry for key.",
        "* Replace a stale entry encountered during a set operation\n         * with an entry for the specified key.  The value passed in\n         * the value parameter is stored in the entry, whether or not\n         * an entry already exists for the specified key.\n         *\n         * As a side effect, this method expunges all stale entries in the\n         * \"run\" containing the stale entry.  (A run is a sequence of entries\n         * between two null slots.)\n         *\n         * @param  key the key\n         * @param  value the value to be associated with key\n         * @param  staleSlot index of the first stale entry encountered while\n         *         searching for key.",
        "* Expunge a stale entry by rehashing any possibly colliding entries\n         * lying between staleSlot and the next null slot.  This also expunges\n         * any other stale entries encountered before the trailing null.  See\n         * Knuth, Section 6.4\n         *\n         * @param staleSlot index of slot known to have null key\n         * @return the index of the next null slot after staleSlot\n         * (all between staleSlot and this slot will have been checked\n         * for expunging).",
        "* Heuristically scan some cells looking for stale entries.\n         * This is invoked when either a new element is added, or\n         * another stale one has been expunged. It performs a\n         * logarithmic number of scans, as a balance between no\n         * scanning (fast but retains garbage) and a number of scans\n         * proportional to number of elements, that would find all\n         * garbage but would cause some insertions to take O(n) time.\n         *\n         * @param i a position known NOT to hold a stale entry. The\n         * scan starts at the element after i.\n         *\n         * @param n scan control: {@code log2(n)} cells are scanned,\n         * unless a stale entry is found, in which case\n         * {@code log2(table.length)-1} additional cells are scanned.\n         * When called from insertions, this parameter is the number\n         * of elements, but when from replaceStaleEntry, it is the\n         * table length. (Note: all this could be changed to be either\n         * more or less aggressive by weighting n instead of just\n         * using straight log n. But this version is simple, fast, and\n         * seems to work well.)\n         *\n         * @return true if any stale entries have been removed.",
        "* Re-pack and/or re-size the table. First scan the entire\n         * table removing stale entries. If this doesn't sufficiently\n         * shrink the size of the table, double the table size.",
        "* Double the capacity of the table.",
        "* Expunge all stale entries in the table."
    ],
    "functions": [
        "nextHashCode",
        "T",
        "initialValue",
        "withInitial",
        "ThreadLocal",
        "T",
        "get",
        "T",
        "setInitialValue",
        "remove",
        "ThreadLocalMap",
        "getMap",
        "createMap",
        "ThreadLocalMap",
        "createInheritedMap",
        "T",
        "childValue",
        "SuppliedThreadLocal",
        "T",
        "initialValue",
        "Entry",
        "isDead",
        "setThreshold",
        "nextIndex",
        "prevIndex",
        "ThreadLocalMap",
        "ThreadLocalMap",
        "Entry",
        "getEntry",
        "Entry",
        "getEntryAfterMiss",
        "remove",
        "replaceStaleEntry",
        "expungeStaleEntry",
        "cleanSomeSlots",
        "rehash",
        "resize",
        "expungeStaleEntries"
    ],
    "classes": [
        "ThreadLocal",
        "SuppliedThreadLocal",
        "ThreadLocalMap",
        "Entry"
    ]
}