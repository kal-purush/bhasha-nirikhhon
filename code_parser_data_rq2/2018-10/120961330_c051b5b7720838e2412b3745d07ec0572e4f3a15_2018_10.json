{
    "identifiers": [
        "io",
        "envoyproxy",
        "controlplane",
        "server",
        "callback",
        "com",
        "google",
        "common",
        "annotations",
        "VisibleForTesting",
        "com",
        "google",
        "common",
        "util",
        "concurrent",
        "ThreadFactoryBuilder",
        "envoy",
        "api",
        "v2",
        "Discovery",
        "io",
        "envoyproxy",
        "controlplane",
        "cache",
        "NodeGroup",
        "io",
        "envoyproxy",
        "controlplane",
        "cache",
        "Snapshot",
        "io",
        "envoyproxy",
        "controlplane",
        "cache",
        "SnapshotCache",
        "io",
        "envoyproxy",
        "controlplane",
        "server",
        "DiscoveryServerCallbacks",
        "java",
        "time",
        "Clock",
        "java",
        "time",
        "Instant",
        "java",
        "time",
        "temporal",
        "ChronoUnit",
        "java",
        "util",
        "LinkedHashSet",
        "java",
        "util",
        "java",
        "util",
        "java",
        "util",
        "concurrent",
        "ConcurrentHashMap",
        "java",
        "util",
        "concurrent",
        "Executors",
        "java",
        "util",
        "concurrent",
        "ScheduledExecutorService",
        "java",
        "util",
        "concurrent",
        "TimeUnit",
        "java",
        "util",
        "Consumer",
        "streamCount",
        "lastSeen",
        "snapshotCache",
        "nodeGroup",
        "clock",
        "collectorCallbacks",
        "collectAfterMillis",
        "snapshotStates",
        "groupByStream",
        "snapshotCache",
        "nodeGroup",
        "clock",
        "collectorCallbacks",
        "collectAfterMillis",
        "collectionIntervalMillis",
        "snapshotCache",
        "snapshotCache",
        "nodeGroup",
        "nodeGroup",
        "clock",
        "clock",
        "collectorCallbacks",
        "collectorCallbacks",
        "collectAfterMillis",
        "collectAfterMillis",
        "executorService",
        "Executors",
        "newSingleThreadScheduledExecutor",
        "setNameFormat",
        "build",
        "executorService",
        "scheduleAtFixedRate",
        "deleteUnreferenced",
        "clock",
        "collectionIntervalMillis",
        "collectionIntervalMillis",
        "TimeUnit",
        "MILLISECONDS",
        "Override",
        "streamId",
        "request",
        "groupIdentifier",
        "nodeGroup",
        "hash",
        "request",
        "getNode",
        "snapshotState",
        "snapshotStates",
        "computeIfAbsent",
        "groupIdentifier",
        "x",
        "snapshotState",
        "lastSeen",
        "clock",
        "instant",
        "groupByStream",
        "put",
        "streamId",
        "groupIdentifier",
        "snapshotState",
        "streamCount",
        "Override",
        "streamId",
        "typeUrl",
        "onStreamCloseHelper",
        "streamId",
        "Override",
        "streamId",
        "typeUrl",
        "error",
        "onStreamCloseHelper",
        "streamId",
        "VisibleForTesting",
        "clock",
        "toDelete",
        "entry",
        "snapshotStates",
        "entrySet",
        "entry",
        "getValue",
        "streamCount",
        "entry",
        "getValue",
        "lastSeen",
        "isBefore",
        "clock",
        "instant",
        "minus",
        "collectAfterMillis",
        "ChronoUnit",
        "MILLIS",
        "groupIdentifier",
        "entry",
        "getKey",
        "snapshotCache",
        "clearSnapshot",
        "groupIdentifier",
        "toDelete",
        "add",
        "groupIdentifier",
        "toDelete",
        "forEach",
        "group",
        "snapshotStates",
        "remove",
        "group",
        "collectorCallbacks",
        "forEach",
        "cb",
        "cb",
        "accept",
        "group",
        "streamId",
        "removed",
        "groupByStream",
        "remove",
        "streamId",
        "removed",
        "snapshotState",
        "snapshotStates",
        "get",
        "removed",
        "snapshotState",
        "streamCount",
        "snapshotState",
        "lastSeen",
        "clock",
        "instant"
    ],
    "literals": [
        "\"snapshot-gc-%d\""
    ],
    "variables": [
        "streamCount",
        "lastSeen",
        "snapshotCache",
        "nodeGroup",
        "clock",
        "collectorCallbacks",
        "collectAfterMillis"
    ],
    "comments": [
        "Keep track of snapshots to delete to avoid CME.",
        "clearSnapshot will do nothing and return false if there are any pending watches - this",
        "ensures that we don't actually remove a snapshot that's in use.",
        "This will happen if the stream closed before we received the first request."
    ],
    "docstrings": [
        "* Callback that keeps track of the number of streams associated with each node group and periodically clears\n * out {@link Snapshot}s from the cache that are no longer referenced by any streams.\n *\n * <p>Works by monitoring the stream to determine what group they belong to and keeps a running count as well\n * as when a request is seen that targets a given node group.\n *\n * <p>Every {@code collectionIntervalMillis} milliseconds a cleanup job runs which looks for snapshots with no\n * active streams that haven't been updated within the configured time frame. Checking the time since last update\n * is done to prevent snapshots from being prematurely removed from the cache. It ensures that a group must have\n * no active streams for {@code collectAfterMillis} milliseconds before being collected.\n *\n * <p>To be notified of snapshots that are removed, a set of callbacks may be provided which will be triggered\n * whenever a snapshot is removed from the cache. Any other callback which maintains state about the snapshots\n * that is cleaned up by one of these callbacks should be run *after* this callback. This helps ensure that\n * if state is cleaned up while a request in inbound, the request will be blocked by the lock in this callback\n * until collection finishes and the subsequent callbacks will see the new request come in after collection. If the\n * order is reversed, another callback might have seen the new request but the refcount here hasn't been incremented,\n * causing it to get cleaned up and wipe the state of the other callback even though we now have an active stream\n * for that group.",
        "* Creates the callback.\n   *\n   * @param snapshotCache the cache to evict snapshots from\n   * @param nodeGroup the node group used to map requests to groups\n   * @param clock system clock\n   * @param collectorCallbacks the callbacks to invoke when snapshot is collected\n   * @param collectAfterMillis how long a snapshot must be referenced for before being collected\n   * @param collectionIntervalMillis how often the collection background action should run"
    ],
    "functions": [
        "SnapshotCollectingCallback",
        "onStreamRequest",
        "onStreamClose",
        "onStreamCloseWithError",
        "deleteUnreferenced",
        "onStreamCloseHelper"
    ],
    "classes": [
        "SnapshotCollectingCallback",
        "SnapshotState"
    ]
}