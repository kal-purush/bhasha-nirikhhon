{
    "identifiers": [
        "TestWorkerTerminated",
        "Worker",
        "workerLockScript",
        "assertEquals",
        "workerLock1",
        "Worker",
        "workerLockScript",
        "assertEquals",
        "workerLock2",
        "Worker",
        "workerWaitScript",
        "assertEquals",
        "workerWait1",
        "Worker",
        "workerWaitScript",
        "assertEquals",
        "workerWait2",
        "Worker",
        "workerAsyncScript",
        "assertEquals",
        "workerAsync",
        "SharedStructType",
        "SharedType",
        "sharedObj",
        "Atomics",
        "Atomics",
        "Atomics",
        "workerLock1",
        "lock_msg",
        "workerWait1",
        "wait_msg",
        "assertEquals",
        "workerLock1",
        "assertEquals",
        "workerWait1",
        "workerAsync",
        "lock_msg",
        "assertEquals",
        "workerAsync",
        "workerAsync",
        "wait_msg",
        "assertEquals",
        "workerAsync",
        "AtomicsSynchronizationPrimitiveNumWaitersForTesting",
        "cv",
        "workerAsync",
        "count_msg",
        "assertEquals",
        "workerAsync",
        "workerLock2",
        "lock_msg",
        "workerWait2",
        "wait_msg",
        "assertEquals",
        "workerWait2",
        "AtomicsSynchronizationPrimitiveNumWaitersForTesting",
        "cv",
        "workerAsync",
        "Atomics",
        "cv_mutex",
        "sharedObj",
        "Atomics",
        "cv",
        "assertEquals",
        "workerLock1",
        "assertEquals",
        "workerLock2",
        "assertEquals",
        "workerLock2",
        "assertEquals",
        "workerWait1",
        "assertEquals",
        "workerWait2",
        "workerLock1",
        "workerLock2",
        "workerWait1",
        "workerWait2"
    ],
    "literals": [
        "onmessage = function(msg) {\n      let {mutex, sharedObj} = msg;\n      Atomics.Mutex.lock(mutex, function() {\n        postMessage('Lock acquired');\n        while(!Atomics.load(sharedObj, 'done')) {}\n      });\n      postMessage('Lock released');\n    };\n    postMessage('Worker started');",
        "onmessage = function(msg) {\n      let {cv_mutex, cv, shared_Obj} = msg;\n      Atomics.Mutex.lock(cv_mutex, function() {\n        postMessage('Waiting started');\n        Atomics.Condition.wait(cv, cv_mutex);\n      });\n      postMessage('Waiting done');\n    };\n    postMessage('Worker started');",
        "onmessage = function(msg) {\n      if (msg.type === 'lock') {\n        let {mutex, sharedObj} = msg;\n        for (let i = 0; i < 10; i++) {\n          Atomics.Mutex.lockAsync(mutex, async function() {})\n        }\n        postMessage('Lock waiters queued');\n      }\n      else if (msg.type === 'wait'){\n        let {cv_mutex, cv} = msg;\n        for (let i = 0; i < 10; i++) {\n          Atomics.Mutex.lockAsync(cv_mutex, async function() {\n            await Atomics.Condition.waitAsync(cv, cv_mutex);\n          })\n        }\n        // The waiters will be processed when the microtask queue is flushed\n        // after this task. This will queue both tasks and microtasks, so other\n        // incoming tasks might be handled before the the waitAsyncs are\n        // executed.\n        postMessage('Handled wait messages');\n      }\n      else {\n        postMessage(%AtomicsSychronizationNumAsyncWaitersInIsolateForTesting());\n      }\n    };\n    postMessage('Worker started');",
        "'string'",
        "'Worker started'",
        "'string'",
        "'Worker started'",
        "'string'",
        "'Worker started'",
        "'string'",
        "'Worker started'",
        "'string'",
        "'Worker started'",
        "'done'",
        "'lock'",
        "'wait'",
        "'count'",
        "'Lock acquired'",
        "'Waiting started'",
        "'Lock waiters queued'",
        "'Handled wait messages'",
        "'Waiting started'",
        "'Lock released'",
        "'Lock acquired'",
        "'Lock released'",
        "'Waiting done'",
        "'Waiting done'"
    ],
    "variables": [
        "workerLockScript",
        "workerWaitScript",
        "workerAsyncScript",
        "workerLock1",
        "workerLock2",
        "workerWait1",
        "workerWait2",
        "workerAsync",
        "SharedType",
        "sharedObj",
        "mutex",
        "cv_mutex",
        "cv",
        "lock_msg",
        "wait_msg",
        "count_msg"
    ],
    "comments": [
        "Copyright 2024 the V8 project authors. All rights reserved.",
        "Use of this source code is governed by a BSD-style license that can be",
        "found in the LICENSE file.",
        "",
        "Flags: --harmony-struct --allow-natives-syntax",
        "Wait until the waitAsync-related tasks are processed in the worker before",
        "posting a new message.",
        "Verify there are 30 waiters in the async waiter list of the workerAsync's",
        "isolate."
    ],
    "docstrings": [],
    "functions": [],
    "classes": []
}