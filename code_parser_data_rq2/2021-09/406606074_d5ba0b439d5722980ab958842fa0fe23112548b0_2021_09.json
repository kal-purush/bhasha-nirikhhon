{
    "identifiers": [
        "navigator",
        "adapter",
        "device",
        "shaderCode",
        "Uint32Array",
        "numbers",
        "device",
        "size",
        "device",
        "size",
        "Uint32Array",
        "storageBuffer",
        "buf",
        "numbers",
        "storageBuffer",
        "device",
        "shaderModule",
        "computePipeline",
        "device",
        "bindGroupLayout",
        "storageBuffer",
        "device",
        "encoder",
        "computePass",
        "computePipeline",
        "computePass",
        "bindGroup",
        "computePass",
        "computePass",
        "numbers",
        "computePass",
        "encoder",
        "storageBuffer",
        "stagingBuffer",
        "size",
        "device",
        "encoder",
        "stagingBuffer",
        "stagingBuffer",
        "a",
        "b",
        "a",
        "b",
        "a",
        "val",
        "i",
        "val",
        "b",
        "i",
        "Uint32Array",
        "data",
        "Uint32Array",
        "actual",
        "expected",
        "isTypedArrayEqual",
        "actual",
        "expected",
        "stagingBuffer",
        "device"
    ],
    "literals": [
        "[[block]]\nstruct PrimeIndices {\n    data: [[stride(4)]] array<u32>;\n}; // this is used as both input and output for convenience\n[[group(0), binding(0)]]\nvar<storage, read_write> v_indices: PrimeIndices;\n// The Collatz Conjecture states that for any integer n:\n// If n is even, n = n/2\n// If n is odd, n = 3n+1\n// And repeat this process for each new n, you will always eventually reach 1.\n// Though the conjecture has not been proven, no counterexample has ever been found.\n// This function returns how many times this recurrence needs to be applied to reach 1.\nfn collatz_iterations(n_base: u32) -> u32{\n    var n: u32 = n_base;\n    var i: u32 = 0u;\n    loop {\n        if (n <= 1u) {\n            break;\n        }\n        if (n % 2u == 0u) {\n            n = n / 2u;\n        }\n        else {\n            // Overflow? (i.e. 3*n + 1 > 0xffffffffu?)\n            if (n >= 1431655765u) {   // 0x55555555u\n                return 4294967295u;   // 0xffffffffu\n            }\n            n = 3u * n + 1u;\n        }\n        i = i + 1u;\n    }\n    return i;\n}\n[[stage(compute), workgroup_size(1)]]\nfn main([[builtin(global_invocation_id)]] global_id: vec3<u32>) {\n    v_indices.data[global_id.x] = collatz_iterations(v_indices.data[global_id.x]);\n}",
        "\"Storage Buffer\"",
        "\"main\"",
        "\"compute collatz iterations\"",
        "\"actual\"",
        "\"expected\"",
        "\"Actual does not equal expected!\""
    ],
    "variables": [
        "adapter",
        "numbers",
        "device",
        "shaderCode",
        "shaderModule",
        "size",
        "stagingBuffer",
        "storageBuffer",
        "buf",
        "computePipeline",
        "bindGroupLayout",
        "bindGroup",
        "encoder",
        "computePass",
        "data",
        "actual",
        "expected"
    ],
    "comments": [],
    "docstrings": [],
    "functions": [
        "isTypedArrayEqual"
    ],
    "classes": []
}