{
    "identifiers": [
        "co",
        "blocke",
        "scalajack",
        "oldstr",
        "newstr",
        "oldstr",
        "length",
        "saw_backslash",
        "i",
        "i",
        "oldstr",
        "length",
        "i",
        "cp",
        "oldstr",
        "codePointAt",
        "i",
        "oldstr",
        "codePointAt",
        "i",
        "MAX_VALUE",
        "i",
        "saw_backslash",
        "cp",
        "saw_backslash",
        "newstr",
        "append",
        "toChars",
        "cp",
        "cp",
        "saw_backslash",
        "newstr",
        "append",
        "newstr",
        "append",
        "cp",
        "newstr",
        "append",
        "newstr",
        "append",
        "newstr",
        "append",
        "newstr",
        "append",
        "newstr",
        "append",
        "newstr",
        "append",
        "newstr",
        "append",
        "newstr",
        "append",
        "i",
        "oldstr",
        "length",
        "die",
        "cp",
        "oldstr",
        "codePointAt",
        "i",
        "cp",
        "die",
        "newstr",
        "append",
        "toChars",
        "cp",
        "die",
        "i",
        "i",
        "oldstr",
        "length",
        "newstr",
        "append",
        "toChars",
        "i",
        "digits",
        "j",
        "j",
        "j",
        "j",
        "i",
        "j",
        "oldstr",
        "length",
        "ch",
        "oldstr",
        "charAt",
        "i",
        "j",
        "ch",
        "ch",
        "digits",
        "digits",
        "i",
        "newstr",
        "append",
        "value",
        "value",
        "parseInt",
        "oldstr",
        "substring",
        "i",
        "i",
        "digits",
        "nfe",
        "die",
        "newstr",
        "append",
        "toChars",
        "value",
        "i",
        "digits",
        "i",
        "oldstr",
        "length",
        "die",
        "i",
        "saw_brace",
        "oldstr",
        "charAt",
        "i",
        "i",
        "saw_brace",
        "j",
        "j",
        "j",
        "j",
        "saw_brace",
        "j",
        "ch",
        "oldstr",
        "charAt",
        "i",
        "j",
        "ch",
        "die",
        "saw_brace",
        "ch",
        "ch",
        "ch",
        "ch",
        "ch",
        "ch",
        "ch",
        "die",
        "format",
        "ch",
        "ch",
        "j",
        "die",
        "value",
        "value",
        "parseInt",
        "oldstr",
        "substring",
        "i",
        "i",
        "j",
        "nfe",
        "die",
        "newstr",
        "append",
        "toChars",
        "value",
        "saw_brace",
        "j",
        "i",
        "j",
        "i",
        "oldstr",
        "length",
        "die",
        "i",
        "j",
        "j",
        "j",
        "j",
        "oldstr",
        "charAt",
        "i",
        "j",
        "die",
        "value",
        "value",
        "parseInt",
        "oldstr",
        "substring",
        "i",
        "i",
        "j",
        "nfe",
        "die",
        "newstr",
        "append",
        "toChars",
        "value",
        "i",
        "j",
        "i",
        "oldstr",
        "length",
        "die",
        "i",
        "j",
        "j",
        "j",
        "j",
        "oldstr",
        "charAt",
        "i",
        "j",
        "die",
        "value",
        "value",
        "parseInt",
        "oldstr",
        "substring",
        "i",
        "i",
        "j",
        "nfe",
        "die",
        "newstr",
        "append",
        "toChars",
        "value",
        "i",
        "j",
        "newstr",
        "append",
        "newstr",
        "append",
        "toChars",
        "cp",
        "saw_backslash",
        "saw_backslash",
        "newstr",
        "append",
        "newstr",
        "toString",
        "s",
        "s",
        "length",
        "sb",
        "s",
        "length",
        "sb",
        "append",
        "i",
        "i",
        "s",
        "length",
        "i",
        "sb",
        "append",
        "format",
        "s",
        "codePointAt",
        "i",
        "s",
        "codePointAt",
        "i",
        "MAX_VALUE",
        "i",
        "i",
        "s",
        "length",
        "sb",
        "append",
        "sb",
        "toString",
        "foa",
        "foa",
        "what",
        "what"
    ],
    "literals": [
        "\"\\\\b\"",
        "\"trailing \\\\c\"",
        "\"expected ASCII after \\\\c\"",
        "\"illegal octal digit\"",
        "\"invalid octal value for \\\\0 escape\"",
        "\"string too short for \\\\x escape\"",
        "\"illegal non-ASCII hex digit in \\\\x escape\"",
        "\"illegal hex digit #%d '%c' in \\\\x\"",
        "\"empty braces in \\\\x{} escape\"",
        "\"invalid hex value for \\\\x escape\"",
        "\"string too short for \\\\u escape\"",
        "\"illegal non-ASCII hex digit in \\\\u escape\"",
        "\"invalid hex value for \\\\u escape\"",
        "\"string too short for \\\\U escape\"",
        "\"illegal non-ASCII hex digit in \\\\U escape\"",
        "\"invalid hex value for \\\\U escape\"",
        "\"\"",
        "\"U+\"",
        "\"%X\"",
        "\".\""
    ],
    "variables": [
        "j",
        "j",
        "j",
        "j"
    ],
    "comments": [],
    "docstrings": [
        "*\n\t * unescape_perl_string()\n\t *\n\t *      Tom Christiansen <tchrist@perl.com>\n\t *      Sun Nov 28 12:55:24 MST 2010\n\t *\n\t * It's completely ridiculous that there's no standard\n\t * unescape_java_string function.  Since I have to do the\n\t * damn thing myself, I might as well make it halfway useful\n\t * by supporting things Java was too stupid to consider in\n\t * strings:\n\t * \n\t *   => \"?\" items  are additions to Java string escapes\n\t *                 but normal in Java regexes\n\t *\n\t *   => \"!\" items  are also additions to Java regex escapes\n\t *   \n\t * Standard singletons: ?\\a ?\\e \\f \\n \\r \\t\n\t * \n\t *      NB: \\b is unsupported as backspace so it can pass-through\n\t *          to the regex translator untouched; I refuse to make anyone\n\t *          doublebackslash it as doublebackslashing is a Java idiocy\n\t *          I desperately wish would die out.  There are plenty of\n\t *          other ways to write it:\n\t *\n\t *              \\cH, \\12, \\012, \\x08 \\x{8}, \\u0008, \\U00000008\n\t *\n\t * Octal escapes: \\0 \\0N \\0NN \\N \\NN \\NNN\n\t *    Can range up to !\\777 not \\377\n\t *    \n\t *      TODO: add !\\o{NNNNN}\n\t *          last Unicode is 4177777\n\t *          maxint is 37777777777\n\t *\n\t * Control chars: ?\\cX\n\t *      Means: ord(X) ^ ord('@')\n\t *\n\t * Old hex escapes: \\xXX\n\t *      unbraced must be 2 xdigits\n\t *\n\t * Perl hex escapes: !\\x{XXX} braced may be 1-8 xdigits\n\t *       NB: proper Unicode never needs more than 6, as highest\n\t *           valid codepoint is 0x10FFFF, not maxint 0xFFFFFFFF\n\t *\n\t * Lame Java escape: \\[IDIOT JAVA PREPROCESSOR]uXXXX must be\n\t *                   exactly 4 xdigits;\n\t *\n\t *       I can't write XXXX in this comment where it belongs\n\t *       because the damned Java Preprocessor can't mind its\n\t *       own business.  Idiots!\n\t *\n\t * Lame Python escape: !\\UXXXXXXXX must be exactly 8 xdigits\n\t * \n\t * TODO: Perl translation escapes: \\Q \\U \\L \\E \\[IDIOT JAVA PREPROCESSOR]u \\l\n\t *       These are not so important to cover if you're passing the\n\t *       result to Pattern.compile(), since it handles them for you\n\t *       further downstream.  Hm, what about \\[IDIOT JAVA PREPROCESSOR]u?\n\t *",
        "* In contrast to fixing Java's broken regex charclasses,\n\t     * this one need be no bigger, as unescaping shrinks the string\n\t     * here, where in the other one, it grows it.",
        "**WE HATES UTF-16! WE HATES IT FOREVERSES!!!***",
        "switch",
        "switch",
        "switch",
        "switch",
        "switch",
        "PASS a \\b THROUGH!!",
        "switch",
        "switch",
        "switch",
        "switch",
        "* A \"control\" character is what you get when you xor its\n\t             * codepoint with '@'==64.  This only makes sense for ASCII,\n\t             * and may not yield a \"control\" character after all.\n\t             *\n\t             * Strange but true: \"\\c{\" is \";\", \"\\c}\" is \"=\", etc.",
        "* don't need to grok surrogates, as next line blows them up",
        "switch",
        "NOTREACHED",
        "* may be 0 to 2 octal digits following this one\n\t     * so back up one for fallthrough to next case;\n\t     * unread this digit and fall through to next case.",
        "FALLTHROUGH",
        "* Can have 0, 1, or 2 octal digits following a 0\n\t             * this permits larger values than octal 377, up to\n\t             * octal 777.",
        "found \\0 at end of string",
        "switch",
        "for",
        "safe because will unread surrogate",
        "for",
        "switch",
        "switch",
        "end case '0'",
        "^^^^^^ ok to ignore surrogates here",
        "for",
        "* ASCII test also catches surrogates",
        "for",
        "switch",
        "this also handles the surrogate issue",
        "switch",
        "this also handles the surrogate issue",
        "switch",
        "* say(String.format(\n\t            *       \"DEFAULT unrecognized escape %c passed through\",\n\t            *       cp));",
        "switch",
        "weird to leave one at the end",
        "* Return a string \"U+XX.XXX.XXXX\" etc, where each XX set is the\n\t * xdigits of the logical Unicode code point. No bloody brain-damaged\n\t * UTF-16 surrogate crap, just true logical characters.",
        "This is just the minimum; sb will grow as needed.",
        "**WE HATES UTF-16! WE HATES IT FOREVERSES!!!***"
    ],
    "functions": [
        "unescape_perl_string",
        "uniplus",
        "die",
        "say"
    ],
    "classes": [
        "Unicode"
    ]
}