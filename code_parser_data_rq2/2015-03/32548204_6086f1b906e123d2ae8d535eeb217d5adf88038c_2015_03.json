{
    "identifiers": [
        "Immutable",
        "collection",
        "Immutable",
        "onChange",
        "newValue",
        "oldValue",
        "keyPath",
        "collection",
        "Immutable",
        "keyPath",
        "onChange",
        "newValue",
        "oldValue",
        "keyPath",
        "collection",
        "Immutable",
        "key",
        "onChange",
        "newValue",
        "oldValue",
        "keyPath",
        "Immutable",
        "subKeyPath",
        "subKey",
        "notSetValue",
        "key",
        "notSetValue",
        "keyPath",
        "notSetValue",
        "keyPath",
        "Immutable",
        "notSetValue",
        "key",
        "value",
        "key",
        "key",
        "updater",
        "value",
        "key",
        "updater",
        "value",
        "key",
        "notSetValue",
        "updater",
        "value",
        "iterables",
        "Immutable",
        "iterables",
        "key",
        "merger",
        "previous",
        "next",
        "iterables",
        "Immutable",
        "merger",
        "previous",
        "next",
        "iterables",
        "key",
        "iterables",
        "Immutable",
        "iterables",
        "key",
        "merger",
        "previous",
        "next",
        "iterables",
        "Immutable",
        "merger",
        "previous",
        "next",
        "iterables",
        "key",
        "keyPath",
        "value",
        "keyPath",
        "Immutable",
        "value",
        "keyPath",
        "keyPath",
        "Immutable",
        "keyPath",
        "keyPath",
        "Immutable",
        "keyPath",
        "updater",
        "value",
        "keyPath",
        "notSetValue",
        "updater",
        "value",
        "keyPath",
        "Immutable",
        "updater",
        "value",
        "keyPath",
        "Immutable",
        "notSetValue",
        "updater",
        "value",
        "keyPath",
        "Immutable",
        "iterables",
        "Immutable",
        "keyPath",
        "iterables",
        "Immutable",
        "keyPath",
        "iterables",
        "key",
        "keyPath",
        "Immutable",
        "iterables",
        "Immutable",
        "keyPath",
        "iterables",
        "Immutable",
        "keyPath",
        "iterables",
        "key",
        "mutator",
        "mutable"
    ],
    "literals": [
        "'immutable/contrib/cursor'",
        "'immutable'",
        "string",
        "string",
        "string",
        "string",
        "string",
        "string"
    ],
    "variables": [],
    "comments": [
        "<reference path='../../dist/immutable.d.ts'/>",
        "Deep persistent changes",
        "Transient changes"
    ],
    "docstrings": [
        "*  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.",
        "* Cursors\n * -------\n *\n * Cursors allow you to hold a reference to a path in a nested immutable data\n * structure, allowing you to pass smaller sections of a larger nested\n * collection to portions of your application while maintaining a central point\n * aware of changes to the entire data structure.\n *\n * This is particularly useful when used in conjuction with component-based UI\n * libraries like [React](http://facebook.github.io/react/) or to simulate\n * \"state\" throughout an application while maintaining a single flow of logic.\n *\n * Cursors provide a simple API for getting the value at that path\n * (the equivalent of `this.getIn(keyPath)`), updating the value at that path\n * (the equivalent of `this.updateIn(keyPath)`), and getting a sub-cursor\n * starting from that path.\n *\n * When updated, a new root collection is created and provided to the `onChange`\n * function provided to the first call to `Cursor(map, onChange)`.\n *\n * When this cursor's (or any of its sub-cursors') `update` method is called,\n * the resulting new data structure will be provided to the `onChange`\n * function. Use this callback to keep track of the most current value or\n * update the rest of your application.",
        "* Returns a sub-cursor following the key-path starting from this cursor.",
        "* Returns the value at the cursor, if the cursor path does not yet exist,\n     * returns `notSetValue`.",
        "* Returns the value at the `key` in the cursor, or `notSetValue` if it\n     * does not exist.\n     *\n     * If the key would return a collection, a new Cursor is returned.",
        "* Returns the value at the `keyPath` in the cursor, or `notSetValue` if it\n     * does not exist.\n     *\n     * If the keyPath would return a collection, a new Cursor is returned.",
        "* Sets `value` at `key` in the cursor, returning a new cursor to the same\n     * point in the new data.",
        "* Deletes `key` from the cursor, returning a new cursor to the same\n     * point in the new data.\n     *\n     * Note: `delete` cannot be safely used in IE8\n     * @alias remove",
        "* Clears the value at this cursor, returning a new cursor to the same\n     * point in the new data.",
        "* Updates the value in the data this cursor points to, triggering the\n     * callback for the root cursor and returning a new cursor pointing to the\n     * new data.",
        "* @see `Map#merge`",
        "* @see `Map#mergeWith`",
        "* @see `Map#mergeDeep`",
        "* @see `Map#mergeDeepWith`",
        "* Returns a new Cursor having set `value` at this `keyPath`. If any keys in\n     * `keyPath` do not exist, a new immutable Map will be created at that key.",
        "* Returns a new Cursor having removed the value at this `keyPath`.\n     *\n     * @alias removeIn",
        "* Returns a new Cursor having applied the `updater` to the value found at\n     * the keyPath.\n     *\n     * If any keys in `keyPath` do not exist, new Immutable `Map`s will\n     * be created at those keys. If the `keyPath` does not already contain a\n     * value, the `updater` function will be called with `notSetValue`, if\n     * provided, otherwise `undefined`.\n     *\n     * If the `updater` function returns the same value it was called with, then\n     * no change will occur. This is still true if `notSetValue` is provided.",
        "* A combination of `updateIn` and `merge`, returning a new Cursor, but\n     * performing the merge at a point arrived at by following the keyPath.\n     * In other words, these two lines are equivalent:\n     *\n     *     x.updateIn(['a', 'b', 'c'], abc => abc.merge(y));\n     *     x.mergeIn(['a', 'b', 'c'], y);\n     *",
        "* A combination of `updateIn` and `mergeDeep`, returning a new Cursor, but\n     * performing the deep merge at a point arrived at by following the keyPath.\n     * In other words, these two lines are equivalent:\n     *\n     *     x.updateIn(['a', 'b', 'c'], abc => abc.mergeDeep(y));\n     *     x.mergeDeepIn(['a', 'b', 'c'], y);\n     *",
        "* Every time you call one of the above functions, a new immutable value is\n     * created and the callback is triggered. If you need to apply a series of\n     * mutations to a Cursor without triggering the callback repeatedly,\n     * `withMutations()` creates a temporary mutable copy of the value which\n     * can apply mutations in a highly performant manner. Afterwards the\n     * callback is triggered with the final value."
    ],
    "functions": [],
    "classes": []
}