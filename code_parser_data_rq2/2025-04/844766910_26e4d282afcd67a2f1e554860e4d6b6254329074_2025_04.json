{
    "identifiers": [
        "useLayoutEffect",
        "useMemo",
        "useState",
        "useSelector",
        "Index",
        "ThoughtId",
        "TreeThought",
        "TreeThoughtPositioned",
        "testFlags",
        "scrollTopStore",
        "head",
        "parentOf",
        "useSortedContext",
        "usePositionedThoughts",
        "treeThoughts",
        "useState",
        "useSelector",
        "state",
        "state",
        "useSelector",
        "state",
        "state",
        "fontSize",
        "useLayoutEffect",
        "dragInProgress",
        "testFlags",
        "toolbar",
        "setToolbarHeight",
        "toolbar",
        "dragInProgress",
        "useSortedContext",
        "scrollTopStore",
        "scrollTop",
        "dragInProgress",
        "scrollTop",
        "useMemo",
        "treeThoughts",
        "node",
        "i",
        "treeThoughts",
        "i",
        "treeThoughts",
        "i",
        "next",
        "next",
        "node",
        "node",
        "singleLineHeight",
        "cliff",
        "cliffPadding",
        "sizes",
        "node",
        "singleLineHeightWithCliff",
        "node",
        "node",
        "accum",
        "childKey",
        "accum",
        "sizes",
        "childKey",
        "tableCol1Width",
        "tableCol1Widths",
        "head",
        "node",
        "tableCol1Width",
        "node",
        "accum",
        "id",
        "i",
        "accum",
        "tableCol1Widths",
        "node",
        "i",
        "node",
        "indentCursorAncestorTables",
        "ancestorTableWidths",
        "node",
        "fontSize",
        "node",
        "tableCol1Widths",
        "node",
        "node",
        "fontSize",
        "node",
        "node",
        "tableCol1Widths",
        "node",
        "node",
        "fontSize",
        "fontSize",
        "node",
        "fontSize",
        "node",
        "ancestorTableWidths",
        "ycol1Ancestors",
        "ycol1Ancestors",
        "node",
        "ycol1Ancestors",
        "ycol1",
        "yaccum",
        "yaccum",
        "ycol1",
        "sizes",
        "node",
        "cliff",
        "prev",
        "node",
        "prev",
        "yaccum",
        "isNewCliff",
        "cliffPadding",
        "node",
        "node",
        "yaccum",
        "height",
        "node",
        "ycol1Ancestors",
        "yaccum",
        "height",
        "node",
        "node",
        "node",
        "next",
        "next",
        "scrollTopIfDragging",
        "node",
        "firstThoughtRank",
        "firstThoughtRank",
        "node",
        "lastThoughtRank",
        "node",
        "y",
        "maxVisibleY",
        "y",
        "scrollTopIfDragging",
        "toolbarHeight",
        "firstVisibleThoughtRank",
        "firstVisibleThoughtRank",
        "node",
        "lastVisibleThoughtRank",
        "node",
        "node",
        "tableCol1Widths",
        "head",
        "parentOf",
        "node",
        "isHoveringSorted",
        "newRank",
        "lastVisibleThoughtRank",
        "lastVisibleThoughtRank",
        "lastThoughtRank",
        "hoverArrowVisibility",
        "newRank",
        "firstVisibleThoughtRank",
        "firstVisibleThoughtRank",
        "firstThoughtRank",
        "hoverArrowVisibility",
        "hoverArrowVisibility",
        "cliffPadding",
        "fontSize",
        "isHoveringSorted",
        "maxVisibleY",
        "newRank",
        "scrollTopIfDragging",
        "singleLineHeight",
        "sizes",
        "toolbarHeight",
        "treeThoughts",
        "usePositionedThoughts"
    ],
    "literals": [
        "'react'",
        "'react-redux'",
        "'../@types/IndexType'",
        "'../@types/ThoughtId'",
        "'../@types/TreeThought'",
        "'../@types/TreeThoughtPositioned'",
        "'../e2e/testFlags'",
        "'../stores/scrollTop'",
        "'../util/head'",
        "'../util/parentOf'",
        "'./useSortedContext'",
        "'above'",
        "'below'",
        "'#toolbar'",
        "'above'",
        "'below'",
        "'above'",
        "'below'",
        "'dim'",
        "'show'",
        "'dim'",
        "'show'",
        "'below'",
        "'above'"
    ],
    "variables": [
        "usePositionedThoughts",
        "toolbarHeight",
        "setToolbarHeight",
        "dragInProgress",
        "fontSize",
        "cliffPadding",
        "toolbar",
        "scrollTopIfDragging",
        "yaccum",
        "indentCursorAncestorTables",
        "hoverArrowVisibility",
        "firstThoughtRank",
        "lastThoughtRank",
        "firstVisibleThoughtRank",
        "lastVisibleThoughtRank",
        "ycol1Ancestors",
        "tableCol1Widths",
        "treeThoughtsPositioned",
        "prev",
        "next",
        "cliff",
        "singleLineHeightWithCliff",
        "height",
        "tableCol1Width",
        "ancestorTableWidths",
        "x",
        "ycol1",
        "isNewCliff",
        "y",
        "isLastVisible"
    ],
    "comments": [
        "Calculates the x,y position of each thought, from top to bottom. Initially renders each thought with y based on estimated height, then re-renders each thought after the actual heights are measured in the DOM. Returns a list of TreeThoughtPositioned, which extends TreeThought with x,y and width,height.",
        "Height of toolbar element",
        "set the bullet width only during drag or when simulateDrop is true",
        "The value of scrollTop. Only enabled when there is a drag in progress for performance reasons.",
        "Accumulate the y position as we iterate the visible thoughts since the sizes may vary.",
        "We need to do this in a second pass since we do not know the height of a thought until it is rendered, and since we need to linearize the tree to get the depth of the next node for calculating the cliff.",
        "the global indent based on the depth of the cursor and how many ancestors are tables",
        "y increases monotically, so it is more efficent to accumulate than to calculate each time",
        "x varies, so we calculate it each time",
        "(it is especially hard to determine how much x is decreased on cliffs when there are any number of tables in between)",
        "Arrow visibility based on the rank of drop target in sorted context.",
        "The rank of the first and last thoughts in sorted context.",
        "The rank of the first and last visible thoughts in sorted context.",
        "A stack of { depth, y } that stores the bottom y value of each col1 ancestor.",
        "By default, yaccum is not advanced by the height of col1. This is what positions col2 at the same y value as col1. However, if the height of col1 exceeds the height of col2, then the next node needs to be positioned below col1, otherwise it will overlap. This stack stores the minimum y value of the next node (i.e. y + height). Depth is used to detect the next node after all of col1's descendants.\n\n    e.g. The height of Boston with its long note exceeds the height of b, c, and d combined. Therefore, the next node, x, needs to be positioned below Boston.\n\n    - a\n      - =view\n        - Table\n      - Boston\n        - =note\n          - What to do when the thought extends onto two or three lines or four lines if we keep going\n        - b\n          - c\n            - d",
        "cache table column 1 widths so they are only calculated once and then assigned to each thought in the column",
        "key thoughtId of thought with =table attribute",
        "cliff is the number of levels that drop off after the last thought at a given depth. Increase in depth is ignored.",
        "This is used to determine how many DropEnd to insert before the next thought (one for each level dropped).",
        "TODO: Fix cliff across context view boundary",
        "The single line height needs to be increased for thoughts that have a cliff below them.",
        "For some reason this is not yielding an exact subpixel match, so the first updateHeight will not short circuit. Performance could be improved if th exact subpixel match could be determined. Still, this is better than not taking into account cliff padding.",
        "set the width of table col1 to the minimum width of all visible thoughts in the column",
        "sum ancestor table widths",
        "ignore thought and parent since horizontal shift should begin with col 2, and tableCol1Widths is keyed by the thought with =table",
        "Calculate the cursor ancestor table width when we are on the cursor node.",
        "This is used to animate the entire tree to the left as the cursor moves right.",
        "table col1: shift left by an additional 1 em so that the shift at the next depth does not feel so extreme",
        "table col2: shift right by the width of table col1 to offset ancestorTableWidths, since col1 is still visible",
        "then shift left by 3 em, which is about the most we can do without col1 getting cropped by the left edge of the screen",
        "table col2 child: if the child is a leaf, shift right by the width of table col1 again since col1 is still visible",
        "otherwise, shift by 3 em since col1 is now hidden, but we don't want too much of a jump",
        "indentation",
        "space between table columns",
        "table col2",
        "Set yaccum to the bottom of the previous row's col1 if it is higher than col2.",
        "See: ycol1Ancestors",
        "Anticipate cliff change on new thought\n\n        There is a special case for the y position when creating a new thought at the end of a context. The former last thought (what will become the new thought's previous sibling) loses its cliff, e.g. cliff changes from -1 to 0. This causes it to lots its cliffPaddingStyle, and thus its height will decrease slightly. However, when the new thought is rendered, its y position is determined by the previous thought's cached height. The height is only re-measured after the nxet render. This causes the new thought's y position to decrease by the cliff padding over a single frame. It will appear to slide up as it animates into the correct y position (based on the updated previous sibling's measurement).\n\n        Solution: Check if a new thought is being rendered at the cliff, and anticipate the updated y position by subtracting cliffPadding. This does not apply if the previous thought's depth is greater than the new thought's depth, as it will not be losing its cliff. It only applies if the prevous thought is a sibling or parent and is losing its cliff.\n\n        (It may have been better to directly check if the previous thought is losing its cliff, however that would require persisting the last cliff for each thought in a ref. The additional state is less than ideal, but it can be pursued if it is discovered that this simple condition has any false positives/negatives.)\n\n        e.g. `a` will lose its cliff but its height will not be re-measured until after [empty] has been rendered with the wrong y\n          - a\n          - [empty]",
        "Capture the y position of the current thought before it is incremented by its own height for the next thought.",
        "increase y by the height of the current thought",
        "if the current thought is in table col1, push its y and depth onto the stack so that the next node after it can be positioned below it instead of overlapping it",
        "See: ycol1Ancestors",
        "Get first and last thought ranks in sorted context",
        "Check if the current thought is visible",
        "Get first and last visible thought ranks in sorted context",
        "Determine hoverArrowVisibility based on newRank and the visible thoughts"
    ],
    "docstrings": [],
    "functions": [],
    "classes": []
}