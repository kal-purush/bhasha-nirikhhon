{
    "identifiers": [
        "AVFrame",
        "AVContentLightMetadata",
        "AVFrameSideDataType",
        "AVPixelFormat",
        "mapUint16Array",
        "WebGLRenderOptions",
        "AVPixelFormatDescriptor",
        "getAVPixelFormatDescriptor",
        "AVPixelFormatFlags",
        "WebGLDefaultRender",
        "generateSteps",
        "ColorTransformOptions",
        "DefaultSDRWhiteLevel",
        "GLType",
        "ColorSpace",
        "HdrMetadata",
        "getAVFrameSideData",
        "VideoProgram16",
        "isPointer",
        "WebGLDefaultRender",
        "canvas",
        "options",
        "canvas",
        "options",
        "make",
        "WebGL2RenderingContext",
        "descriptor",
        "colorTransformOptions",
        "colorTransformOptions",
        "generateSteps",
        "colorTransformOptions",
        "descriptor",
        "com",
        "i",
        "i",
        "com",
        "shifts",
        "i",
        "com",
        "maxes",
        "i",
        "com",
        "samplerMap",
        "descriptor",
        "offsetMap",
        "descriptor",
        "descriptor",
        "samplerMap",
        "descriptor",
        "offsetMap",
        "descriptor",
        "descriptor",
        "AVPixelFormatFlags",
        "descriptor",
        "samplerMap",
        "descriptor",
        "offsetMap",
        "descriptor",
        "descriptor",
        "AVPixelFormatFlags",
        "descriptor",
        "AVPixelFormatFlags",
        "a",
        "samplerMap",
        "descriptor",
        "descriptor",
        "offsetMap",
        "descriptor",
        "descriptor",
        "descriptor",
        "descriptor",
        "u",
        "descriptor",
        "AVPixelFormatFlags",
        "s",
        "s",
        "descriptor",
        "AVPixelFormatFlags",
        "isTexture",
        "y",
        "descriptor",
        "AVPixelFormatFlags",
        "y",
        "y",
        "shifts",
        "maxes",
        "y",
        "isTexture",
        "u",
        "descriptor",
        "AVPixelFormatFlags",
        "u",
        "u",
        "shifts",
        "maxes",
        "u",
        "isTexture",
        "v",
        "descriptor",
        "AVPixelFormatFlags",
        "v",
        "v",
        "shifts",
        "maxes",
        "v",
        "isTexture",
        "a",
        "descriptor",
        "AVPixelFormatFlags",
        "a",
        "a",
        "shifts",
        "descriptor",
        "maxes",
        "descriptor",
        "a",
        "steps",
        "pre",
        "current",
        "pre",
        "current",
        "frame",
        "frame",
        "frame",
        "frame",
        "frame",
        "getAVPixelFormatDescriptor",
        "frame",
        "ColorSpace",
        "frame",
        "frame",
        "frame",
        "frame",
        "GLType",
        "descriptor",
        "DefaultSDRWhiteLevel",
        "getAVFrameSideData",
        "frame",
        "AVFrameSideDataType",
        "sideData",
        "reinterpret_cast",
        "sideData",
        "lightMetadata",
        "colorTransformOptions",
        "static_cast",
        "lightMetadata",
        "descriptor",
        "colorTransformOptions",
        "VideoProgram16",
        "descriptor",
        "AVPixelFormatFlags",
        "frame",
        "plane",
        "frame",
        "descriptor",
        "descriptor",
        "descriptor",
        "frame",
        "plane",
        "isUVPlane",
        "frame",
        "descriptor",
        "isUVPlane",
        "frame",
        "plane",
        "frame",
        "descriptor",
        "isUVPlane",
        "descriptor",
        "AVPixelFormatFlags",
        "frame",
        "plane",
        "frame",
        "frame",
        "descriptor",
        "descriptor",
        "formatMap",
        "planeCount",
        "internalformatMap",
        "planeCount",
        "frame",
        "planeCount",
        "frame",
        "frame",
        "planeCount",
        "frame",
        "frame",
        "frame",
        "frame",
        "getAVPixelFormatDescriptor",
        "frame",
        "descriptor",
        "frame",
        "mapUint16Array",
        "reinterpret_cast",
        "frame",
        "plane",
        "frame",
        "plane",
        "descriptor",
        "AVPixelFormatFlags",
        "descriptor",
        "mapUint16Array",
        "reinterpret_cast",
        "frame",
        "plane",
        "frame",
        "plane",
        "descriptor",
        "descriptor",
        "mapUint16Array",
        "reinterpret_cast",
        "frame",
        "plane",
        "frame",
        "plane",
        "descriptor",
        "AVPixelFormatFlags",
        "mapUint16Array",
        "reinterpret_cast",
        "frame",
        "plane",
        "frame",
        "plane",
        "unmake",
        "frame",
        "isPointer",
        "frame",
        "getAVPixelFormatDescriptor",
        "frame",
        "descriptor",
        "descriptor"
    ],
    "literals": [
        "'avutil/struct/avframe'",
        "'avutil/pixfmt'",
        "'cheap/std/memory'",
        "'./WebGLRender'",
        "'avutil/pixelFormatDescriptor'",
        "'./WebGLDefaultRender'",
        "'./colorTransform/generateSteps'",
        "'./colorTransform/options'",
        "'./colorSpace/ColorSpace'",
        "'./struct/HdrMetadata'",
        "'avutil/util/avframe'",
        "'./webgl/program/VideoProgram16'",
        "'cheap/std/function/isPointer'",
        "'not support webgl2'",
        "#version 300 es\n      precision highp float;\n      in vec3 point;\n      in vec4 color;\n      out vec4 v_color;\n      uniform mat4 rotateMatrix;\n      void main(void) {\n        gl_Position = rotateMatrix * vec4(point, 1.0);\n        v_color = color;\n      }",
        "'y'",
        "'u'",
        "'v'",
        "'a'",
        "'r'",
        "'g'",
        "'b'",
        "'a'",
        "texture(${samplerMap[descriptor.comp[0].plane]}_Sampler, v_color.xy).${offsetMap[descriptor.comp[0].offset / bytes[0]]}",
        "texture(${samplerMap[descriptor.comp[1].plane]}_Sampler, v_color.xy).${offsetMap[descriptor.comp[1].offset / bytes[1]]}",
        "'0.0'",
        "'0.5'",
        "texture(${samplerMap[descriptor.comp[2].plane]}_Sampler, v_color.xy).${offsetMap[descriptor.comp[2].offset / bytes[2]]}",
        "'0.0'",
        "'0.5'",
        "'1.0'",
        "texture(${samplerMap[descriptor.comp[descriptor.comp.length - 1].plane]}_Sampler, v_color.xy).${offsetMap[descriptor.comp[descriptor.comp.length - 1].offset / bytes[descriptor.comp.length - 1]]}",
        "'0.0'",
        "'0.5'",
        "string",
        "#version 300 es\n      precision highp float;\n      precision highp usampler2D;\n      in vec4 v_color;\n      out vec4 outColor;\n      uniform usampler2D y_Sampler;\n      uniform usampler2D u_Sampler;\n      uniform usampler2D v_Sampler;\n      uniform usampler2D a_Sampler;\n      uniform float offset;\n      uniform float multiplier;\n      uniform float pq_tonemap_a;\n      uniform float pq_tonemap_b;\n      uniform float hlg_ootf_gamma_minus_one;\n      uniform float nits_to_sdr_relative_factor;\n      uniform float sdr_relative_to_nits_factor;\n      ${(descriptor.flags & AVPixelFormatFlags.BIG_ENDIAN) ? `\n        uint swap(uint x) {\n          uint l = x & 0xFFu;\n          uint h = (x >> 8u) & 0xFFu;\n          return (l << 8u) | h;\n        }\n      ` : ''}\n      void main () {\n        float y = ${isTexture(y) ? `float(${(descriptor.flags & AVPixelFormatFlags.BIG_ENDIAN) ? `swap(${y})` : y} >> ${shifts[0]}) / float(${maxes[0]})` : y};\n        float u = ${isTexture(u) ? `float(${(descriptor.flags & AVPixelFormatFlags.BIG_ENDIAN) ? `swap(${u})` : u} >> ${shifts[1]}) / float(${maxes[1]})` : u};\n        float v = ${isTexture(v) ? `float(${(descriptor.flags & AVPixelFormatFlags.BIG_ENDIAN) ? `swap(${v})` : v} >> ${shifts[2]}) / float(${maxes[2]})` : v};\n        float a = ${isTexture(a) ? `float(${(descriptor.flags & AVPixelFormatFlags.BIG_ENDIAN) ? `swap(${a})` : a} >> ${shifts[descriptor.comp.length - 1]}) / float(${maxes[descriptor.comp.length - 1]})` : a};\n        vec4 color = vec4(y, u, v, a);\n        if (color.a > 0.0) {\n          color.r /= color.a;\n          color.g /= color.a;\n          color.b /= color.a;\n        }\n        color.r -= offset;\n        color.g -= offset;\n        color.b -= offset;\n        color.r *= multiplier;\n        color.g *= multiplier;\n        color.b *= multiplier;\n        ${steps.reduce((pre, current) => pre + current, '')}\n        color.r *= color.a;\n        color.g *= color.a;\n        color.b *= color.a;\n        outColor = color;\n      }",
        "uint swap(uint x) {\n          uint l = x & 0xFFu;\n          uint h = (x >> 8u) & 0xFFu;\n          return (l << 8u) | h;\n        }",
        "''",
        "float(${(descriptor.flags & AVPixelFormatFlags.BIG_ENDIAN) ? `swap(${y})` : y} >> ${shifts[0]}) / float(${maxes[0]})",
        "swap(${y})",
        "float(${(descriptor.flags & AVPixelFormatFlags.BIG_ENDIAN) ? `swap(${u})` : u} >> ${shifts[1]}) / float(${maxes[1]})",
        "swap(${u})",
        "float(${(descriptor.flags & AVPixelFormatFlags.BIG_ENDIAN) ? `swap(${v})` : v} >> ${shifts[2]}) / float(${maxes[2]})",
        "swap(${v})",
        "float(${(descriptor.flags & AVPixelFormatFlags.BIG_ENDIAN) ? `swap(${a})` : a} >> ${shifts[descriptor.comp.length - 1]}) / float(${maxes[descriptor.comp.length - 1]})",
        "swap(${a})",
        "''"
    ],
    "variables": [
        "steps",
        "samplerMap",
        "offsetMap",
        "shifts",
        "maxes",
        "y",
        "u",
        "v",
        "a",
        "descriptor",
        "colorTransformOptions",
        "sideData",
        "lightMetadata",
        "plane",
        "isUVPlane",
        "planeCount",
        "formatMap",
        "internalformatMap",
        "descriptor",
        "plane",
        "descriptor"
    ],
    "comments": [],
    "docstrings": [
        "* libmedia WebGLDefault16Render\n *\n * 版权所有 (C) 2024 赵高兴\n * Copyright (C) 2024 Gaoxing Zhao\n *\n * 此文件是 libmedia 的一部分\n * This file is part of libmedia.\n * \n * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1\n * 或任何其更新的版本条款重新分发或修改它\n * libmedia is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3.1 of the License, or (at your option) any later version.\n * \n * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证\n * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。\n * libmedia is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *"
    ],
    "functions": [
        "init",
        "generateVertexSource",
        "generateFragmentSource",
        "isTexture",
        "checkFrame",
        "render",
        "destroy",
        "isSupport"
    ],
    "classes": [
        "WebGLDefault16Render"
    ]
}