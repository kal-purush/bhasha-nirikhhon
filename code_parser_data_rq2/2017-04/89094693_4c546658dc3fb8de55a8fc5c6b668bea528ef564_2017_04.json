{
    "identifiers": [
        "java",
        "util",
        "root",
        "x",
        "line_num",
        "root",
        "insert",
        "x",
        "line_num",
        "root",
        "x",
        "root",
        "remove",
        "x",
        "root",
        "x",
        "t",
        "t",
        "t",
        "compareResult",
        "x",
        "compareTo",
        "t",
        "element",
        "compareResult",
        "t",
        "left",
        "remove",
        "x",
        "t",
        "left",
        "compareResult",
        "t",
        "right",
        "remove",
        "x",
        "t",
        "right",
        "t",
        "left",
        "t",
        "right",
        "t",
        "element",
        "findMin",
        "t",
        "right",
        "element",
        "t",
        "right",
        "remove",
        "t",
        "element",
        "t",
        "right",
        "t",
        "t",
        "left",
        "t",
        "left",
        "t",
        "right",
        "balance",
        "t",
        "isEmpty",
        "findMin",
        "root",
        "element",
        "isEmpty",
        "findMax",
        "root",
        "element",
        "x",
        "contains",
        "x",
        "root",
        "x",
        "temp",
        "find",
        "x",
        "root",
        "temp",
        "root",
        "root",
        "isEmpty",
        "printTree",
        "root",
        "ALLOWED_IMBALANCE",
        "t",
        "t",
        "t",
        "height",
        "t",
        "left",
        "height",
        "t",
        "right",
        "ALLOWED_IMBALANCE",
        "height",
        "t",
        "left",
        "left",
        "height",
        "t",
        "left",
        "right",
        "t",
        "rotateWithLeftChild",
        "t",
        "t",
        "doubleWithLeftChild",
        "t",
        "height",
        "t",
        "right",
        "height",
        "t",
        "left",
        "ALLOWED_IMBALANCE",
        "height",
        "t",
        "right",
        "right",
        "height",
        "t",
        "right",
        "left",
        "t",
        "rotateWithRightChild",
        "t",
        "t",
        "doubleWithRightChild",
        "t",
        "t",
        "height",
        "max",
        "height",
        "t",
        "left",
        "height",
        "t",
        "right",
        "t",
        "checkBalance",
        "root",
        "t",
        "t",
        "t",
        "hl",
        "checkBalance",
        "t",
        "left",
        "hr",
        "checkBalance",
        "t",
        "right",
        "abs",
        "height",
        "t",
        "left",
        "height",
        "t",
        "right",
        "height",
        "t",
        "left",
        "hl",
        "height",
        "t",
        "right",
        "hr",
        "height",
        "t",
        "x",
        "line_num",
        "t",
        "t",
        "x",
        "line_num",
        "contains",
        "x",
        "indexWord",
        "x",
        "line_num",
        "compareResult",
        "x",
        "compareTo",
        "t",
        "element",
        "compareResult",
        "t",
        "left",
        "insert",
        "x",
        "line_num",
        "t",
        "left",
        "compareResult",
        "t",
        "right",
        "insert",
        "x",
        "line_num",
        "t",
        "right",
        "balance",
        "t",
        "t",
        "t",
        "t",
        "t",
        "t",
        "left",
        "t",
        "t",
        "left",
        "t",
        "t",
        "t",
        "t",
        "t",
        "right",
        "t",
        "t",
        "right",
        "t",
        "x",
        "t",
        "t",
        "compareResult",
        "x",
        "compareTo",
        "t",
        "element",
        "compareResult",
        "t",
        "t",
        "left",
        "compareResult",
        "t",
        "t",
        "right",
        "t",
        "t",
        "printTree",
        "t",
        "left",
        "t",
        "element",
        "printTree",
        "t",
        "right",
        "t",
        "t",
        "t",
        "height",
        "k2",
        "k1",
        "k2",
        "left",
        "k2",
        "left",
        "k1",
        "right",
        "k1",
        "right",
        "k2",
        "k2",
        "height",
        "max",
        "height",
        "k2",
        "left",
        "height",
        "k2",
        "right",
        "k1",
        "height",
        "max",
        "height",
        "k1",
        "left",
        "k2",
        "height",
        "k1",
        "k1",
        "k2",
        "k1",
        "right",
        "k1",
        "right",
        "k2",
        "left",
        "k2",
        "left",
        "k1",
        "k1",
        "height",
        "max",
        "height",
        "k1",
        "left",
        "height",
        "k1",
        "right",
        "k2",
        "height",
        "max",
        "height",
        "k2",
        "right",
        "k1",
        "height",
        "k2",
        "k3",
        "k3",
        "left",
        "rotateWithRightChild",
        "k3",
        "left",
        "rotateWithLeftChild",
        "k3",
        "k1",
        "k1",
        "right",
        "rotateWithLeftChild",
        "k1",
        "right",
        "rotateWithRightChild",
        "k1",
        "node",
        "node",
        "element",
        "theElement",
        "line_num",
        "theElement",
        "line_num",
        "theElement",
        "line_num",
        "lt",
        "rt",
        "element",
        "theElement",
        "line_list",
        "add",
        "line_num",
        "left",
        "lt",
        "right",
        "rt",
        "height",
        "element",
        "line_list",
        "left",
        "right",
        "height",
        "x",
        "t",
        "t",
        "x",
        "compareTo",
        "t",
        "element",
        "t",
        "t",
        "left",
        "x",
        "compareTo",
        "t",
        "element",
        "t",
        "t",
        "right",
        "t",
        "word",
        "line",
        "contains",
        "word",
        "tempNode",
        "find",
        "word",
        "tempNode",
        "line_list",
        "contains",
        "line",
        "tempNode",
        "line_list",
        "add",
        "line",
        "word",
        "contains",
        "word",
        "tempNode",
        "find",
        "word",
        "tempNode",
        "line_list",
        "printIndex",
        "root",
        "t",
        "t",
        "printIndex",
        "t",
        "left",
        "t",
        "element",
        "i",
        "i",
        "t",
        "line_list",
        "size",
        "i",
        "t",
        "line_list",
        "get",
        "i",
        "printIndex",
        "t",
        "right",
        "root"
    ],
    "literals": [
        "\"Empty tree\"",
        "\"OOPS!!\"",
        "\"This word cannot be found in the file (AVL tree).\"",
        "\" ---in lines: \"",
        "\" \""
    ],
    "variables": [
        "element",
        "left",
        "right",
        "height",
        "root"
    ],
    "comments": [
        "AvlTree class",
        "CONSTRUCTION: with no initializer",
        "",
        "void insert( x )       --> Insert x",
        "void remove( x )       --> Remove x (unimplemented)",
        "boolean contains( x )  --> Return true if x is present",
        "AvlNode<String> find( String x ) --> Return the AvlNode if x is present in tree",
        "boolean remove( x )    --> Return true if x was present",
        "Comparable findMin( )  --> Return smallest item",
        "Comparable findMax( )  --> Return largest item",
        "boolean isEmpty( )     --> Return true if empty; else false",
        "void makeEmpty( )      --> Remove all items",
        "void printTree( )      --> Print tree in sorted order",
        "Throws UnderflowException as appropriate",
        "Item not found; do nothing",
        "Two children",
        "Assume t is either balanced or within one of being balanced",
        "empty tree",
        "duplicates are NOT ignored",
        "add the occurrence of the word x if this word already exists in the tree",
        "if the word doesn't already exist in the tree, then insert the node in appropriate place:",
        "Duplicate; do nothing",
        "Match",
        "No match",
        "Constructors",
        "System.out.println(\"Just inserted a new Node: \"+ theElement+\" ---at line \" + line_num);",
        "the word",
        "the line number -- we know it is the first occurance of the word",
        "Each element of the AVL tree (NODE) should contain a unique word and a linked list of line numbers where that word occurs.",
        "The data in the node = the unique word",
        "a linked list of line numbers where that word occurs.",
        "Left child",
        "Right child",
        "Height",
        "author: Weiss",
        "Match",
        "No match",
        "if the tree already contains the word",
        "contains() returns true if the word already exists in the AVL tree",
        "add the new line number to the existing node LinkedList",
        "find that node that contains the word",
        "check if the line # already appears",
        "if the line number doesn't exist in the linked list already -->> add it.",
        "add line number to the linked list in the node --> word already exists",
        "Note: a better way to do this without calling contains AND find? --> order n^2?",
        "looks up a word and returns a list of lines in which it occurs.",
        "find the word in the AVL tree",
        "calls a private function printIndex(root);",
        "print out the unique word",
        "get the line number from the linked list",
        "Test program"
    ],
    "docstrings": [
        "Jessica Gary\n * jsg2213\n * COMS3134 Columbia 2017\n * \n * HW3 Programming part 2 \n * \n * ************Modified the following methods/class:***************\n * AvlNode class - to accept linked_list & line numbers, each Node should contain a unique word and a linked list of where that word occurs in the text\n * insert \t\t - to accept line numbers \n * \n * ******************Added the following methods:******************\n * public void indexWord(String word, int line) -->  adds an occurrence of the word word in line line\n * public List getLinesForWord(String word)     -->  looks up a word and returns a list of lines in which it occurs.\n * public void printIndex()\t\t\t\t\t\t-->  prints out each unique word that is stored in the Avl tree along with a list of line numbers in which that word appears\n *",
        "******************PUBLIC OPERATIONS*****************************",
        "******************ERRORS****************************************",
        "* Implements an AVL tree.\n * Note that all \"matching\" is based on the compareTo method.\n * @author Mark Allen Weiss\n *",
        "* Construct the tree.",
        "* Insert into the tree; duplicates are ignored.\n     * @param x the item to insert.",
        "* Remove from the tree. Nothing is done if x is not found.\n     * @param x the item to remove.",
        "* Internal method to remove from a subtree.\n     * @param x the item to remove.\n     * @param t the node that roots the subtree.\n     * @return the new root of the subtree.",
        "* Find the smallest item in the tree.\n     * @return smallest item or null if empty.",
        "* Find the largest item in the tree.\n     * @return the largest item of null if empty.",
        "* Find an item in the tree.\n     * @param x the item to search for.\n     * @return true if x is found.",
        "* Make the tree logically empty.",
        "* Test if the tree is logically empty.\n     * @return true if empty, false otherwise.",
        "* Print the tree contents in sorted order.",
        "* Internal method to insert into a subtree.\n     * @param x the item to insert.\n     * @param t the node that roots the subtree.\n     * @return the new root of the subtree.",
        "* Internal method to find the smallest item in a subtree.\n     * @param t the node that roots the tree.\n     * @return node containing the smallest item.",
        "* Internal method to find the largest item in a subtree.\n     * @param t the node that roots the tree.\n     * @return node containing the largest item.",
        "* Internal method to find an item in a subtree.\n     * @param x is item to search for.\n     * @param t the node that roots the tree.\n     * @return true if x is found in subtree.",
        "* Internal method to print a subtree in sorted order.\n     * @param t the node that roots the tree.",
        "* Return the height of node t, or -1, if null.",
        "* Rotate binary tree node with left child.\n     * For AVL trees, this is a single rotation for case 1.\n     * Update heights, then return new root.",
        "* Rotate binary tree node with right child.\n     * For AVL trees, this is a single rotation for case 4.\n     * Update heights, then return new root.",
        "* Double rotate binary tree node: first left child\n     * with its right child; then node k3 with new left child.\n     * For AVL trees, this is a double rotation for case 2.\n     * Update heights, then return new root.",
        "* Double rotate binary tree node: first right child\n     * with its left child; then node k1 with new right child.\n     * For AVL trees, this is a double rotation for case 3.\n     * Update heights, then return new root.",
        "*  adds an occurrence of the word word in line line. \n    \t *  If a word already exists in the AVL Tree, simply add the new line number to the existing node. \n    \t *  If a word appears on the same line twice, it should only have one entry in the list for that line.",
        "rints out each unique word that is stored in the Avl tree \n    \t * along with a list of line numbers in which that word appears.",
        "The tree root.",
        "public static void main( String [ ] args )\n    {\n        AvlTree<Integer> t = new AvlTree<Integer>( );\n        final int SMALL = 40;\n        final int NUMS = 1000000;  // must be even\n        final int GAP  =   37;\n\n        System.out.println( \"Checking... (no more output means success)\" );\n\n        for( int i = GAP; i != 0; i = ( i + GAP ) % NUMS )\n        {\n        //    System.out.println( \"INSERT: \" + i );\n            t.insert( i );\n            if( NUMS < SMALL )\n                t.checkBalance( );\n        }\n        \n        for( int i = 1; i < NUMS; i+= 2 )\n        {\n         //   System.out.println( \"REMOVE: \" + i );\n            t.remove( i );\n            if( NUMS < SMALL )\n                t.checkBalance( );\n        }\n        if( NUMS < SMALL )\n            t.printTree( );\n        if( t.findMin( ) != 2 || t.findMax( ) != NUMS - 2 )\n            System.out.println( \"FindMin or FindMax error!\" );\n\n        for( int i = 2; i < NUMS; i+=2 )\n             if( !t.contains( i ) )\n                 System.out.println( \"Find error1!\" );\n\n        for( int i = 1; i < NUMS; i+=2 )\n        {\n            if( t.contains( i ) )\n                System.out.println( \"Find error2!\" );\n        }\n    }"
    ],
    "functions": [
        "AvlTree",
        "insert",
        "remove",
        "remove",
        "findMin",
        "findMax",
        "contains",
        "find",
        "makeEmpty",
        "isEmpty",
        "printTree",
        "balance",
        "checkBalance",
        "checkBalance",
        "insert",
        "findMin",
        "findMax",
        "contains",
        "printTree",
        "height",
        "rotateWithLeftChild",
        "rotateWithRightChild",
        "doubleWithLeftChild",
        "doubleWithRightChild",
        "getElement",
        "AvlNode",
        "AvlNode",
        "find",
        "indexWord",
        "getLinesForWord",
        "printIndex",
        "printIndex"
    ],
    "classes": [
        "AvlTree",
        "AvlNode"
    ]
}