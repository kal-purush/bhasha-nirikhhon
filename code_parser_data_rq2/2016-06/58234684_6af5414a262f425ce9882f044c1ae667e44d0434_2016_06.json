{
    "identifiers": [
        "numpy",
        "np",
        "random",
        "model",
        "logistic_layer",
        "LogisticLayer",
        "model",
        "classifier",
        "Classifier",
        "sklearn",
        "metrics",
        "accuracy_score",
        "Classifier",
        "train",
        "valid",
        "test",
        "layers",
        "input_weights",
        "output_task",
        "output_activation",
        "cost",
        "learning_rate",
        "epochs",
        "nlayer",
        "learning_rate",
        "epochs",
        "output_task",
        "output_activation",
        "cost",
        "train",
        "valid",
        "test",
        "layers",
        "input_weights",
        "training_set",
        "np",
        "insert",
        "training_set",
        "input",
        "axis",
        "validation_set",
        "np",
        "insert",
        "validation_set",
        "input",
        "axis",
        "test_set",
        "np",
        "insert",
        "test_set",
        "input",
        "axis",
        "layers",
        "append",
        "LogisticLayer",
        "train",
        "input",
        "shape",
        "output_activation",
        "is_classifier_layer",
        "nlayer",
        "n",
        "nlayer",
        "layers",
        "append",
        "LogisticLayer",
        "output_activation",
        "is_classifier_layer",
        "layers",
        "append",
        "LogisticLayer",
        "output_activation",
        "training_set",
        "np",
        "insert",
        "training_set",
        "input",
        "axis",
        "validation_set",
        "np",
        "insert",
        "validation_set",
        "input",
        "axis",
        "test_set",
        "np",
        "insert",
        "test_set",
        "input",
        "axis",
        "layer_index",
        "layers",
        "layer_index",
        "get_layer",
        "get_layer",
        "inp",
        "inp",
        "layer",
        "layers",
        "layer",
        "forward",
        "outp",
        "target",
        "target",
        "target",
        "target",
        "target",
        "target",
        "target",
        "target",
        "target",
        "target",
        "target",
        "val",
        "outp",
        "max",
        "outp",
        "outp",
        "m",
        "outp",
        "m",
        "outp",
        "m",
        "outp",
        "m",
        "outp",
        "m",
        "outp",
        "m",
        "outp",
        "m",
        "outp",
        "m",
        "outp",
        "m",
        "outp",
        "m",
        "val",
        "target",
        "_encode_target",
        "target",
        "layers",
        "output_activation",
        "lastlayer",
        "computeDerivative",
        "next_derivatives",
        "target",
        "outp",
        "outp",
        "outp",
        "output_activation",
        "lastlayer",
        "computeDerivative",
        "next_derivatives",
        "target",
        "outp",
        "layer",
        "nextlayer",
        "layers",
        "layers",
        "layer",
        "computeDerivative",
        "next_derivatives",
        "nextlayer",
        "deltas",
        "next_weights",
        "nextlayer",
        "weights",
        "learning_rate",
        "layer",
        "layers",
        "layer",
        "updateWeights",
        "learning_rate",
        "layer",
        "layers",
        "np",
        "zeros",
        "layer",
        "n_out",
        "verbose",
        "epoch",
        "epochs",
        "verbose",
        "format",
        "epoch",
        "epochs",
        "_train_one_epoch",
        "verbose",
        "accuracy_score",
        "validation_set",
        "label",
        "evaluate",
        "validation_set",
        "performances",
        "append",
        "accuracy",
        "format",
        "accuracy",
        "img",
        "label",
        "training_set",
        "input",
        "training_set",
        "label",
        "_feed_forward",
        "img",
        "_compute_error",
        "label",
        "_update_weights",
        "learning_rate",
        "test_instance",
        "_feed_forward",
        "test_instance",
        "_decode_target",
        "outp",
        "outp",
        "test",
        "test",
        "test_set",
        "input",
        "classify",
        "test",
        "training_set",
        "np",
        "training_set",
        "input",
        "axis",
        "validation_set",
        "np",
        "validation_set",
        "input",
        "axis",
        "test_set",
        "np",
        "test_set",
        "input",
        "axis"
    ],
    "literals": [
        "'classification'",
        "'sigmoid'",
        "'crossentropy'",
        "\"sigmoid\"",
        "\"softmax\"",
        "\"Training epoch {0}/{1}..\"",
        "\"Accuracy on validation: {0:.2f}%\"",
        "\"-----------------------------\""
    ],
    "variables": [
        "learning_rate",
        "epochs",
        "output_task",
        "output_activation",
        "cost",
        "training_set",
        "validation_set",
        "test_set",
        "performances",
        "layers",
        "input_weights",
        "input",
        "input",
        "input",
        "layers",
        "outp",
        "input",
        "input",
        "input",
        "outp",
        "outp",
        "val",
        "val",
        "val",
        "val",
        "val",
        "val",
        "val",
        "val",
        "val",
        "val",
        "m",
        "val",
        "val",
        "val",
        "val",
        "val",
        "val",
        "val",
        "val",
        "val",
        "val",
        "target",
        "lastlayer",
        "layer",
        "deltas",
        "accuracy",
        "outp",
        "test",
        "input",
        "input",
        "input"
    ],
    "comments": [
        "from util.activation_functions import Activation",
        "from loss_functions import CrossEntropyError",
        "Either classification or regression",
        "Record the performance of each epoch for later usages",
        "e.g. plotting, reporting..",
        "add bias values (\"1\"s) at the beginning of all data sets",
        "Build up the network from specific layers",
        "Here is an example of a MLP acting like the Logistic Regression",
        "output_activation = \"sigmoid\"",
        "self.layers.append(LogisticLayer(train.input.shape[1], 1, None, output_activation, False))",
        "add bias values (\"1\"s) at the beginning of all data sets",
        "Record the performance of each epoch for later usages",
        "e.g. plotting, reporting..",
        "Do a forward pass to calculate the output and the error",
        "Classify an instance given the model of the classifier",
        "You need to implement something here",
        "if True in np.isnan(self.outp):",
        "import pdb ; pdb.set_trace()",
        "Once you can classify an instance, just use map for all of the test",
        "set.",
        "Remove the bias from input data"
    ],
    "docstrings": [
        "\"\"\"\n    A multilayer perceptron used for classification\n    \"\"\"",
        "\"\"\"\n        A digit-7 recognizer based on logistic regression algorithm\n\n        Parameters\n        ----------\n        train : list\n        valid : list\n        test : list\n        learning_rate : float\n        epochs : positive int\n\n        Attributes\n        ----------\n        training_set : list\n        validation_set : list\n        test_set : list\n        learning_rate : float\n        epochs : positive int\n        performances: array of floats\n        \"\"\"",
        "\"\"\"\n        Do feed forward through the layers of the network\n\n        Parameters\n        ----------\n        inp : ndarray\n            a numpy array containing the input of the layer\n\n        # Here you have to propagate forward through the layers\n        # And remember the activation values of each layer\n        \"\"\"",
        "\"\"\"\n        Compute the total error of the network\n\n        Returns\n        -------\n        ndarray :\n            a numpy array (1,nOut) containing the output of the layer\n        \"\"\"",
        "\"\"\"\n        Update the weights of the layers by propagating back the error\n        \"\"\"",
        "\"\"\"Train the Multi-layer Perceptrons\n\n        Parameters\n        ----------\n        verbose : boolean\n            Print logging messages with validation accuracy if verbose is True.\n        \"\"\"",
        "\"\"\"\n        Train one epoch, seeing all input instances\n        \"\"\"",
        "\"\"\"Evaluate a whole dataset.\n\n        Parameters\n        ----------\n        test : the dataset to be classified\n        if no test data, the test set associated to the classifier will be used\n\n        Returns\n        -------\n        List:\n            List of classified decisions for the dataset's entries.\n        \"\"\""
    ],
    "functions": [
        "_get_layer",
        "_get_input_layer",
        "_get_output_layer",
        "_feed_forward",
        "_encode_target",
        "_decode_target",
        "_compute_error",
        "_update_weights",
        "_init_deltas",
        "train",
        "_train_one_epoch",
        "classify",
        "evaluate",
        "__del__"
    ],
    "classes": [
        "MultilayerPerceptron"
    ]
}